// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_UNI_EQUIP_TARGET: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_UNI_EQUIP_TARGET: i32 = 6;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_UNI_EQUIP_TARGET: [enum__Torappu_UniEquipTarget; 7] = [
    enum__Torappu_UniEquipTarget::NONE,
    enum__Torappu_UniEquipTarget::TRAIT,
    enum__Torappu_UniEquipTarget::TRAIT_DATA_ONLY,
    enum__Torappu_UniEquipTarget::TALENT,
    enum__Torappu_UniEquipTarget::TALENT_DATA_ONLY,
    enum__Torappu_UniEquipTarget::DISPLAY,
    enum__Torappu_UniEquipTarget::OVERWRITE_BATTLE_DATA,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_UniEquipTarget(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_UniEquipTarget {
    pub const NONE: Self = Self(0);
    pub const TRAIT: Self = Self(1);
    pub const TRAIT_DATA_ONLY: Self = Self(2);
    pub const TALENT: Self = Self(3);
    pub const TALENT_DATA_ONLY: Self = Self(4);
    pub const DISPLAY: Self = Self(5);
    pub const OVERWRITE_BATTLE_DATA: Self = Self(6);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 6;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::TRAIT,
        Self::TRAIT_DATA_ONLY,
        Self::TALENT,
        Self::TALENT_DATA_ONLY,
        Self::DISPLAY,
        Self::OVERWRITE_BATTLE_DATA,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::TRAIT => Some("TRAIT"),
            Self::TRAIT_DATA_ONLY => Some("TRAIT_DATA_ONLY"),
            Self::TALENT => Some("TALENT"),
            Self::TALENT_DATA_ONLY => Some("TALENT_DATA_ONLY"),
            Self::DISPLAY => Some("DISPLAY"),
            Self::OVERWRITE_BATTLE_DATA => Some("OVERWRITE_BATTLE_DATA"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_UniEquipTarget {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_UniEquipTarget {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_UniEquipTarget {
    type Output = enum__Torappu_UniEquipTarget;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_UniEquipTarget {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_UniEquipTarget {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_UniEquipTarget {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_EVOLVE_PHASE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_EVOLVE_PHASE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_EVOLVE_PHASE: [enum__Torappu_EvolvePhase; 5] = [
    enum__Torappu_EvolvePhase::PHASE_0,
    enum__Torappu_EvolvePhase::PHASE_1,
    enum__Torappu_EvolvePhase::PHASE_2,
    enum__Torappu_EvolvePhase::PHASE_3,
    enum__Torappu_EvolvePhase::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_EvolvePhase(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_EvolvePhase {
    pub const PHASE_0: Self = Self(0);
    pub const PHASE_1: Self = Self(1);
    pub const PHASE_2: Self = Self(2);
    pub const PHASE_3: Self = Self(3);
    pub const E_NUM: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::PHASE_0,
        Self::PHASE_1,
        Self::PHASE_2,
        Self::PHASE_3,
        Self::E_NUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::PHASE_0 => Some("PHASE_0"),
            Self::PHASE_1 => Some("PHASE_1"),
            Self::PHASE_2 => Some("PHASE_2"),
            Self::PHASE_3 => Some("PHASE_3"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_EvolvePhase {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_EvolvePhase {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_EvolvePhase {
    type Output = enum__Torappu_EvolvePhase;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_EvolvePhase {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_EvolvePhase {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_EvolvePhase {}
pub enum clz_Torappu_CharacterData_UnlockConditionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharacterData_UnlockCondition<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharacterData_UnlockCondition<'a> {
    type Inner = clz_Torappu_CharacterData_UnlockCondition<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharacterData_UnlockCondition<'a> {
    pub const VT_PHASE: flatbuffers::VOffsetT = 4;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharacterData_UnlockCondition { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharacterData_UnlockConditionArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'bldr>> {
        let mut builder = clz_Torappu_CharacterData_UnlockConditionBuilder::new(_fbb);
        builder.add_level(args.level);
        builder.add_phase(args.phase);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharacterData_UnlockConditionT {
        let phase = self.phase();
        let level = self.level();
        clz_Torappu_CharacterData_UnlockConditionT { phase, level }
    }

    #[inline]
    pub fn phase(&self) -> enum__Torappu_EvolvePhase {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_EvolvePhase>(
                    clz_Torappu_CharacterData_UnlockCondition::VT_PHASE,
                    Some(enum__Torappu_EvolvePhase::PHASE_0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CharacterData_UnlockCondition::VT_LEVEL, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharacterData_UnlockCondition<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_EvolvePhase>("phase", Self::VT_PHASE, false)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharacterData_UnlockConditionArgs {
    pub phase: enum__Torappu_EvolvePhase,
    pub level: i32,
}
impl<'a> Default for clz_Torappu_CharacterData_UnlockConditionArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharacterData_UnlockConditionArgs {
            phase: enum__Torappu_EvolvePhase::PHASE_0,
            level: 0,
        }
    }
}

pub struct clz_Torappu_CharacterData_UnlockConditionBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharacterData_UnlockConditionBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_phase(&mut self, phase: enum__Torappu_EvolvePhase) {
        self.fbb_.push_slot::<enum__Torappu_EvolvePhase>(
            clz_Torappu_CharacterData_UnlockCondition::VT_PHASE,
            phase,
            enum__Torappu_EvolvePhase::PHASE_0,
        );
    }
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_CharacterData_UnlockCondition::VT_LEVEL,
            level,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharacterData_UnlockConditionBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharacterData_UnlockConditionBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharacterData_UnlockCondition<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharacterData_UnlockCondition");
        ds.field("phase", &self.phase());
        ds.field("level", &self.level());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharacterData_UnlockConditionT {
    pub phase: enum__Torappu_EvolvePhase,
    pub level: i32,
}
impl Default for clz_Torappu_CharacterData_UnlockConditionT {
    fn default() -> Self {
        Self {
            phase: enum__Torappu_EvolvePhase::PHASE_0,
            level: 0,
        }
    }
}
impl clz_Torappu_CharacterData_UnlockConditionT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'b>> {
        let phase = self.phase;
        let level = self.level;
        clz_Torappu_CharacterData_UnlockCondition::create(
            _fbb,
            &clz_Torappu_CharacterData_UnlockConditionArgs { phase, level },
        )
    }
}
pub enum clz_Torappu_Blackboard_DataPairOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Blackboard_DataPair<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Blackboard_DataPair<'a> {
    type Inner = clz_Torappu_Blackboard_DataPair<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Blackboard_DataPair<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;
    pub const VT_VALUESTR: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Blackboard_DataPair { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Blackboard_DataPairArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'bldr>> {
        let mut builder = clz_Torappu_Blackboard_DataPairBuilder::new(_fbb);
        if let Some(x) = args.valueStr {
            builder.add_valueStr(x);
        }
        builder.add_value(args.value);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Blackboard_DataPairT {
        let key = self.key().map(|x| x.to_string());
        let value = self.value();
        let valueStr = self.valueStr().map(|x| x.to_string());
        clz_Torappu_Blackboard_DataPairT {
            key,
            value,
            valueStr,
        }
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_KEY,
                None,
            )
        }
    }
    #[inline]
    pub fn value(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn valueStr(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Blackboard_DataPair<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<f32>("value", Self::VT_VALUE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "valueStr",
                Self::VT_VALUESTR,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Blackboard_DataPairArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: f32,
    pub valueStr: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Blackboard_DataPairArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Blackboard_DataPairArgs {
            key: None,
            value: 0.0,
            valueStr: None,
        }
    }
}

pub struct clz_Torappu_Blackboard_DataPairBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, value, 0.0);
    }
    #[inline]
    pub fn add_valueStr(&mut self, valueStr: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
            valueStr,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Blackboard_DataPairBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Blackboard_DataPair<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Blackboard_DataPair");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.field("valueStr", &self.valueStr());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Blackboard_DataPairT {
    pub key: Option<String>,
    pub value: f32,
    pub valueStr: Option<String>,
}
impl Default for clz_Torappu_Blackboard_DataPairT {
    fn default() -> Self {
        Self {
            key: None,
            value: 0.0,
            valueStr: None,
        }
    }
}
impl clz_Torappu_Blackboard_DataPairT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'b>> {
        let key = self.key.as_ref().map(|x| _fbb.create_string(x));
        let value = self.value;
        let valueStr = self.valueStr.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Blackboard_DataPair::create(
            _fbb,
            &clz_Torappu_Blackboard_DataPairArgs {
                key,
                value,
                valueStr,
            },
        )
    }
}
pub enum clz_Torappu_EquipTalentDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_EquipTalentData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_EquipTalentData<'a> {
    type Inner = clz_Torappu_EquipTalentData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_EquipTalentData<'a> {
    pub const VT_DISPLAYRANGEID: flatbuffers::VOffsetT = 4;
    pub const VT_UPGRADEDESCRIPTION: flatbuffers::VOffsetT = 6;
    pub const VT_TALENTINDEX: flatbuffers::VOffsetT = 8;
    pub const VT_UNLOCKCONDITION: flatbuffers::VOffsetT = 10;
    pub const VT_REQUIREDPOTENTIALRANK: flatbuffers::VOffsetT = 12;
    pub const VT_PREFABKEY: flatbuffers::VOffsetT = 14;
    pub const VT_NAME: flatbuffers::VOffsetT = 16;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 18;
    pub const VT_RANGEID: flatbuffers::VOffsetT = 20;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 22;
    pub const VT_TOKENKEY: flatbuffers::VOffsetT = 24;
    pub const VT_ISHIDETALENT: flatbuffers::VOffsetT = 26;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_EquipTalentData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_EquipTalentDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EquipTalentData<'bldr>> {
        let mut builder = clz_Torappu_EquipTalentDataBuilder::new(_fbb);
        if let Some(x) = args.tokenKey {
            builder.add_tokenKey(x);
        }
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        if let Some(x) = args.rangeId {
            builder.add_rangeId(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.prefabKey {
            builder.add_prefabKey(x);
        }
        builder.add_requiredPotentialRank(args.requiredPotentialRank);
        if let Some(x) = args.unlockCondition {
            builder.add_unlockCondition(x);
        }
        builder.add_talentIndex(args.talentIndex);
        if let Some(x) = args.upgradeDescription {
            builder.add_upgradeDescription(x);
        }
        builder.add_isHideTalent(args.isHideTalent);
        builder.add_displayRangeId(args.displayRangeId);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_EquipTalentDataT {
        let displayRangeId = self.displayRangeId();
        let upgradeDescription = self.upgradeDescription().map(|x| x.to_string());
        let talentIndex = self.talentIndex();
        let unlockCondition = self.unlockCondition().map(|x| Box::new(x.unpack()));
        let requiredPotentialRank = self.requiredPotentialRank();
        let prefabKey = self.prefabKey().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let rangeId = self.rangeId().map(|x| x.to_string());
        let blackboard = self
            .blackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let tokenKey = self.tokenKey().map(|x| x.to_string());
        let isHideTalent = self.isHideTalent();
        clz_Torappu_EquipTalentDataT {
            displayRangeId,
            upgradeDescription,
            talentIndex,
            unlockCondition,
            requiredPotentialRank,
            prefabKey,
            name,
            description,
            rangeId,
            blackboard,
            tokenKey,
            isHideTalent,
        }
    }

    #[inline]
    pub fn displayRangeId(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_EquipTalentData::VT_DISPLAYRANGEID, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn upgradeDescription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_EquipTalentData::VT_UPGRADEDESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn talentIndex(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_EquipTalentData::VT_TALENTINDEX, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockCondition(&self) -> Option<clz_Torappu_CharacterData_UnlockCondition<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                    clz_Torappu_EquipTalentData::VT_UNLOCKCONDITION,
                    None,
                )
        }
    }
    #[inline]
    pub fn requiredPotentialRank(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_EquipTalentData::VT_REQUIREDPOTENTIALRANK,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn prefabKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_EquipTalentData::VT_PREFABKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_EquipTalentData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_EquipTalentData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn rangeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_EquipTalentData::VT_RANGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(clz_Torappu_EquipTalentData::VT_BLACKBOARD, None)
        }
    }
    #[inline]
    pub fn tokenKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_EquipTalentData::VT_TOKENKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn isHideTalent(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_EquipTalentData::VT_ISHIDETALENT, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_EquipTalentData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("displayRangeId", Self::VT_DISPLAYRANGEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "upgradeDescription",
                Self::VT_UPGRADEDESCRIPTION,
                false,
            )?
            .visit_field::<i32>("talentIndex", Self::VT_TALENTINDEX, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                "unlockCondition",
                Self::VT_UNLOCKCONDITION,
                false,
            )?
            .visit_field::<i32>(
                "requiredPotentialRank",
                Self::VT_REQUIREDPOTENTIALRANK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "prefabKey",
                Self::VT_PREFABKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rangeId", Self::VT_RANGEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "tokenKey",
                Self::VT_TOKENKEY,
                false,
            )?
            .visit_field::<bool>("isHideTalent", Self::VT_ISHIDETALENT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_EquipTalentDataArgs<'a> {
    pub displayRangeId: bool,
    pub upgradeDescription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub talentIndex: i32,
    pub unlockCondition:
        Option<flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'a>>>,
    pub requiredPotentialRank: i32,
    pub prefabKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rangeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
    pub tokenKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isHideTalent: bool,
}
impl<'a> Default for clz_Torappu_EquipTalentDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_EquipTalentDataArgs {
            displayRangeId: false,
            upgradeDescription: None,
            talentIndex: 0,
            unlockCondition: None,
            requiredPotentialRank: 0,
            prefabKey: None,
            name: None,
            description: None,
            rangeId: None,
            blackboard: None,
            tokenKey: None,
            isHideTalent: false,
        }
    }
}

pub struct clz_Torappu_EquipTalentDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_EquipTalentDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_displayRangeId(&mut self, displayRangeId: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_EquipTalentData::VT_DISPLAYRANGEID,
            displayRangeId,
            false,
        );
    }
    #[inline]
    pub fn add_upgradeDescription(&mut self, upgradeDescription: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EquipTalentData::VT_UPGRADEDESCRIPTION,
            upgradeDescription,
        );
    }
    #[inline]
    pub fn add_talentIndex(&mut self, talentIndex: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_EquipTalentData::VT_TALENTINDEX, talentIndex, 0);
    }
    #[inline]
    pub fn add_unlockCondition(
        &mut self,
        unlockCondition: flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                clz_Torappu_EquipTalentData::VT_UNLOCKCONDITION,
                unlockCondition,
            );
    }
    #[inline]
    pub fn add_requiredPotentialRank(&mut self, requiredPotentialRank: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_EquipTalentData::VT_REQUIREDPOTENTIALRANK,
            requiredPotentialRank,
            0,
        );
    }
    #[inline]
    pub fn add_prefabKey(&mut self, prefabKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EquipTalentData::VT_PREFABKEY,
            prefabKey,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EquipTalentData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EquipTalentData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_rangeId(&mut self, rangeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EquipTalentData::VT_RANGEID,
            rangeId,
        );
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EquipTalentData::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn add_tokenKey(&mut self, tokenKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EquipTalentData::VT_TOKENKEY,
            tokenKey,
        );
    }
    #[inline]
    pub fn add_isHideTalent(&mut self, isHideTalent: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_EquipTalentData::VT_ISHIDETALENT,
            isHideTalent,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_EquipTalentDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_EquipTalentDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_EquipTalentData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_EquipTalentData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_EquipTalentData");
        ds.field("displayRangeId", &self.displayRangeId());
        ds.field("upgradeDescription", &self.upgradeDescription());
        ds.field("talentIndex", &self.talentIndex());
        ds.field("unlockCondition", &self.unlockCondition());
        ds.field("requiredPotentialRank", &self.requiredPotentialRank());
        ds.field("prefabKey", &self.prefabKey());
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.field("rangeId", &self.rangeId());
        ds.field("blackboard", &self.blackboard());
        ds.field("tokenKey", &self.tokenKey());
        ds.field("isHideTalent", &self.isHideTalent());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_EquipTalentDataT {
    pub displayRangeId: bool,
    pub upgradeDescription: Option<String>,
    pub talentIndex: i32,
    pub unlockCondition: Option<Box<clz_Torappu_CharacterData_UnlockConditionT>>,
    pub requiredPotentialRank: i32,
    pub prefabKey: Option<String>,
    pub name: Option<String>,
    pub description: Option<String>,
    pub rangeId: Option<String>,
    pub blackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
    pub tokenKey: Option<String>,
    pub isHideTalent: bool,
}
impl Default for clz_Torappu_EquipTalentDataT {
    fn default() -> Self {
        Self {
            displayRangeId: false,
            upgradeDescription: None,
            talentIndex: 0,
            unlockCondition: None,
            requiredPotentialRank: 0,
            prefabKey: None,
            name: None,
            description: None,
            rangeId: None,
            blackboard: None,
            tokenKey: None,
            isHideTalent: false,
        }
    }
}
impl clz_Torappu_EquipTalentDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EquipTalentData<'b>> {
        let displayRangeId = self.displayRangeId;
        let upgradeDescription = self
            .upgradeDescription
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let talentIndex = self.talentIndex;
        let unlockCondition = self.unlockCondition.as_ref().map(|x| x.pack(_fbb));
        let requiredPotentialRank = self.requiredPotentialRank;
        let prefabKey = self.prefabKey.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let rangeId = self.rangeId.as_ref().map(|x| _fbb.create_string(x));
        let blackboard = self.blackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let tokenKey = self.tokenKey.as_ref().map(|x| _fbb.create_string(x));
        let isHideTalent = self.isHideTalent;
        clz_Torappu_EquipTalentData::create(
            _fbb,
            &clz_Torappu_EquipTalentDataArgs {
                displayRangeId,
                upgradeDescription,
                talentIndex,
                unlockCondition,
                requiredPotentialRank,
                prefabKey,
                name,
                description,
                rangeId,
                blackboard,
                tokenKey,
                isHideTalent,
            },
        )
    }
}
pub enum clz_Torappu_TalentDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_TalentData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_TalentData<'a> {
    type Inner = clz_Torappu_TalentData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_TalentData<'a> {
    pub const VT_UNLOCKCONDITION: flatbuffers::VOffsetT = 4;
    pub const VT_REQUIREDPOTENTIALRANK: flatbuffers::VOffsetT = 6;
    pub const VT_PREFABKEY: flatbuffers::VOffsetT = 8;
    pub const VT_NAME: flatbuffers::VOffsetT = 10;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 12;
    pub const VT_RANGEID: flatbuffers::VOffsetT = 14;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 16;
    pub const VT_TOKENKEY: flatbuffers::VOffsetT = 18;
    pub const VT_ISHIDETALENT: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_TalentData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_TalentDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TalentData<'bldr>> {
        let mut builder = clz_Torappu_TalentDataBuilder::new(_fbb);
        if let Some(x) = args.tokenKey {
            builder.add_tokenKey(x);
        }
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        if let Some(x) = args.rangeId {
            builder.add_rangeId(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.prefabKey {
            builder.add_prefabKey(x);
        }
        builder.add_requiredPotentialRank(args.requiredPotentialRank);
        if let Some(x) = args.unlockCondition {
            builder.add_unlockCondition(x);
        }
        builder.add_isHideTalent(args.isHideTalent);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_TalentDataT {
        let unlockCondition = self.unlockCondition().map(|x| Box::new(x.unpack()));
        let requiredPotentialRank = self.requiredPotentialRank();
        let prefabKey = self.prefabKey().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let rangeId = self.rangeId().map(|x| x.to_string());
        let blackboard = self
            .blackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let tokenKey = self.tokenKey().map(|x| x.to_string());
        let isHideTalent = self.isHideTalent();
        clz_Torappu_TalentDataT {
            unlockCondition,
            requiredPotentialRank,
            prefabKey,
            name,
            description,
            rangeId,
            blackboard,
            tokenKey,
            isHideTalent,
        }
    }

    #[inline]
    pub fn unlockCondition(&self) -> Option<clz_Torappu_CharacterData_UnlockCondition<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                    clz_Torappu_TalentData::VT_UNLOCKCONDITION,
                    None,
                )
        }
    }
    #[inline]
    pub fn requiredPotentialRank(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_TalentData::VT_REQUIREDPOTENTIALRANK, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn prefabKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TalentData::VT_PREFABKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_TalentData::VT_NAME, None)
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TalentData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn rangeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_TalentData::VT_RANGEID, None)
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(clz_Torappu_TalentData::VT_BLACKBOARD, None)
        }
    }
    #[inline]
    pub fn tokenKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TalentData::VT_TOKENKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn isHideTalent(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_TalentData::VT_ISHIDETALENT, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_TalentData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                "unlockCondition",
                Self::VT_UNLOCKCONDITION,
                false,
            )?
            .visit_field::<i32>(
                "requiredPotentialRank",
                Self::VT_REQUIREDPOTENTIALRANK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "prefabKey",
                Self::VT_PREFABKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rangeId", Self::VT_RANGEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "tokenKey",
                Self::VT_TOKENKEY,
                false,
            )?
            .visit_field::<bool>("isHideTalent", Self::VT_ISHIDETALENT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_TalentDataArgs<'a> {
    pub unlockCondition:
        Option<flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'a>>>,
    pub requiredPotentialRank: i32,
    pub prefabKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rangeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
    pub tokenKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isHideTalent: bool,
}
impl<'a> Default for clz_Torappu_TalentDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_TalentDataArgs {
            unlockCondition: None,
            requiredPotentialRank: 0,
            prefabKey: None,
            name: None,
            description: None,
            rangeId: None,
            blackboard: None,
            tokenKey: None,
            isHideTalent: false,
        }
    }
}

pub struct clz_Torappu_TalentDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_TalentDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_unlockCondition(
        &mut self,
        unlockCondition: flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                clz_Torappu_TalentData::VT_UNLOCKCONDITION,
                unlockCondition,
            );
    }
    #[inline]
    pub fn add_requiredPotentialRank(&mut self, requiredPotentialRank: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_TalentData::VT_REQUIREDPOTENTIALRANK,
            requiredPotentialRank,
            0,
        );
    }
    #[inline]
    pub fn add_prefabKey(&mut self, prefabKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TalentData::VT_PREFABKEY,
            prefabKey,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_TalentData::VT_NAME, name);
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TalentData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_rangeId(&mut self, rangeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TalentData::VT_RANGEID,
            rangeId,
        );
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TalentData::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn add_tokenKey(&mut self, tokenKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TalentData::VT_TOKENKEY,
            tokenKey,
        );
    }
    #[inline]
    pub fn add_isHideTalent(&mut self, isHideTalent: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_TalentData::VT_ISHIDETALENT, isHideTalent, false);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_TalentDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_TalentDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_TalentData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_TalentData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_TalentData");
        ds.field("unlockCondition", &self.unlockCondition());
        ds.field("requiredPotentialRank", &self.requiredPotentialRank());
        ds.field("prefabKey", &self.prefabKey());
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.field("rangeId", &self.rangeId());
        ds.field("blackboard", &self.blackboard());
        ds.field("tokenKey", &self.tokenKey());
        ds.field("isHideTalent", &self.isHideTalent());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_TalentDataT {
    pub unlockCondition: Option<Box<clz_Torappu_CharacterData_UnlockConditionT>>,
    pub requiredPotentialRank: i32,
    pub prefabKey: Option<String>,
    pub name: Option<String>,
    pub description: Option<String>,
    pub rangeId: Option<String>,
    pub blackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
    pub tokenKey: Option<String>,
    pub isHideTalent: bool,
}
impl Default for clz_Torappu_TalentDataT {
    fn default() -> Self {
        Self {
            unlockCondition: None,
            requiredPotentialRank: 0,
            prefabKey: None,
            name: None,
            description: None,
            rangeId: None,
            blackboard: None,
            tokenKey: None,
            isHideTalent: false,
        }
    }
}
impl clz_Torappu_TalentDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TalentData<'b>> {
        let unlockCondition = self.unlockCondition.as_ref().map(|x| x.pack(_fbb));
        let requiredPotentialRank = self.requiredPotentialRank;
        let prefabKey = self.prefabKey.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let rangeId = self.rangeId.as_ref().map(|x| _fbb.create_string(x));
        let blackboard = self.blackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let tokenKey = self.tokenKey.as_ref().map(|x| _fbb.create_string(x));
        let isHideTalent = self.isHideTalent;
        clz_Torappu_TalentData::create(
            _fbb,
            &clz_Torappu_TalentDataArgs {
                unlockCondition,
                requiredPotentialRank,
                prefabKey,
                name,
                description,
                rangeId,
                blackboard,
                tokenKey,
                isHideTalent,
            },
        )
    }
}
pub enum clz_Torappu_CharacterData_EquipTalentDataBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharacterData_EquipTalentDataBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharacterData_EquipTalentDataBundle<'a> {
    type Inner = clz_Torappu_CharacterData_EquipTalentDataBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharacterData_EquipTalentDataBundle<'a> {
    pub const VT_CANDIDATES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharacterData_EquipTalentDataBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharacterData_EquipTalentDataBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_EquipTalentDataBundle<'bldr>> {
        let mut builder = clz_Torappu_CharacterData_EquipTalentDataBundleBuilder::new(_fbb);
        if let Some(x) = args.candidates {
            builder.add_candidates(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharacterData_EquipTalentDataBundleT {
        let candidates = self
            .candidates()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_CharacterData_EquipTalentDataBundleT { candidates }
    }

    #[inline]
    pub fn candidates(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_EquipTalentData<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_EquipTalentData>>,
            >>(
                clz_Torappu_CharacterData_EquipTalentDataBundle::VT_CANDIDATES,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharacterData_EquipTalentDataBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_EquipTalentData>>,
            >>("candidates", Self::VT_CANDIDATES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharacterData_EquipTalentDataBundleArgs<'a> {
    pub candidates: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_EquipTalentData<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_CharacterData_EquipTalentDataBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharacterData_EquipTalentDataBundleArgs { candidates: None }
    }
}

pub struct clz_Torappu_CharacterData_EquipTalentDataBundleBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharacterData_EquipTalentDataBundleBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_candidates(
        &mut self,
        candidates: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_EquipTalentData<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_EquipTalentDataBundle::VT_CANDIDATES,
            candidates,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharacterData_EquipTalentDataBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharacterData_EquipTalentDataBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_EquipTalentDataBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharacterData_EquipTalentDataBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharacterData_EquipTalentDataBundle");
        ds.field("candidates", &self.candidates());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharacterData_EquipTalentDataBundleT {
    pub candidates: Option<Vec<clz_Torappu_EquipTalentDataT>>,
}
impl Default for clz_Torappu_CharacterData_EquipTalentDataBundleT {
    fn default() -> Self {
        Self { candidates: None }
    }
}
impl clz_Torappu_CharacterData_EquipTalentDataBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_EquipTalentDataBundle<'b>> {
        let candidates = self.candidates.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_CharacterData_EquipTalentDataBundle::create(
            _fbb,
            &clz_Torappu_CharacterData_EquipTalentDataBundleArgs { candidates },
        )
    }
}
pub enum clz_Torappu_CharacterData_EquipTraitDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharacterData_EquipTraitData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharacterData_EquipTraitData<'a> {
    type Inner = clz_Torappu_CharacterData_EquipTraitData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharacterData_EquipTraitData<'a> {
    pub const VT_ADDITIONALDESCRIPTION: flatbuffers::VOffsetT = 4;
    pub const VT_UNLOCKCONDITION: flatbuffers::VOffsetT = 6;
    pub const VT_REQUIREDPOTENTIALRANK: flatbuffers::VOffsetT = 8;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 10;
    pub const VT_OVERRIDEDESCRIPTON: flatbuffers::VOffsetT = 12;
    pub const VT_PREFABKEY: flatbuffers::VOffsetT = 14;
    pub const VT_RANGEID: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharacterData_EquipTraitData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharacterData_EquipTraitDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_EquipTraitData<'bldr>> {
        let mut builder = clz_Torappu_CharacterData_EquipTraitDataBuilder::new(_fbb);
        if let Some(x) = args.rangeId {
            builder.add_rangeId(x);
        }
        if let Some(x) = args.prefabKey {
            builder.add_prefabKey(x);
        }
        if let Some(x) = args.overrideDescripton {
            builder.add_overrideDescripton(x);
        }
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        builder.add_requiredPotentialRank(args.requiredPotentialRank);
        if let Some(x) = args.unlockCondition {
            builder.add_unlockCondition(x);
        }
        if let Some(x) = args.additionalDescription {
            builder.add_additionalDescription(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharacterData_EquipTraitDataT {
        let additionalDescription = self.additionalDescription().map(|x| x.to_string());
        let unlockCondition = self.unlockCondition().map(|x| Box::new(x.unpack()));
        let requiredPotentialRank = self.requiredPotentialRank();
        let blackboard = self
            .blackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let overrideDescripton = self.overrideDescripton().map(|x| x.to_string());
        let prefabKey = self.prefabKey().map(|x| x.to_string());
        let rangeId = self.rangeId().map(|x| x.to_string());
        clz_Torappu_CharacterData_EquipTraitDataT {
            additionalDescription,
            unlockCondition,
            requiredPotentialRank,
            blackboard,
            overrideDescripton,
            prefabKey,
            rangeId,
        }
    }

    #[inline]
    pub fn additionalDescription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData_EquipTraitData::VT_ADDITIONALDESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockCondition(&self) -> Option<clz_Torappu_CharacterData_UnlockCondition<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                    clz_Torappu_CharacterData_EquipTraitData::VT_UNLOCKCONDITION,
                    None,
                )
        }
    }
    #[inline]
    pub fn requiredPotentialRank(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_CharacterData_EquipTraitData::VT_REQUIREDPOTENTIALRANK,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(
                clz_Torappu_CharacterData_EquipTraitData::VT_BLACKBOARD,
                None,
            )
        }
    }
    #[inline]
    pub fn overrideDescripton(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData_EquipTraitData::VT_OVERRIDEDESCRIPTON,
                None,
            )
        }
    }
    #[inline]
    pub fn prefabKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData_EquipTraitData::VT_PREFABKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn rangeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData_EquipTraitData::VT_RANGEID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharacterData_EquipTraitData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "additionalDescription",
                Self::VT_ADDITIONALDESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                "unlockCondition",
                Self::VT_UNLOCKCONDITION,
                false,
            )?
            .visit_field::<i32>(
                "requiredPotentialRank",
                Self::VT_REQUIREDPOTENTIALRANK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "overrideDescripton",
                Self::VT_OVERRIDEDESCRIPTON,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "prefabKey",
                Self::VT_PREFABKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rangeId", Self::VT_RANGEID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharacterData_EquipTraitDataArgs<'a> {
    pub additionalDescription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockCondition:
        Option<flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'a>>>,
    pub requiredPotentialRank: i32,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
    pub overrideDescripton: Option<flatbuffers::WIPOffset<&'a str>>,
    pub prefabKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rangeId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_CharacterData_EquipTraitDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharacterData_EquipTraitDataArgs {
            additionalDescription: None,
            unlockCondition: None,
            requiredPotentialRank: 0,
            blackboard: None,
            overrideDescripton: None,
            prefabKey: None,
            rangeId: None,
        }
    }
}

pub struct clz_Torappu_CharacterData_EquipTraitDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharacterData_EquipTraitDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_additionalDescription(
        &mut self,
        additionalDescription: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_EquipTraitData::VT_ADDITIONALDESCRIPTION,
            additionalDescription,
        );
    }
    #[inline]
    pub fn add_unlockCondition(
        &mut self,
        unlockCondition: flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                clz_Torappu_CharacterData_EquipTraitData::VT_UNLOCKCONDITION,
                unlockCondition,
            );
    }
    #[inline]
    pub fn add_requiredPotentialRank(&mut self, requiredPotentialRank: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_CharacterData_EquipTraitData::VT_REQUIREDPOTENTIALRANK,
            requiredPotentialRank,
            0,
        );
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_EquipTraitData::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn add_overrideDescripton(&mut self, overrideDescripton: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_EquipTraitData::VT_OVERRIDEDESCRIPTON,
            overrideDescripton,
        );
    }
    #[inline]
    pub fn add_prefabKey(&mut self, prefabKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_EquipTraitData::VT_PREFABKEY,
            prefabKey,
        );
    }
    #[inline]
    pub fn add_rangeId(&mut self, rangeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_EquipTraitData::VT_RANGEID,
            rangeId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharacterData_EquipTraitDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharacterData_EquipTraitDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_EquipTraitData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharacterData_EquipTraitData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharacterData_EquipTraitData");
        ds.field("additionalDescription", &self.additionalDescription());
        ds.field("unlockCondition", &self.unlockCondition());
        ds.field("requiredPotentialRank", &self.requiredPotentialRank());
        ds.field("blackboard", &self.blackboard());
        ds.field("overrideDescripton", &self.overrideDescripton());
        ds.field("prefabKey", &self.prefabKey());
        ds.field("rangeId", &self.rangeId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharacterData_EquipTraitDataT {
    pub additionalDescription: Option<String>,
    pub unlockCondition: Option<Box<clz_Torappu_CharacterData_UnlockConditionT>>,
    pub requiredPotentialRank: i32,
    pub blackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
    pub overrideDescripton: Option<String>,
    pub prefabKey: Option<String>,
    pub rangeId: Option<String>,
}
impl Default for clz_Torappu_CharacterData_EquipTraitDataT {
    fn default() -> Self {
        Self {
            additionalDescription: None,
            unlockCondition: None,
            requiredPotentialRank: 0,
            blackboard: None,
            overrideDescripton: None,
            prefabKey: None,
            rangeId: None,
        }
    }
}
impl clz_Torappu_CharacterData_EquipTraitDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_EquipTraitData<'b>> {
        let additionalDescription = self
            .additionalDescription
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let unlockCondition = self.unlockCondition.as_ref().map(|x| x.pack(_fbb));
        let requiredPotentialRank = self.requiredPotentialRank;
        let blackboard = self.blackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let overrideDescripton = self
            .overrideDescripton
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let prefabKey = self.prefabKey.as_ref().map(|x| _fbb.create_string(x));
        let rangeId = self.rangeId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_CharacterData_EquipTraitData::create(
            _fbb,
            &clz_Torappu_CharacterData_EquipTraitDataArgs {
                additionalDescription,
                unlockCondition,
                requiredPotentialRank,
                blackboard,
                overrideDescripton,
                prefabKey,
                rangeId,
            },
        )
    }
}
pub enum clz_Torappu_CharacterData_EquipTraitDataBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharacterData_EquipTraitDataBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharacterData_EquipTraitDataBundle<'a> {
    type Inner = clz_Torappu_CharacterData_EquipTraitDataBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharacterData_EquipTraitDataBundle<'a> {
    pub const VT_CANDIDATES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharacterData_EquipTraitDataBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharacterData_EquipTraitDataBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_EquipTraitDataBundle<'bldr>> {
        let mut builder = clz_Torappu_CharacterData_EquipTraitDataBundleBuilder::new(_fbb);
        if let Some(x) = args.candidates {
            builder.add_candidates(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharacterData_EquipTraitDataBundleT {
        let candidates = self
            .candidates()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_CharacterData_EquipTraitDataBundleT { candidates }
    }

    #[inline]
    pub fn candidates(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_EquipTraitData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_EquipTraitData>,
                >,
            >>(
                clz_Torappu_CharacterData_EquipTraitDataBundle::VT_CANDIDATES,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharacterData_EquipTraitDataBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_EquipTraitData>,
                >,
            >>("candidates", Self::VT_CANDIDATES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharacterData_EquipTraitDataBundleArgs<'a> {
    pub candidates: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_EquipTraitData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_CharacterData_EquipTraitDataBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharacterData_EquipTraitDataBundleArgs { candidates: None }
    }
}

pub struct clz_Torappu_CharacterData_EquipTraitDataBundleBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharacterData_EquipTraitDataBundleBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_candidates(
        &mut self,
        candidates: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_EquipTraitData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_EquipTraitDataBundle::VT_CANDIDATES,
            candidates,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharacterData_EquipTraitDataBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharacterData_EquipTraitDataBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_EquipTraitDataBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharacterData_EquipTraitDataBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharacterData_EquipTraitDataBundle");
        ds.field("candidates", &self.candidates());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharacterData_EquipTraitDataBundleT {
    pub candidates: Option<Vec<clz_Torappu_CharacterData_EquipTraitDataT>>,
}
impl Default for clz_Torappu_CharacterData_EquipTraitDataBundleT {
    fn default() -> Self {
        Self { candidates: None }
    }
}
impl clz_Torappu_CharacterData_EquipTraitDataBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_EquipTraitDataBundle<'b>> {
        let candidates = self.candidates.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_CharacterData_EquipTraitDataBundle::create(
            _fbb,
            &clz_Torappu_CharacterData_EquipTraitDataBundleArgs { candidates },
        )
    }
}
pub enum clz_Torappu_BattleUniEquipDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BattleUniEquipData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BattleUniEquipData<'a> {
    type Inner = clz_Torappu_BattleUniEquipData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_BattleUniEquipData<'a> {
    pub const VT_RESKEY: flatbuffers::VOffsetT = 4;
    pub const VT_TARGET: flatbuffers::VOffsetT = 6;
    pub const VT_ISTOKEN: flatbuffers::VOffsetT = 8;
    pub const VT_VALIDINGAMETAG: flatbuffers::VOffsetT = 10;
    pub const VT_ADDOROVERRIDETALENTDATABUNDLE: flatbuffers::VOffsetT = 12;
    pub const VT_OVERRIDETRAITDATABUNDLE: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BattleUniEquipData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BattleUniEquipDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BattleUniEquipData<'bldr>> {
        let mut builder = clz_Torappu_BattleUniEquipDataBuilder::new(_fbb);
        if let Some(x) = args.overrideTraitDataBundle {
            builder.add_overrideTraitDataBundle(x);
        }
        if let Some(x) = args.addOrOverrideTalentDataBundle {
            builder.add_addOrOverrideTalentDataBundle(x);
        }
        if let Some(x) = args.validInGameTag {
            builder.add_validInGameTag(x);
        }
        builder.add_target(args.target);
        if let Some(x) = args.resKey {
            builder.add_resKey(x);
        }
        builder.add_isToken(args.isToken);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_BattleUniEquipDataT {
        let resKey = self.resKey().map(|x| x.to_string());
        let target = self.target();
        let isToken = self.isToken();
        let validInGameTag = self.validInGameTag().map(|x| x.to_string());
        let addOrOverrideTalentDataBundle = self
            .addOrOverrideTalentDataBundle()
            .map(|x| Box::new(x.unpack()));
        let overrideTraitDataBundle = self.overrideTraitDataBundle().map(|x| Box::new(x.unpack()));
        clz_Torappu_BattleUniEquipDataT {
            resKey,
            target,
            isToken,
            validInGameTag,
            addOrOverrideTalentDataBundle,
            overrideTraitDataBundle,
        }
    }

    #[inline]
    pub fn resKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BattleUniEquipData::VT_RESKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn target(&self) -> enum__Torappu_UniEquipTarget {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_UniEquipTarget>(
                    clz_Torappu_BattleUniEquipData::VT_TARGET,
                    Some(enum__Torappu_UniEquipTarget::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn isToken(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_BattleUniEquipData::VT_ISTOKEN, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn validInGameTag(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BattleUniEquipData::VT_VALIDINGAMETAG,
                None,
            )
        }
    }
    #[inline]
    pub fn addOrOverrideTalentDataBundle(
        &self,
    ) -> Option<clz_Torappu_CharacterData_EquipTalentDataBundle<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_EquipTalentDataBundle>>(clz_Torappu_BattleUniEquipData::VT_ADDOROVERRIDETALENTDATABUNDLE, None)
        }
    }
    #[inline]
    pub fn overrideTraitDataBundle(
        &self,
    ) -> Option<clz_Torappu_CharacterData_EquipTraitDataBundle<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_EquipTraitDataBundle>>(clz_Torappu_BattleUniEquipData::VT_OVERRIDETRAITDATABUNDLE, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BattleUniEquipData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("resKey", Self::VT_RESKEY, false)?
     .visit_field::<enum__Torappu_UniEquipTarget>("target", Self::VT_TARGET, false)?
     .visit_field::<bool>("isToken", Self::VT_ISTOKEN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("validInGameTag", Self::VT_VALIDINGAMETAG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_EquipTalentDataBundle>>("addOrOverrideTalentDataBundle", Self::VT_ADDOROVERRIDETALENTDATABUNDLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_EquipTraitDataBundle>>("overrideTraitDataBundle", Self::VT_OVERRIDETRAITDATABUNDLE, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BattleUniEquipDataArgs<'a> {
    pub resKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub target: enum__Torappu_UniEquipTarget,
    pub isToken: bool,
    pub validInGameTag: Option<flatbuffers::WIPOffset<&'a str>>,
    pub addOrOverrideTalentDataBundle:
        Option<flatbuffers::WIPOffset<clz_Torappu_CharacterData_EquipTalentDataBundle<'a>>>,
    pub overrideTraitDataBundle:
        Option<flatbuffers::WIPOffset<clz_Torappu_CharacterData_EquipTraitDataBundle<'a>>>,
}
impl<'a> Default for clz_Torappu_BattleUniEquipDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BattleUniEquipDataArgs {
            resKey: None,
            target: enum__Torappu_UniEquipTarget::NONE,
            isToken: false,
            validInGameTag: None,
            addOrOverrideTalentDataBundle: None,
            overrideTraitDataBundle: None,
        }
    }
}

pub struct clz_Torappu_BattleUniEquipDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_BattleUniEquipDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_resKey(&mut self, resKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BattleUniEquipData::VT_RESKEY,
            resKey,
        );
    }
    #[inline]
    pub fn add_target(&mut self, target: enum__Torappu_UniEquipTarget) {
        self.fbb_.push_slot::<enum__Torappu_UniEquipTarget>(
            clz_Torappu_BattleUniEquipData::VT_TARGET,
            target,
            enum__Torappu_UniEquipTarget::NONE,
        );
    }
    #[inline]
    pub fn add_isToken(&mut self, isToken: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_BattleUniEquipData::VT_ISTOKEN, isToken, false);
    }
    #[inline]
    pub fn add_validInGameTag(&mut self, validInGameTag: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BattleUniEquipData::VT_VALIDINGAMETAG,
            validInGameTag,
        );
    }
    #[inline]
    pub fn add_addOrOverrideTalentDataBundle(
        &mut self,
        addOrOverrideTalentDataBundle: flatbuffers::WIPOffset<
            clz_Torappu_CharacterData_EquipTalentDataBundle<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharacterData_EquipTalentDataBundle>>(clz_Torappu_BattleUniEquipData::VT_ADDOROVERRIDETALENTDATABUNDLE, addOrOverrideTalentDataBundle);
    }
    #[inline]
    pub fn add_overrideTraitDataBundle(
        &mut self,
        overrideTraitDataBundle: flatbuffers::WIPOffset<
            clz_Torappu_CharacterData_EquipTraitDataBundle<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharacterData_EquipTraitDataBundle>>(clz_Torappu_BattleUniEquipData::VT_OVERRIDETRAITDATABUNDLE, overrideTraitDataBundle);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BattleUniEquipDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BattleUniEquipDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BattleUniEquipData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BattleUniEquipData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BattleUniEquipData");
        ds.field("resKey", &self.resKey());
        ds.field("target", &self.target());
        ds.field("isToken", &self.isToken());
        ds.field("validInGameTag", &self.validInGameTag());
        ds.field(
            "addOrOverrideTalentDataBundle",
            &self.addOrOverrideTalentDataBundle(),
        );
        ds.field("overrideTraitDataBundle", &self.overrideTraitDataBundle());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_BattleUniEquipDataT {
    pub resKey: Option<String>,
    pub target: enum__Torappu_UniEquipTarget,
    pub isToken: bool,
    pub validInGameTag: Option<String>,
    pub addOrOverrideTalentDataBundle:
        Option<Box<clz_Torappu_CharacterData_EquipTalentDataBundleT>>,
    pub overrideTraitDataBundle: Option<Box<clz_Torappu_CharacterData_EquipTraitDataBundleT>>,
}
impl Default for clz_Torappu_BattleUniEquipDataT {
    fn default() -> Self {
        Self {
            resKey: None,
            target: enum__Torappu_UniEquipTarget::NONE,
            isToken: false,
            validInGameTag: None,
            addOrOverrideTalentDataBundle: None,
            overrideTraitDataBundle: None,
        }
    }
}
impl clz_Torappu_BattleUniEquipDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BattleUniEquipData<'b>> {
        let resKey = self.resKey.as_ref().map(|x| _fbb.create_string(x));
        let target = self.target;
        let isToken = self.isToken;
        let validInGameTag = self.validInGameTag.as_ref().map(|x| _fbb.create_string(x));
        let addOrOverrideTalentDataBundle = self
            .addOrOverrideTalentDataBundle
            .as_ref()
            .map(|x| x.pack(_fbb));
        let overrideTraitDataBundle = self.overrideTraitDataBundle.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_BattleUniEquipData::create(
            _fbb,
            &clz_Torappu_BattleUniEquipDataArgs {
                resKey,
                target,
                isToken,
                validInGameTag,
                addOrOverrideTalentDataBundle,
                overrideTraitDataBundle,
            },
        )
    }
}
pub enum dict__string__list_clz_Torappu_Blackboard_DataPairOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_clz_Torappu_Blackboard_DataPair<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__list_clz_Torappu_Blackboard_DataPair<'a> {
    type Inner = dict__string__list_clz_Torappu_Blackboard_DataPair<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__list_clz_Torappu_Blackboard_DataPair<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_clz_Torappu_Blackboard_DataPair { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_clz_Torappu_Blackboard_DataPairArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_Blackboard_DataPair<'bldr>> {
        let mut builder = dict__string__list_clz_Torappu_Blackboard_DataPairBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__list_clz_Torappu_Blackboard_DataPairT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| x.iter().map(|t| t.unpack()).collect());
        dict__string__list_clz_Torappu_Blackboard_DataPairT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__list_clz_Torappu_Blackboard_DataPair::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__list_clz_Torappu_Blackboard_DataPair,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(
                dict__string__list_clz_Torappu_Blackboard_DataPair::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__list_clz_Torappu_Blackboard_DataPair<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_clz_Torappu_Blackboard_DataPairArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for dict__string__list_clz_Torappu_Blackboard_DataPairArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__list_clz_Torappu_Blackboard_DataPairArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__list_clz_Torappu_Blackboard_DataPairBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__list_clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_clz_Torappu_Blackboard_DataPair::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_clz_Torappu_Blackboard_DataPair::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__list_clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__list_clz_Torappu_Blackboard_DataPairBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_Blackboard_DataPair<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__list_clz_Torappu_Blackboard_DataPair::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__list_clz_Torappu_Blackboard_DataPair<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__list_clz_Torappu_Blackboard_DataPair");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__list_clz_Torappu_Blackboard_DataPairT {
    pub key: String,
    pub value: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
}
impl Default for dict__string__list_clz_Torappu_Blackboard_DataPairT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__list_clz_Torappu_Blackboard_DataPairT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_Blackboard_DataPair<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        dict__string__list_clz_Torappu_Blackboard_DataPair::create(
            _fbb,
            &dict__string__list_clz_Torappu_Blackboard_DataPairArgs { key, value },
        )
    }
}
pub enum clz_Torappu_BattleEquipPerLevelPackOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BattleEquipPerLevelPack<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BattleEquipPerLevelPack<'a> {
    type Inner = clz_Torappu_BattleEquipPerLevelPack<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_BattleEquipPerLevelPack<'a> {
    pub const VT_EQUIPLEVEL: flatbuffers::VOffsetT = 4;
    pub const VT_PARTS: flatbuffers::VOffsetT = 6;
    pub const VT_ATTRIBUTEBLACKBOARD: flatbuffers::VOffsetT = 8;
    pub const VT_TOKENATTRIBUTEBLACKBOARD: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BattleEquipPerLevelPack { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BattleEquipPerLevelPackArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BattleEquipPerLevelPack<'bldr>> {
        let mut builder = clz_Torappu_BattleEquipPerLevelPackBuilder::new(_fbb);
        if let Some(x) = args.tokenAttributeBlackboard {
            builder.add_tokenAttributeBlackboard(x);
        }
        if let Some(x) = args.attributeBlackboard {
            builder.add_attributeBlackboard(x);
        }
        if let Some(x) = args.parts {
            builder.add_parts(x);
        }
        builder.add_equipLevel(args.equipLevel);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_BattleEquipPerLevelPackT {
        let equipLevel = self.equipLevel();
        let parts = self.parts().map(|x| x.iter().map(|t| t.unpack()).collect());
        let attributeBlackboard = self
            .attributeBlackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let tokenAttributeBlackboard = self
            .tokenAttributeBlackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_BattleEquipPerLevelPackT {
            equipLevel,
            parts,
            attributeBlackboard,
            tokenAttributeBlackboard,
        }
    }

    #[inline]
    pub fn equipLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BattleEquipPerLevelPack::VT_EQUIPLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn parts(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_BattleUniEquipData<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BattleUniEquipData>,
                >,
            >>(clz_Torappu_BattleEquipPerLevelPack::VT_PARTS, None)
        }
    }
    #[inline]
    pub fn attributeBlackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(
                clz_Torappu_BattleEquipPerLevelPack::VT_ATTRIBUTEBLACKBOARD,
                None,
            )
        }
    }
    #[inline]
    pub fn tokenAttributeBlackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__list_clz_Torappu_Blackboard_DataPair<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__list_clz_Torappu_Blackboard_DataPair,
                    >,
                >,
            >>(
                clz_Torappu_BattleEquipPerLevelPack::VT_TOKENATTRIBUTEBLACKBOARD,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BattleEquipPerLevelPack<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("equipLevel", Self::VT_EQUIPLEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BattleUniEquipData>,
                >,
            >>("parts", Self::VT_PARTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("attributeBlackboard", Self::VT_ATTRIBUTEBLACKBOARD, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__list_clz_Torappu_Blackboard_DataPair,
                    >,
                >,
            >>(
                "tokenAttributeBlackboard",
                Self::VT_TOKENATTRIBUTEBLACKBOARD,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BattleEquipPerLevelPackArgs<'a> {
    pub equipLevel: i32,
    pub parts: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BattleUniEquipData<'a>>,
            >,
        >,
    >,
    pub attributeBlackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
    pub tokenAttributeBlackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_clz_Torappu_Blackboard_DataPair<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BattleEquipPerLevelPackArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BattleEquipPerLevelPackArgs {
            equipLevel: 0,
            parts: None,
            attributeBlackboard: None,
            tokenAttributeBlackboard: None,
        }
    }
}

pub struct clz_Torappu_BattleEquipPerLevelPackBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BattleEquipPerLevelPackBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_equipLevel(&mut self, equipLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BattleEquipPerLevelPack::VT_EQUIPLEVEL,
            equipLevel,
            0,
        );
    }
    #[inline]
    pub fn add_parts(
        &mut self,
        parts: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BattleUniEquipData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BattleEquipPerLevelPack::VT_PARTS,
            parts,
        );
    }
    #[inline]
    pub fn add_attributeBlackboard(
        &mut self,
        attributeBlackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BattleEquipPerLevelPack::VT_ATTRIBUTEBLACKBOARD,
            attributeBlackboard,
        );
    }
    #[inline]
    pub fn add_tokenAttributeBlackboard(
        &mut self,
        tokenAttributeBlackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_clz_Torappu_Blackboard_DataPair<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BattleEquipPerLevelPack::VT_TOKENATTRIBUTEBLACKBOARD,
            tokenAttributeBlackboard,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BattleEquipPerLevelPackBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BattleEquipPerLevelPackBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BattleEquipPerLevelPack<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BattleEquipPerLevelPack<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BattleEquipPerLevelPack");
        ds.field("equipLevel", &self.equipLevel());
        ds.field("parts", &self.parts());
        ds.field("attributeBlackboard", &self.attributeBlackboard());
        ds.field("tokenAttributeBlackboard", &self.tokenAttributeBlackboard());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_BattleEquipPerLevelPackT {
    pub equipLevel: i32,
    pub parts: Option<Vec<clz_Torappu_BattleUniEquipDataT>>,
    pub attributeBlackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
    pub tokenAttributeBlackboard: Option<Vec<dict__string__list_clz_Torappu_Blackboard_DataPairT>>,
}
impl Default for clz_Torappu_BattleEquipPerLevelPackT {
    fn default() -> Self {
        Self {
            equipLevel: 0,
            parts: None,
            attributeBlackboard: None,
            tokenAttributeBlackboard: None,
        }
    }
}
impl clz_Torappu_BattleEquipPerLevelPackT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BattleEquipPerLevelPack<'b>> {
        let equipLevel = self.equipLevel;
        let parts = self.parts.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let attributeBlackboard = self.attributeBlackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let tokenAttributeBlackboard = self.tokenAttributeBlackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_BattleEquipPerLevelPack::create(
            _fbb,
            &clz_Torappu_BattleEquipPerLevelPackArgs {
                equipLevel,
                parts,
                attributeBlackboard,
                tokenAttributeBlackboard,
            },
        )
    }
}
pub enum clz_Torappu_BattleEquipPackOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BattleEquipPack<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BattleEquipPack<'a> {
    type Inner = clz_Torappu_BattleEquipPack<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_BattleEquipPack<'a> {
    pub const VT_PHASES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BattleEquipPack { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BattleEquipPackArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BattleEquipPack<'bldr>> {
        let mut builder = clz_Torappu_BattleEquipPackBuilder::new(_fbb);
        if let Some(x) = args.phases {
            builder.add_phases(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_BattleEquipPackT {
        let phases = self
            .phases()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_BattleEquipPackT { phases }
    }

    #[inline]
    pub fn phases(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BattleEquipPerLevelPack<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BattleEquipPerLevelPack>,
                >,
            >>(clz_Torappu_BattleEquipPack::VT_PHASES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BattleEquipPack<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BattleEquipPerLevelPack>,
                >,
            >>("phases", Self::VT_PHASES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BattleEquipPackArgs<'a> {
    pub phases: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BattleEquipPerLevelPack<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BattleEquipPackArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BattleEquipPackArgs { phases: None }
    }
}

pub struct clz_Torappu_BattleEquipPackBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_BattleEquipPackBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_phases(
        &mut self,
        phases: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BattleEquipPerLevelPack<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BattleEquipPack::VT_PHASES,
            phases,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BattleEquipPackBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BattleEquipPackBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BattleEquipPack<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BattleEquipPack<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BattleEquipPack");
        ds.field("phases", &self.phases());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_BattleEquipPackT {
    pub phases: Option<Vec<clz_Torappu_BattleEquipPerLevelPackT>>,
}
impl Default for clz_Torappu_BattleEquipPackT {
    fn default() -> Self {
        Self { phases: None }
    }
}
impl clz_Torappu_BattleEquipPackT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BattleEquipPack<'b>> {
        let phases = self.phases.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_BattleEquipPack::create(_fbb, &clz_Torappu_BattleEquipPackArgs { phases })
    }
}
pub enum dict__string__clz_Torappu_BattleEquipPackOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BattleEquipPack<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_BattleEquipPack<'a> {
    type Inner = dict__string__clz_Torappu_BattleEquipPack<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_BattleEquipPack<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BattleEquipPack { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BattleEquipPackArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BattleEquipPack<'bldr>> {
        let mut builder = dict__string__clz_Torappu_BattleEquipPackBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_BattleEquipPackT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_BattleEquipPackT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BattleEquipPack::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_BattleEquipPack) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BattleEquipPack<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BattleEquipPack>>(
                    dict__string__clz_Torappu_BattleEquipPack::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_BattleEquipPack<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BattleEquipPack>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BattleEquipPackArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_BattleEquipPack<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BattleEquipPackArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BattleEquipPackArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_BattleEquipPackBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BattleEquipPackBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BattleEquipPack::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_BattleEquipPack<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BattleEquipPack>>(
                dict__string__clz_Torappu_BattleEquipPack::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BattleEquipPackBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BattleEquipPackBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BattleEquipPack<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_BattleEquipPack::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BattleEquipPack<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_BattleEquipPack");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_BattleEquipPackT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_BattleEquipPackT>>,
}
impl Default for dict__string__clz_Torappu_BattleEquipPackT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_BattleEquipPackT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BattleEquipPack<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_BattleEquipPack::create(
            _fbb,
            &dict__string__clz_Torappu_BattleEquipPackArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPackOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack<'a> {
    type Inner = clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack<'a> {
    pub const VT_EQUIPS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPackArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack<'bldr>> {
        let mut builder = clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPackBuilder::new(_fbb);
        if let Some(x) = args.equips {
            builder.add_equips(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPackT {
        let equips = self
            .equips()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPackT { equips }
    }

    #[inline]
    pub fn equips(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BattleEquipPack<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BattleEquipPack>,
                >,
            >>(
                clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack::VT_EQUIPS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BattleEquipPack>,
                >,
            >>("equips", Self::VT_EQUIPS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPackArgs<'a> {
    pub equips: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BattleEquipPack<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPackArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPackArgs { equips: None }
    }
}

pub struct clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPackBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPackBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_equips(
        &mut self,
        equips: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BattleEquipPack<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack::VT_EQUIPS,
            equips,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPackBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPackBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack");
        ds.field("equips", &self.equips());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPackT {
    pub equips: Option<Vec<dict__string__clz_Torappu_BattleEquipPackT>>,
}
impl Default for clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPackT {
    fn default() -> Self {
        Self { equips: None }
    }
}
impl clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPackT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack<'b>> {
        let equips = self.equips.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack::create(
            _fbb,
            &clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPackArgs { equips },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_simple_kvtable_clz_torappu_battle_equip_pack_unchecked`.
pub fn root_as_clz_torappu_simple_kvtable_clz_torappu_battle_equip_pack(
    buf: &[u8],
) -> Result<clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack<'_>, flatbuffers::InvalidFlatbuffer>
{
    flatbuffers::root::<clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_simple_kvtable_clz_torappu_battle_equip_pack_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_simple_kvtable_clz_torappu_battle_equip_pack(
    buf: &[u8],
) -> Result<clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack<'_>, flatbuffers::InvalidFlatbuffer>
{
    flatbuffers::size_prefixed_root::<clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_simple_kvtable_clz_torappu_battle_equip_pack_unchecked`.
pub fn root_as_clz_torappu_simple_kvtable_clz_torappu_battle_equip_pack_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack<'b>, flatbuffers::InvalidFlatbuffer>
{
    flatbuffers::root_with_opts::<clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack<'b>>(
        opts, buf,
    )
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_simple_kvtable_clz_torappu_battle_equip_pack_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_simple_kvtable_clz_torappu_battle_equip_pack_with_opts<
    'b,
    'o,
>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack<'b>, flatbuffers::InvalidFlatbuffer>
{
    flatbuffers::size_prefixed_root_with_opts::<
        clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack<'b>,
    >(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack`.
pub unsafe fn root_as_clz_torappu_simple_kvtable_clz_torappu_battle_equip_pack_unchecked(
    buf: &[u8],
) -> clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack<'_> {
    unsafe {
        flatbuffers::root_unchecked::<clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack>(buf)
    }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack`.
pub unsafe fn size_prefixed_root_as_clz_torappu_simple_kvtable_clz_torappu_battle_equip_pack_unchecked(
    buf: &[u8],
) -> clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack<'_> {
    unsafe {
        flatbuffers::size_prefixed_root_unchecked::<
            clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack,
        >(buf)
    }
}
#[inline]
pub fn finish_clz_torappu_simple_kvtable_clz_torappu_battle_equip_pack_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_simple_kvtable_clz_torappu_battle_equip_pack_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_SimpleKVTable_clz_Torappu_BattleEquipPack<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
