// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SPECIAL_OPERATOR_TARGET_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SPECIAL_OPERATOR_TARGET_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SPECIAL_OPERATOR_TARGET_TYPE:
    [enum__Torappu_SpecialOperatorTargetType; 2] = [
    enum__Torappu_SpecialOperatorTargetType::NONE,
    enum__Torappu_SpecialOperatorTargetType::ROGUE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SpecialOperatorTargetType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SpecialOperatorTargetType {
    pub const NONE: Self = Self(0);
    pub const ROGUE: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::ROGUE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ROGUE => Some("ROGUE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SpecialOperatorTargetType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SpecialOperatorTargetType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SpecialOperatorTargetType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SpecialOperatorTargetType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SpecialOperatorTargetType {
    type Output = enum__Torappu_SpecialOperatorTargetType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SpecialOperatorTargetType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SpecialOperatorTargetType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SpecialOperatorTargetType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUILDABLE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUILDABLE_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUILDABLE_TYPE: [enum__Torappu_BuildableType; 4] = [
    enum__Torappu_BuildableType::NONE,
    enum__Torappu_BuildableType::MELEE,
    enum__Torappu_BuildableType::RANGED,
    enum__Torappu_BuildableType::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuildableType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuildableType {
    pub const NONE: Self = Self(0);
    pub const MELEE: Self = Self(1);
    pub const RANGED: Self = Self(2);
    pub const ALL: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::MELEE, Self::RANGED, Self::ALL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MELEE => Some("MELEE"),
            Self::RANGED => Some("RANGED"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuildableType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_BuildableType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_BuildableType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuildableType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuildableType {
    type Output = enum__Torappu_BuildableType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuildableType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuildableType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuildableType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_RARITY_RANK: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_RARITY_RANK: i32 = 6;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_RARITY_RANK: [enum__Torappu_RarityRank; 7] = [
    enum__Torappu_RarityRank::TIER_1,
    enum__Torappu_RarityRank::TIER_2,
    enum__Torappu_RarityRank::TIER_3,
    enum__Torappu_RarityRank::TIER_4,
    enum__Torappu_RarityRank::TIER_5,
    enum__Torappu_RarityRank::TIER_6,
    enum__Torappu_RarityRank::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RarityRank(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RarityRank {
    pub const TIER_1: Self = Self(0);
    pub const TIER_2: Self = Self(1);
    pub const TIER_3: Self = Self(2);
    pub const TIER_4: Self = Self(3);
    pub const TIER_5: Self = Self(4);
    pub const TIER_6: Self = Self(5);
    pub const E_NUM: Self = Self(6);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 6;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::TIER_1,
        Self::TIER_2,
        Self::TIER_3,
        Self::TIER_4,
        Self::TIER_5,
        Self::TIER_6,
        Self::E_NUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::TIER_1 => Some("TIER_1"),
            Self::TIER_2 => Some("TIER_2"),
            Self::TIER_3 => Some("TIER_3"),
            Self::TIER_4 => Some("TIER_4"),
            Self::TIER_5 => Some("TIER_5"),
            Self::TIER_6 => Some("TIER_6"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RarityRank {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RarityRank {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RarityRank",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RarityRank {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RarityRank {
    type Output = enum__Torappu_RarityRank;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RarityRank {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RarityRank {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RarityRank {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_PROFESSION_CATEGORY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_PROFESSION_CATEGORY: i32 = 512;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_PROFESSION_CATEGORY: [enum__Torappu_ProfessionCategory; 11] = [
    enum__Torappu_ProfessionCategory::NONE,
    enum__Torappu_ProfessionCategory::WARRIOR,
    enum__Torappu_ProfessionCategory::SNIPER,
    enum__Torappu_ProfessionCategory::TANK,
    enum__Torappu_ProfessionCategory::MEDIC,
    enum__Torappu_ProfessionCategory::SUPPORT,
    enum__Torappu_ProfessionCategory::CASTER,
    enum__Torappu_ProfessionCategory::SPECIAL,
    enum__Torappu_ProfessionCategory::TOKEN,
    enum__Torappu_ProfessionCategory::TRAP,
    enum__Torappu_ProfessionCategory::PIONEER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ProfessionCategory(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ProfessionCategory {
    pub const NONE: Self = Self(0);
    pub const WARRIOR: Self = Self(1);
    pub const SNIPER: Self = Self(2);
    pub const TANK: Self = Self(4);
    pub const MEDIC: Self = Self(8);
    pub const SUPPORT: Self = Self(16);
    pub const CASTER: Self = Self(32);
    pub const SPECIAL: Self = Self(64);
    pub const TOKEN: Self = Self(128);
    pub const TRAP: Self = Self(256);
    pub const PIONEER: Self = Self(512);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 512;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::WARRIOR,
        Self::SNIPER,
        Self::TANK,
        Self::MEDIC,
        Self::SUPPORT,
        Self::CASTER,
        Self::SPECIAL,
        Self::TOKEN,
        Self::TRAP,
        Self::PIONEER,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::WARRIOR => Some("WARRIOR"),
            Self::SNIPER => Some("SNIPER"),
            Self::TANK => Some("TANK"),
            Self::MEDIC => Some("MEDIC"),
            Self::SUPPORT => Some("SUPPORT"),
            Self::CASTER => Some("CASTER"),
            Self::SPECIAL => Some("SPECIAL"),
            Self::TOKEN => Some("TOKEN"),
            Self::TRAP => Some("TRAP"),
            Self::PIONEER => Some("PIONEER"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ProfessionCategory {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ProfessionCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ProfessionCategory",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ProfessionCategory {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ProfessionCategory {
    type Output = enum__Torappu_ProfessionCategory;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ProfessionCategory {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ProfessionCategory {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ProfessionCategory {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_EVOLVE_PHASE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_EVOLVE_PHASE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_EVOLVE_PHASE: [enum__Torappu_EvolvePhase; 5] = [
    enum__Torappu_EvolvePhase::PHASE_0,
    enum__Torappu_EvolvePhase::PHASE_1,
    enum__Torappu_EvolvePhase::PHASE_2,
    enum__Torappu_EvolvePhase::PHASE_3,
    enum__Torappu_EvolvePhase::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_EvolvePhase(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_EvolvePhase {
    pub const PHASE_0: Self = Self(0);
    pub const PHASE_1: Self = Self(1);
    pub const PHASE_2: Self = Self(2);
    pub const PHASE_3: Self = Self(3);
    pub const E_NUM: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::PHASE_0,
        Self::PHASE_1,
        Self::PHASE_2,
        Self::PHASE_3,
        Self::E_NUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::PHASE_0 => Some("PHASE_0"),
            Self::PHASE_1 => Some("PHASE_1"),
            Self::PHASE_2 => Some("PHASE_2"),
            Self::PHASE_3 => Some("PHASE_3"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_EvolvePhase {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_EvolvePhase {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_EvolvePhase",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_EvolvePhase {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_EvolvePhase {
    type Output = enum__Torappu_EvolvePhase;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_EvolvePhase {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_EvolvePhase {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_EvolvePhase {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ITEM_TYPE: i32 = 90;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ITEM_TYPE: [enum__Torappu_ItemType; 91] = [
    enum__Torappu_ItemType::NONE,
    enum__Torappu_ItemType::CHAR,
    enum__Torappu_ItemType::CARD_EXP,
    enum__Torappu_ItemType::MATERIAL,
    enum__Torappu_ItemType::GOLD,
    enum__Torappu_ItemType::EXP_PLAYER,
    enum__Torappu_ItemType::TKT_TRY,
    enum__Torappu_ItemType::TKT_RECRUIT,
    enum__Torappu_ItemType::TKT_INST_FIN,
    enum__Torappu_ItemType::TKT_GACHA,
    enum__Torappu_ItemType::ACTIVITY_COIN,
    enum__Torappu_ItemType::DIAMOND,
    enum__Torappu_ItemType::DIAMOND_SHD,
    enum__Torappu_ItemType::HGG_SHD,
    enum__Torappu_ItemType::LGG_SHD,
    enum__Torappu_ItemType::FURN,
    enum__Torappu_ItemType::AP_GAMEPLAY,
    enum__Torappu_ItemType::AP_BASE,
    enum__Torappu_ItemType::SOCIAL_PT,
    enum__Torappu_ItemType::CHAR_SKIN,
    enum__Torappu_ItemType::TKT_GACHA_10,
    enum__Torappu_ItemType::TKT_GACHA_PRSV,
    enum__Torappu_ItemType::AP_ITEM,
    enum__Torappu_ItemType::AP_SUPPLY,
    enum__Torappu_ItemType::RENAMING_CARD,
    enum__Torappu_ItemType::RENAMING_CARD_2,
    enum__Torappu_ItemType::ET_STAGE,
    enum__Torappu_ItemType::ACTIVITY_ITEM,
    enum__Torappu_ItemType::VOUCHER_PICK,
    enum__Torappu_ItemType::VOUCHER_CGACHA,
    enum__Torappu_ItemType::VOUCHER_MGACHA,
    enum__Torappu_ItemType::CRS_SHOP_COIN,
    enum__Torappu_ItemType::CRS_RUNE_COIN,
    enum__Torappu_ItemType::LMTGS_COIN,
    enum__Torappu_ItemType::EPGS_COIN,
    enum__Torappu_ItemType::LIMITED_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_FREE_GACHA,
    enum__Torappu_ItemType::REP_COIN,
    enum__Torappu_ItemType::ROGUELIKE,
    enum__Torappu_ItemType::LINKAGE_TKT_GACHA_10,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_4,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_5,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_6,
    enum__Torappu_ItemType::VOUCHER_SKIN,
    enum__Torappu_ItemType::RETRO_COIN,
    enum__Torappu_ItemType::PLAYER_AVATAR,
    enum__Torappu_ItemType::UNI_COLLECTION,
    enum__Torappu_ItemType::VOUCHER_FULL_POTENTIAL,
    enum__Torappu_ItemType::RL_COIN,
    enum__Torappu_ItemType::RETURN_CREDIT,
    enum__Torappu_ItemType::MEDAL,
    enum__Torappu_ItemType::CHARM,
    enum__Torappu_ItemType::HOME_BACKGROUND,
    enum__Torappu_ItemType::EXTERMINATION_AGENT,
    enum__Torappu_ItemType::OPTIONAL_VOUCHER_PICK,
    enum__Torappu_ItemType::ACT_CART_COMPONENT,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_4,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_4,
    enum__Torappu_ItemType::ACTIVITY_POTENTIAL,
    enum__Torappu_ItemType::ITEM_PACK,
    enum__Torappu_ItemType::SANDBOX,
    enum__Torappu_ItemType::FAVOR_ADD_ITEM,
    enum__Torappu_ItemType::CLASSIC_SHD,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_BUFF,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_5,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_6,
    enum__Torappu_ItemType::RETURN_PROGRESS,
    enum__Torappu_ItemType::NEW_PROGRESS,
    enum__Torappu_ItemType::MCARD_VOUCHER,
    enum__Torappu_ItemType::MATERIAL_ISSUE_VOUCHER,
    enum__Torappu_ItemType::CRS_SHOP_COIN_V2,
    enum__Torappu_ItemType::HOME_THEME,
    enum__Torappu_ItemType::SANDBOX_PERM,
    enum__Torappu_ItemType::SANDBOX_TOKEN,
    enum__Torappu_ItemType::TEMPLATE_TRAP,
    enum__Torappu_ItemType::NAME_CARD_SKIN,
    enum__Torappu_ItemType::EMOTICON_SET,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA_10,
    enum__Torappu_ItemType::SO_CHAR_EXP,
    enum__Torappu_ItemType::GIFTPACKAGE_TKT,
    enum__Torappu_ItemType::VOUCHER_SKIN_V2,
    enum__Torappu_ItemType::RANDOM_VOUCHER_SKIN,
    enum__Torappu_ItemType::ACT1VHALFIDLE_ITEM,
    enum__Torappu_ItemType::PLOT_ITEM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ItemType {
    pub const NONE: Self = Self(0);
    pub const CHAR: Self = Self(1);
    pub const CARD_EXP: Self = Self(2);
    pub const MATERIAL: Self = Self(3);
    pub const GOLD: Self = Self(4);
    pub const EXP_PLAYER: Self = Self(5);
    pub const TKT_TRY: Self = Self(6);
    pub const TKT_RECRUIT: Self = Self(7);
    pub const TKT_INST_FIN: Self = Self(8);
    pub const TKT_GACHA: Self = Self(9);
    pub const ACTIVITY_COIN: Self = Self(10);
    pub const DIAMOND: Self = Self(11);
    pub const DIAMOND_SHD: Self = Self(12);
    pub const HGG_SHD: Self = Self(13);
    pub const LGG_SHD: Self = Self(14);
    pub const FURN: Self = Self(15);
    pub const AP_GAMEPLAY: Self = Self(16);
    pub const AP_BASE: Self = Self(17);
    pub const SOCIAL_PT: Self = Self(18);
    pub const CHAR_SKIN: Self = Self(19);
    pub const TKT_GACHA_10: Self = Self(20);
    pub const TKT_GACHA_PRSV: Self = Self(21);
    pub const AP_ITEM: Self = Self(22);
    pub const AP_SUPPLY: Self = Self(23);
    pub const RENAMING_CARD: Self = Self(24);
    pub const RENAMING_CARD_2: Self = Self(25);
    pub const ET_STAGE: Self = Self(26);
    pub const ACTIVITY_ITEM: Self = Self(27);
    pub const VOUCHER_PICK: Self = Self(28);
    pub const VOUCHER_CGACHA: Self = Self(29);
    pub const VOUCHER_MGACHA: Self = Self(30);
    pub const CRS_SHOP_COIN: Self = Self(31);
    pub const CRS_RUNE_COIN: Self = Self(32);
    pub const LMTGS_COIN: Self = Self(33);
    pub const EPGS_COIN: Self = Self(34);
    pub const LIMITED_TKT_GACHA_10: Self = Self(35);
    pub const LIMITED_FREE_GACHA: Self = Self(36);
    pub const REP_COIN: Self = Self(37);
    pub const ROGUELIKE: Self = Self(38);
    pub const LINKAGE_TKT_GACHA_10: Self = Self(39);
    pub const VOUCHER_ELITE_II_4: Self = Self(40);
    pub const VOUCHER_ELITE_II_5: Self = Self(41);
    pub const VOUCHER_ELITE_II_6: Self = Self(42);
    pub const VOUCHER_SKIN: Self = Self(43);
    pub const RETRO_COIN: Self = Self(44);
    pub const PLAYER_AVATAR: Self = Self(45);
    pub const UNI_COLLECTION: Self = Self(46);
    pub const VOUCHER_FULL_POTENTIAL: Self = Self(47);
    pub const RL_COIN: Self = Self(48);
    pub const RETURN_CREDIT: Self = Self(49);
    pub const MEDAL: Self = Self(50);
    pub const CHARM: Self = Self(51);
    pub const HOME_BACKGROUND: Self = Self(52);
    pub const EXTERMINATION_AGENT: Self = Self(53);
    pub const OPTIONAL_VOUCHER_PICK: Self = Self(54);
    pub const ACT_CART_COMPONENT: Self = Self(55);
    pub const VOUCHER_LEVELMAX_6: Self = Self(56);
    pub const VOUCHER_LEVELMAX_5: Self = Self(57);
    pub const VOUCHER_LEVELMAX_4: Self = Self(58);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_6: Self = Self(59);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_5: Self = Self(60);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_4: Self = Self(61);
    pub const ACTIVITY_POTENTIAL: Self = Self(62);
    pub const ITEM_PACK: Self = Self(63);
    pub const SANDBOX: Self = Self(64);
    pub const FAVOR_ADD_ITEM: Self = Self(65);
    pub const CLASSIC_SHD: Self = Self(66);
    pub const CLASSIC_TKT_GACHA: Self = Self(67);
    pub const CLASSIC_TKT_GACHA_10: Self = Self(68);
    pub const LIMITED_BUFF: Self = Self(69);
    pub const CLASSIC_FES_PICK_TIER_5: Self = Self(70);
    pub const CLASSIC_FES_PICK_TIER_6: Self = Self(71);
    pub const RETURN_PROGRESS: Self = Self(72);
    pub const NEW_PROGRESS: Self = Self(73);
    pub const MCARD_VOUCHER: Self = Self(74);
    pub const MATERIAL_ISSUE_VOUCHER: Self = Self(75);
    pub const CRS_SHOP_COIN_V2: Self = Self(76);
    pub const HOME_THEME: Self = Self(77);
    pub const SANDBOX_PERM: Self = Self(78);
    pub const SANDBOX_TOKEN: Self = Self(79);
    pub const TEMPLATE_TRAP: Self = Self(80);
    pub const NAME_CARD_SKIN: Self = Self(81);
    pub const EMOTICON_SET: Self = Self(82);
    pub const EXCLUSIVE_TKT_GACHA: Self = Self(83);
    pub const EXCLUSIVE_TKT_GACHA_10: Self = Self(84);
    pub const SO_CHAR_EXP: Self = Self(85);
    pub const GIFTPACKAGE_TKT: Self = Self(86);
    pub const VOUCHER_SKIN_V2: Self = Self(87);
    pub const RANDOM_VOUCHER_SKIN: Self = Self(88);
    pub const ACT1VHALFIDLE_ITEM: Self = Self(89);
    pub const PLOT_ITEM: Self = Self(90);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 90;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::CHAR,
        Self::CARD_EXP,
        Self::MATERIAL,
        Self::GOLD,
        Self::EXP_PLAYER,
        Self::TKT_TRY,
        Self::TKT_RECRUIT,
        Self::TKT_INST_FIN,
        Self::TKT_GACHA,
        Self::ACTIVITY_COIN,
        Self::DIAMOND,
        Self::DIAMOND_SHD,
        Self::HGG_SHD,
        Self::LGG_SHD,
        Self::FURN,
        Self::AP_GAMEPLAY,
        Self::AP_BASE,
        Self::SOCIAL_PT,
        Self::CHAR_SKIN,
        Self::TKT_GACHA_10,
        Self::TKT_GACHA_PRSV,
        Self::AP_ITEM,
        Self::AP_SUPPLY,
        Self::RENAMING_CARD,
        Self::RENAMING_CARD_2,
        Self::ET_STAGE,
        Self::ACTIVITY_ITEM,
        Self::VOUCHER_PICK,
        Self::VOUCHER_CGACHA,
        Self::VOUCHER_MGACHA,
        Self::CRS_SHOP_COIN,
        Self::CRS_RUNE_COIN,
        Self::LMTGS_COIN,
        Self::EPGS_COIN,
        Self::LIMITED_TKT_GACHA_10,
        Self::LIMITED_FREE_GACHA,
        Self::REP_COIN,
        Self::ROGUELIKE,
        Self::LINKAGE_TKT_GACHA_10,
        Self::VOUCHER_ELITE_II_4,
        Self::VOUCHER_ELITE_II_5,
        Self::VOUCHER_ELITE_II_6,
        Self::VOUCHER_SKIN,
        Self::RETRO_COIN,
        Self::PLAYER_AVATAR,
        Self::UNI_COLLECTION,
        Self::VOUCHER_FULL_POTENTIAL,
        Self::RL_COIN,
        Self::RETURN_CREDIT,
        Self::MEDAL,
        Self::CHARM,
        Self::HOME_BACKGROUND,
        Self::EXTERMINATION_AGENT,
        Self::OPTIONAL_VOUCHER_PICK,
        Self::ACT_CART_COMPONENT,
        Self::VOUCHER_LEVELMAX_6,
        Self::VOUCHER_LEVELMAX_5,
        Self::VOUCHER_LEVELMAX_4,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_6,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_5,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_4,
        Self::ACTIVITY_POTENTIAL,
        Self::ITEM_PACK,
        Self::SANDBOX,
        Self::FAVOR_ADD_ITEM,
        Self::CLASSIC_SHD,
        Self::CLASSIC_TKT_GACHA,
        Self::CLASSIC_TKT_GACHA_10,
        Self::LIMITED_BUFF,
        Self::CLASSIC_FES_PICK_TIER_5,
        Self::CLASSIC_FES_PICK_TIER_6,
        Self::RETURN_PROGRESS,
        Self::NEW_PROGRESS,
        Self::MCARD_VOUCHER,
        Self::MATERIAL_ISSUE_VOUCHER,
        Self::CRS_SHOP_COIN_V2,
        Self::HOME_THEME,
        Self::SANDBOX_PERM,
        Self::SANDBOX_TOKEN,
        Self::TEMPLATE_TRAP,
        Self::NAME_CARD_SKIN,
        Self::EMOTICON_SET,
        Self::EXCLUSIVE_TKT_GACHA,
        Self::EXCLUSIVE_TKT_GACHA_10,
        Self::SO_CHAR_EXP,
        Self::GIFTPACKAGE_TKT,
        Self::VOUCHER_SKIN_V2,
        Self::RANDOM_VOUCHER_SKIN,
        Self::ACT1VHALFIDLE_ITEM,
        Self::PLOT_ITEM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::CHAR => Some("CHAR"),
            Self::CARD_EXP => Some("CARD_EXP"),
            Self::MATERIAL => Some("MATERIAL"),
            Self::GOLD => Some("GOLD"),
            Self::EXP_PLAYER => Some("EXP_PLAYER"),
            Self::TKT_TRY => Some("TKT_TRY"),
            Self::TKT_RECRUIT => Some("TKT_RECRUIT"),
            Self::TKT_INST_FIN => Some("TKT_INST_FIN"),
            Self::TKT_GACHA => Some("TKT_GACHA"),
            Self::ACTIVITY_COIN => Some("ACTIVITY_COIN"),
            Self::DIAMOND => Some("DIAMOND"),
            Self::DIAMOND_SHD => Some("DIAMOND_SHD"),
            Self::HGG_SHD => Some("HGG_SHD"),
            Self::LGG_SHD => Some("LGG_SHD"),
            Self::FURN => Some("FURN"),
            Self::AP_GAMEPLAY => Some("AP_GAMEPLAY"),
            Self::AP_BASE => Some("AP_BASE"),
            Self::SOCIAL_PT => Some("SOCIAL_PT"),
            Self::CHAR_SKIN => Some("CHAR_SKIN"),
            Self::TKT_GACHA_10 => Some("TKT_GACHA_10"),
            Self::TKT_GACHA_PRSV => Some("TKT_GACHA_PRSV"),
            Self::AP_ITEM => Some("AP_ITEM"),
            Self::AP_SUPPLY => Some("AP_SUPPLY"),
            Self::RENAMING_CARD => Some("RENAMING_CARD"),
            Self::RENAMING_CARD_2 => Some("RENAMING_CARD_2"),
            Self::ET_STAGE => Some("ET_STAGE"),
            Self::ACTIVITY_ITEM => Some("ACTIVITY_ITEM"),
            Self::VOUCHER_PICK => Some("VOUCHER_PICK"),
            Self::VOUCHER_CGACHA => Some("VOUCHER_CGACHA"),
            Self::VOUCHER_MGACHA => Some("VOUCHER_MGACHA"),
            Self::CRS_SHOP_COIN => Some("CRS_SHOP_COIN"),
            Self::CRS_RUNE_COIN => Some("CRS_RUNE_COIN"),
            Self::LMTGS_COIN => Some("LMTGS_COIN"),
            Self::EPGS_COIN => Some("EPGS_COIN"),
            Self::LIMITED_TKT_GACHA_10 => Some("LIMITED_TKT_GACHA_10"),
            Self::LIMITED_FREE_GACHA => Some("LIMITED_FREE_GACHA"),
            Self::REP_COIN => Some("REP_COIN"),
            Self::ROGUELIKE => Some("ROGUELIKE"),
            Self::LINKAGE_TKT_GACHA_10 => Some("LINKAGE_TKT_GACHA_10"),
            Self::VOUCHER_ELITE_II_4 => Some("VOUCHER_ELITE_II_4"),
            Self::VOUCHER_ELITE_II_5 => Some("VOUCHER_ELITE_II_5"),
            Self::VOUCHER_ELITE_II_6 => Some("VOUCHER_ELITE_II_6"),
            Self::VOUCHER_SKIN => Some("VOUCHER_SKIN"),
            Self::RETRO_COIN => Some("RETRO_COIN"),
            Self::PLAYER_AVATAR => Some("PLAYER_AVATAR"),
            Self::UNI_COLLECTION => Some("UNI_COLLECTION"),
            Self::VOUCHER_FULL_POTENTIAL => Some("VOUCHER_FULL_POTENTIAL"),
            Self::RL_COIN => Some("RL_COIN"),
            Self::RETURN_CREDIT => Some("RETURN_CREDIT"),
            Self::MEDAL => Some("MEDAL"),
            Self::CHARM => Some("CHARM"),
            Self::HOME_BACKGROUND => Some("HOME_BACKGROUND"),
            Self::EXTERMINATION_AGENT => Some("EXTERMINATION_AGENT"),
            Self::OPTIONAL_VOUCHER_PICK => Some("OPTIONAL_VOUCHER_PICK"),
            Self::ACT_CART_COMPONENT => Some("ACT_CART_COMPONENT"),
            Self::VOUCHER_LEVELMAX_6 => Some("VOUCHER_LEVELMAX_6"),
            Self::VOUCHER_LEVELMAX_5 => Some("VOUCHER_LEVELMAX_5"),
            Self::VOUCHER_LEVELMAX_4 => Some("VOUCHER_LEVELMAX_4"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_6 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_6"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_5 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_5"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_4 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_4"),
            Self::ACTIVITY_POTENTIAL => Some("ACTIVITY_POTENTIAL"),
            Self::ITEM_PACK => Some("ITEM_PACK"),
            Self::SANDBOX => Some("SANDBOX"),
            Self::FAVOR_ADD_ITEM => Some("FAVOR_ADD_ITEM"),
            Self::CLASSIC_SHD => Some("CLASSIC_SHD"),
            Self::CLASSIC_TKT_GACHA => Some("CLASSIC_TKT_GACHA"),
            Self::CLASSIC_TKT_GACHA_10 => Some("CLASSIC_TKT_GACHA_10"),
            Self::LIMITED_BUFF => Some("LIMITED_BUFF"),
            Self::CLASSIC_FES_PICK_TIER_5 => Some("CLASSIC_FES_PICK_TIER_5"),
            Self::CLASSIC_FES_PICK_TIER_6 => Some("CLASSIC_FES_PICK_TIER_6"),
            Self::RETURN_PROGRESS => Some("RETURN_PROGRESS"),
            Self::NEW_PROGRESS => Some("NEW_PROGRESS"),
            Self::MCARD_VOUCHER => Some("MCARD_VOUCHER"),
            Self::MATERIAL_ISSUE_VOUCHER => Some("MATERIAL_ISSUE_VOUCHER"),
            Self::CRS_SHOP_COIN_V2 => Some("CRS_SHOP_COIN_V2"),
            Self::HOME_THEME => Some("HOME_THEME"),
            Self::SANDBOX_PERM => Some("SANDBOX_PERM"),
            Self::SANDBOX_TOKEN => Some("SANDBOX_TOKEN"),
            Self::TEMPLATE_TRAP => Some("TEMPLATE_TRAP"),
            Self::NAME_CARD_SKIN => Some("NAME_CARD_SKIN"),
            Self::EMOTICON_SET => Some("EMOTICON_SET"),
            Self::EXCLUSIVE_TKT_GACHA => Some("EXCLUSIVE_TKT_GACHA"),
            Self::EXCLUSIVE_TKT_GACHA_10 => Some("EXCLUSIVE_TKT_GACHA_10"),
            Self::SO_CHAR_EXP => Some("SO_CHAR_EXP"),
            Self::GIFTPACKAGE_TKT => Some("GIFTPACKAGE_TKT"),
            Self::VOUCHER_SKIN_V2 => Some("VOUCHER_SKIN_V2"),
            Self::RANDOM_VOUCHER_SKIN => Some("RANDOM_VOUCHER_SKIN"),
            Self::ACT1VHALFIDLE_ITEM => Some("ACT1VHALFIDLE_ITEM"),
            Self::PLOT_ITEM => Some("PLOT_ITEM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ItemType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ItemType {
    type Output = enum__Torappu_ItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_CHARACTER_DATA_POTENTIAL_RANK_TYPE_ENUM: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_CHARACTER_DATA_POTENTIAL_RANK_TYPE_ENUM: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_CHARACTER_DATA_POTENTIAL_RANK_TYPE_ENUM:
    [enum__Torappu_CharacterData_PotentialRank_TypeEnum; 2] = [
    enum__Torappu_CharacterData_PotentialRank_TypeEnum::BUFF,
    enum__Torappu_CharacterData_PotentialRank_TypeEnum::CUSTOM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_CharacterData_PotentialRank_TypeEnum(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_CharacterData_PotentialRank_TypeEnum {
    pub const BUFF: Self = Self(0);
    pub const CUSTOM: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::BUFF, Self::CUSTOM];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::BUFF => Some("BUFF"),
            Self::CUSTOM => Some("CUSTOM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_CharacterData_PotentialRank_TypeEnum {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_CharacterData_PotentialRank_TypeEnum {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_CharacterData_PotentialRank_TypeEnum",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_CharacterData_PotentialRank_TypeEnum {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_CharacterData_PotentialRank_TypeEnum {
    type Output = enum__Torappu_CharacterData_PotentialRank_TypeEnum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_CharacterData_PotentialRank_TypeEnum {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_CharacterData_PotentialRank_TypeEnum {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_CharacterData_PotentialRank_TypeEnum {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ABNORMAL_FLAG: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ABNORMAL_FLAG: i32 = 42;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ABNORMAL_FLAG: [enum__Torappu_AbnormalFlag; 43] = [
    enum__Torappu_AbnormalFlag::STUNNED,
    enum__Torappu_AbnormalFlag::SP_RECOVER_STOPPED,
    enum__Torappu_AbnormalFlag::TARGET_FREE,
    enum__Torappu_AbnormalFlag::BLOCK_FREE,
    enum__Torappu_AbnormalFlag::HIDDEN,
    enum__Torappu_AbnormalFlag::INVINCIBLE,
    enum__Torappu_AbnormalFlag::UNDEADABLE,
    enum__Torappu_AbnormalFlag::HEAL_FREE,
    enum__Torappu_AbnormalFlag::UNBALANCE_IMMUNE,
    enum__Torappu_AbnormalFlag::INVISIBLE,
    enum__Torappu_AbnormalFlag::UNUSED_PLACEHOLDER_1,
    enum__Torappu_AbnormalFlag::DISARMED,
    enum__Torappu_AbnormalFlag::SILENCED,
    enum__Torappu_AbnormalFlag::UNMOVABLE,
    enum__Torappu_AbnormalFlag::UNUSED_PLACEHOLDER_2,
    enum__Torappu_AbnormalFlag::ALLY_TARGET_FREE,
    enum__Torappu_AbnormalFlag::FROZEN,
    enum__Torappu_AbnormalFlag::CAMOUFLAGE,
    enum__Torappu_AbnormalFlag::FORCE_DISARMED,
    enum__Torappu_AbnormalFlag::STUNNED_NO_AMPLIFY_DAMAGE,
    enum__Torappu_AbnormalFlag::DISABLE_COMBAT,
    enum__Torappu_AbnormalFlag::ELEMENT_FREE_ALL,
    enum__Torappu_AbnormalFlag::UNMOVABLE_PRIVATE,
    enum__Torappu_AbnormalFlag::COLD,
    enum__Torappu_AbnormalFlag::SKILL_NOT_ACTIVATABLE,
    enum__Torappu_AbnormalFlag::LEVITATE,
    enum__Torappu_AbnormalFlag::DURANCE,
    enum__Torappu_AbnormalFlag::NOT_WITHDRAWABLE,
    enum__Torappu_AbnormalFlag::OUT_OF_GROUND,
    enum__Torappu_AbnormalFlag::SP_MODIFY_STOPPED,
    enum__Torappu_AbnormalFlag::ANTI_STATUS_RESISTABLE,
    enum__Torappu_AbnormalFlag::DISARMED_COMBAT,
    enum__Torappu_AbnormalFlag::TOWER_TARGET_FREE,
    enum__Torappu_AbnormalFlag::FEARED,
    enum__Torappu_AbnormalFlag::SKILL_ACTIVABLE_IN_ABNORMAL,
    enum__Torappu_AbnormalFlag::MOTION_TARGET_FREE,
    enum__Torappu_AbnormalFlag::FORCE_LEVITATE,
    enum__Torappu_AbnormalFlag::BUFF_ADD_CAN_BE_CANCELED_IF_DEFENSE,
    enum__Torappu_AbnormalFlag::DEFENSE_BUFF_ADD_IF_CANCELABLE_BUFF,
    enum__Torappu_AbnormalFlag::PALSY,
    enum__Torappu_AbnormalFlag::PALSYING,
    enum__Torappu_AbnormalFlag::ATTRACTED,
    enum__Torappu_AbnormalFlag::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_AbnormalFlag(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_AbnormalFlag {
    pub const STUNNED: Self = Self(0);
    pub const SP_RECOVER_STOPPED: Self = Self(1);
    pub const TARGET_FREE: Self = Self(2);
    pub const BLOCK_FREE: Self = Self(3);
    pub const HIDDEN: Self = Self(4);
    pub const INVINCIBLE: Self = Self(5);
    pub const UNDEADABLE: Self = Self(6);
    pub const HEAL_FREE: Self = Self(7);
    pub const UNBALANCE_IMMUNE: Self = Self(8);
    pub const INVISIBLE: Self = Self(9);
    pub const UNUSED_PLACEHOLDER_1: Self = Self(10);
    pub const DISARMED: Self = Self(11);
    pub const SILENCED: Self = Self(12);
    pub const UNMOVABLE: Self = Self(13);
    pub const UNUSED_PLACEHOLDER_2: Self = Self(14);
    pub const ALLY_TARGET_FREE: Self = Self(15);
    pub const FROZEN: Self = Self(16);
    pub const CAMOUFLAGE: Self = Self(17);
    pub const FORCE_DISARMED: Self = Self(18);
    pub const STUNNED_NO_AMPLIFY_DAMAGE: Self = Self(19);
    pub const DISABLE_COMBAT: Self = Self(20);
    pub const ELEMENT_FREE_ALL: Self = Self(21);
    pub const UNMOVABLE_PRIVATE: Self = Self(22);
    pub const COLD: Self = Self(23);
    pub const SKILL_NOT_ACTIVATABLE: Self = Self(24);
    pub const LEVITATE: Self = Self(25);
    pub const DURANCE: Self = Self(26);
    pub const NOT_WITHDRAWABLE: Self = Self(27);
    pub const OUT_OF_GROUND: Self = Self(28);
    pub const SP_MODIFY_STOPPED: Self = Self(29);
    pub const ANTI_STATUS_RESISTABLE: Self = Self(30);
    pub const DISARMED_COMBAT: Self = Self(31);
    pub const TOWER_TARGET_FREE: Self = Self(32);
    pub const FEARED: Self = Self(33);
    pub const SKILL_ACTIVABLE_IN_ABNORMAL: Self = Self(34);
    pub const MOTION_TARGET_FREE: Self = Self(35);
    pub const FORCE_LEVITATE: Self = Self(36);
    pub const BUFF_ADD_CAN_BE_CANCELED_IF_DEFENSE: Self = Self(37);
    pub const DEFENSE_BUFF_ADD_IF_CANCELABLE_BUFF: Self = Self(38);
    pub const PALSY: Self = Self(39);
    pub const PALSYING: Self = Self(40);
    pub const ATTRACTED: Self = Self(41);
    pub const E_NUM: Self = Self(42);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 42;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::STUNNED,
        Self::SP_RECOVER_STOPPED,
        Self::TARGET_FREE,
        Self::BLOCK_FREE,
        Self::HIDDEN,
        Self::INVINCIBLE,
        Self::UNDEADABLE,
        Self::HEAL_FREE,
        Self::UNBALANCE_IMMUNE,
        Self::INVISIBLE,
        Self::UNUSED_PLACEHOLDER_1,
        Self::DISARMED,
        Self::SILENCED,
        Self::UNMOVABLE,
        Self::UNUSED_PLACEHOLDER_2,
        Self::ALLY_TARGET_FREE,
        Self::FROZEN,
        Self::CAMOUFLAGE,
        Self::FORCE_DISARMED,
        Self::STUNNED_NO_AMPLIFY_DAMAGE,
        Self::DISABLE_COMBAT,
        Self::ELEMENT_FREE_ALL,
        Self::UNMOVABLE_PRIVATE,
        Self::COLD,
        Self::SKILL_NOT_ACTIVATABLE,
        Self::LEVITATE,
        Self::DURANCE,
        Self::NOT_WITHDRAWABLE,
        Self::OUT_OF_GROUND,
        Self::SP_MODIFY_STOPPED,
        Self::ANTI_STATUS_RESISTABLE,
        Self::DISARMED_COMBAT,
        Self::TOWER_TARGET_FREE,
        Self::FEARED,
        Self::SKILL_ACTIVABLE_IN_ABNORMAL,
        Self::MOTION_TARGET_FREE,
        Self::FORCE_LEVITATE,
        Self::BUFF_ADD_CAN_BE_CANCELED_IF_DEFENSE,
        Self::DEFENSE_BUFF_ADD_IF_CANCELABLE_BUFF,
        Self::PALSY,
        Self::PALSYING,
        Self::ATTRACTED,
        Self::E_NUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::STUNNED => Some("STUNNED"),
            Self::SP_RECOVER_STOPPED => Some("SP_RECOVER_STOPPED"),
            Self::TARGET_FREE => Some("TARGET_FREE"),
            Self::BLOCK_FREE => Some("BLOCK_FREE"),
            Self::HIDDEN => Some("HIDDEN"),
            Self::INVINCIBLE => Some("INVINCIBLE"),
            Self::UNDEADABLE => Some("UNDEADABLE"),
            Self::HEAL_FREE => Some("HEAL_FREE"),
            Self::UNBALANCE_IMMUNE => Some("UNBALANCE_IMMUNE"),
            Self::INVISIBLE => Some("INVISIBLE"),
            Self::UNUSED_PLACEHOLDER_1 => Some("UNUSED_PLACEHOLDER_1"),
            Self::DISARMED => Some("DISARMED"),
            Self::SILENCED => Some("SILENCED"),
            Self::UNMOVABLE => Some("UNMOVABLE"),
            Self::UNUSED_PLACEHOLDER_2 => Some("UNUSED_PLACEHOLDER_2"),
            Self::ALLY_TARGET_FREE => Some("ALLY_TARGET_FREE"),
            Self::FROZEN => Some("FROZEN"),
            Self::CAMOUFLAGE => Some("CAMOUFLAGE"),
            Self::FORCE_DISARMED => Some("FORCE_DISARMED"),
            Self::STUNNED_NO_AMPLIFY_DAMAGE => Some("STUNNED_NO_AMPLIFY_DAMAGE"),
            Self::DISABLE_COMBAT => Some("DISABLE_COMBAT"),
            Self::ELEMENT_FREE_ALL => Some("ELEMENT_FREE_ALL"),
            Self::UNMOVABLE_PRIVATE => Some("UNMOVABLE_PRIVATE"),
            Self::COLD => Some("COLD"),
            Self::SKILL_NOT_ACTIVATABLE => Some("SKILL_NOT_ACTIVATABLE"),
            Self::LEVITATE => Some("LEVITATE"),
            Self::DURANCE => Some("DURANCE"),
            Self::NOT_WITHDRAWABLE => Some("NOT_WITHDRAWABLE"),
            Self::OUT_OF_GROUND => Some("OUT_OF_GROUND"),
            Self::SP_MODIFY_STOPPED => Some("SP_MODIFY_STOPPED"),
            Self::ANTI_STATUS_RESISTABLE => Some("ANTI_STATUS_RESISTABLE"),
            Self::DISARMED_COMBAT => Some("DISARMED_COMBAT"),
            Self::TOWER_TARGET_FREE => Some("TOWER_TARGET_FREE"),
            Self::FEARED => Some("FEARED"),
            Self::SKILL_ACTIVABLE_IN_ABNORMAL => Some("SKILL_ACTIVABLE_IN_ABNORMAL"),
            Self::MOTION_TARGET_FREE => Some("MOTION_TARGET_FREE"),
            Self::FORCE_LEVITATE => Some("FORCE_LEVITATE"),
            Self::BUFF_ADD_CAN_BE_CANCELED_IF_DEFENSE => {
                Some("BUFF_ADD_CAN_BE_CANCELED_IF_DEFENSE")
            }
            Self::DEFENSE_BUFF_ADD_IF_CANCELABLE_BUFF => {
                Some("DEFENSE_BUFF_ADD_IF_CANCELABLE_BUFF")
            }
            Self::PALSY => Some("PALSY"),
            Self::PALSYING => Some("PALSYING"),
            Self::ATTRACTED => Some("ATTRACTED"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_AbnormalFlag {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_AbnormalFlag {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_AbnormalFlag",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_AbnormalFlag {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_AbnormalFlag {
    type Output = enum__Torappu_AbnormalFlag;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_AbnormalFlag {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_AbnormalFlag {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_AbnormalFlag {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ABNORMAL_COMBO: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ABNORMAL_COMBO: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ABNORMAL_COMBO: [enum__Torappu_AbnormalCombo; 3] = [
    enum__Torappu_AbnormalCombo::SLEEPING,
    enum__Torappu_AbnormalCombo::SHELTERING,
    enum__Torappu_AbnormalCombo::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_AbnormalCombo(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_AbnormalCombo {
    pub const SLEEPING: Self = Self(0);
    pub const SHELTERING: Self = Self(1);
    pub const E_NUM: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::SLEEPING, Self::SHELTERING, Self::E_NUM];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::SLEEPING => Some("SLEEPING"),
            Self::SHELTERING => Some("SHELTERING"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_AbnormalCombo {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_AbnormalCombo {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_AbnormalCombo",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_AbnormalCombo {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_AbnormalCombo {
    type Output = enum__Torappu_AbnormalCombo;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_AbnormalCombo {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_AbnormalCombo {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_AbnormalCombo {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ATTRIBUTE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ATTRIBUTE_TYPE: i32 = 36;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ATTRIBUTE_TYPE: [enum__Torappu_AttributeType; 37] = [
    enum__Torappu_AttributeType::MAX_HP,
    enum__Torappu_AttributeType::ATK,
    enum__Torappu_AttributeType::DEF,
    enum__Torappu_AttributeType::MAGIC_RESISTANCE,
    enum__Torappu_AttributeType::COST,
    enum__Torappu_AttributeType::BLOCK_CNT,
    enum__Torappu_AttributeType::MOVE_SPEED,
    enum__Torappu_AttributeType::ATTACK_SPEED,
    enum__Torappu_AttributeType::BASE_ATTACK_TIME,
    enum__Torappu_AttributeType::RESERVED_0,
    enum__Torappu_AttributeType::RESERVED_1,
    enum__Torappu_AttributeType::RESERVED_2,
    enum__Torappu_AttributeType::RESERVED_3,
    enum__Torappu_AttributeType::HP_RECOVERY_PER_SEC,
    enum__Torappu_AttributeType::SP_RECOVERY_PER_SEC,
    enum__Torappu_AttributeType::ABILITY_RANGE_FORWARD_EXTEND,
    enum__Torappu_AttributeType::MAX_DEPLOY_COUNT,
    enum__Torappu_AttributeType::DEF_PENETRATE,
    enum__Torappu_AttributeType::MAGIC_RESIST_PENETRATE,
    enum__Torappu_AttributeType::HP_RECOVERY_PER_SEC_BY_MAX_HP_RATIO,
    enum__Torappu_AttributeType::TAUNT_LEVEL,
    enum__Torappu_AttributeType::RESPAWN_TIME,
    enum__Torappu_AttributeType::MAX_DECK_STACK_CNT,
    enum__Torappu_AttributeType::MASS_LEVEL,
    enum__Torappu_AttributeType::BASE_FORCE_LEVEL,
    enum__Torappu_AttributeType::DEF_PENETRATE_FIXED,
    enum__Torappu_AttributeType::ONE_MINUS_STATUS_RESISTANCE,
    enum__Torappu_AttributeType::MAGIC_RESIST_PENETRATE_FIXED,
    enum__Torappu_AttributeType::MAX_EP,
    enum__Torappu_AttributeType::EP_RECOVERY_PER_SEC,
    enum__Torappu_AttributeType::SP_RECOVER_RATIO,
    enum__Torappu_AttributeType::EP_DAMAGE_RESISTANCE,
    enum__Torappu_AttributeType::EP_RESISTANCE,
    enum__Torappu_AttributeType::DAMAGE_HITRATE_PHYSICAL,
    enum__Torappu_AttributeType::DAMAGE_HITRATE_MAGICAL,
    enum__Torappu_AttributeType::EP_BREAK_RECOVER_SPEED,
    enum__Torappu_AttributeType::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_AttributeType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_AttributeType {
    pub const MAX_HP: Self = Self(0);
    pub const ATK: Self = Self(1);
    pub const DEF: Self = Self(2);
    pub const MAGIC_RESISTANCE: Self = Self(3);
    pub const COST: Self = Self(4);
    pub const BLOCK_CNT: Self = Self(5);
    pub const MOVE_SPEED: Self = Self(6);
    pub const ATTACK_SPEED: Self = Self(7);
    pub const BASE_ATTACK_TIME: Self = Self(8);
    pub const RESERVED_0: Self = Self(9);
    pub const RESERVED_1: Self = Self(10);
    pub const RESERVED_2: Self = Self(11);
    pub const RESERVED_3: Self = Self(12);
    pub const HP_RECOVERY_PER_SEC: Self = Self(13);
    pub const SP_RECOVERY_PER_SEC: Self = Self(14);
    pub const ABILITY_RANGE_FORWARD_EXTEND: Self = Self(15);
    pub const MAX_DEPLOY_COUNT: Self = Self(16);
    pub const DEF_PENETRATE: Self = Self(17);
    pub const MAGIC_RESIST_PENETRATE: Self = Self(18);
    pub const HP_RECOVERY_PER_SEC_BY_MAX_HP_RATIO: Self = Self(19);
    pub const TAUNT_LEVEL: Self = Self(20);
    pub const RESPAWN_TIME: Self = Self(21);
    pub const MAX_DECK_STACK_CNT: Self = Self(22);
    pub const MASS_LEVEL: Self = Self(23);
    pub const BASE_FORCE_LEVEL: Self = Self(24);
    pub const DEF_PENETRATE_FIXED: Self = Self(25);
    pub const ONE_MINUS_STATUS_RESISTANCE: Self = Self(26);
    pub const MAGIC_RESIST_PENETRATE_FIXED: Self = Self(27);
    pub const MAX_EP: Self = Self(28);
    pub const EP_RECOVERY_PER_SEC: Self = Self(29);
    pub const SP_RECOVER_RATIO: Self = Self(30);
    pub const EP_DAMAGE_RESISTANCE: Self = Self(31);
    pub const EP_RESISTANCE: Self = Self(32);
    pub const DAMAGE_HITRATE_PHYSICAL: Self = Self(33);
    pub const DAMAGE_HITRATE_MAGICAL: Self = Self(34);
    pub const EP_BREAK_RECOVER_SPEED: Self = Self(35);
    pub const E_NUM: Self = Self(36);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 36;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::MAX_HP,
        Self::ATK,
        Self::DEF,
        Self::MAGIC_RESISTANCE,
        Self::COST,
        Self::BLOCK_CNT,
        Self::MOVE_SPEED,
        Self::ATTACK_SPEED,
        Self::BASE_ATTACK_TIME,
        Self::RESERVED_0,
        Self::RESERVED_1,
        Self::RESERVED_2,
        Self::RESERVED_3,
        Self::HP_RECOVERY_PER_SEC,
        Self::SP_RECOVERY_PER_SEC,
        Self::ABILITY_RANGE_FORWARD_EXTEND,
        Self::MAX_DEPLOY_COUNT,
        Self::DEF_PENETRATE,
        Self::MAGIC_RESIST_PENETRATE,
        Self::HP_RECOVERY_PER_SEC_BY_MAX_HP_RATIO,
        Self::TAUNT_LEVEL,
        Self::RESPAWN_TIME,
        Self::MAX_DECK_STACK_CNT,
        Self::MASS_LEVEL,
        Self::BASE_FORCE_LEVEL,
        Self::DEF_PENETRATE_FIXED,
        Self::ONE_MINUS_STATUS_RESISTANCE,
        Self::MAGIC_RESIST_PENETRATE_FIXED,
        Self::MAX_EP,
        Self::EP_RECOVERY_PER_SEC,
        Self::SP_RECOVER_RATIO,
        Self::EP_DAMAGE_RESISTANCE,
        Self::EP_RESISTANCE,
        Self::DAMAGE_HITRATE_PHYSICAL,
        Self::DAMAGE_HITRATE_MAGICAL,
        Self::EP_BREAK_RECOVER_SPEED,
        Self::E_NUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::MAX_HP => Some("MAX_HP"),
            Self::ATK => Some("ATK"),
            Self::DEF => Some("DEF"),
            Self::MAGIC_RESISTANCE => Some("MAGIC_RESISTANCE"),
            Self::COST => Some("COST"),
            Self::BLOCK_CNT => Some("BLOCK_CNT"),
            Self::MOVE_SPEED => Some("MOVE_SPEED"),
            Self::ATTACK_SPEED => Some("ATTACK_SPEED"),
            Self::BASE_ATTACK_TIME => Some("BASE_ATTACK_TIME"),
            Self::RESERVED_0 => Some("RESERVED_0"),
            Self::RESERVED_1 => Some("RESERVED_1"),
            Self::RESERVED_2 => Some("RESERVED_2"),
            Self::RESERVED_3 => Some("RESERVED_3"),
            Self::HP_RECOVERY_PER_SEC => Some("HP_RECOVERY_PER_SEC"),
            Self::SP_RECOVERY_PER_SEC => Some("SP_RECOVERY_PER_SEC"),
            Self::ABILITY_RANGE_FORWARD_EXTEND => Some("ABILITY_RANGE_FORWARD_EXTEND"),
            Self::MAX_DEPLOY_COUNT => Some("MAX_DEPLOY_COUNT"),
            Self::DEF_PENETRATE => Some("DEF_PENETRATE"),
            Self::MAGIC_RESIST_PENETRATE => Some("MAGIC_RESIST_PENETRATE"),
            Self::HP_RECOVERY_PER_SEC_BY_MAX_HP_RATIO => {
                Some("HP_RECOVERY_PER_SEC_BY_MAX_HP_RATIO")
            }
            Self::TAUNT_LEVEL => Some("TAUNT_LEVEL"),
            Self::RESPAWN_TIME => Some("RESPAWN_TIME"),
            Self::MAX_DECK_STACK_CNT => Some("MAX_DECK_STACK_CNT"),
            Self::MASS_LEVEL => Some("MASS_LEVEL"),
            Self::BASE_FORCE_LEVEL => Some("BASE_FORCE_LEVEL"),
            Self::DEF_PENETRATE_FIXED => Some("DEF_PENETRATE_FIXED"),
            Self::ONE_MINUS_STATUS_RESISTANCE => Some("ONE_MINUS_STATUS_RESISTANCE"),
            Self::MAGIC_RESIST_PENETRATE_FIXED => Some("MAGIC_RESIST_PENETRATE_FIXED"),
            Self::MAX_EP => Some("MAX_EP"),
            Self::EP_RECOVERY_PER_SEC => Some("EP_RECOVERY_PER_SEC"),
            Self::SP_RECOVER_RATIO => Some("SP_RECOVER_RATIO"),
            Self::EP_DAMAGE_RESISTANCE => Some("EP_DAMAGE_RESISTANCE"),
            Self::EP_RESISTANCE => Some("EP_RESISTANCE"),
            Self::DAMAGE_HITRATE_PHYSICAL => Some("DAMAGE_HITRATE_PHYSICAL"),
            Self::DAMAGE_HITRATE_MAGICAL => Some("DAMAGE_HITRATE_MAGICAL"),
            Self::EP_BREAK_RECOVER_SPEED => Some("EP_BREAK_RECOVER_SPEED"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_AttributeType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_AttributeType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_AttributeType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_AttributeType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_AttributeType {
    type Output = enum__Torappu_AttributeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_AttributeType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_AttributeType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_AttributeType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ATTRIBUTE_MODIFIER_DATA_ATTRIBUTE_MODIFIER_FORMULA_ITEM_TYPE: i32 =
    0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ATTRIBUTE_MODIFIER_DATA_ATTRIBUTE_MODIFIER_FORMULA_ITEM_TYPE: i32 =
    3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ATTRIBUTE_MODIFIER_DATA_ATTRIBUTE_MODIFIER_FORMULA_ITEM_TYPE:
    [enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType; 4] = [
    enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType::ADDITION,
    enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType::MULTIPLIER,
    enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType::FINAL_ADDITION,
    enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType::FINAL_SCALER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType {
    pub const ADDITION: Self = Self(0);
    pub const MULTIPLIER: Self = Self(1);
    pub const FINAL_ADDITION: Self = Self(2);
    pub const FINAL_SCALER: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::ADDITION,
        Self::MULTIPLIER,
        Self::FINAL_ADDITION,
        Self::FINAL_SCALER,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ADDITION => Some("ADDITION"),
            Self::MULTIPLIER => Some("MULTIPLIER"),
            Self::FINAL_ADDITION => Some("FINAL_ADDITION"),
            Self::FINAL_SCALER => Some("FINAL_SCALER"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a>
    for enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType
{
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType {
    type Output = enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar
    for enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType
{
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable
    for enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice
    for enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType
{
}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_PLAYER_BATTLE_RANK: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_PLAYER_BATTLE_RANK: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_PLAYER_BATTLE_RANK: [enum__Torappu_PlayerBattleRank; 4] = [
    enum__Torappu_PlayerBattleRank::ERR_ZERO,
    enum__Torappu_PlayerBattleRank::FAIL,
    enum__Torappu_PlayerBattleRank::PASS,
    enum__Torappu_PlayerBattleRank::COMPLETE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_PlayerBattleRank(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_PlayerBattleRank {
    pub const ERR_ZERO: Self = Self(0);
    pub const FAIL: Self = Self(1);
    pub const PASS: Self = Self(2);
    pub const COMPLETE: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::ERR_ZERO, Self::FAIL, Self::PASS, Self::COMPLETE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ERR_ZERO => Some("ERR_ZERO"),
            Self::FAIL => Some("FAIL"),
            Self::PASS => Some("PASS"),
            Self::COMPLETE => Some("COMPLETE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_PlayerBattleRank {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_PlayerBattleRank {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_PlayerBattleRank",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_PlayerBattleRank {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_PlayerBattleRank {
    type Output = enum__Torappu_PlayerBattleRank;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_PlayerBattleRank {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_PlayerBattleRank {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_PlayerBattleRank {}
pub enum clz_Torappu_CharPatchData_PatchInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharPatchData_PatchInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharPatchData_PatchInfo<'a> {
    type Inner = clz_Torappu_CharPatchData_PatchInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharPatchData_PatchInfo<'a> {
    pub const VT_TMPLIDS: flatbuffers::VOffsetT = 4;
    pub const VT_DEFAULT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharPatchData_PatchInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharPatchData_PatchInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharPatchData_PatchInfo<'bldr>> {
        let mut builder = clz_Torappu_CharPatchData_PatchInfoBuilder::new(_fbb);
        if let Some(x) = args.default {
            builder.add_default(x);
        }
        if let Some(x) = args.tmplIds {
            builder.add_tmplIds(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharPatchData_PatchInfoT {
        let tmplIds = self
            .tmplIds()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let default = self.default().map(|x| x.to_string());
        clz_Torappu_CharPatchData_PatchInfoT { tmplIds, default }
    }

    #[inline]
    pub fn tmplIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_CharPatchData_PatchInfo::VT_TMPLIDS, None)
        }
    }
    #[inline]
    pub fn default(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharPatchData_PatchInfo::VT_DEFAULT,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharPatchData_PatchInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("tmplIds", Self::VT_TMPLIDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("default", Self::VT_DEFAULT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharPatchData_PatchInfoArgs<'a> {
    pub tmplIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub default: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_CharPatchData_PatchInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharPatchData_PatchInfoArgs {
            tmplIds: None,
            default: None,
        }
    }
}

impl Serialize for clz_Torappu_CharPatchData_PatchInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharPatchData_PatchInfo", 2)?;
        if let Some(f) = self.tmplIds() {
            s.serialize_field("tmplIds", &f)?;
        } else {
            s.skip_field("tmplIds")?;
        }
        if let Some(f) = self.default() {
            s.serialize_field("default", &f)?;
        } else {
            s.skip_field("default")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CharPatchData_PatchInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharPatchData_PatchInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_tmplIds(
        &mut self,
        tmplIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharPatchData_PatchInfo::VT_TMPLIDS,
            tmplIds,
        );
    }
    #[inline]
    pub fn add_default(&mut self, default: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharPatchData_PatchInfo::VT_DEFAULT,
            default,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharPatchData_PatchInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharPatchData_PatchInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharPatchData_PatchInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharPatchData_PatchInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharPatchData_PatchInfo");
        ds.field("tmplIds", &self.tmplIds());
        ds.field("default", &self.default());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharPatchData_PatchInfoT {
    pub tmplIds: Option<Vec<String>>,
    pub default: Option<String>,
}
impl Default for clz_Torappu_CharPatchData_PatchInfoT {
    fn default() -> Self {
        Self {
            tmplIds: None,
            default: None,
        }
    }
}
impl clz_Torappu_CharPatchData_PatchInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharPatchData_PatchInfo<'b>> {
        let tmplIds = self.tmplIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let default = self.default.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_CharPatchData_PatchInfo::create(
            _fbb,
            &clz_Torappu_CharPatchData_PatchInfoArgs { tmplIds, default },
        )
    }
}
pub enum dict__string__clz_Torappu_CharPatchData_PatchInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_CharPatchData_PatchInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_CharPatchData_PatchInfo<'a> {
    type Inner = dict__string__clz_Torappu_CharPatchData_PatchInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_CharPatchData_PatchInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_CharPatchData_PatchInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_CharPatchData_PatchInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharPatchData_PatchInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_CharPatchData_PatchInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_CharPatchData_PatchInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_CharPatchData_PatchInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_CharPatchData_PatchInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_CharPatchData_PatchInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_CharPatchData_PatchInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharPatchData_PatchInfo>>(
                    dict__string__clz_Torappu_CharPatchData_PatchInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_CharPatchData_PatchInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharPatchData_PatchInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_CharPatchData_PatchInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_CharPatchData_PatchInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_CharPatchData_PatchInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_CharPatchData_PatchInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_CharPatchData_PatchInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_CharPatchData_PatchInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_CharPatchData_PatchInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_CharPatchData_PatchInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_CharPatchData_PatchInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_CharPatchData_PatchInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharPatchData_PatchInfo>>(
                dict__string__clz_Torappu_CharPatchData_PatchInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_CharPatchData_PatchInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_CharPatchData_PatchInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharPatchData_PatchInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_CharPatchData_PatchInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_CharPatchData_PatchInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_CharPatchData_PatchInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_CharPatchData_PatchInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_CharPatchData_PatchInfoT>>,
}
impl Default for dict__string__clz_Torappu_CharPatchData_PatchInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_CharPatchData_PatchInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharPatchData_PatchInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_CharPatchData_PatchInfo::create(
            _fbb,
            &dict__string__clz_Torappu_CharPatchData_PatchInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_CharacterData_PowerDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharacterData_PowerData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharacterData_PowerData<'a> {
    type Inner = clz_Torappu_CharacterData_PowerData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharacterData_PowerData<'a> {
    pub const VT_NATIONID: flatbuffers::VOffsetT = 4;
    pub const VT_GROUPID: flatbuffers::VOffsetT = 6;
    pub const VT_TEAMID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharacterData_PowerData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharacterData_PowerDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_PowerData<'bldr>> {
        let mut builder = clz_Torappu_CharacterData_PowerDataBuilder::new(_fbb);
        if let Some(x) = args.teamId {
            builder.add_teamId(x);
        }
        if let Some(x) = args.groupId {
            builder.add_groupId(x);
        }
        if let Some(x) = args.nationId {
            builder.add_nationId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharacterData_PowerDataT {
        let nationId = self.nationId().map(|x| x.to_string());
        let groupId = self.groupId().map(|x| x.to_string());
        let teamId = self.teamId().map(|x| x.to_string());
        clz_Torappu_CharacterData_PowerDataT {
            nationId,
            groupId,
            teamId,
        }
    }

    #[inline]
    pub fn nationId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData_PowerData::VT_NATIONID,
                None,
            )
        }
    }
    #[inline]
    pub fn groupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData_PowerData::VT_GROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn teamId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData_PowerData::VT_TEAMID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharacterData_PowerData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nationId",
                Self::VT_NATIONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("groupId", Self::VT_GROUPID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("teamId", Self::VT_TEAMID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharacterData_PowerDataArgs<'a> {
    pub nationId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub groupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teamId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_CharacterData_PowerDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharacterData_PowerDataArgs {
            nationId: None,
            groupId: None,
            teamId: None,
        }
    }
}

impl Serialize for clz_Torappu_CharacterData_PowerData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharacterData_PowerData", 3)?;
        if let Some(f) = self.nationId() {
            s.serialize_field("nationId", &f)?;
        } else {
            s.skip_field("nationId")?;
        }
        if let Some(f) = self.groupId() {
            s.serialize_field("groupId", &f)?;
        } else {
            s.skip_field("groupId")?;
        }
        if let Some(f) = self.teamId() {
            s.serialize_field("teamId", &f)?;
        } else {
            s.skip_field("teamId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CharacterData_PowerDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharacterData_PowerDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nationId(&mut self, nationId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_PowerData::VT_NATIONID,
            nationId,
        );
    }
    #[inline]
    pub fn add_groupId(&mut self, groupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_PowerData::VT_GROUPID,
            groupId,
        );
    }
    #[inline]
    pub fn add_teamId(&mut self, teamId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_PowerData::VT_TEAMID,
            teamId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharacterData_PowerDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharacterData_PowerDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_PowerData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharacterData_PowerData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharacterData_PowerData");
        ds.field("nationId", &self.nationId());
        ds.field("groupId", &self.groupId());
        ds.field("teamId", &self.teamId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharacterData_PowerDataT {
    pub nationId: Option<String>,
    pub groupId: Option<String>,
    pub teamId: Option<String>,
}
impl Default for clz_Torappu_CharacterData_PowerDataT {
    fn default() -> Self {
        Self {
            nationId: None,
            groupId: None,
            teamId: None,
        }
    }
}
impl clz_Torappu_CharacterData_PowerDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_PowerData<'b>> {
        let nationId = self.nationId.as_ref().map(|x| _fbb.create_string(x));
        let groupId = self.groupId.as_ref().map(|x| _fbb.create_string(x));
        let teamId = self.teamId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_CharacterData_PowerData::create(
            _fbb,
            &clz_Torappu_CharacterData_PowerDataArgs {
                nationId,
                groupId,
                teamId,
            },
        )
    }
}
pub enum clz_Torappu_CharacterData_UnlockConditionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharacterData_UnlockCondition<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharacterData_UnlockCondition<'a> {
    type Inner = clz_Torappu_CharacterData_UnlockCondition<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharacterData_UnlockCondition<'a> {
    pub const VT_PHASE: flatbuffers::VOffsetT = 4;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharacterData_UnlockCondition { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharacterData_UnlockConditionArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'bldr>> {
        let mut builder = clz_Torappu_CharacterData_UnlockConditionBuilder::new(_fbb);
        builder.add_level(args.level);
        builder.add_phase(args.phase);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharacterData_UnlockConditionT {
        let phase = self.phase();
        let level = self.level();
        clz_Torappu_CharacterData_UnlockConditionT { phase, level }
    }

    #[inline]
    pub fn phase(&self) -> enum__Torappu_EvolvePhase {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_EvolvePhase>(
                    clz_Torappu_CharacterData_UnlockCondition::VT_PHASE,
                    Some(enum__Torappu_EvolvePhase::PHASE_0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CharacterData_UnlockCondition::VT_LEVEL, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharacterData_UnlockCondition<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_EvolvePhase>("phase", Self::VT_PHASE, false)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharacterData_UnlockConditionArgs {
    pub phase: enum__Torappu_EvolvePhase,
    pub level: i32,
}
impl<'a> Default for clz_Torappu_CharacterData_UnlockConditionArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharacterData_UnlockConditionArgs {
            phase: enum__Torappu_EvolvePhase::PHASE_0,
            level: 0,
        }
    }
}

impl Serialize for clz_Torappu_CharacterData_UnlockCondition<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharacterData_UnlockCondition", 2)?;
        s.serialize_field("phase", &self.phase())?;
        s.serialize_field("level", &self.level())?;
        s.end()
    }
}

pub struct clz_Torappu_CharacterData_UnlockConditionBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharacterData_UnlockConditionBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_phase(&mut self, phase: enum__Torappu_EvolvePhase) {
        self.fbb_.push_slot::<enum__Torappu_EvolvePhase>(
            clz_Torappu_CharacterData_UnlockCondition::VT_PHASE,
            phase,
            enum__Torappu_EvolvePhase::PHASE_0,
        );
    }
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_CharacterData_UnlockCondition::VT_LEVEL,
            level,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharacterData_UnlockConditionBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharacterData_UnlockConditionBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharacterData_UnlockCondition<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharacterData_UnlockCondition");
        ds.field("phase", &self.phase());
        ds.field("level", &self.level());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharacterData_UnlockConditionT {
    pub phase: enum__Torappu_EvolvePhase,
    pub level: i32,
}
impl Default for clz_Torappu_CharacterData_UnlockConditionT {
    fn default() -> Self {
        Self {
            phase: enum__Torappu_EvolvePhase::PHASE_0,
            level: 0,
        }
    }
}
impl clz_Torappu_CharacterData_UnlockConditionT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'b>> {
        let phase = self.phase;
        let level = self.level;
        clz_Torappu_CharacterData_UnlockCondition::create(
            _fbb,
            &clz_Torappu_CharacterData_UnlockConditionArgs { phase, level },
        )
    }
}
pub enum clz_Torappu_Blackboard_DataPairOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Blackboard_DataPair<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Blackboard_DataPair<'a> {
    type Inner = clz_Torappu_Blackboard_DataPair<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Blackboard_DataPair<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;
    pub const VT_VALUESTR: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Blackboard_DataPair { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Blackboard_DataPairArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'bldr>> {
        let mut builder = clz_Torappu_Blackboard_DataPairBuilder::new(_fbb);
        if let Some(x) = args.valueStr {
            builder.add_valueStr(x);
        }
        builder.add_value(args.value);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Blackboard_DataPairT {
        let key = self.key().map(|x| x.to_string());
        let value = self.value();
        let valueStr = self.valueStr().map(|x| x.to_string());
        clz_Torappu_Blackboard_DataPairT {
            key,
            value,
            valueStr,
        }
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_KEY,
                None,
            )
        }
    }
    #[inline]
    pub fn value(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn valueStr(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Blackboard_DataPair<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<f32>("value", Self::VT_VALUE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "valueStr",
                Self::VT_VALUESTR,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Blackboard_DataPairArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: f32,
    pub valueStr: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Blackboard_DataPairArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Blackboard_DataPairArgs {
            key: None,
            value: 0.0,
            valueStr: None,
        }
    }
}

impl Serialize for clz_Torappu_Blackboard_DataPair<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Blackboard_DataPair", 3)?;
        if let Some(f) = self.key() {
            s.serialize_field("key", &f)?;
        } else {
            s.skip_field("key")?;
        }
        s.serialize_field("value", &self.value())?;
        if let Some(f) = self.valueStr() {
            s.serialize_field("valueStr", &f)?;
        } else {
            s.skip_field("valueStr")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Blackboard_DataPairBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, value, 0.0);
    }
    #[inline]
    pub fn add_valueStr(&mut self, valueStr: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
            valueStr,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Blackboard_DataPairBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Blackboard_DataPair<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Blackboard_DataPair");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.field("valueStr", &self.valueStr());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Blackboard_DataPairT {
    pub key: Option<String>,
    pub value: f32,
    pub valueStr: Option<String>,
}
impl Default for clz_Torappu_Blackboard_DataPairT {
    fn default() -> Self {
        Self {
            key: None,
            value: 0.0,
            valueStr: None,
        }
    }
}
impl clz_Torappu_Blackboard_DataPairT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'b>> {
        let key = self.key.as_ref().map(|x| _fbb.create_string(x));
        let value = self.value;
        let valueStr = self.valueStr.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Blackboard_DataPair::create(
            _fbb,
            &clz_Torappu_Blackboard_DataPairArgs {
                key,
                value,
                valueStr,
            },
        )
    }
}
pub enum clz_Torappu_CharacterData_TraitDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharacterData_TraitData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharacterData_TraitData<'a> {
    type Inner = clz_Torappu_CharacterData_TraitData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharacterData_TraitData<'a> {
    pub const VT_UNLOCKCONDITION: flatbuffers::VOffsetT = 4;
    pub const VT_REQUIREDPOTENTIALRANK: flatbuffers::VOffsetT = 6;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 8;
    pub const VT_OVERRIDEDESCRIPTON: flatbuffers::VOffsetT = 10;
    pub const VT_PREFABKEY: flatbuffers::VOffsetT = 12;
    pub const VT_RANGEID: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharacterData_TraitData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharacterData_TraitDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_TraitData<'bldr>> {
        let mut builder = clz_Torappu_CharacterData_TraitDataBuilder::new(_fbb);
        if let Some(x) = args.rangeId {
            builder.add_rangeId(x);
        }
        if let Some(x) = args.prefabKey {
            builder.add_prefabKey(x);
        }
        if let Some(x) = args.overrideDescripton {
            builder.add_overrideDescripton(x);
        }
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        builder.add_requiredPotentialRank(args.requiredPotentialRank);
        if let Some(x) = args.unlockCondition {
            builder.add_unlockCondition(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharacterData_TraitDataT {
        let unlockCondition = self.unlockCondition().map(|x| Box::new(x.unpack()));
        let requiredPotentialRank = self.requiredPotentialRank();
        let blackboard = self
            .blackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let overrideDescripton = self.overrideDescripton().map(|x| x.to_string());
        let prefabKey = self.prefabKey().map(|x| x.to_string());
        let rangeId = self.rangeId().map(|x| x.to_string());
        clz_Torappu_CharacterData_TraitDataT {
            unlockCondition,
            requiredPotentialRank,
            blackboard,
            overrideDescripton,
            prefabKey,
            rangeId,
        }
    }

    #[inline]
    pub fn unlockCondition(&self) -> Option<clz_Torappu_CharacterData_UnlockCondition<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                    clz_Torappu_CharacterData_TraitData::VT_UNLOCKCONDITION,
                    None,
                )
        }
    }
    #[inline]
    pub fn requiredPotentialRank(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_CharacterData_TraitData::VT_REQUIREDPOTENTIALRANK,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(clz_Torappu_CharacterData_TraitData::VT_BLACKBOARD, None)
        }
    }
    #[inline]
    pub fn overrideDescripton(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData_TraitData::VT_OVERRIDEDESCRIPTON,
                None,
            )
        }
    }
    #[inline]
    pub fn prefabKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData_TraitData::VT_PREFABKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn rangeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData_TraitData::VT_RANGEID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharacterData_TraitData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                "unlockCondition",
                Self::VT_UNLOCKCONDITION,
                false,
            )?
            .visit_field::<i32>(
                "requiredPotentialRank",
                Self::VT_REQUIREDPOTENTIALRANK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "overrideDescripton",
                Self::VT_OVERRIDEDESCRIPTON,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "prefabKey",
                Self::VT_PREFABKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rangeId", Self::VT_RANGEID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharacterData_TraitDataArgs<'a> {
    pub unlockCondition:
        Option<flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'a>>>,
    pub requiredPotentialRank: i32,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
    pub overrideDescripton: Option<flatbuffers::WIPOffset<&'a str>>,
    pub prefabKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rangeId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_CharacterData_TraitDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharacterData_TraitDataArgs {
            unlockCondition: None,
            requiredPotentialRank: 0,
            blackboard: None,
            overrideDescripton: None,
            prefabKey: None,
            rangeId: None,
        }
    }
}

impl Serialize for clz_Torappu_CharacterData_TraitData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharacterData_TraitData", 6)?;
        if let Some(f) = self.unlockCondition() {
            s.serialize_field("unlockCondition", &f)?;
        } else {
            s.skip_field("unlockCondition")?;
        }
        s.serialize_field("requiredPotentialRank", &self.requiredPotentialRank())?;
        if let Some(f) = self.blackboard() {
            s.serialize_field("blackboard", &f)?;
        } else {
            s.skip_field("blackboard")?;
        }
        if let Some(f) = self.overrideDescripton() {
            s.serialize_field("overrideDescripton", &f)?;
        } else {
            s.skip_field("overrideDescripton")?;
        }
        if let Some(f) = self.prefabKey() {
            s.serialize_field("prefabKey", &f)?;
        } else {
            s.skip_field("prefabKey")?;
        }
        if let Some(f) = self.rangeId() {
            s.serialize_field("rangeId", &f)?;
        } else {
            s.skip_field("rangeId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CharacterData_TraitDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharacterData_TraitDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_unlockCondition(
        &mut self,
        unlockCondition: flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                clz_Torappu_CharacterData_TraitData::VT_UNLOCKCONDITION,
                unlockCondition,
            );
    }
    #[inline]
    pub fn add_requiredPotentialRank(&mut self, requiredPotentialRank: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_CharacterData_TraitData::VT_REQUIREDPOTENTIALRANK,
            requiredPotentialRank,
            0,
        );
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_TraitData::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn add_overrideDescripton(&mut self, overrideDescripton: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_TraitData::VT_OVERRIDEDESCRIPTON,
            overrideDescripton,
        );
    }
    #[inline]
    pub fn add_prefabKey(&mut self, prefabKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_TraitData::VT_PREFABKEY,
            prefabKey,
        );
    }
    #[inline]
    pub fn add_rangeId(&mut self, rangeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_TraitData::VT_RANGEID,
            rangeId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharacterData_TraitDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharacterData_TraitDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_TraitData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharacterData_TraitData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharacterData_TraitData");
        ds.field("unlockCondition", &self.unlockCondition());
        ds.field("requiredPotentialRank", &self.requiredPotentialRank());
        ds.field("blackboard", &self.blackboard());
        ds.field("overrideDescripton", &self.overrideDescripton());
        ds.field("prefabKey", &self.prefabKey());
        ds.field("rangeId", &self.rangeId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharacterData_TraitDataT {
    pub unlockCondition: Option<Box<clz_Torappu_CharacterData_UnlockConditionT>>,
    pub requiredPotentialRank: i32,
    pub blackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
    pub overrideDescripton: Option<String>,
    pub prefabKey: Option<String>,
    pub rangeId: Option<String>,
}
impl Default for clz_Torappu_CharacterData_TraitDataT {
    fn default() -> Self {
        Self {
            unlockCondition: None,
            requiredPotentialRank: 0,
            blackboard: None,
            overrideDescripton: None,
            prefabKey: None,
            rangeId: None,
        }
    }
}
impl clz_Torappu_CharacterData_TraitDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_TraitData<'b>> {
        let unlockCondition = self.unlockCondition.as_ref().map(|x| x.pack(_fbb));
        let requiredPotentialRank = self.requiredPotentialRank;
        let blackboard = self.blackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let overrideDescripton = self
            .overrideDescripton
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let prefabKey = self.prefabKey.as_ref().map(|x| _fbb.create_string(x));
        let rangeId = self.rangeId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_CharacterData_TraitData::create(
            _fbb,
            &clz_Torappu_CharacterData_TraitDataArgs {
                unlockCondition,
                requiredPotentialRank,
                blackboard,
                overrideDescripton,
                prefabKey,
                rangeId,
            },
        )
    }
}
pub enum clz_Torappu_CharacterData_TraitDataBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharacterData_TraitDataBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharacterData_TraitDataBundle<'a> {
    type Inner = clz_Torappu_CharacterData_TraitDataBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharacterData_TraitDataBundle<'a> {
    pub const VT_CANDIDATES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharacterData_TraitDataBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharacterData_TraitDataBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_TraitDataBundle<'bldr>> {
        let mut builder = clz_Torappu_CharacterData_TraitDataBundleBuilder::new(_fbb);
        if let Some(x) = args.candidates {
            builder.add_candidates(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharacterData_TraitDataBundleT {
        let candidates = self
            .candidates()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_CharacterData_TraitDataBundleT { candidates }
    }

    #[inline]
    pub fn candidates(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_TraitData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_TraitData>,
                >,
            >>(
                clz_Torappu_CharacterData_TraitDataBundle::VT_CANDIDATES,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharacterData_TraitDataBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_TraitData>,
                >,
            >>("candidates", Self::VT_CANDIDATES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharacterData_TraitDataBundleArgs<'a> {
    pub candidates: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_TraitData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_CharacterData_TraitDataBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharacterData_TraitDataBundleArgs { candidates: None }
    }
}

impl Serialize for clz_Torappu_CharacterData_TraitDataBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharacterData_TraitDataBundle", 1)?;
        if let Some(f) = self.candidates() {
            s.serialize_field("candidates", &f)?;
        } else {
            s.skip_field("candidates")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CharacterData_TraitDataBundleBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharacterData_TraitDataBundleBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_candidates(
        &mut self,
        candidates: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_TraitData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_TraitDataBundle::VT_CANDIDATES,
            candidates,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharacterData_TraitDataBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharacterData_TraitDataBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_TraitDataBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharacterData_TraitDataBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharacterData_TraitDataBundle");
        ds.field("candidates", &self.candidates());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharacterData_TraitDataBundleT {
    pub candidates: Option<Vec<clz_Torappu_CharacterData_TraitDataT>>,
}
impl Default for clz_Torappu_CharacterData_TraitDataBundleT {
    fn default() -> Self {
        Self { candidates: None }
    }
}
impl clz_Torappu_CharacterData_TraitDataBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_TraitDataBundle<'b>> {
        let candidates = self.candidates.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_CharacterData_TraitDataBundle::create(
            _fbb,
            &clz_Torappu_CharacterData_TraitDataBundleArgs { candidates },
        )
    }
}
pub enum clz_Torappu_AttributesDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_AttributesData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_AttributesData<'a> {
    type Inner = clz_Torappu_AttributesData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_AttributesData<'a> {
    pub const VT_MAXHP: flatbuffers::VOffsetT = 4;
    pub const VT_ATK: flatbuffers::VOffsetT = 6;
    pub const VT_DEF: flatbuffers::VOffsetT = 8;
    pub const VT_MAGICRESISTANCE: flatbuffers::VOffsetT = 10;
    pub const VT_COST: flatbuffers::VOffsetT = 12;
    pub const VT_BLOCKCNT: flatbuffers::VOffsetT = 14;
    pub const VT_MOVESPEED: flatbuffers::VOffsetT = 16;
    pub const VT_ATTACKSPEED: flatbuffers::VOffsetT = 18;
    pub const VT_BASEATTACKTIME: flatbuffers::VOffsetT = 20;
    pub const VT_RESPAWNTIME: flatbuffers::VOffsetT = 22;
    pub const VT_HPRECOVERYPERSEC: flatbuffers::VOffsetT = 24;
    pub const VT_SPRECOVERYPERSEC: flatbuffers::VOffsetT = 26;
    pub const VT_MAXDEPLOYCOUNT: flatbuffers::VOffsetT = 28;
    pub const VT_MAXDECKSTACKCNT: flatbuffers::VOffsetT = 30;
    pub const VT_TAUNTLEVEL: flatbuffers::VOffsetT = 32;
    pub const VT_MASSLEVEL: flatbuffers::VOffsetT = 34;
    pub const VT_BASEFORCELEVEL: flatbuffers::VOffsetT = 36;
    pub const VT_STUNIMMUNE: flatbuffers::VOffsetT = 38;
    pub const VT_SILENCEIMMUNE: flatbuffers::VOffsetT = 40;
    pub const VT_SLEEPIMMUNE: flatbuffers::VOffsetT = 42;
    pub const VT_FROZENIMMUNE: flatbuffers::VOffsetT = 44;
    pub const VT_LEVITATEIMMUNE: flatbuffers::VOffsetT = 46;
    pub const VT_DISARMEDCOMBATIMMUNE: flatbuffers::VOffsetT = 48;
    pub const VT_FEAREDIMMUNE: flatbuffers::VOffsetT = 50;
    pub const VT_PALSYIMMUNE: flatbuffers::VOffsetT = 52;
    pub const VT_ATTRACTIMMUNE: flatbuffers::VOffsetT = 54;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_AttributesData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_AttributesDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_AttributesData<'bldr>> {
        let mut builder = clz_Torappu_AttributesDataBuilder::new(_fbb);
        builder.add_baseForceLevel(args.baseForceLevel);
        builder.add_massLevel(args.massLevel);
        builder.add_tauntLevel(args.tauntLevel);
        builder.add_maxDeckStackCnt(args.maxDeckStackCnt);
        builder.add_maxDeployCount(args.maxDeployCount);
        builder.add_spRecoveryPerSec(args.spRecoveryPerSec);
        builder.add_hpRecoveryPerSec(args.hpRecoveryPerSec);
        builder.add_respawnTime(args.respawnTime);
        builder.add_baseAttackTime(args.baseAttackTime);
        builder.add_attackSpeed(args.attackSpeed);
        builder.add_moveSpeed(args.moveSpeed);
        builder.add_blockCnt(args.blockCnt);
        builder.add_cost(args.cost);
        builder.add_magicResistance(args.magicResistance);
        builder.add_def(args.def);
        builder.add_atk(args.atk);
        builder.add_maxHp(args.maxHp);
        builder.add_attractImmune(args.attractImmune);
        builder.add_palsyImmune(args.palsyImmune);
        builder.add_fearedImmune(args.fearedImmune);
        builder.add_disarmedCombatImmune(args.disarmedCombatImmune);
        builder.add_levitateImmune(args.levitateImmune);
        builder.add_frozenImmune(args.frozenImmune);
        builder.add_sleepImmune(args.sleepImmune);
        builder.add_silenceImmune(args.silenceImmune);
        builder.add_stunImmune(args.stunImmune);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_AttributesDataT {
        let maxHp = self.maxHp();
        let atk = self.atk();
        let def = self.def();
        let magicResistance = self.magicResistance();
        let cost = self.cost();
        let blockCnt = self.blockCnt();
        let moveSpeed = self.moveSpeed();
        let attackSpeed = self.attackSpeed();
        let baseAttackTime = self.baseAttackTime();
        let respawnTime = self.respawnTime();
        let hpRecoveryPerSec = self.hpRecoveryPerSec();
        let spRecoveryPerSec = self.spRecoveryPerSec();
        let maxDeployCount = self.maxDeployCount();
        let maxDeckStackCnt = self.maxDeckStackCnt();
        let tauntLevel = self.tauntLevel();
        let massLevel = self.massLevel();
        let baseForceLevel = self.baseForceLevel();
        let stunImmune = self.stunImmune();
        let silenceImmune = self.silenceImmune();
        let sleepImmune = self.sleepImmune();
        let frozenImmune = self.frozenImmune();
        let levitateImmune = self.levitateImmune();
        let disarmedCombatImmune = self.disarmedCombatImmune();
        let fearedImmune = self.fearedImmune();
        let palsyImmune = self.palsyImmune();
        let attractImmune = self.attractImmune();
        clz_Torappu_AttributesDataT {
            maxHp,
            atk,
            def,
            magicResistance,
            cost,
            blockCnt,
            moveSpeed,
            attackSpeed,
            baseAttackTime,
            respawnTime,
            hpRecoveryPerSec,
            spRecoveryPerSec,
            maxDeployCount,
            maxDeckStackCnt,
            tauntLevel,
            massLevel,
            baseForceLevel,
            stunImmune,
            silenceImmune,
            sleepImmune,
            frozenImmune,
            levitateImmune,
            disarmedCombatImmune,
            fearedImmune,
            palsyImmune,
            attractImmune,
        }
    }

    #[inline]
    pub fn maxHp(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesData::VT_MAXHP, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn atk(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesData::VT_ATK, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn def(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesData::VT_DEF, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn magicResistance(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_AttributesData::VT_MAGICRESISTANCE, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn cost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesData::VT_COST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn blockCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesData::VT_BLOCKCNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn moveSpeed(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_AttributesData::VT_MOVESPEED, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn attackSpeed(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_AttributesData::VT_ATTACKSPEED, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn baseAttackTime(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_AttributesData::VT_BASEATTACKTIME, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn respawnTime(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesData::VT_RESPAWNTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn hpRecoveryPerSec(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_AttributesData::VT_HPRECOVERYPERSEC, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn spRecoveryPerSec(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_AttributesData::VT_SPRECOVERYPERSEC, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn maxDeployCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesData::VT_MAXDEPLOYCOUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn maxDeckStackCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesData::VT_MAXDECKSTACKCNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn tauntLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesData::VT_TAUNTLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn massLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesData::VT_MASSLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn baseForceLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesData::VT_BASEFORCELEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn stunImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_AttributesData::VT_STUNIMMUNE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn silenceImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_AttributesData::VT_SILENCEIMMUNE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn sleepImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_AttributesData::VT_SLEEPIMMUNE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn frozenImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_AttributesData::VT_FROZENIMMUNE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn levitateImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_AttributesData::VT_LEVITATEIMMUNE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn disarmedCombatImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_AttributesData::VT_DISARMEDCOMBATIMMUNE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn fearedImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_AttributesData::VT_FEAREDIMMUNE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn palsyImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_AttributesData::VT_PALSYIMMUNE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn attractImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_AttributesData::VT_ATTRACTIMMUNE, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_AttributesData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("maxHp", Self::VT_MAXHP, false)?
            .visit_field::<i32>("atk", Self::VT_ATK, false)?
            .visit_field::<i32>("def", Self::VT_DEF, false)?
            .visit_field::<f32>("magicResistance", Self::VT_MAGICRESISTANCE, false)?
            .visit_field::<i32>("cost", Self::VT_COST, false)?
            .visit_field::<i32>("blockCnt", Self::VT_BLOCKCNT, false)?
            .visit_field::<f32>("moveSpeed", Self::VT_MOVESPEED, false)?
            .visit_field::<f32>("attackSpeed", Self::VT_ATTACKSPEED, false)?
            .visit_field::<f32>("baseAttackTime", Self::VT_BASEATTACKTIME, false)?
            .visit_field::<i32>("respawnTime", Self::VT_RESPAWNTIME, false)?
            .visit_field::<f32>("hpRecoveryPerSec", Self::VT_HPRECOVERYPERSEC, false)?
            .visit_field::<f32>("spRecoveryPerSec", Self::VT_SPRECOVERYPERSEC, false)?
            .visit_field::<i32>("maxDeployCount", Self::VT_MAXDEPLOYCOUNT, false)?
            .visit_field::<i32>("maxDeckStackCnt", Self::VT_MAXDECKSTACKCNT, false)?
            .visit_field::<i32>("tauntLevel", Self::VT_TAUNTLEVEL, false)?
            .visit_field::<i32>("massLevel", Self::VT_MASSLEVEL, false)?
            .visit_field::<i32>("baseForceLevel", Self::VT_BASEFORCELEVEL, false)?
            .visit_field::<bool>("stunImmune", Self::VT_STUNIMMUNE, false)?
            .visit_field::<bool>("silenceImmune", Self::VT_SILENCEIMMUNE, false)?
            .visit_field::<bool>("sleepImmune", Self::VT_SLEEPIMMUNE, false)?
            .visit_field::<bool>("frozenImmune", Self::VT_FROZENIMMUNE, false)?
            .visit_field::<bool>("levitateImmune", Self::VT_LEVITATEIMMUNE, false)?
            .visit_field::<bool>("disarmedCombatImmune", Self::VT_DISARMEDCOMBATIMMUNE, false)?
            .visit_field::<bool>("fearedImmune", Self::VT_FEAREDIMMUNE, false)?
            .visit_field::<bool>("palsyImmune", Self::VT_PALSYIMMUNE, false)?
            .visit_field::<bool>("attractImmune", Self::VT_ATTRACTIMMUNE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_AttributesDataArgs {
    pub maxHp: i32,
    pub atk: i32,
    pub def: i32,
    pub magicResistance: f32,
    pub cost: i32,
    pub blockCnt: i32,
    pub moveSpeed: f32,
    pub attackSpeed: f32,
    pub baseAttackTime: f32,
    pub respawnTime: i32,
    pub hpRecoveryPerSec: f32,
    pub spRecoveryPerSec: f32,
    pub maxDeployCount: i32,
    pub maxDeckStackCnt: i32,
    pub tauntLevel: i32,
    pub massLevel: i32,
    pub baseForceLevel: i32,
    pub stunImmune: bool,
    pub silenceImmune: bool,
    pub sleepImmune: bool,
    pub frozenImmune: bool,
    pub levitateImmune: bool,
    pub disarmedCombatImmune: bool,
    pub fearedImmune: bool,
    pub palsyImmune: bool,
    pub attractImmune: bool,
}
impl<'a> Default for clz_Torappu_AttributesDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_AttributesDataArgs {
            maxHp: 0,
            atk: 0,
            def: 0,
            magicResistance: 0.0,
            cost: 0,
            blockCnt: 0,
            moveSpeed: 0.0,
            attackSpeed: 0.0,
            baseAttackTime: 0.0,
            respawnTime: 0,
            hpRecoveryPerSec: 0.0,
            spRecoveryPerSec: 0.0,
            maxDeployCount: 0,
            maxDeckStackCnt: 0,
            tauntLevel: 0,
            massLevel: 0,
            baseForceLevel: 0,
            stunImmune: false,
            silenceImmune: false,
            sleepImmune: false,
            frozenImmune: false,
            levitateImmune: false,
            disarmedCombatImmune: false,
            fearedImmune: false,
            palsyImmune: false,
            attractImmune: false,
        }
    }
}

impl Serialize for clz_Torappu_AttributesData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_AttributesData", 26)?;
        s.serialize_field("maxHp", &self.maxHp())?;
        s.serialize_field("atk", &self.atk())?;
        s.serialize_field("def", &self.def())?;
        s.serialize_field("magicResistance", &self.magicResistance())?;
        s.serialize_field("cost", &self.cost())?;
        s.serialize_field("blockCnt", &self.blockCnt())?;
        s.serialize_field("moveSpeed", &self.moveSpeed())?;
        s.serialize_field("attackSpeed", &self.attackSpeed())?;
        s.serialize_field("baseAttackTime", &self.baseAttackTime())?;
        s.serialize_field("respawnTime", &self.respawnTime())?;
        s.serialize_field("hpRecoveryPerSec", &self.hpRecoveryPerSec())?;
        s.serialize_field("spRecoveryPerSec", &self.spRecoveryPerSec())?;
        s.serialize_field("maxDeployCount", &self.maxDeployCount())?;
        s.serialize_field("maxDeckStackCnt", &self.maxDeckStackCnt())?;
        s.serialize_field("tauntLevel", &self.tauntLevel())?;
        s.serialize_field("massLevel", &self.massLevel())?;
        s.serialize_field("baseForceLevel", &self.baseForceLevel())?;
        s.serialize_field("stunImmune", &self.stunImmune())?;
        s.serialize_field("silenceImmune", &self.silenceImmune())?;
        s.serialize_field("sleepImmune", &self.sleepImmune())?;
        s.serialize_field("frozenImmune", &self.frozenImmune())?;
        s.serialize_field("levitateImmune", &self.levitateImmune())?;
        s.serialize_field("disarmedCombatImmune", &self.disarmedCombatImmune())?;
        s.serialize_field("fearedImmune", &self.fearedImmune())?;
        s.serialize_field("palsyImmune", &self.palsyImmune())?;
        s.serialize_field("attractImmune", &self.attractImmune())?;
        s.end()
    }
}

pub struct clz_Torappu_AttributesDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_AttributesDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_maxHp(&mut self, maxHp: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_AttributesData::VT_MAXHP, maxHp, 0);
    }
    #[inline]
    pub fn add_atk(&mut self, atk: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_AttributesData::VT_ATK, atk, 0);
    }
    #[inline]
    pub fn add_def(&mut self, def: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_AttributesData::VT_DEF, def, 0);
    }
    #[inline]
    pub fn add_magicResistance(&mut self, magicResistance: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_AttributesData::VT_MAGICRESISTANCE,
            magicResistance,
            0.0,
        );
    }
    #[inline]
    pub fn add_cost(&mut self, cost: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_AttributesData::VT_COST, cost, 0);
    }
    #[inline]
    pub fn add_blockCnt(&mut self, blockCnt: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_AttributesData::VT_BLOCKCNT, blockCnt, 0);
    }
    #[inline]
    pub fn add_moveSpeed(&mut self, moveSpeed: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_AttributesData::VT_MOVESPEED, moveSpeed, 0.0);
    }
    #[inline]
    pub fn add_attackSpeed(&mut self, attackSpeed: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_AttributesData::VT_ATTACKSPEED, attackSpeed, 0.0);
    }
    #[inline]
    pub fn add_baseAttackTime(&mut self, baseAttackTime: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_AttributesData::VT_BASEATTACKTIME,
            baseAttackTime,
            0.0,
        );
    }
    #[inline]
    pub fn add_respawnTime(&mut self, respawnTime: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_AttributesData::VT_RESPAWNTIME, respawnTime, 0);
    }
    #[inline]
    pub fn add_hpRecoveryPerSec(&mut self, hpRecoveryPerSec: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_AttributesData::VT_HPRECOVERYPERSEC,
            hpRecoveryPerSec,
            0.0,
        );
    }
    #[inline]
    pub fn add_spRecoveryPerSec(&mut self, spRecoveryPerSec: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_AttributesData::VT_SPRECOVERYPERSEC,
            spRecoveryPerSec,
            0.0,
        );
    }
    #[inline]
    pub fn add_maxDeployCount(&mut self, maxDeployCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_AttributesData::VT_MAXDEPLOYCOUNT,
            maxDeployCount,
            0,
        );
    }
    #[inline]
    pub fn add_maxDeckStackCnt(&mut self, maxDeckStackCnt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_AttributesData::VT_MAXDECKSTACKCNT,
            maxDeckStackCnt,
            0,
        );
    }
    #[inline]
    pub fn add_tauntLevel(&mut self, tauntLevel: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_AttributesData::VT_TAUNTLEVEL, tauntLevel, 0);
    }
    #[inline]
    pub fn add_massLevel(&mut self, massLevel: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_AttributesData::VT_MASSLEVEL, massLevel, 0);
    }
    #[inline]
    pub fn add_baseForceLevel(&mut self, baseForceLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_AttributesData::VT_BASEFORCELEVEL,
            baseForceLevel,
            0,
        );
    }
    #[inline]
    pub fn add_stunImmune(&mut self, stunImmune: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_AttributesData::VT_STUNIMMUNE, stunImmune, false);
    }
    #[inline]
    pub fn add_silenceImmune(&mut self, silenceImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesData::VT_SILENCEIMMUNE,
            silenceImmune,
            false,
        );
    }
    #[inline]
    pub fn add_sleepImmune(&mut self, sleepImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesData::VT_SLEEPIMMUNE,
            sleepImmune,
            false,
        );
    }
    #[inline]
    pub fn add_frozenImmune(&mut self, frozenImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesData::VT_FROZENIMMUNE,
            frozenImmune,
            false,
        );
    }
    #[inline]
    pub fn add_levitateImmune(&mut self, levitateImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesData::VT_LEVITATEIMMUNE,
            levitateImmune,
            false,
        );
    }
    #[inline]
    pub fn add_disarmedCombatImmune(&mut self, disarmedCombatImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesData::VT_DISARMEDCOMBATIMMUNE,
            disarmedCombatImmune,
            false,
        );
    }
    #[inline]
    pub fn add_fearedImmune(&mut self, fearedImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesData::VT_FEAREDIMMUNE,
            fearedImmune,
            false,
        );
    }
    #[inline]
    pub fn add_palsyImmune(&mut self, palsyImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesData::VT_PALSYIMMUNE,
            palsyImmune,
            false,
        );
    }
    #[inline]
    pub fn add_attractImmune(&mut self, attractImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesData::VT_ATTRACTIMMUNE,
            attractImmune,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_AttributesDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_AttributesDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_AttributesData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_AttributesData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_AttributesData");
        ds.field("maxHp", &self.maxHp());
        ds.field("atk", &self.atk());
        ds.field("def", &self.def());
        ds.field("magicResistance", &self.magicResistance());
        ds.field("cost", &self.cost());
        ds.field("blockCnt", &self.blockCnt());
        ds.field("moveSpeed", &self.moveSpeed());
        ds.field("attackSpeed", &self.attackSpeed());
        ds.field("baseAttackTime", &self.baseAttackTime());
        ds.field("respawnTime", &self.respawnTime());
        ds.field("hpRecoveryPerSec", &self.hpRecoveryPerSec());
        ds.field("spRecoveryPerSec", &self.spRecoveryPerSec());
        ds.field("maxDeployCount", &self.maxDeployCount());
        ds.field("maxDeckStackCnt", &self.maxDeckStackCnt());
        ds.field("tauntLevel", &self.tauntLevel());
        ds.field("massLevel", &self.massLevel());
        ds.field("baseForceLevel", &self.baseForceLevel());
        ds.field("stunImmune", &self.stunImmune());
        ds.field("silenceImmune", &self.silenceImmune());
        ds.field("sleepImmune", &self.sleepImmune());
        ds.field("frozenImmune", &self.frozenImmune());
        ds.field("levitateImmune", &self.levitateImmune());
        ds.field("disarmedCombatImmune", &self.disarmedCombatImmune());
        ds.field("fearedImmune", &self.fearedImmune());
        ds.field("palsyImmune", &self.palsyImmune());
        ds.field("attractImmune", &self.attractImmune());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_AttributesDataT {
    pub maxHp: i32,
    pub atk: i32,
    pub def: i32,
    pub magicResistance: f32,
    pub cost: i32,
    pub blockCnt: i32,
    pub moveSpeed: f32,
    pub attackSpeed: f32,
    pub baseAttackTime: f32,
    pub respawnTime: i32,
    pub hpRecoveryPerSec: f32,
    pub spRecoveryPerSec: f32,
    pub maxDeployCount: i32,
    pub maxDeckStackCnt: i32,
    pub tauntLevel: i32,
    pub massLevel: i32,
    pub baseForceLevel: i32,
    pub stunImmune: bool,
    pub silenceImmune: bool,
    pub sleepImmune: bool,
    pub frozenImmune: bool,
    pub levitateImmune: bool,
    pub disarmedCombatImmune: bool,
    pub fearedImmune: bool,
    pub palsyImmune: bool,
    pub attractImmune: bool,
}
impl Default for clz_Torappu_AttributesDataT {
    fn default() -> Self {
        Self {
            maxHp: 0,
            atk: 0,
            def: 0,
            magicResistance: 0.0,
            cost: 0,
            blockCnt: 0,
            moveSpeed: 0.0,
            attackSpeed: 0.0,
            baseAttackTime: 0.0,
            respawnTime: 0,
            hpRecoveryPerSec: 0.0,
            spRecoveryPerSec: 0.0,
            maxDeployCount: 0,
            maxDeckStackCnt: 0,
            tauntLevel: 0,
            massLevel: 0,
            baseForceLevel: 0,
            stunImmune: false,
            silenceImmune: false,
            sleepImmune: false,
            frozenImmune: false,
            levitateImmune: false,
            disarmedCombatImmune: false,
            fearedImmune: false,
            palsyImmune: false,
            attractImmune: false,
        }
    }
}
impl clz_Torappu_AttributesDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_AttributesData<'b>> {
        let maxHp = self.maxHp;
        let atk = self.atk;
        let def = self.def;
        let magicResistance = self.magicResistance;
        let cost = self.cost;
        let blockCnt = self.blockCnt;
        let moveSpeed = self.moveSpeed;
        let attackSpeed = self.attackSpeed;
        let baseAttackTime = self.baseAttackTime;
        let respawnTime = self.respawnTime;
        let hpRecoveryPerSec = self.hpRecoveryPerSec;
        let spRecoveryPerSec = self.spRecoveryPerSec;
        let maxDeployCount = self.maxDeployCount;
        let maxDeckStackCnt = self.maxDeckStackCnt;
        let tauntLevel = self.tauntLevel;
        let massLevel = self.massLevel;
        let baseForceLevel = self.baseForceLevel;
        let stunImmune = self.stunImmune;
        let silenceImmune = self.silenceImmune;
        let sleepImmune = self.sleepImmune;
        let frozenImmune = self.frozenImmune;
        let levitateImmune = self.levitateImmune;
        let disarmedCombatImmune = self.disarmedCombatImmune;
        let fearedImmune = self.fearedImmune;
        let palsyImmune = self.palsyImmune;
        let attractImmune = self.attractImmune;
        clz_Torappu_AttributesData::create(
            _fbb,
            &clz_Torappu_AttributesDataArgs {
                maxHp,
                atk,
                def,
                magicResistance,
                cost,
                blockCnt,
                moveSpeed,
                attackSpeed,
                baseAttackTime,
                respawnTime,
                hpRecoveryPerSec,
                spRecoveryPerSec,
                maxDeployCount,
                maxDeckStackCnt,
                tauntLevel,
                massLevel,
                baseForceLevel,
                stunImmune,
                silenceImmune,
                sleepImmune,
                frozenImmune,
                levitateImmune,
                disarmedCombatImmune,
                fearedImmune,
                palsyImmune,
                attractImmune,
            },
        )
    }
}
pub enum clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_<'a>
{
    type Inner =
        clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_<'a> {
    pub const VT_LEVEL: flatbuffers::VOffsetT = 4;
    pub const VT_DATA: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_ {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_Args<'args>,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_<'bldr>,
    > {
        let mut builder = clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_Builder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.add_level(args.level);
        builder.finish()
    }

    pub fn unpack(
        &self,
    ) -> clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_T {
        let level = self.level();
        let data = self.data().map(|x| Box::new(x.unpack()));
        clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_T {
            level,
            data,
        }
    }

    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<i32>(clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_::VT_LEVEL, Some(0)).unwrap()
        }
    }
    #[inline]
    pub fn data(&self) -> Option<clz_Torappu_AttributesData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_AttributesData>>(clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_::VT_DATA, None)
        }
    }
}

impl flatbuffers::Verifiable
    for clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_AttributesData>>(
                "data",
                Self::VT_DATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_Args<'a> {
    pub level: i32,
    pub data: Option<flatbuffers::WIPOffset<clz_Torappu_AttributesData<'a>>>,
}
impl<'a> Default
    for clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_Args<'a>
{
    #[inline]
    fn default() -> Self {
        clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_Args {
            level: 0,
            data: None,
        }
    }
}

impl Serialize
    for clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_<'_>
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_",
            2,
        )?;
        s.serialize_field("level", &self.level())?;
        if let Some(f) = self.data() {
            s.serialize_field("data", &f)?;
        } else {
            s.skip_field("data")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_Builder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_Builder<
        'a,
        'b,
        A,
    >
{
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_.push_slot::<i32>(clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_::VT_LEVEL, level, 0);
    }
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<clz_Torappu_AttributesData<'b>>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_AttributesData>>(clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_::VT_DATA, data);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_Builder<
        'a,
        'b,
        A,
    > {
        let start = _fbb.start_table();
        clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct(
            "clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_",
        );
        ds.field("level", &self.level());
        ds.field("data", &self.data());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_T {
    pub level: i32,
    pub data: Option<Box<clz_Torappu_AttributesDataT>>,
}
impl Default for clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_T {
    fn default() -> Self {
        Self {
            level: 0,
            data: None,
        }
    }
}
impl clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_T {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_<'b>,
    > {
        let level = self.level;
        let data = self.data.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_::create(
            _fbb,
            &clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_Args {
                level,
                data,
            },
        )
    }
}
pub enum clz_Torappu_ItemBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ItemBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ItemBundle<'a> {
    type Inner = clz_Torappu_ItemBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ItemBundle<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_COUNT: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ItemBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ItemBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'bldr>> {
        let mut builder = clz_Torappu_ItemBundleBuilder::new(_fbb);
        builder.add_type_(args.type_);
        builder.add_count(args.count);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ItemBundleT {
        let id = self.id().map(|x| x.to_string());
        let count = self.count();
        let type_ = self.type_();
        clz_Torappu_ItemBundleT { id, count, type_ }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_ItemBundle::VT_ID, None)
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ItemBundle::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_ItemBundle::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ItemBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ItemBundleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl<'a> Default for clz_Torappu_ItemBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ItemBundleArgs {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_ItemBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ItemBundle", 3)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("count", &self.count())?;
        s.serialize_field("type_", &self.type_())?;
        s.end()
    }
}

pub struct clz_Torappu_ItemBundleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ItemBundle::VT_ID, id);
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ItemBundle::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_ItemBundle::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ItemBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ItemBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ItemBundle");
        ds.field("id", &self.id());
        ds.field("count", &self.count());
        ds.field("type_", &self.type_());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ItemBundleT {
    pub id: Option<String>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl Default for clz_Torappu_ItemBundleT {
    fn default() -> Self {
        Self {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}
impl clz_Torappu_ItemBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let count = self.count;
        let type_ = self.type_;
        clz_Torappu_ItemBundle::create(_fbb, &clz_Torappu_ItemBundleArgs { id, count, type_ })
    }
}
pub enum clz_Torappu_CharacterData_PhaseDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharacterData_PhaseData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharacterData_PhaseData<'a> {
    type Inner = clz_Torappu_CharacterData_PhaseData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharacterData_PhaseData<'a> {
    pub const VT_CHARACTERPREFABKEY: flatbuffers::VOffsetT = 4;
    pub const VT_RANGEID: flatbuffers::VOffsetT = 6;
    pub const VT_MAXLEVEL: flatbuffers::VOffsetT = 8;
    pub const VT_ATTRIBUTESKEYFRAMES: flatbuffers::VOffsetT = 10;
    pub const VT_EVOLVECOST: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharacterData_PhaseData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharacterData_PhaseDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_PhaseData<'bldr>> {
        let mut builder = clz_Torappu_CharacterData_PhaseDataBuilder::new(_fbb);
        if let Some(x) = args.evolveCost {
            builder.add_evolveCost(x);
        }
        if let Some(x) = args.attributesKeyFrames {
            builder.add_attributesKeyFrames(x);
        }
        builder.add_maxLevel(args.maxLevel);
        if let Some(x) = args.rangeId {
            builder.add_rangeId(x);
        }
        if let Some(x) = args.characterPrefabKey {
            builder.add_characterPrefabKey(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharacterData_PhaseDataT {
        let characterPrefabKey = self.characterPrefabKey().map(|x| x.to_string());
        let rangeId = self.rangeId().map(|x| x.to_string());
        let maxLevel = self.maxLevel();
        let attributesKeyFrames = self
            .attributesKeyFrames()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let evolveCost = self
            .evolveCost()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_CharacterData_PhaseDataT {
            characterPrefabKey,
            rangeId,
            maxLevel,
            attributesKeyFrames,
            evolveCost,
        }
    }

    #[inline]
    pub fn characterPrefabKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData_PhaseData::VT_CHARACTERPREFABKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn rangeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData_PhaseData::VT_RANGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn maxLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CharacterData_PhaseData::VT_MAXLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn attributesKeyFrames(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_>>>>(clz_Torappu_CharacterData_PhaseData::VT_ATTRIBUTESKEYFRAMES, None)
        }
    }
    #[inline]
    pub fn evolveCost(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(clz_Torappu_CharacterData_PhaseData::VT_EVOLVECOST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharacterData_PhaseData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("characterPrefabKey", Self::VT_CHARACTERPREFABKEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rangeId", Self::VT_RANGEID, false)?
     .visit_field::<i32>("maxLevel", Self::VT_MAXLEVEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_>>>>("attributesKeyFrames", Self::VT_ATTRIBUTESKEYFRAMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>>>("evolveCost", Self::VT_EVOLVECOST, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharacterData_PhaseDataArgs<'a> {
    pub characterPrefabKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rangeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub maxLevel: i32,
    pub attributesKeyFrames: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_<
                        'a,
                    >,
                >,
            >,
        >,
    >,
    pub evolveCost: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_CharacterData_PhaseDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharacterData_PhaseDataArgs {
            characterPrefabKey: None,
            rangeId: None,
            maxLevel: 0,
            attributesKeyFrames: None,
            evolveCost: None,
        }
    }
}

impl Serialize for clz_Torappu_CharacterData_PhaseData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharacterData_PhaseData", 5)?;
        if let Some(f) = self.characterPrefabKey() {
            s.serialize_field("characterPrefabKey", &f)?;
        } else {
            s.skip_field("characterPrefabKey")?;
        }
        if let Some(f) = self.rangeId() {
            s.serialize_field("rangeId", &f)?;
        } else {
            s.skip_field("rangeId")?;
        }
        s.serialize_field("maxLevel", &self.maxLevel())?;
        if let Some(f) = self.attributesKeyFrames() {
            s.serialize_field("attributesKeyFrames", &f)?;
        } else {
            s.skip_field("attributesKeyFrames")?;
        }
        if let Some(f) = self.evolveCost() {
            s.serialize_field("evolveCost", &f)?;
        } else {
            s.skip_field("evolveCost")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CharacterData_PhaseDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharacterData_PhaseDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_characterPrefabKey(&mut self, characterPrefabKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_PhaseData::VT_CHARACTERPREFABKEY,
            characterPrefabKey,
        );
    }
    #[inline]
    pub fn add_rangeId(&mut self, rangeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_PhaseData::VT_RANGEID,
            rangeId,
        );
    }
    #[inline]
    pub fn add_maxLevel(&mut self, maxLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_CharacterData_PhaseData::VT_MAXLEVEL,
            maxLevel,
            0,
        );
    }
    #[inline]
    pub fn add_attributesKeyFrames(
        &mut self,
        attributesKeyFrames: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_<
                        'b,
                    >,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_PhaseData::VT_ATTRIBUTESKEYFRAMES,
            attributesKeyFrames,
        );
    }
    #[inline]
    pub fn add_evolveCost(
        &mut self,
        evolveCost: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_PhaseData::VT_EVOLVECOST,
            evolveCost,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharacterData_PhaseDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharacterData_PhaseDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_PhaseData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharacterData_PhaseData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharacterData_PhaseData");
        ds.field("characterPrefabKey", &self.characterPrefabKey());
        ds.field("rangeId", &self.rangeId());
        ds.field("maxLevel", &self.maxLevel());
        ds.field("attributesKeyFrames", &self.attributesKeyFrames());
        ds.field("evolveCost", &self.evolveCost());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharacterData_PhaseDataT {
    pub characterPrefabKey: Option<String>,
    pub rangeId: Option<String>,
    pub maxLevel: i32,
    pub attributesKeyFrames: Option<
        Vec<clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesData_Torappu_AttributesData_T>,
    >,
    pub evolveCost: Option<Vec<clz_Torappu_ItemBundleT>>,
}
impl Default for clz_Torappu_CharacterData_PhaseDataT {
    fn default() -> Self {
        Self {
            characterPrefabKey: None,
            rangeId: None,
            maxLevel: 0,
            attributesKeyFrames: None,
            evolveCost: None,
        }
    }
}
impl clz_Torappu_CharacterData_PhaseDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_PhaseData<'b>> {
        let characterPrefabKey = self
            .characterPrefabKey
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let rangeId = self.rangeId.as_ref().map(|x| _fbb.create_string(x));
        let maxLevel = self.maxLevel;
        let attributesKeyFrames = self.attributesKeyFrames.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let evolveCost = self.evolveCost.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_CharacterData_PhaseData::create(
            _fbb,
            &clz_Torappu_CharacterData_PhaseDataArgs {
                characterPrefabKey,
                rangeId,
                maxLevel,
                attributesKeyFrames,
                evolveCost,
            },
        )
    }
}
pub enum clz_Torappu_CharacterData_MainSkill_SpecializeLevelDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharacterData_MainSkill_SpecializeLevelData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharacterData_MainSkill_SpecializeLevelData<'a> {
    type Inner = clz_Torappu_CharacterData_MainSkill_SpecializeLevelData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharacterData_MainSkill_SpecializeLevelData<'a> {
    pub const VT_UNLOCKCOND: flatbuffers::VOffsetT = 4;
    pub const VT_LVLUPTIME: flatbuffers::VOffsetT = 6;
    pub const VT_LEVELUPCOST: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharacterData_MainSkill_SpecializeLevelData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharacterData_MainSkill_SpecializeLevelDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_MainSkill_SpecializeLevelData<'bldr>>
    {
        let mut builder = clz_Torappu_CharacterData_MainSkill_SpecializeLevelDataBuilder::new(_fbb);
        if let Some(x) = args.levelUpCost {
            builder.add_levelUpCost(x);
        }
        builder.add_lvlUpTime(args.lvlUpTime);
        if let Some(x) = args.unlockCond {
            builder.add_unlockCond(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharacterData_MainSkill_SpecializeLevelDataT {
        let unlockCond = self.unlockCond().map(|x| Box::new(x.unpack()));
        let lvlUpTime = self.lvlUpTime();
        let levelUpCost = self
            .levelUpCost()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_CharacterData_MainSkill_SpecializeLevelDataT {
            unlockCond,
            lvlUpTime,
            levelUpCost,
        }
    }

    #[inline]
    pub fn unlockCond(&self) -> Option<clz_Torappu_CharacterData_UnlockCondition<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                    clz_Torappu_CharacterData_MainSkill_SpecializeLevelData::VT_UNLOCKCOND,
                    None,
                )
        }
    }
    #[inline]
    pub fn lvlUpTime(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_CharacterData_MainSkill_SpecializeLevelData::VT_LVLUPTIME,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn levelUpCost(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(
                clz_Torappu_CharacterData_MainSkill_SpecializeLevelData::VT_LEVELUPCOST,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharacterData_MainSkill_SpecializeLevelData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                "unlockCond",
                Self::VT_UNLOCKCOND,
                false,
            )?
            .visit_field::<i32>("lvlUpTime", Self::VT_LVLUPTIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("levelUpCost", Self::VT_LEVELUPCOST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharacterData_MainSkill_SpecializeLevelDataArgs<'a> {
    pub unlockCond: Option<flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'a>>>,
    pub lvlUpTime: i32,
    pub levelUpCost: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_CharacterData_MainSkill_SpecializeLevelDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharacterData_MainSkill_SpecializeLevelDataArgs {
            unlockCond: None,
            lvlUpTime: 0,
            levelUpCost: None,
        }
    }
}

impl Serialize for clz_Torappu_CharacterData_MainSkill_SpecializeLevelData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("clz_Torappu_CharacterData_MainSkill_SpecializeLevelData", 3)?;
        if let Some(f) = self.unlockCond() {
            s.serialize_field("unlockCond", &f)?;
        } else {
            s.skip_field("unlockCond")?;
        }
        s.serialize_field("lvlUpTime", &self.lvlUpTime())?;
        if let Some(f) = self.levelUpCost() {
            s.serialize_field("levelUpCost", &f)?;
        } else {
            s.skip_field("levelUpCost")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CharacterData_MainSkill_SpecializeLevelDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharacterData_MainSkill_SpecializeLevelDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_unlockCond(
        &mut self,
        unlockCond: flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                clz_Torappu_CharacterData_MainSkill_SpecializeLevelData::VT_UNLOCKCOND,
                unlockCond,
            );
    }
    #[inline]
    pub fn add_lvlUpTime(&mut self, lvlUpTime: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_CharacterData_MainSkill_SpecializeLevelData::VT_LVLUPTIME,
            lvlUpTime,
            0,
        );
    }
    #[inline]
    pub fn add_levelUpCost(
        &mut self,
        levelUpCost: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_MainSkill_SpecializeLevelData::VT_LEVELUPCOST,
            levelUpCost,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharacterData_MainSkill_SpecializeLevelDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharacterData_MainSkill_SpecializeLevelDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_MainSkill_SpecializeLevelData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharacterData_MainSkill_SpecializeLevelData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharacterData_MainSkill_SpecializeLevelData");
        ds.field("unlockCond", &self.unlockCond());
        ds.field("lvlUpTime", &self.lvlUpTime());
        ds.field("levelUpCost", &self.levelUpCost());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharacterData_MainSkill_SpecializeLevelDataT {
    pub unlockCond: Option<Box<clz_Torappu_CharacterData_UnlockConditionT>>,
    pub lvlUpTime: i32,
    pub levelUpCost: Option<Vec<clz_Torappu_ItemBundleT>>,
}
impl Default for clz_Torappu_CharacterData_MainSkill_SpecializeLevelDataT {
    fn default() -> Self {
        Self {
            unlockCond: None,
            lvlUpTime: 0,
            levelUpCost: None,
        }
    }
}
impl clz_Torappu_CharacterData_MainSkill_SpecializeLevelDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_MainSkill_SpecializeLevelData<'b>> {
        let unlockCond = self.unlockCond.as_ref().map(|x| x.pack(_fbb));
        let lvlUpTime = self.lvlUpTime;
        let levelUpCost = self.levelUpCost.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_CharacterData_MainSkill_SpecializeLevelData::create(
            _fbb,
            &clz_Torappu_CharacterData_MainSkill_SpecializeLevelDataArgs {
                unlockCond,
                lvlUpTime,
                levelUpCost,
            },
        )
    }
}
pub enum clz_Torappu_CharacterData_MainSkillOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharacterData_MainSkill<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharacterData_MainSkill<'a> {
    type Inner = clz_Torappu_CharacterData_MainSkill<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharacterData_MainSkill<'a> {
    pub const VT_SKILLID: flatbuffers::VOffsetT = 4;
    pub const VT_OVERRIDEPREFABKEY: flatbuffers::VOffsetT = 6;
    pub const VT_OVERRIDETOKENKEY: flatbuffers::VOffsetT = 8;
    pub const VT_LEVELUPCOSTCOND: flatbuffers::VOffsetT = 10;
    pub const VT_UNLOCKCOND: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharacterData_MainSkill { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharacterData_MainSkillArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_MainSkill<'bldr>> {
        let mut builder = clz_Torappu_CharacterData_MainSkillBuilder::new(_fbb);
        if let Some(x) = args.unlockCond {
            builder.add_unlockCond(x);
        }
        if let Some(x) = args.levelUpCostCond {
            builder.add_levelUpCostCond(x);
        }
        if let Some(x) = args.overrideTokenKey {
            builder.add_overrideTokenKey(x);
        }
        if let Some(x) = args.overridePrefabKey {
            builder.add_overridePrefabKey(x);
        }
        if let Some(x) = args.skillId {
            builder.add_skillId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharacterData_MainSkillT {
        let skillId = self.skillId().map(|x| x.to_string());
        let overridePrefabKey = self.overridePrefabKey().map(|x| x.to_string());
        let overrideTokenKey = self.overrideTokenKey().map(|x| x.to_string());
        let levelUpCostCond = self
            .levelUpCostCond()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let unlockCond = self.unlockCond().map(|x| Box::new(x.unpack()));
        clz_Torappu_CharacterData_MainSkillT {
            skillId,
            overridePrefabKey,
            overrideTokenKey,
            levelUpCostCond,
            unlockCond,
        }
    }

    #[inline]
    pub fn skillId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData_MainSkill::VT_SKILLID,
                None,
            )
        }
    }
    #[inline]
    pub fn overridePrefabKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData_MainSkill::VT_OVERRIDEPREFABKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn overrideTokenKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData_MainSkill::VT_OVERRIDETOKENKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn levelUpCostCond(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                clz_Torappu_CharacterData_MainSkill_SpecializeLevelData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_CharacterData_MainSkill_SpecializeLevelData,
                    >,
                >,
            >>(
                clz_Torappu_CharacterData_MainSkill::VT_LEVELUPCOSTCOND,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockCond(&self) -> Option<clz_Torappu_CharacterData_UnlockCondition<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                    clz_Torappu_CharacterData_MainSkill::VT_UNLOCKCOND,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharacterData_MainSkill<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("skillId", Self::VT_SKILLID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "overridePrefabKey",
                Self::VT_OVERRIDEPREFABKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "overrideTokenKey",
                Self::VT_OVERRIDETOKENKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_CharacterData_MainSkill_SpecializeLevelData,
                    >,
                >,
            >>("levelUpCostCond", Self::VT_LEVELUPCOSTCOND, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                "unlockCond",
                Self::VT_UNLOCKCOND,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharacterData_MainSkillArgs<'a> {
    pub skillId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub overridePrefabKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub overrideTokenKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub levelUpCostCond: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_CharacterData_MainSkill_SpecializeLevelData<'a>,
                >,
            >,
        >,
    >,
    pub unlockCond: Option<flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'a>>>,
}
impl<'a> Default for clz_Torappu_CharacterData_MainSkillArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharacterData_MainSkillArgs {
            skillId: None,
            overridePrefabKey: None,
            overrideTokenKey: None,
            levelUpCostCond: None,
            unlockCond: None,
        }
    }
}

impl Serialize for clz_Torappu_CharacterData_MainSkill<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharacterData_MainSkill", 5)?;
        if let Some(f) = self.skillId() {
            s.serialize_field("skillId", &f)?;
        } else {
            s.skip_field("skillId")?;
        }
        if let Some(f) = self.overridePrefabKey() {
            s.serialize_field("overridePrefabKey", &f)?;
        } else {
            s.skip_field("overridePrefabKey")?;
        }
        if let Some(f) = self.overrideTokenKey() {
            s.serialize_field("overrideTokenKey", &f)?;
        } else {
            s.skip_field("overrideTokenKey")?;
        }
        if let Some(f) = self.levelUpCostCond() {
            s.serialize_field("levelUpCostCond", &f)?;
        } else {
            s.skip_field("levelUpCostCond")?;
        }
        if let Some(f) = self.unlockCond() {
            s.serialize_field("unlockCond", &f)?;
        } else {
            s.skip_field("unlockCond")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CharacterData_MainSkillBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharacterData_MainSkillBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_skillId(&mut self, skillId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_MainSkill::VT_SKILLID,
            skillId,
        );
    }
    #[inline]
    pub fn add_overridePrefabKey(&mut self, overridePrefabKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_MainSkill::VT_OVERRIDEPREFABKEY,
            overridePrefabKey,
        );
    }
    #[inline]
    pub fn add_overrideTokenKey(&mut self, overrideTokenKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_MainSkill::VT_OVERRIDETOKENKEY,
            overrideTokenKey,
        );
    }
    #[inline]
    pub fn add_levelUpCostCond(
        &mut self,
        levelUpCostCond: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_CharacterData_MainSkill_SpecializeLevelData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_MainSkill::VT_LEVELUPCOSTCOND,
            levelUpCostCond,
        );
    }
    #[inline]
    pub fn add_unlockCond(
        &mut self,
        unlockCond: flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                clz_Torappu_CharacterData_MainSkill::VT_UNLOCKCOND,
                unlockCond,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharacterData_MainSkillBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharacterData_MainSkillBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_MainSkill<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharacterData_MainSkill<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharacterData_MainSkill");
        ds.field("skillId", &self.skillId());
        ds.field("overridePrefabKey", &self.overridePrefabKey());
        ds.field("overrideTokenKey", &self.overrideTokenKey());
        ds.field("levelUpCostCond", &self.levelUpCostCond());
        ds.field("unlockCond", &self.unlockCond());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharacterData_MainSkillT {
    pub skillId: Option<String>,
    pub overridePrefabKey: Option<String>,
    pub overrideTokenKey: Option<String>,
    pub levelUpCostCond: Option<Vec<clz_Torappu_CharacterData_MainSkill_SpecializeLevelDataT>>,
    pub unlockCond: Option<Box<clz_Torappu_CharacterData_UnlockConditionT>>,
}
impl Default for clz_Torappu_CharacterData_MainSkillT {
    fn default() -> Self {
        Self {
            skillId: None,
            overridePrefabKey: None,
            overrideTokenKey: None,
            levelUpCostCond: None,
            unlockCond: None,
        }
    }
}
impl clz_Torappu_CharacterData_MainSkillT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_MainSkill<'b>> {
        let skillId = self.skillId.as_ref().map(|x| _fbb.create_string(x));
        let overridePrefabKey = self
            .overridePrefabKey
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let overrideTokenKey = self
            .overrideTokenKey
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let levelUpCostCond = self.levelUpCostCond.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let unlockCond = self.unlockCond.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_CharacterData_MainSkill::create(
            _fbb,
            &clz_Torappu_CharacterData_MainSkillArgs {
                skillId,
                overridePrefabKey,
                overrideTokenKey,
                levelUpCostCond,
                unlockCond,
            },
        )
    }
}
pub enum dict__string__boolOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__bool<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__bool<'a> {
    type Inner = dict__string__bool<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__bool<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__bool { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__boolArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__bool<'bldr>> {
        let mut builder = dict__string__boolBuilder::new(_fbb);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.add_value(args.value);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__boolT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value();
        dict__string__boolT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__bool::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__bool) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(dict__string__bool::VT_VALUE, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for dict__string__bool<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<bool>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__boolArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: bool,
}
impl<'a> Default for dict__string__boolArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__boolArgs {
            key: None, // required field
            value: false,
        }
    }
}

impl Serialize for dict__string__bool<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__bool", 2)?;
        s.serialize_field("key", &self.key())?;
        s.serialize_field("value", &self.value())?;
        s.end()
    }
}

pub struct dict__string__boolBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__boolBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__bool::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(&mut self, value: bool) {
        self.fbb_
            .push_slot::<bool>(dict__string__bool::VT_VALUE, value, false);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__boolBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__boolBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__bool<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, dict__string__bool::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__bool<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__bool");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__boolT {
    pub key: String,
    pub value: bool,
}
impl Default for dict__string__boolT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: false,
        }
    }
}
impl dict__string__boolT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__bool<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value;
        dict__string__bool::create(_fbb, &dict__string__boolArgs { key, value })
    }
}
pub enum clz_Torappu_TalentDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_TalentData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_TalentData<'a> {
    type Inner = clz_Torappu_TalentData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_TalentData<'a> {
    pub const VT_UNLOCKCONDITION: flatbuffers::VOffsetT = 4;
    pub const VT_REQUIREDPOTENTIALRANK: flatbuffers::VOffsetT = 6;
    pub const VT_PREFABKEY: flatbuffers::VOffsetT = 8;
    pub const VT_NAME: flatbuffers::VOffsetT = 10;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 12;
    pub const VT_RANGEID: flatbuffers::VOffsetT = 14;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 16;
    pub const VT_TOKENKEY: flatbuffers::VOffsetT = 18;
    pub const VT_ISHIDETALENT: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_TalentData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_TalentDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TalentData<'bldr>> {
        let mut builder = clz_Torappu_TalentDataBuilder::new(_fbb);
        if let Some(x) = args.tokenKey {
            builder.add_tokenKey(x);
        }
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        if let Some(x) = args.rangeId {
            builder.add_rangeId(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.prefabKey {
            builder.add_prefabKey(x);
        }
        builder.add_requiredPotentialRank(args.requiredPotentialRank);
        if let Some(x) = args.unlockCondition {
            builder.add_unlockCondition(x);
        }
        builder.add_isHideTalent(args.isHideTalent);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_TalentDataT {
        let unlockCondition = self.unlockCondition().map(|x| Box::new(x.unpack()));
        let requiredPotentialRank = self.requiredPotentialRank();
        let prefabKey = self.prefabKey().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let rangeId = self.rangeId().map(|x| x.to_string());
        let blackboard = self
            .blackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let tokenKey = self.tokenKey().map(|x| x.to_string());
        let isHideTalent = self.isHideTalent();
        clz_Torappu_TalentDataT {
            unlockCondition,
            requiredPotentialRank,
            prefabKey,
            name,
            description,
            rangeId,
            blackboard,
            tokenKey,
            isHideTalent,
        }
    }

    #[inline]
    pub fn unlockCondition(&self) -> Option<clz_Torappu_CharacterData_UnlockCondition<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                    clz_Torappu_TalentData::VT_UNLOCKCONDITION,
                    None,
                )
        }
    }
    #[inline]
    pub fn requiredPotentialRank(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_TalentData::VT_REQUIREDPOTENTIALRANK, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn prefabKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TalentData::VT_PREFABKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_TalentData::VT_NAME, None)
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TalentData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn rangeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_TalentData::VT_RANGEID, None)
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(clz_Torappu_TalentData::VT_BLACKBOARD, None)
        }
    }
    #[inline]
    pub fn tokenKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TalentData::VT_TOKENKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn isHideTalent(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_TalentData::VT_ISHIDETALENT, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_TalentData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                "unlockCondition",
                Self::VT_UNLOCKCONDITION,
                false,
            )?
            .visit_field::<i32>(
                "requiredPotentialRank",
                Self::VT_REQUIREDPOTENTIALRANK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "prefabKey",
                Self::VT_PREFABKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rangeId", Self::VT_RANGEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "tokenKey",
                Self::VT_TOKENKEY,
                false,
            )?
            .visit_field::<bool>("isHideTalent", Self::VT_ISHIDETALENT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_TalentDataArgs<'a> {
    pub unlockCondition:
        Option<flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'a>>>,
    pub requiredPotentialRank: i32,
    pub prefabKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rangeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
    pub tokenKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isHideTalent: bool,
}
impl<'a> Default for clz_Torappu_TalentDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_TalentDataArgs {
            unlockCondition: None,
            requiredPotentialRank: 0,
            prefabKey: None,
            name: None,
            description: None,
            rangeId: None,
            blackboard: None,
            tokenKey: None,
            isHideTalent: false,
        }
    }
}

impl Serialize for clz_Torappu_TalentData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_TalentData", 9)?;
        if let Some(f) = self.unlockCondition() {
            s.serialize_field("unlockCondition", &f)?;
        } else {
            s.skip_field("unlockCondition")?;
        }
        s.serialize_field("requiredPotentialRank", &self.requiredPotentialRank())?;
        if let Some(f) = self.prefabKey() {
            s.serialize_field("prefabKey", &f)?;
        } else {
            s.skip_field("prefabKey")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        if let Some(f) = self.rangeId() {
            s.serialize_field("rangeId", &f)?;
        } else {
            s.skip_field("rangeId")?;
        }
        if let Some(f) = self.blackboard() {
            s.serialize_field("blackboard", &f)?;
        } else {
            s.skip_field("blackboard")?;
        }
        if let Some(f) = self.tokenKey() {
            s.serialize_field("tokenKey", &f)?;
        } else {
            s.skip_field("tokenKey")?;
        }
        s.serialize_field("isHideTalent", &self.isHideTalent())?;
        s.end()
    }
}

pub struct clz_Torappu_TalentDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_TalentDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_unlockCondition(
        &mut self,
        unlockCondition: flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                clz_Torappu_TalentData::VT_UNLOCKCONDITION,
                unlockCondition,
            );
    }
    #[inline]
    pub fn add_requiredPotentialRank(&mut self, requiredPotentialRank: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_TalentData::VT_REQUIREDPOTENTIALRANK,
            requiredPotentialRank,
            0,
        );
    }
    #[inline]
    pub fn add_prefabKey(&mut self, prefabKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TalentData::VT_PREFABKEY,
            prefabKey,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_TalentData::VT_NAME, name);
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TalentData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_rangeId(&mut self, rangeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TalentData::VT_RANGEID,
            rangeId,
        );
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TalentData::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn add_tokenKey(&mut self, tokenKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TalentData::VT_TOKENKEY,
            tokenKey,
        );
    }
    #[inline]
    pub fn add_isHideTalent(&mut self, isHideTalent: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_TalentData::VT_ISHIDETALENT, isHideTalent, false);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_TalentDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_TalentDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_TalentData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_TalentData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_TalentData");
        ds.field("unlockCondition", &self.unlockCondition());
        ds.field("requiredPotentialRank", &self.requiredPotentialRank());
        ds.field("prefabKey", &self.prefabKey());
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.field("rangeId", &self.rangeId());
        ds.field("blackboard", &self.blackboard());
        ds.field("tokenKey", &self.tokenKey());
        ds.field("isHideTalent", &self.isHideTalent());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_TalentDataT {
    pub unlockCondition: Option<Box<clz_Torappu_CharacterData_UnlockConditionT>>,
    pub requiredPotentialRank: i32,
    pub prefabKey: Option<String>,
    pub name: Option<String>,
    pub description: Option<String>,
    pub rangeId: Option<String>,
    pub blackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
    pub tokenKey: Option<String>,
    pub isHideTalent: bool,
}
impl Default for clz_Torappu_TalentDataT {
    fn default() -> Self {
        Self {
            unlockCondition: None,
            requiredPotentialRank: 0,
            prefabKey: None,
            name: None,
            description: None,
            rangeId: None,
            blackboard: None,
            tokenKey: None,
            isHideTalent: false,
        }
    }
}
impl clz_Torappu_TalentDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TalentData<'b>> {
        let unlockCondition = self.unlockCondition.as_ref().map(|x| x.pack(_fbb));
        let requiredPotentialRank = self.requiredPotentialRank;
        let prefabKey = self.prefabKey.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let rangeId = self.rangeId.as_ref().map(|x| _fbb.create_string(x));
        let blackboard = self.blackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let tokenKey = self.tokenKey.as_ref().map(|x| _fbb.create_string(x));
        let isHideTalent = self.isHideTalent;
        clz_Torappu_TalentData::create(
            _fbb,
            &clz_Torappu_TalentDataArgs {
                unlockCondition,
                requiredPotentialRank,
                prefabKey,
                name,
                description,
                rangeId,
                blackboard,
                tokenKey,
                isHideTalent,
            },
        )
    }
}
pub enum clz_Torappu_CharacterData_TalentDataBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharacterData_TalentDataBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharacterData_TalentDataBundle<'a> {
    type Inner = clz_Torappu_CharacterData_TalentDataBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharacterData_TalentDataBundle<'a> {
    pub const VT_CANDIDATES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharacterData_TalentDataBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharacterData_TalentDataBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_TalentDataBundle<'bldr>> {
        let mut builder = clz_Torappu_CharacterData_TalentDataBundleBuilder::new(_fbb);
        if let Some(x) = args.candidates {
            builder.add_candidates(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharacterData_TalentDataBundleT {
        let candidates = self
            .candidates()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_CharacterData_TalentDataBundleT { candidates }
    }

    #[inline]
    pub fn candidates(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TalentData<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TalentData>>,
            >>(
                clz_Torappu_CharacterData_TalentDataBundle::VT_CANDIDATES,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharacterData_TalentDataBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_TalentData>>,
            >>("candidates", Self::VT_CANDIDATES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharacterData_TalentDataBundleArgs<'a> {
    pub candidates: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TalentData<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_CharacterData_TalentDataBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharacterData_TalentDataBundleArgs { candidates: None }
    }
}

impl Serialize for clz_Torappu_CharacterData_TalentDataBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharacterData_TalentDataBundle", 1)?;
        if let Some(f) = self.candidates() {
            s.serialize_field("candidates", &f)?;
        } else {
            s.skip_field("candidates")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CharacterData_TalentDataBundleBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharacterData_TalentDataBundleBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_candidates(
        &mut self,
        candidates: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_TalentData<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_TalentDataBundle::VT_CANDIDATES,
            candidates,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharacterData_TalentDataBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharacterData_TalentDataBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_TalentDataBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharacterData_TalentDataBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharacterData_TalentDataBundle");
        ds.field("candidates", &self.candidates());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharacterData_TalentDataBundleT {
    pub candidates: Option<Vec<clz_Torappu_TalentDataT>>,
}
impl Default for clz_Torappu_CharacterData_TalentDataBundleT {
    fn default() -> Self {
        Self { candidates: None }
    }
}
impl clz_Torappu_CharacterData_TalentDataBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_TalentDataBundle<'b>> {
        let candidates = self.candidates.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_CharacterData_TalentDataBundle::create(
            _fbb,
            &clz_Torappu_CharacterData_TalentDataBundleArgs { candidates },
        )
    }
}
pub enum clz_Torappu_AttributeModifierData_AttributeModifierOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_AttributeModifierData_AttributeModifier<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_AttributeModifierData_AttributeModifier<'a> {
    type Inner = clz_Torappu_AttributeModifierData_AttributeModifier<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_AttributeModifierData_AttributeModifier<'a> {
    pub const VT_ATTRIBUTETYPE: flatbuffers::VOffsetT = 4;
    pub const VT_FORMULAITEM: flatbuffers::VOffsetT = 6;
    pub const VT_VALUE: flatbuffers::VOffsetT = 8;
    pub const VT_LOADFROMBLACKBOARD: flatbuffers::VOffsetT = 10;
    pub const VT_FETCHBASEVALUEFROMSOURCEENTITY: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_AttributeModifierData_AttributeModifier { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_AttributeModifierData_AttributeModifierArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_AttributeModifierData_AttributeModifier<'bldr>> {
        let mut builder = clz_Torappu_AttributeModifierData_AttributeModifierBuilder::new(_fbb);
        builder.add_value(args.value);
        builder.add_formulaItem(args.formulaItem);
        builder.add_attributeType(args.attributeType);
        builder.add_fetchBaseValueFromSourceEntity(args.fetchBaseValueFromSourceEntity);
        builder.add_loadFromBlackboard(args.loadFromBlackboard);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_AttributeModifierData_AttributeModifierT {
        let attributeType = self.attributeType();
        let formulaItem = self.formulaItem();
        let value = self.value();
        let loadFromBlackboard = self.loadFromBlackboard();
        let fetchBaseValueFromSourceEntity = self.fetchBaseValueFromSourceEntity();
        clz_Torappu_AttributeModifierData_AttributeModifierT {
            attributeType,
            formulaItem,
            value,
            loadFromBlackboard,
            fetchBaseValueFromSourceEntity,
        }
    }

    #[inline]
    pub fn attributeType(&self) -> enum__Torappu_AttributeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_AttributeType>(
                    clz_Torappu_AttributeModifierData_AttributeModifier::VT_ATTRIBUTETYPE,
                    Some(enum__Torappu_AttributeType::MAX_HP),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn formulaItem(
        &self,
    ) -> enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType>(clz_Torappu_AttributeModifierData_AttributeModifier::VT_FORMULAITEM, Some(enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType::ADDITION)).unwrap()
        }
    }
    #[inline]
    pub fn value(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_AttributeModifierData_AttributeModifier::VT_VALUE,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn loadFromBlackboard(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_AttributeModifierData_AttributeModifier::VT_LOADFROMBLACKBOARD,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn fetchBaseValueFromSourceEntity(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<bool>(clz_Torappu_AttributeModifierData_AttributeModifier::VT_FETCHBASEVALUEFROMSOURCEENTITY, Some(false)).unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_AttributeModifierData_AttributeModifier<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_AttributeType>(
                "attributeType",
                Self::VT_ATTRIBUTETYPE,
                false,
            )?
            .visit_field::<enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType>(
                "formulaItem",
                Self::VT_FORMULAITEM,
                false,
            )?
            .visit_field::<f32>("value", Self::VT_VALUE, false)?
            .visit_field::<bool>("loadFromBlackboard", Self::VT_LOADFROMBLACKBOARD, false)?
            .visit_field::<bool>(
                "fetchBaseValueFromSourceEntity",
                Self::VT_FETCHBASEVALUEFROMSOURCEENTITY,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_AttributeModifierData_AttributeModifierArgs {
    pub attributeType: enum__Torappu_AttributeType,
    pub formulaItem: enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType,
    pub value: f32,
    pub loadFromBlackboard: bool,
    pub fetchBaseValueFromSourceEntity: bool,
}
impl<'a> Default for clz_Torappu_AttributeModifierData_AttributeModifierArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_AttributeModifierData_AttributeModifierArgs {
            attributeType: enum__Torappu_AttributeType::MAX_HP,
            formulaItem:
                enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType::ADDITION,
            value: 0.0,
            loadFromBlackboard: false,
            fetchBaseValueFromSourceEntity: false,
        }
    }
}

impl Serialize for clz_Torappu_AttributeModifierData_AttributeModifier<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("clz_Torappu_AttributeModifierData_AttributeModifier", 5)?;
        s.serialize_field("attributeType", &self.attributeType())?;
        s.serialize_field("formulaItem", &self.formulaItem())?;
        s.serialize_field("value", &self.value())?;
        s.serialize_field("loadFromBlackboard", &self.loadFromBlackboard())?;
        s.serialize_field(
            "fetchBaseValueFromSourceEntity",
            &self.fetchBaseValueFromSourceEntity(),
        )?;
        s.end()
    }
}

pub struct clz_Torappu_AttributeModifierData_AttributeModifierBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_AttributeModifierData_AttributeModifierBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_attributeType(&mut self, attributeType: enum__Torappu_AttributeType) {
        self.fbb_.push_slot::<enum__Torappu_AttributeType>(
            clz_Torappu_AttributeModifierData_AttributeModifier::VT_ATTRIBUTETYPE,
            attributeType,
            enum__Torappu_AttributeType::MAX_HP,
        );
    }
    #[inline]
    pub fn add_formulaItem(
        &mut self,
        formulaItem: enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType>(
                clz_Torappu_AttributeModifierData_AttributeModifier::VT_FORMULAITEM,
                formulaItem,
                enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType::ADDITION,
            );
    }
    #[inline]
    pub fn add_value(&mut self, value: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_AttributeModifierData_AttributeModifier::VT_VALUE,
            value,
            0.0,
        );
    }
    #[inline]
    pub fn add_loadFromBlackboard(&mut self, loadFromBlackboard: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributeModifierData_AttributeModifier::VT_LOADFROMBLACKBOARD,
            loadFromBlackboard,
            false,
        );
    }
    #[inline]
    pub fn add_fetchBaseValueFromSourceEntity(&mut self, fetchBaseValueFromSourceEntity: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributeModifierData_AttributeModifier::VT_FETCHBASEVALUEFROMSOURCEENTITY,
            fetchBaseValueFromSourceEntity,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_AttributeModifierData_AttributeModifierBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_AttributeModifierData_AttributeModifierBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_AttributeModifierData_AttributeModifier<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_AttributeModifierData_AttributeModifier<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_AttributeModifierData_AttributeModifier");
        ds.field("attributeType", &self.attributeType());
        ds.field("formulaItem", &self.formulaItem());
        ds.field("value", &self.value());
        ds.field("loadFromBlackboard", &self.loadFromBlackboard());
        ds.field(
            "fetchBaseValueFromSourceEntity",
            &self.fetchBaseValueFromSourceEntity(),
        );
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_AttributeModifierData_AttributeModifierT {
    pub attributeType: enum__Torappu_AttributeType,
    pub formulaItem: enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType,
    pub value: f32,
    pub loadFromBlackboard: bool,
    pub fetchBaseValueFromSourceEntity: bool,
}
impl Default for clz_Torappu_AttributeModifierData_AttributeModifierT {
    fn default() -> Self {
        Self {
            attributeType: enum__Torappu_AttributeType::MAX_HP,
            formulaItem:
                enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType::ADDITION,
            value: 0.0,
            loadFromBlackboard: false,
            fetchBaseValueFromSourceEntity: false,
        }
    }
}
impl clz_Torappu_AttributeModifierData_AttributeModifierT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_AttributeModifierData_AttributeModifier<'b>> {
        let attributeType = self.attributeType;
        let formulaItem = self.formulaItem;
        let value = self.value;
        let loadFromBlackboard = self.loadFromBlackboard;
        let fetchBaseValueFromSourceEntity = self.fetchBaseValueFromSourceEntity;
        clz_Torappu_AttributeModifierData_AttributeModifier::create(
            _fbb,
            &clz_Torappu_AttributeModifierData_AttributeModifierArgs {
                attributeType,
                formulaItem,
                value,
                loadFromBlackboard,
                fetchBaseValueFromSourceEntity,
            },
        )
    }
}
pub enum clz_Torappu_AttributeModifierDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_AttributeModifierData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_AttributeModifierData<'a> {
    type Inner = clz_Torappu_AttributeModifierData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_AttributeModifierData<'a> {
    pub const VT_ABNORMALFLAGS: flatbuffers::VOffsetT = 4;
    pub const VT_ABNORMALIMMUNES: flatbuffers::VOffsetT = 6;
    pub const VT_ABNORMALANTIS: flatbuffers::VOffsetT = 8;
    pub const VT_ABNORMALCOMBOS: flatbuffers::VOffsetT = 10;
    pub const VT_ABNORMALCOMBOIMMUNES: flatbuffers::VOffsetT = 12;
    pub const VT_ATTRIBUTEMODIFIERS: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_AttributeModifierData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_AttributeModifierDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_AttributeModifierData<'bldr>> {
        let mut builder = clz_Torappu_AttributeModifierDataBuilder::new(_fbb);
        if let Some(x) = args.attributeModifiers {
            builder.add_attributeModifiers(x);
        }
        if let Some(x) = args.abnormalComboImmunes {
            builder.add_abnormalComboImmunes(x);
        }
        if let Some(x) = args.abnormalCombos {
            builder.add_abnormalCombos(x);
        }
        if let Some(x) = args.abnormalAntis {
            builder.add_abnormalAntis(x);
        }
        if let Some(x) = args.abnormalImmunes {
            builder.add_abnormalImmunes(x);
        }
        if let Some(x) = args.abnormalFlags {
            builder.add_abnormalFlags(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_AttributeModifierDataT {
        let abnormalFlags = self.abnormalFlags().map(|x| x.into_iter().collect());
        let abnormalImmunes = self.abnormalImmunes().map(|x| x.into_iter().collect());
        let abnormalAntis = self.abnormalAntis().map(|x| x.into_iter().collect());
        let abnormalCombos = self.abnormalCombos().map(|x| x.into_iter().collect());
        let abnormalComboImmunes = self.abnormalComboImmunes().map(|x| x.into_iter().collect());
        let attributeModifiers = self
            .attributeModifiers()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_AttributeModifierDataT {
            abnormalFlags,
            abnormalImmunes,
            abnormalAntis,
            abnormalCombos,
            abnormalComboImmunes,
            attributeModifiers,
        }
    }

    #[inline]
    pub fn abnormalFlags(&self) -> Option<flatbuffers::Vector<'a, enum__Torappu_AbnormalFlag>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_AbnormalFlag>,
            >>(clz_Torappu_AttributeModifierData::VT_ABNORMALFLAGS, None)
        }
    }
    #[inline]
    pub fn abnormalImmunes(&self) -> Option<flatbuffers::Vector<'a, enum__Torappu_AbnormalFlag>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_AbnormalFlag>,
            >>(clz_Torappu_AttributeModifierData::VT_ABNORMALIMMUNES, None)
        }
    }
    #[inline]
    pub fn abnormalAntis(&self) -> Option<flatbuffers::Vector<'a, enum__Torappu_AbnormalFlag>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_AbnormalFlag>,
            >>(clz_Torappu_AttributeModifierData::VT_ABNORMALANTIS, None)
        }
    }
    #[inline]
    pub fn abnormalCombos(&self) -> Option<flatbuffers::Vector<'a, enum__Torappu_AbnormalCombo>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_AbnormalCombo>,
            >>(clz_Torappu_AttributeModifierData::VT_ABNORMALCOMBOS, None)
        }
    }
    #[inline]
    pub fn abnormalComboImmunes(
        &self,
    ) -> Option<flatbuffers::Vector<'a, enum__Torappu_AbnormalCombo>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_AbnormalCombo>,
            >>(
                clz_Torappu_AttributeModifierData::VT_ABNORMALCOMBOIMMUNES,
                None,
            )
        }
    }
    #[inline]
    pub fn attributeModifiers(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_AttributeModifierData_AttributeModifier<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_AttributeModifierData_AttributeModifier,
                    >,
                >,
            >>(
                clz_Torappu_AttributeModifierData::VT_ATTRIBUTEMODIFIERS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_AttributeModifierData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_AbnormalFlag>>>("abnormalFlags", Self::VT_ABNORMALFLAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_AbnormalFlag>>>("abnormalImmunes", Self::VT_ABNORMALIMMUNES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_AbnormalFlag>>>("abnormalAntis", Self::VT_ABNORMALANTIS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_AbnormalCombo>>>("abnormalCombos", Self::VT_ABNORMALCOMBOS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_AbnormalCombo>>>("abnormalComboImmunes", Self::VT_ABNORMALCOMBOIMMUNES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_AttributeModifierData_AttributeModifier>>>>("attributeModifiers", Self::VT_ATTRIBUTEMODIFIERS, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_AttributeModifierDataArgs<'a> {
    pub abnormalFlags:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_AbnormalFlag>>>,
    pub abnormalImmunes:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_AbnormalFlag>>>,
    pub abnormalAntis:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_AbnormalFlag>>>,
    pub abnormalCombos:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_AbnormalCombo>>>,
    pub abnormalComboImmunes:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_AbnormalCombo>>>,
    pub attributeModifiers: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_AttributeModifierData_AttributeModifier<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_AttributeModifierDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_AttributeModifierDataArgs {
            abnormalFlags: None,
            abnormalImmunes: None,
            abnormalAntis: None,
            abnormalCombos: None,
            abnormalComboImmunes: None,
            attributeModifiers: None,
        }
    }
}

impl Serialize for clz_Torappu_AttributeModifierData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_AttributeModifierData", 6)?;
        if let Some(f) = self.abnormalFlags() {
            s.serialize_field("abnormalFlags", &f)?;
        } else {
            s.skip_field("abnormalFlags")?;
        }
        if let Some(f) = self.abnormalImmunes() {
            s.serialize_field("abnormalImmunes", &f)?;
        } else {
            s.skip_field("abnormalImmunes")?;
        }
        if let Some(f) = self.abnormalAntis() {
            s.serialize_field("abnormalAntis", &f)?;
        } else {
            s.skip_field("abnormalAntis")?;
        }
        if let Some(f) = self.abnormalCombos() {
            s.serialize_field("abnormalCombos", &f)?;
        } else {
            s.skip_field("abnormalCombos")?;
        }
        if let Some(f) = self.abnormalComboImmunes() {
            s.serialize_field("abnormalComboImmunes", &f)?;
        } else {
            s.skip_field("abnormalComboImmunes")?;
        }
        if let Some(f) = self.attributeModifiers() {
            s.serialize_field("attributeModifiers", &f)?;
        } else {
            s.skip_field("attributeModifiers")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_AttributeModifierDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_AttributeModifierDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_abnormalFlags(
        &mut self,
        abnormalFlags: flatbuffers::WIPOffset<flatbuffers::Vector<'b, enum__Torappu_AbnormalFlag>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_AttributeModifierData::VT_ABNORMALFLAGS,
            abnormalFlags,
        );
    }
    #[inline]
    pub fn add_abnormalImmunes(
        &mut self,
        abnormalImmunes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, enum__Torappu_AbnormalFlag>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_AttributeModifierData::VT_ABNORMALIMMUNES,
            abnormalImmunes,
        );
    }
    #[inline]
    pub fn add_abnormalAntis(
        &mut self,
        abnormalAntis: flatbuffers::WIPOffset<flatbuffers::Vector<'b, enum__Torappu_AbnormalFlag>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_AttributeModifierData::VT_ABNORMALANTIS,
            abnormalAntis,
        );
    }
    #[inline]
    pub fn add_abnormalCombos(
        &mut self,
        abnormalCombos: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, enum__Torappu_AbnormalCombo>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_AttributeModifierData::VT_ABNORMALCOMBOS,
            abnormalCombos,
        );
    }
    #[inline]
    pub fn add_abnormalComboImmunes(
        &mut self,
        abnormalComboImmunes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, enum__Torappu_AbnormalCombo>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_AttributeModifierData::VT_ABNORMALCOMBOIMMUNES,
            abnormalComboImmunes,
        );
    }
    #[inline]
    pub fn add_attributeModifiers(
        &mut self,
        attributeModifiers: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_AttributeModifierData_AttributeModifier<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_AttributeModifierData::VT_ATTRIBUTEMODIFIERS,
            attributeModifiers,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_AttributeModifierDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_AttributeModifierDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_AttributeModifierData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_AttributeModifierData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_AttributeModifierData");
        ds.field("abnormalFlags", &self.abnormalFlags());
        ds.field("abnormalImmunes", &self.abnormalImmunes());
        ds.field("abnormalAntis", &self.abnormalAntis());
        ds.field("abnormalCombos", &self.abnormalCombos());
        ds.field("abnormalComboImmunes", &self.abnormalComboImmunes());
        ds.field("attributeModifiers", &self.attributeModifiers());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_AttributeModifierDataT {
    pub abnormalFlags: Option<Vec<enum__Torappu_AbnormalFlag>>,
    pub abnormalImmunes: Option<Vec<enum__Torappu_AbnormalFlag>>,
    pub abnormalAntis: Option<Vec<enum__Torappu_AbnormalFlag>>,
    pub abnormalCombos: Option<Vec<enum__Torappu_AbnormalCombo>>,
    pub abnormalComboImmunes: Option<Vec<enum__Torappu_AbnormalCombo>>,
    pub attributeModifiers: Option<Vec<clz_Torappu_AttributeModifierData_AttributeModifierT>>,
}
impl Default for clz_Torappu_AttributeModifierDataT {
    fn default() -> Self {
        Self {
            abnormalFlags: None,
            abnormalImmunes: None,
            abnormalAntis: None,
            abnormalCombos: None,
            abnormalComboImmunes: None,
            attributeModifiers: None,
        }
    }
}
impl clz_Torappu_AttributeModifierDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_AttributeModifierData<'b>> {
        let abnormalFlags = self.abnormalFlags.as_ref().map(|x| _fbb.create_vector(x));
        let abnormalImmunes = self.abnormalImmunes.as_ref().map(|x| _fbb.create_vector(x));
        let abnormalAntis = self.abnormalAntis.as_ref().map(|x| _fbb.create_vector(x));
        let abnormalCombos = self.abnormalCombos.as_ref().map(|x| _fbb.create_vector(x));
        let abnormalComboImmunes = self
            .abnormalComboImmunes
            .as_ref()
            .map(|x| _fbb.create_vector(x));
        let attributeModifiers = self.attributeModifiers.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_AttributeModifierData::create(
            _fbb,
            &clz_Torappu_AttributeModifierDataArgs {
                abnormalFlags,
                abnormalImmunes,
                abnormalAntis,
                abnormalCombos,
                abnormalComboImmunes,
                attributeModifiers,
            },
        )
    }
}
pub enum clz_Torappu_ExternalBuffOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ExternalBuff<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ExternalBuff<'a> {
    type Inner = clz_Torappu_ExternalBuff<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ExternalBuff<'a> {
    pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ExternalBuff { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ExternalBuffArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ExternalBuff<'bldr>> {
        let mut builder = clz_Torappu_ExternalBuffBuilder::new(_fbb);
        if let Some(x) = args.attributes {
            builder.add_attributes(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ExternalBuffT {
        let attributes = self.attributes().map(|x| Box::new(x.unpack()));
        clz_Torappu_ExternalBuffT { attributes }
    }

    #[inline]
    pub fn attributes(&self) -> Option<clz_Torappu_AttributeModifierData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_AttributeModifierData>>(
                    clz_Torappu_ExternalBuff::VT_ATTRIBUTES,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ExternalBuff<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_AttributeModifierData>>(
                "attributes",
                Self::VT_ATTRIBUTES,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ExternalBuffArgs<'a> {
    pub attributes: Option<flatbuffers::WIPOffset<clz_Torappu_AttributeModifierData<'a>>>,
}
impl<'a> Default for clz_Torappu_ExternalBuffArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ExternalBuffArgs { attributes: None }
    }
}

impl Serialize for clz_Torappu_ExternalBuff<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ExternalBuff", 1)?;
        if let Some(f) = self.attributes() {
            s.serialize_field("attributes", &f)?;
        } else {
            s.skip_field("attributes")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ExternalBuffBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ExternalBuffBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_attributes(
        &mut self,
        attributes: flatbuffers::WIPOffset<clz_Torappu_AttributeModifierData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_AttributeModifierData>>(
                clz_Torappu_ExternalBuff::VT_ATTRIBUTES,
                attributes,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ExternalBuffBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ExternalBuffBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ExternalBuff<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ExternalBuff<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ExternalBuff");
        ds.field("attributes", &self.attributes());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ExternalBuffT {
    pub attributes: Option<Box<clz_Torappu_AttributeModifierDataT>>,
}
impl Default for clz_Torappu_ExternalBuffT {
    fn default() -> Self {
        Self { attributes: None }
    }
}
impl clz_Torappu_ExternalBuffT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ExternalBuff<'b>> {
        let attributes = self.attributes.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_ExternalBuff::create(_fbb, &clz_Torappu_ExternalBuffArgs { attributes })
    }
}
pub enum clz_Torappu_CharacterData_PotentialRankOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharacterData_PotentialRank<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharacterData_PotentialRank<'a> {
    type Inner = clz_Torappu_CharacterData_PotentialRank<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharacterData_PotentialRank<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
    pub const VT_BUFF: flatbuffers::VOffsetT = 8;
    pub const VT_EQUIVALENTCOST: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharacterData_PotentialRank { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharacterData_PotentialRankArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_PotentialRank<'bldr>> {
        let mut builder = clz_Torappu_CharacterData_PotentialRankBuilder::new(_fbb);
        if let Some(x) = args.equivalentCost {
            builder.add_equivalentCost(x);
        }
        if let Some(x) = args.buff {
            builder.add_buff(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharacterData_PotentialRankT {
        let type_ = self.type_();
        let description = self.description().map(|x| x.to_string());
        let buff = self.buff().map(|x| Box::new(x.unpack()));
        let equivalentCost = self
            .equivalentCost()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_CharacterData_PotentialRankT {
            type_,
            description,
            buff,
            equivalentCost,
        }
    }

    #[inline]
    pub fn type_(&self) -> enum__Torappu_CharacterData_PotentialRank_TypeEnum {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_CharacterData_PotentialRank_TypeEnum>(
                    clz_Torappu_CharacterData_PotentialRank::VT_TYPE_,
                    Some(enum__Torappu_CharacterData_PotentialRank_TypeEnum::BUFF),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData_PotentialRank::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn buff(&self) -> Option<clz_Torappu_ExternalBuff<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ExternalBuff>>(
                    clz_Torappu_CharacterData_PotentialRank::VT_BUFF,
                    None,
                )
        }
    }
    #[inline]
    pub fn equivalentCost(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(
                clz_Torappu_CharacterData_PotentialRank::VT_EQUIVALENTCOST,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharacterData_PotentialRank<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_CharacterData_PotentialRank_TypeEnum>(
                "type_",
                Self::VT_TYPE_,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ExternalBuff>>(
                "buff",
                Self::VT_BUFF,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("equivalentCost", Self::VT_EQUIVALENTCOST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharacterData_PotentialRankArgs<'a> {
    pub type_: enum__Torappu_CharacterData_PotentialRank_TypeEnum,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buff: Option<flatbuffers::WIPOffset<clz_Torappu_ExternalBuff<'a>>>,
    pub equivalentCost: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_CharacterData_PotentialRankArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharacterData_PotentialRankArgs {
            type_: enum__Torappu_CharacterData_PotentialRank_TypeEnum::BUFF,
            description: None,
            buff: None,
            equivalentCost: None,
        }
    }
}

impl Serialize for clz_Torappu_CharacterData_PotentialRank<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharacterData_PotentialRank", 4)?;
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        if let Some(f) = self.buff() {
            s.serialize_field("buff", &f)?;
        } else {
            s.skip_field("buff")?;
        }
        if let Some(f) = self.equivalentCost() {
            s.serialize_field("equivalentCost", &f)?;
        } else {
            s.skip_field("equivalentCost")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CharacterData_PotentialRankBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharacterData_PotentialRankBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_CharacterData_PotentialRank_TypeEnum) {
        self.fbb_
            .push_slot::<enum__Torappu_CharacterData_PotentialRank_TypeEnum>(
                clz_Torappu_CharacterData_PotentialRank::VT_TYPE_,
                type_,
                enum__Torappu_CharacterData_PotentialRank_TypeEnum::BUFF,
            );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_PotentialRank::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_buff(&mut self, buff: flatbuffers::WIPOffset<clz_Torappu_ExternalBuff<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ExternalBuff>>(
                clz_Torappu_CharacterData_PotentialRank::VT_BUFF,
                buff,
            );
    }
    #[inline]
    pub fn add_equivalentCost(
        &mut self,
        equivalentCost: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_PotentialRank::VT_EQUIVALENTCOST,
            equivalentCost,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharacterData_PotentialRankBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharacterData_PotentialRankBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_PotentialRank<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharacterData_PotentialRank<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharacterData_PotentialRank");
        ds.field("type_", &self.type_());
        ds.field("description", &self.description());
        ds.field("buff", &self.buff());
        ds.field("equivalentCost", &self.equivalentCost());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharacterData_PotentialRankT {
    pub type_: enum__Torappu_CharacterData_PotentialRank_TypeEnum,
    pub description: Option<String>,
    pub buff: Option<Box<clz_Torappu_ExternalBuffT>>,
    pub equivalentCost: Option<Vec<clz_Torappu_ItemBundleT>>,
}
impl Default for clz_Torappu_CharacterData_PotentialRankT {
    fn default() -> Self {
        Self {
            type_: enum__Torappu_CharacterData_PotentialRank_TypeEnum::BUFF,
            description: None,
            buff: None,
            equivalentCost: None,
        }
    }
}
impl clz_Torappu_CharacterData_PotentialRankT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_PotentialRank<'b>> {
        let type_ = self.type_;
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let buff = self.buff.as_ref().map(|x| x.pack(_fbb));
        let equivalentCost = self.equivalentCost.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_CharacterData_PotentialRank::create(
            _fbb,
            &clz_Torappu_CharacterData_PotentialRankArgs {
                type_,
                description,
                buff,
                equivalentCost,
            },
        )
    }
}
pub enum clz_Torappu_AttributesDeltaDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_AttributesDeltaData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_AttributesDeltaData<'a> {
    type Inner = clz_Torappu_AttributesDeltaData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_AttributesDeltaData<'a> {
    pub const VT_MAXHP: flatbuffers::VOffsetT = 4;
    pub const VT_ATK: flatbuffers::VOffsetT = 6;
    pub const VT_DEF: flatbuffers::VOffsetT = 8;
    pub const VT_MAGICRESISTANCE: flatbuffers::VOffsetT = 10;
    pub const VT_COST: flatbuffers::VOffsetT = 12;
    pub const VT_BLOCKCNT: flatbuffers::VOffsetT = 14;
    pub const VT_MOVESPEED: flatbuffers::VOffsetT = 16;
    pub const VT_ATTACKSPEED: flatbuffers::VOffsetT = 18;
    pub const VT_BASEATTACKTIME: flatbuffers::VOffsetT = 20;
    pub const VT_RESPAWNTIME: flatbuffers::VOffsetT = 22;
    pub const VT_HPRECOVERYPERSEC: flatbuffers::VOffsetT = 24;
    pub const VT_SPRECOVERYPERSEC: flatbuffers::VOffsetT = 26;
    pub const VT_MAXDEPLOYCOUNT: flatbuffers::VOffsetT = 28;
    pub const VT_MAXDECKSTACKCNT: flatbuffers::VOffsetT = 30;
    pub const VT_TAUNTLEVEL: flatbuffers::VOffsetT = 32;
    pub const VT_MASSLEVEL: flatbuffers::VOffsetT = 34;
    pub const VT_BASEFORCELEVEL: flatbuffers::VOffsetT = 36;
    pub const VT_STUNIMMUNE: flatbuffers::VOffsetT = 38;
    pub const VT_SILENCEIMMUNE: flatbuffers::VOffsetT = 40;
    pub const VT_SLEEPIMMUNE: flatbuffers::VOffsetT = 42;
    pub const VT_FROZENIMMUNE: flatbuffers::VOffsetT = 44;
    pub const VT_LEVITATEIMMUNE: flatbuffers::VOffsetT = 46;
    pub const VT_DISARMEDCOMBATIMMUNE: flatbuffers::VOffsetT = 48;
    pub const VT_FEAREDIMMUNE: flatbuffers::VOffsetT = 50;
    pub const VT_PALSYIMMUNE: flatbuffers::VOffsetT = 52;
    pub const VT_ATTRACTIMMUNE: flatbuffers::VOffsetT = 54;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_AttributesDeltaData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_AttributesDeltaDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_AttributesDeltaData<'bldr>> {
        let mut builder = clz_Torappu_AttributesDeltaDataBuilder::new(_fbb);
        builder.add_baseForceLevel(args.baseForceLevel);
        builder.add_massLevel(args.massLevel);
        builder.add_tauntLevel(args.tauntLevel);
        builder.add_maxDeckStackCnt(args.maxDeckStackCnt);
        builder.add_maxDeployCount(args.maxDeployCount);
        builder.add_spRecoveryPerSec(args.spRecoveryPerSec);
        builder.add_hpRecoveryPerSec(args.hpRecoveryPerSec);
        builder.add_respawnTime(args.respawnTime);
        builder.add_baseAttackTime(args.baseAttackTime);
        builder.add_attackSpeed(args.attackSpeed);
        builder.add_moveSpeed(args.moveSpeed);
        builder.add_blockCnt(args.blockCnt);
        builder.add_cost(args.cost);
        builder.add_magicResistance(args.magicResistance);
        builder.add_def(args.def);
        builder.add_atk(args.atk);
        builder.add_maxHp(args.maxHp);
        builder.add_attractImmune(args.attractImmune);
        builder.add_palsyImmune(args.palsyImmune);
        builder.add_fearedImmune(args.fearedImmune);
        builder.add_disarmedCombatImmune(args.disarmedCombatImmune);
        builder.add_levitateImmune(args.levitateImmune);
        builder.add_frozenImmune(args.frozenImmune);
        builder.add_sleepImmune(args.sleepImmune);
        builder.add_silenceImmune(args.silenceImmune);
        builder.add_stunImmune(args.stunImmune);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_AttributesDeltaDataT {
        let maxHp = self.maxHp();
        let atk = self.atk();
        let def = self.def();
        let magicResistance = self.magicResistance();
        let cost = self.cost();
        let blockCnt = self.blockCnt();
        let moveSpeed = self.moveSpeed();
        let attackSpeed = self.attackSpeed();
        let baseAttackTime = self.baseAttackTime();
        let respawnTime = self.respawnTime();
        let hpRecoveryPerSec = self.hpRecoveryPerSec();
        let spRecoveryPerSec = self.spRecoveryPerSec();
        let maxDeployCount = self.maxDeployCount();
        let maxDeckStackCnt = self.maxDeckStackCnt();
        let tauntLevel = self.tauntLevel();
        let massLevel = self.massLevel();
        let baseForceLevel = self.baseForceLevel();
        let stunImmune = self.stunImmune();
        let silenceImmune = self.silenceImmune();
        let sleepImmune = self.sleepImmune();
        let frozenImmune = self.frozenImmune();
        let levitateImmune = self.levitateImmune();
        let disarmedCombatImmune = self.disarmedCombatImmune();
        let fearedImmune = self.fearedImmune();
        let palsyImmune = self.palsyImmune();
        let attractImmune = self.attractImmune();
        clz_Torappu_AttributesDeltaDataT {
            maxHp,
            atk,
            def,
            magicResistance,
            cost,
            blockCnt,
            moveSpeed,
            attackSpeed,
            baseAttackTime,
            respawnTime,
            hpRecoveryPerSec,
            spRecoveryPerSec,
            maxDeployCount,
            maxDeckStackCnt,
            tauntLevel,
            massLevel,
            baseForceLevel,
            stunImmune,
            silenceImmune,
            sleepImmune,
            frozenImmune,
            levitateImmune,
            disarmedCombatImmune,
            fearedImmune,
            palsyImmune,
            attractImmune,
        }
    }

    #[inline]
    pub fn maxHp(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesDeltaData::VT_MAXHP, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn atk(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesDeltaData::VT_ATK, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn def(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesDeltaData::VT_DEF, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn magicResistance(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_AttributesDeltaData::VT_MAGICRESISTANCE,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn cost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesDeltaData::VT_COST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn blockCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesDeltaData::VT_BLOCKCNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn moveSpeed(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_AttributesDeltaData::VT_MOVESPEED, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn attackSpeed(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_AttributesDeltaData::VT_ATTACKSPEED, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn baseAttackTime(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_AttributesDeltaData::VT_BASEATTACKTIME,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn respawnTime(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesDeltaData::VT_RESPAWNTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn hpRecoveryPerSec(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_AttributesDeltaData::VT_HPRECOVERYPERSEC,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn spRecoveryPerSec(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_AttributesDeltaData::VT_SPRECOVERYPERSEC,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxDeployCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesDeltaData::VT_MAXDEPLOYCOUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn maxDeckStackCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesDeltaData::VT_MAXDECKSTACKCNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn tauntLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesDeltaData::VT_TAUNTLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn massLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesDeltaData::VT_MASSLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn baseForceLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesDeltaData::VT_BASEFORCELEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn stunImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_AttributesDeltaData::VT_STUNIMMUNE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn silenceImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_AttributesDeltaData::VT_SILENCEIMMUNE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sleepImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_AttributesDeltaData::VT_SLEEPIMMUNE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn frozenImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_AttributesDeltaData::VT_FROZENIMMUNE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn levitateImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_AttributesDeltaData::VT_LEVITATEIMMUNE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn disarmedCombatImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_AttributesDeltaData::VT_DISARMEDCOMBATIMMUNE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn fearedImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_AttributesDeltaData::VT_FEAREDIMMUNE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn palsyImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_AttributesDeltaData::VT_PALSYIMMUNE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn attractImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_AttributesDeltaData::VT_ATTRACTIMMUNE,
                    Some(false),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_AttributesDeltaData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("maxHp", Self::VT_MAXHP, false)?
            .visit_field::<i32>("atk", Self::VT_ATK, false)?
            .visit_field::<i32>("def", Self::VT_DEF, false)?
            .visit_field::<f32>("magicResistance", Self::VT_MAGICRESISTANCE, false)?
            .visit_field::<i32>("cost", Self::VT_COST, false)?
            .visit_field::<i32>("blockCnt", Self::VT_BLOCKCNT, false)?
            .visit_field::<f32>("moveSpeed", Self::VT_MOVESPEED, false)?
            .visit_field::<f32>("attackSpeed", Self::VT_ATTACKSPEED, false)?
            .visit_field::<f32>("baseAttackTime", Self::VT_BASEATTACKTIME, false)?
            .visit_field::<i32>("respawnTime", Self::VT_RESPAWNTIME, false)?
            .visit_field::<f32>("hpRecoveryPerSec", Self::VT_HPRECOVERYPERSEC, false)?
            .visit_field::<f32>("spRecoveryPerSec", Self::VT_SPRECOVERYPERSEC, false)?
            .visit_field::<i32>("maxDeployCount", Self::VT_MAXDEPLOYCOUNT, false)?
            .visit_field::<i32>("maxDeckStackCnt", Self::VT_MAXDECKSTACKCNT, false)?
            .visit_field::<i32>("tauntLevel", Self::VT_TAUNTLEVEL, false)?
            .visit_field::<i32>("massLevel", Self::VT_MASSLEVEL, false)?
            .visit_field::<i32>("baseForceLevel", Self::VT_BASEFORCELEVEL, false)?
            .visit_field::<bool>("stunImmune", Self::VT_STUNIMMUNE, false)?
            .visit_field::<bool>("silenceImmune", Self::VT_SILENCEIMMUNE, false)?
            .visit_field::<bool>("sleepImmune", Self::VT_SLEEPIMMUNE, false)?
            .visit_field::<bool>("frozenImmune", Self::VT_FROZENIMMUNE, false)?
            .visit_field::<bool>("levitateImmune", Self::VT_LEVITATEIMMUNE, false)?
            .visit_field::<bool>("disarmedCombatImmune", Self::VT_DISARMEDCOMBATIMMUNE, false)?
            .visit_field::<bool>("fearedImmune", Self::VT_FEAREDIMMUNE, false)?
            .visit_field::<bool>("palsyImmune", Self::VT_PALSYIMMUNE, false)?
            .visit_field::<bool>("attractImmune", Self::VT_ATTRACTIMMUNE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_AttributesDeltaDataArgs {
    pub maxHp: i32,
    pub atk: i32,
    pub def: i32,
    pub magicResistance: f32,
    pub cost: i32,
    pub blockCnt: i32,
    pub moveSpeed: f32,
    pub attackSpeed: f32,
    pub baseAttackTime: f32,
    pub respawnTime: i32,
    pub hpRecoveryPerSec: f32,
    pub spRecoveryPerSec: f32,
    pub maxDeployCount: i32,
    pub maxDeckStackCnt: i32,
    pub tauntLevel: i32,
    pub massLevel: i32,
    pub baseForceLevel: i32,
    pub stunImmune: bool,
    pub silenceImmune: bool,
    pub sleepImmune: bool,
    pub frozenImmune: bool,
    pub levitateImmune: bool,
    pub disarmedCombatImmune: bool,
    pub fearedImmune: bool,
    pub palsyImmune: bool,
    pub attractImmune: bool,
}
impl<'a> Default for clz_Torappu_AttributesDeltaDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_AttributesDeltaDataArgs {
            maxHp: 0,
            atk: 0,
            def: 0,
            magicResistance: 0.0,
            cost: 0,
            blockCnt: 0,
            moveSpeed: 0.0,
            attackSpeed: 0.0,
            baseAttackTime: 0.0,
            respawnTime: 0,
            hpRecoveryPerSec: 0.0,
            spRecoveryPerSec: 0.0,
            maxDeployCount: 0,
            maxDeckStackCnt: 0,
            tauntLevel: 0,
            massLevel: 0,
            baseForceLevel: 0,
            stunImmune: false,
            silenceImmune: false,
            sleepImmune: false,
            frozenImmune: false,
            levitateImmune: false,
            disarmedCombatImmune: false,
            fearedImmune: false,
            palsyImmune: false,
            attractImmune: false,
        }
    }
}

impl Serialize for clz_Torappu_AttributesDeltaData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_AttributesDeltaData", 26)?;
        s.serialize_field("maxHp", &self.maxHp())?;
        s.serialize_field("atk", &self.atk())?;
        s.serialize_field("def", &self.def())?;
        s.serialize_field("magicResistance", &self.magicResistance())?;
        s.serialize_field("cost", &self.cost())?;
        s.serialize_field("blockCnt", &self.blockCnt())?;
        s.serialize_field("moveSpeed", &self.moveSpeed())?;
        s.serialize_field("attackSpeed", &self.attackSpeed())?;
        s.serialize_field("baseAttackTime", &self.baseAttackTime())?;
        s.serialize_field("respawnTime", &self.respawnTime())?;
        s.serialize_field("hpRecoveryPerSec", &self.hpRecoveryPerSec())?;
        s.serialize_field("spRecoveryPerSec", &self.spRecoveryPerSec())?;
        s.serialize_field("maxDeployCount", &self.maxDeployCount())?;
        s.serialize_field("maxDeckStackCnt", &self.maxDeckStackCnt())?;
        s.serialize_field("tauntLevel", &self.tauntLevel())?;
        s.serialize_field("massLevel", &self.massLevel())?;
        s.serialize_field("baseForceLevel", &self.baseForceLevel())?;
        s.serialize_field("stunImmune", &self.stunImmune())?;
        s.serialize_field("silenceImmune", &self.silenceImmune())?;
        s.serialize_field("sleepImmune", &self.sleepImmune())?;
        s.serialize_field("frozenImmune", &self.frozenImmune())?;
        s.serialize_field("levitateImmune", &self.levitateImmune())?;
        s.serialize_field("disarmedCombatImmune", &self.disarmedCombatImmune())?;
        s.serialize_field("fearedImmune", &self.fearedImmune())?;
        s.serialize_field("palsyImmune", &self.palsyImmune())?;
        s.serialize_field("attractImmune", &self.attractImmune())?;
        s.end()
    }
}

pub struct clz_Torappu_AttributesDeltaDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_AttributesDeltaDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_maxHp(&mut self, maxHp: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_AttributesDeltaData::VT_MAXHP, maxHp, 0);
    }
    #[inline]
    pub fn add_atk(&mut self, atk: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_AttributesDeltaData::VT_ATK, atk, 0);
    }
    #[inline]
    pub fn add_def(&mut self, def: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_AttributesDeltaData::VT_DEF, def, 0);
    }
    #[inline]
    pub fn add_magicResistance(&mut self, magicResistance: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_AttributesDeltaData::VT_MAGICRESISTANCE,
            magicResistance,
            0.0,
        );
    }
    #[inline]
    pub fn add_cost(&mut self, cost: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_AttributesDeltaData::VT_COST, cost, 0);
    }
    #[inline]
    pub fn add_blockCnt(&mut self, blockCnt: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_AttributesDeltaData::VT_BLOCKCNT, blockCnt, 0);
    }
    #[inline]
    pub fn add_moveSpeed(&mut self, moveSpeed: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_AttributesDeltaData::VT_MOVESPEED,
            moveSpeed,
            0.0,
        );
    }
    #[inline]
    pub fn add_attackSpeed(&mut self, attackSpeed: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_AttributesDeltaData::VT_ATTACKSPEED,
            attackSpeed,
            0.0,
        );
    }
    #[inline]
    pub fn add_baseAttackTime(&mut self, baseAttackTime: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_AttributesDeltaData::VT_BASEATTACKTIME,
            baseAttackTime,
            0.0,
        );
    }
    #[inline]
    pub fn add_respawnTime(&mut self, respawnTime: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_AttributesDeltaData::VT_RESPAWNTIME,
            respawnTime,
            0,
        );
    }
    #[inline]
    pub fn add_hpRecoveryPerSec(&mut self, hpRecoveryPerSec: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_AttributesDeltaData::VT_HPRECOVERYPERSEC,
            hpRecoveryPerSec,
            0.0,
        );
    }
    #[inline]
    pub fn add_spRecoveryPerSec(&mut self, spRecoveryPerSec: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_AttributesDeltaData::VT_SPRECOVERYPERSEC,
            spRecoveryPerSec,
            0.0,
        );
    }
    #[inline]
    pub fn add_maxDeployCount(&mut self, maxDeployCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_AttributesDeltaData::VT_MAXDEPLOYCOUNT,
            maxDeployCount,
            0,
        );
    }
    #[inline]
    pub fn add_maxDeckStackCnt(&mut self, maxDeckStackCnt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_AttributesDeltaData::VT_MAXDECKSTACKCNT,
            maxDeckStackCnt,
            0,
        );
    }
    #[inline]
    pub fn add_tauntLevel(&mut self, tauntLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_AttributesDeltaData::VT_TAUNTLEVEL,
            tauntLevel,
            0,
        );
    }
    #[inline]
    pub fn add_massLevel(&mut self, massLevel: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_AttributesDeltaData::VT_MASSLEVEL, massLevel, 0);
    }
    #[inline]
    pub fn add_baseForceLevel(&mut self, baseForceLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_AttributesDeltaData::VT_BASEFORCELEVEL,
            baseForceLevel,
            0,
        );
    }
    #[inline]
    pub fn add_stunImmune(&mut self, stunImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesDeltaData::VT_STUNIMMUNE,
            stunImmune,
            false,
        );
    }
    #[inline]
    pub fn add_silenceImmune(&mut self, silenceImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesDeltaData::VT_SILENCEIMMUNE,
            silenceImmune,
            false,
        );
    }
    #[inline]
    pub fn add_sleepImmune(&mut self, sleepImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesDeltaData::VT_SLEEPIMMUNE,
            sleepImmune,
            false,
        );
    }
    #[inline]
    pub fn add_frozenImmune(&mut self, frozenImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesDeltaData::VT_FROZENIMMUNE,
            frozenImmune,
            false,
        );
    }
    #[inline]
    pub fn add_levitateImmune(&mut self, levitateImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesDeltaData::VT_LEVITATEIMMUNE,
            levitateImmune,
            false,
        );
    }
    #[inline]
    pub fn add_disarmedCombatImmune(&mut self, disarmedCombatImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesDeltaData::VT_DISARMEDCOMBATIMMUNE,
            disarmedCombatImmune,
            false,
        );
    }
    #[inline]
    pub fn add_fearedImmune(&mut self, fearedImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesDeltaData::VT_FEAREDIMMUNE,
            fearedImmune,
            false,
        );
    }
    #[inline]
    pub fn add_palsyImmune(&mut self, palsyImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesDeltaData::VT_PALSYIMMUNE,
            palsyImmune,
            false,
        );
    }
    #[inline]
    pub fn add_attractImmune(&mut self, attractImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesDeltaData::VT_ATTRACTIMMUNE,
            attractImmune,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_AttributesDeltaDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_AttributesDeltaDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_AttributesDeltaData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_AttributesDeltaData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_AttributesDeltaData");
        ds.field("maxHp", &self.maxHp());
        ds.field("atk", &self.atk());
        ds.field("def", &self.def());
        ds.field("magicResistance", &self.magicResistance());
        ds.field("cost", &self.cost());
        ds.field("blockCnt", &self.blockCnt());
        ds.field("moveSpeed", &self.moveSpeed());
        ds.field("attackSpeed", &self.attackSpeed());
        ds.field("baseAttackTime", &self.baseAttackTime());
        ds.field("respawnTime", &self.respawnTime());
        ds.field("hpRecoveryPerSec", &self.hpRecoveryPerSec());
        ds.field("spRecoveryPerSec", &self.spRecoveryPerSec());
        ds.field("maxDeployCount", &self.maxDeployCount());
        ds.field("maxDeckStackCnt", &self.maxDeckStackCnt());
        ds.field("tauntLevel", &self.tauntLevel());
        ds.field("massLevel", &self.massLevel());
        ds.field("baseForceLevel", &self.baseForceLevel());
        ds.field("stunImmune", &self.stunImmune());
        ds.field("silenceImmune", &self.silenceImmune());
        ds.field("sleepImmune", &self.sleepImmune());
        ds.field("frozenImmune", &self.frozenImmune());
        ds.field("levitateImmune", &self.levitateImmune());
        ds.field("disarmedCombatImmune", &self.disarmedCombatImmune());
        ds.field("fearedImmune", &self.fearedImmune());
        ds.field("palsyImmune", &self.palsyImmune());
        ds.field("attractImmune", &self.attractImmune());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_AttributesDeltaDataT {
    pub maxHp: i32,
    pub atk: i32,
    pub def: i32,
    pub magicResistance: f32,
    pub cost: i32,
    pub blockCnt: i32,
    pub moveSpeed: f32,
    pub attackSpeed: f32,
    pub baseAttackTime: f32,
    pub respawnTime: i32,
    pub hpRecoveryPerSec: f32,
    pub spRecoveryPerSec: f32,
    pub maxDeployCount: i32,
    pub maxDeckStackCnt: i32,
    pub tauntLevel: i32,
    pub massLevel: i32,
    pub baseForceLevel: i32,
    pub stunImmune: bool,
    pub silenceImmune: bool,
    pub sleepImmune: bool,
    pub frozenImmune: bool,
    pub levitateImmune: bool,
    pub disarmedCombatImmune: bool,
    pub fearedImmune: bool,
    pub palsyImmune: bool,
    pub attractImmune: bool,
}
impl Default for clz_Torappu_AttributesDeltaDataT {
    fn default() -> Self {
        Self {
            maxHp: 0,
            atk: 0,
            def: 0,
            magicResistance: 0.0,
            cost: 0,
            blockCnt: 0,
            moveSpeed: 0.0,
            attackSpeed: 0.0,
            baseAttackTime: 0.0,
            respawnTime: 0,
            hpRecoveryPerSec: 0.0,
            spRecoveryPerSec: 0.0,
            maxDeployCount: 0,
            maxDeckStackCnt: 0,
            tauntLevel: 0,
            massLevel: 0,
            baseForceLevel: 0,
            stunImmune: false,
            silenceImmune: false,
            sleepImmune: false,
            frozenImmune: false,
            levitateImmune: false,
            disarmedCombatImmune: false,
            fearedImmune: false,
            palsyImmune: false,
            attractImmune: false,
        }
    }
}
impl clz_Torappu_AttributesDeltaDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_AttributesDeltaData<'b>> {
        let maxHp = self.maxHp;
        let atk = self.atk;
        let def = self.def;
        let magicResistance = self.magicResistance;
        let cost = self.cost;
        let blockCnt = self.blockCnt;
        let moveSpeed = self.moveSpeed;
        let attackSpeed = self.attackSpeed;
        let baseAttackTime = self.baseAttackTime;
        let respawnTime = self.respawnTime;
        let hpRecoveryPerSec = self.hpRecoveryPerSec;
        let spRecoveryPerSec = self.spRecoveryPerSec;
        let maxDeployCount = self.maxDeployCount;
        let maxDeckStackCnt = self.maxDeckStackCnt;
        let tauntLevel = self.tauntLevel;
        let massLevel = self.massLevel;
        let baseForceLevel = self.baseForceLevel;
        let stunImmune = self.stunImmune;
        let silenceImmune = self.silenceImmune;
        let sleepImmune = self.sleepImmune;
        let frozenImmune = self.frozenImmune;
        let levitateImmune = self.levitateImmune;
        let disarmedCombatImmune = self.disarmedCombatImmune;
        let fearedImmune = self.fearedImmune;
        let palsyImmune = self.palsyImmune;
        let attractImmune = self.attractImmune;
        clz_Torappu_AttributesDeltaData::create(
            _fbb,
            &clz_Torappu_AttributesDeltaDataArgs {
                maxHp,
                atk,
                def,
                magicResistance,
                cost,
                blockCnt,
                moveSpeed,
                attackSpeed,
                baseAttackTime,
                respawnTime,
                hpRecoveryPerSec,
                spRecoveryPerSec,
                maxDeployCount,
                maxDeckStackCnt,
                tauntLevel,
                massLevel,
                baseForceLevel,
                stunImmune,
                silenceImmune,
                sleepImmune,
                frozenImmune,
                levitateImmune,
                disarmedCombatImmune,
                fearedImmune,
                palsyImmune,
                attractImmune,
            },
        )
    }
}
pub enum clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_Offset
{}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_<'a>
{
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_<'a>
{
    type Inner =
        clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_<'a> {
    pub const VT_LEVEL: flatbuffers::VOffsetT = 4;
    pub const VT_DATA: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_ {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_Args<'args>,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_<'bldr>,
    > {
        let mut builder = clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_Builder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.add_level(args.level);
        builder.finish()
    }

    pub fn unpack(
        &self,
    ) -> clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_T {
        let level = self.level();
        let data = self.data().map(|x| Box::new(x.unpack()));
        clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_T {
            level,
            data,
        }
    }

    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<i32>(clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_::VT_LEVEL, Some(0)).unwrap()
        }
    }
    #[inline]
    pub fn data(&self) -> Option<clz_Torappu_AttributesDeltaData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_AttributesDeltaData>>(clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_::VT_DATA, None)
        }
    }
}

impl flatbuffers::Verifiable
    for clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_AttributesDeltaData>>(
                "data",
                Self::VT_DATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_Args<
    'a,
> {
    pub level: i32,
    pub data: Option<flatbuffers::WIPOffset<clz_Torappu_AttributesDeltaData<'a>>>,
}
impl<'a> Default
    for clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_Args<'a>
{
    #[inline]
    fn default() -> Self {
        clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_Args {
            level: 0,
            data: None,
        }
    }
}

impl Serialize
    for clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_<'_>
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_",
            2,
        )?;
        s.serialize_field("level", &self.level())?;
        if let Some(f) = self.data() {
            s.serialize_field("data", &f)?;
        } else {
            s.skip_field("data")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_Builder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_Builder<
        'a,
        'b,
        A,
    >
{
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_.push_slot::<i32>(clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_::VT_LEVEL, level, 0);
    }
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<clz_Torappu_AttributesDeltaData<'b>>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_AttributesDeltaData>>(clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_Builder<'a, 'b, A>{
        let start = _fbb.start_table();
        clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_Builder {
      fbb_: _fbb,
      start_: start,
    }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct(
            "clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_",
        );
        ds.field("level", &self.level());
        ds.field("data", &self.data());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_T {
    pub level: i32,
    pub data: Option<Box<clz_Torappu_AttributesDeltaDataT>>,
}
impl Default
    for clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_T
{
    fn default() -> Self {
        Self {
            level: 0,
            data: None,
        }
    }
}
impl clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_T {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_<'b>,
    > {
        let level = self.level;
        let data = self.data.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_::create(_fbb, &clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_Args{
      level,
      data,
    })
    }
}
pub enum clz_Torappu_CharacterData_SkillLevelCostOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharacterData_SkillLevelCost<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharacterData_SkillLevelCost<'a> {
    type Inner = clz_Torappu_CharacterData_SkillLevelCost<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharacterData_SkillLevelCost<'a> {
    pub const VT_UNLOCKCOND: flatbuffers::VOffsetT = 4;
    pub const VT_LVLUPCOST: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharacterData_SkillLevelCost { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharacterData_SkillLevelCostArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_SkillLevelCost<'bldr>> {
        let mut builder = clz_Torappu_CharacterData_SkillLevelCostBuilder::new(_fbb);
        if let Some(x) = args.lvlUpCost {
            builder.add_lvlUpCost(x);
        }
        if let Some(x) = args.unlockCond {
            builder.add_unlockCond(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharacterData_SkillLevelCostT {
        let unlockCond = self.unlockCond().map(|x| Box::new(x.unpack()));
        let lvlUpCost = self
            .lvlUpCost()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_CharacterData_SkillLevelCostT {
            unlockCond,
            lvlUpCost,
        }
    }

    #[inline]
    pub fn unlockCond(&self) -> Option<clz_Torappu_CharacterData_UnlockCondition<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                    clz_Torappu_CharacterData_SkillLevelCost::VT_UNLOCKCOND,
                    None,
                )
        }
    }
    #[inline]
    pub fn lvlUpCost(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(clz_Torappu_CharacterData_SkillLevelCost::VT_LVLUPCOST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharacterData_SkillLevelCost<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                "unlockCond",
                Self::VT_UNLOCKCOND,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("lvlUpCost", Self::VT_LVLUPCOST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharacterData_SkillLevelCostArgs<'a> {
    pub unlockCond: Option<flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'a>>>,
    pub lvlUpCost: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_CharacterData_SkillLevelCostArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharacterData_SkillLevelCostArgs {
            unlockCond: None,
            lvlUpCost: None,
        }
    }
}

impl Serialize for clz_Torappu_CharacterData_SkillLevelCost<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharacterData_SkillLevelCost", 2)?;
        if let Some(f) = self.unlockCond() {
            s.serialize_field("unlockCond", &f)?;
        } else {
            s.skip_field("unlockCond")?;
        }
        if let Some(f) = self.lvlUpCost() {
            s.serialize_field("lvlUpCost", &f)?;
        } else {
            s.skip_field("lvlUpCost")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CharacterData_SkillLevelCostBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharacterData_SkillLevelCostBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_unlockCond(
        &mut self,
        unlockCond: flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                clz_Torappu_CharacterData_SkillLevelCost::VT_UNLOCKCOND,
                unlockCond,
            );
    }
    #[inline]
    pub fn add_lvlUpCost(
        &mut self,
        lvlUpCost: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_SkillLevelCost::VT_LVLUPCOST,
            lvlUpCost,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharacterData_SkillLevelCostBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharacterData_SkillLevelCostBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_SkillLevelCost<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharacterData_SkillLevelCost<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharacterData_SkillLevelCost");
        ds.field("unlockCond", &self.unlockCond());
        ds.field("lvlUpCost", &self.lvlUpCost());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharacterData_SkillLevelCostT {
    pub unlockCond: Option<Box<clz_Torappu_CharacterData_UnlockConditionT>>,
    pub lvlUpCost: Option<Vec<clz_Torappu_ItemBundleT>>,
}
impl Default for clz_Torappu_CharacterData_SkillLevelCostT {
    fn default() -> Self {
        Self {
            unlockCond: None,
            lvlUpCost: None,
        }
    }
}
impl clz_Torappu_CharacterData_SkillLevelCostT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_SkillLevelCost<'b>> {
        let unlockCond = self.unlockCond.as_ref().map(|x| x.pack(_fbb));
        let lvlUpCost = self.lvlUpCost.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_CharacterData_SkillLevelCost::create(
            _fbb,
            &clz_Torappu_CharacterData_SkillLevelCostArgs {
                unlockCond,
                lvlUpCost,
            },
        )
    }
}
pub enum clz_Torappu_CharacterDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharacterData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharacterData<'a> {
    type Inner = clz_Torappu_CharacterData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharacterData<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
    pub const VT_SORTINDEX: flatbuffers::VOffsetT = 8;
    pub const VT_SPTARGETTYPE: flatbuffers::VOffsetT = 10;
    pub const VT_SPTARGETID: flatbuffers::VOffsetT = 12;
    pub const VT_CANUSEGENERALPOTENTIALITEM: flatbuffers::VOffsetT = 14;
    pub const VT_CANUSEACTIVITYPOTENTIALITEM: flatbuffers::VOffsetT = 16;
    pub const VT_POTENTIALITEMID: flatbuffers::VOffsetT = 18;
    pub const VT_ACTIVITYPOTENTIALITEMID: flatbuffers::VOffsetT = 20;
    pub const VT_CLASSICPOTENTIALITEMID: flatbuffers::VOffsetT = 22;
    pub const VT_NATIONID: flatbuffers::VOffsetT = 24;
    pub const VT_GROUPID: flatbuffers::VOffsetT = 26;
    pub const VT_TEAMID: flatbuffers::VOffsetT = 28;
    pub const VT_MAINPOWER: flatbuffers::VOffsetT = 30;
    pub const VT_SUBPOWER: flatbuffers::VOffsetT = 32;
    pub const VT_DISPLAYNUMBER: flatbuffers::VOffsetT = 34;
    pub const VT_APPELLATION: flatbuffers::VOffsetT = 36;
    pub const VT_POSITION: flatbuffers::VOffsetT = 38;
    pub const VT_TAGLIST: flatbuffers::VOffsetT = 40;
    pub const VT_ITEMUSAGE: flatbuffers::VOffsetT = 42;
    pub const VT_ITEMDESC: flatbuffers::VOffsetT = 44;
    pub const VT_ITEMOBTAINAPPROACH: flatbuffers::VOffsetT = 46;
    pub const VT_ISNOTOBTAINABLE: flatbuffers::VOffsetT = 48;
    pub const VT_ISSPCHAR: flatbuffers::VOffsetT = 50;
    pub const VT_MAXPOTENTIALLEVEL: flatbuffers::VOffsetT = 52;
    pub const VT_RARITY: flatbuffers::VOffsetT = 54;
    pub const VT_PROFESSION: flatbuffers::VOffsetT = 56;
    pub const VT_SUBPROFESSIONID: flatbuffers::VOffsetT = 58;
    pub const VT_TRAIT_: flatbuffers::VOffsetT = 60;
    pub const VT_PHASES: flatbuffers::VOffsetT = 62;
    pub const VT_SKILLS: flatbuffers::VOffsetT = 64;
    pub const VT_DISPLAYTOKENDICT: flatbuffers::VOffsetT = 66;
    pub const VT_TALENTS: flatbuffers::VOffsetT = 68;
    pub const VT_POTENTIALRANKS: flatbuffers::VOffsetT = 70;
    pub const VT_FAVORKEYFRAMES: flatbuffers::VOffsetT = 72;
    pub const VT_ALLSKILLLVLUP: flatbuffers::VOffsetT = 74;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharacterData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharacterDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData<'bldr>> {
        let mut builder = clz_Torappu_CharacterDataBuilder::new(_fbb);
        if let Some(x) = args.allSkillLvlup {
            builder.add_allSkillLvlup(x);
        }
        if let Some(x) = args.favorKeyFrames {
            builder.add_favorKeyFrames(x);
        }
        if let Some(x) = args.potentialRanks {
            builder.add_potentialRanks(x);
        }
        if let Some(x) = args.talents {
            builder.add_talents(x);
        }
        if let Some(x) = args.displayTokenDict {
            builder.add_displayTokenDict(x);
        }
        if let Some(x) = args.skills {
            builder.add_skills(x);
        }
        if let Some(x) = args.phases {
            builder.add_phases(x);
        }
        if let Some(x) = args.trait_ {
            builder.add_trait_(x);
        }
        if let Some(x) = args.subProfessionId {
            builder.add_subProfessionId(x);
        }
        builder.add_profession(args.profession);
        builder.add_rarity(args.rarity);
        builder.add_maxPotentialLevel(args.maxPotentialLevel);
        if let Some(x) = args.itemObtainApproach {
            builder.add_itemObtainApproach(x);
        }
        if let Some(x) = args.itemDesc {
            builder.add_itemDesc(x);
        }
        if let Some(x) = args.itemUsage {
            builder.add_itemUsage(x);
        }
        if let Some(x) = args.tagList {
            builder.add_tagList(x);
        }
        builder.add_position(args.position);
        if let Some(x) = args.appellation {
            builder.add_appellation(x);
        }
        if let Some(x) = args.displayNumber {
            builder.add_displayNumber(x);
        }
        if let Some(x) = args.subPower {
            builder.add_subPower(x);
        }
        if let Some(x) = args.mainPower {
            builder.add_mainPower(x);
        }
        if let Some(x) = args.teamId {
            builder.add_teamId(x);
        }
        if let Some(x) = args.groupId {
            builder.add_groupId(x);
        }
        if let Some(x) = args.nationId {
            builder.add_nationId(x);
        }
        if let Some(x) = args.classicPotentialItemId {
            builder.add_classicPotentialItemId(x);
        }
        if let Some(x) = args.activityPotentialItemId {
            builder.add_activityPotentialItemId(x);
        }
        if let Some(x) = args.potentialItemId {
            builder.add_potentialItemId(x);
        }
        if let Some(x) = args.spTargetId {
            builder.add_spTargetId(x);
        }
        builder.add_spTargetType(args.spTargetType);
        builder.add_sortIndex(args.sortIndex);
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_isSpChar(args.isSpChar);
        builder.add_isNotObtainable(args.isNotObtainable);
        builder.add_canUseActivityPotentialItem(args.canUseActivityPotentialItem);
        builder.add_canUseGeneralPotentialItem(args.canUseGeneralPotentialItem);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharacterDataT {
        let name = self.name().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let sortIndex = self.sortIndex();
        let spTargetType = self.spTargetType();
        let spTargetId = self.spTargetId().map(|x| x.to_string());
        let canUseGeneralPotentialItem = self.canUseGeneralPotentialItem();
        let canUseActivityPotentialItem = self.canUseActivityPotentialItem();
        let potentialItemId = self.potentialItemId().map(|x| x.to_string());
        let activityPotentialItemId = self.activityPotentialItemId().map(|x| x.to_string());
        let classicPotentialItemId = self.classicPotentialItemId().map(|x| x.to_string());
        let nationId = self.nationId().map(|x| x.to_string());
        let groupId = self.groupId().map(|x| x.to_string());
        let teamId = self.teamId().map(|x| x.to_string());
        let mainPower = self.mainPower().map(|x| Box::new(x.unpack()));
        let subPower = self
            .subPower()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let displayNumber = self.displayNumber().map(|x| x.to_string());
        let appellation = self.appellation().map(|x| x.to_string());
        let position = self.position();
        let tagList = self
            .tagList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let itemUsage = self.itemUsage().map(|x| x.to_string());
        let itemDesc = self.itemDesc().map(|x| x.to_string());
        let itemObtainApproach = self.itemObtainApproach().map(|x| x.to_string());
        let isNotObtainable = self.isNotObtainable();
        let isSpChar = self.isSpChar();
        let maxPotentialLevel = self.maxPotentialLevel();
        let rarity = self.rarity();
        let profession = self.profession();
        let subProfessionId = self.subProfessionId().map(|x| x.to_string());
        let trait_ = self.trait_().map(|x| Box::new(x.unpack()));
        let phases = self
            .phases()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let skills = self
            .skills()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let displayTokenDict = self
            .displayTokenDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let talents = self
            .talents()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let potentialRanks = self
            .potentialRanks()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let favorKeyFrames = self
            .favorKeyFrames()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let allSkillLvlup = self
            .allSkillLvlup()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_CharacterDataT {
            name,
            description,
            sortIndex,
            spTargetType,
            spTargetId,
            canUseGeneralPotentialItem,
            canUseActivityPotentialItem,
            potentialItemId,
            activityPotentialItemId,
            classicPotentialItemId,
            nationId,
            groupId,
            teamId,
            mainPower,
            subPower,
            displayNumber,
            appellation,
            position,
            tagList,
            itemUsage,
            itemDesc,
            itemObtainApproach,
            isNotObtainable,
            isSpChar,
            maxPotentialLevel,
            rarity,
            profession,
            subProfessionId,
            trait_,
            phases,
            skills,
            displayTokenDict,
            talents,
            potentialRanks,
            favorKeyFrames,
            allSkillLvlup,
        }
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_CharacterData::VT_NAME, None)
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn sortIndex(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CharacterData::VT_SORTINDEX, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn spTargetType(&self) -> enum__Torappu_SpecialOperatorTargetType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SpecialOperatorTargetType>(
                    clz_Torappu_CharacterData::VT_SPTARGETTYPE,
                    Some(enum__Torappu_SpecialOperatorTargetType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn spTargetId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData::VT_SPTARGETID,
                None,
            )
        }
    }
    #[inline]
    pub fn canUseGeneralPotentialItem(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_CharacterData::VT_CANUSEGENERALPOTENTIALITEM,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn canUseActivityPotentialItem(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_CharacterData::VT_CANUSEACTIVITYPOTENTIALITEM,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn potentialItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData::VT_POTENTIALITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn activityPotentialItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData::VT_ACTIVITYPOTENTIALITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn classicPotentialItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData::VT_CLASSICPOTENTIALITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn nationId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData::VT_NATIONID,
                None,
            )
        }
    }
    #[inline]
    pub fn groupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData::VT_GROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn teamId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData::VT_TEAMID,
                None,
            )
        }
    }
    #[inline]
    pub fn mainPower(&self) -> Option<clz_Torappu_CharacterData_PowerData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_PowerData>>(
                    clz_Torappu_CharacterData::VT_MAINPOWER,
                    None,
                )
        }
    }
    #[inline]
    pub fn subPower(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_PowerData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_PowerData>,
                >,
            >>(clz_Torappu_CharacterData::VT_SUBPOWER, None)
        }
    }
    #[inline]
    pub fn displayNumber(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData::VT_DISPLAYNUMBER,
                None,
            )
        }
    }
    #[inline]
    pub fn appellation(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData::VT_APPELLATION,
                None,
            )
        }
    }
    #[inline]
    pub fn position(&self) -> enum__Torappu_BuildableType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildableType>(
                    clz_Torappu_CharacterData::VT_POSITION,
                    Some(enum__Torappu_BuildableType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn tagList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_CharacterData::VT_TAGLIST, None)
        }
    }
    #[inline]
    pub fn itemUsage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData::VT_ITEMUSAGE,
                None,
            )
        }
    }
    #[inline]
    pub fn itemDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData::VT_ITEMDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn itemObtainApproach(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData::VT_ITEMOBTAINAPPROACH,
                None,
            )
        }
    }
    #[inline]
    pub fn isNotObtainable(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_CharacterData::VT_ISNOTOBTAINABLE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn isSpChar(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_CharacterData::VT_ISSPCHAR, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn maxPotentialLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CharacterData::VT_MAXPOTENTIALLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn rarity(&self) -> enum__Torappu_RarityRank {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RarityRank>(
                    clz_Torappu_CharacterData::VT_RARITY,
                    Some(enum__Torappu_RarityRank::TIER_1),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn profession(&self) -> enum__Torappu_ProfessionCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ProfessionCategory>(
                    clz_Torappu_CharacterData::VT_PROFESSION,
                    Some(enum__Torappu_ProfessionCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn subProfessionId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData::VT_SUBPROFESSIONID,
                None,
            )
        }
    }
    #[inline]
    pub fn trait_(&self) -> Option<clz_Torappu_CharacterData_TraitDataBundle<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_TraitDataBundle>>(
                    clz_Torappu_CharacterData::VT_TRAIT_,
                    None,
                )
        }
    }
    #[inline]
    pub fn phases(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_PhaseData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_PhaseData>,
                >,
            >>(clz_Torappu_CharacterData::VT_PHASES, None)
        }
    }
    #[inline]
    pub fn skills(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MainSkill<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MainSkill>,
                >,
            >>(clz_Torappu_CharacterData::VT_SKILLS, None)
        }
    }
    #[inline]
    pub fn displayTokenDict(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__bool<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__bool>>,
            >>(clz_Torappu_CharacterData::VT_DISPLAYTOKENDICT, None)
        }
    }
    #[inline]
    pub fn talents(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_TalentDataBundle<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_TalentDataBundle>,
                >,
            >>(clz_Torappu_CharacterData::VT_TALENTS, None)
        }
    }
    #[inline]
    pub fn potentialRanks(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_PotentialRank<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_PotentialRank>,
                >,
            >>(clz_Torappu_CharacterData::VT_POTENTIALRANKS, None)
        }
    }
    #[inline]
    pub fn favorKeyFrames(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_<'a>>>>{
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_>>>>(clz_Torappu_CharacterData::VT_FAVORKEYFRAMES, None)
        }
    }
    #[inline]
    pub fn allSkillLvlup(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_SkillLevelCost<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_SkillLevelCost>,
                >,
            >>(clz_Torappu_CharacterData::VT_ALLSKILLLVLUP, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharacterData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<i32>("sortIndex", Self::VT_SORTINDEX, false)?
     .visit_field::<enum__Torappu_SpecialOperatorTargetType>("spTargetType", Self::VT_SPTARGETTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("spTargetId", Self::VT_SPTARGETID, false)?
     .visit_field::<bool>("canUseGeneralPotentialItem", Self::VT_CANUSEGENERALPOTENTIALITEM, false)?
     .visit_field::<bool>("canUseActivityPotentialItem", Self::VT_CANUSEACTIVITYPOTENTIALITEM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("potentialItemId", Self::VT_POTENTIALITEMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("activityPotentialItemId", Self::VT_ACTIVITYPOTENTIALITEMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classicPotentialItemId", Self::VT_CLASSICPOTENTIALITEMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nationId", Self::VT_NATIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("groupId", Self::VT_GROUPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("teamId", Self::VT_TEAMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_PowerData>>("mainPower", Self::VT_MAINPOWER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_PowerData>>>>("subPower", Self::VT_SUBPOWER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("displayNumber", Self::VT_DISPLAYNUMBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("appellation", Self::VT_APPELLATION, false)?
     .visit_field::<enum__Torappu_BuildableType>("position", Self::VT_POSITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("tagList", Self::VT_TAGLIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemUsage", Self::VT_ITEMUSAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemDesc", Self::VT_ITEMDESC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemObtainApproach", Self::VT_ITEMOBTAINAPPROACH, false)?
     .visit_field::<bool>("isNotObtainable", Self::VT_ISNOTOBTAINABLE, false)?
     .visit_field::<bool>("isSpChar", Self::VT_ISSPCHAR, false)?
     .visit_field::<i32>("maxPotentialLevel", Self::VT_MAXPOTENTIALLEVEL, false)?
     .visit_field::<enum__Torappu_RarityRank>("rarity", Self::VT_RARITY, false)?
     .visit_field::<enum__Torappu_ProfessionCategory>("profession", Self::VT_PROFESSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("subProfessionId", Self::VT_SUBPROFESSIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_TraitDataBundle>>("trait_", Self::VT_TRAIT_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_PhaseData>>>>("phases", Self::VT_PHASES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MainSkill>>>>("skills", Self::VT_SKILLS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__bool>>>>("displayTokenDict", Self::VT_DISPLAYTOKENDICT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_TalentDataBundle>>>>("talents", Self::VT_TALENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_PotentialRank>>>>("potentialRanks", Self::VT_POTENTIALRANKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_>>>>("favorKeyFrames", Self::VT_FAVORKEYFRAMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_SkillLevelCost>>>>("allSkillLvlup", Self::VT_ALLSKILLLVLUP, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharacterDataArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortIndex: i32,
    pub spTargetType: enum__Torappu_SpecialOperatorTargetType,
    pub spTargetId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub canUseGeneralPotentialItem: bool,
    pub canUseActivityPotentialItem: bool,
    pub potentialItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub activityPotentialItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classicPotentialItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nationId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub groupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teamId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mainPower: Option<flatbuffers::WIPOffset<clz_Torappu_CharacterData_PowerData<'a>>>,
    pub subPower: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_PowerData<'a>>>>>,
    pub displayNumber: Option<flatbuffers::WIPOffset<&'a str>>,
    pub appellation: Option<flatbuffers::WIPOffset<&'a str>>,
    pub position: enum__Torappu_BuildableType,
    pub tagList: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub itemUsage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemObtainApproach: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isNotObtainable: bool,
    pub isSpChar: bool,
    pub maxPotentialLevel: i32,
    pub rarity: enum__Torappu_RarityRank,
    pub profession: enum__Torappu_ProfessionCategory,
    pub subProfessionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trait_: Option<flatbuffers::WIPOffset<clz_Torappu_CharacterData_TraitDataBundle<'a>>>,
    pub phases: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_PhaseData<'a>>>>>,
    pub skills: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MainSkill<'a>>>>>,
    pub displayTokenDict: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__bool<'a>>>>>,
    pub talents: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_TalentDataBundle<'a>>>>>,
    pub potentialRanks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_PotentialRank<'a>>>>>,
    pub favorKeyFrames: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_<'a>>>>>,
    pub allSkillLvlup: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_SkillLevelCost<'a>>>>>,
}
impl<'a> Default for clz_Torappu_CharacterDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharacterDataArgs {
            name: None,
            description: None,
            sortIndex: 0,
            spTargetType: enum__Torappu_SpecialOperatorTargetType::NONE,
            spTargetId: None,
            canUseGeneralPotentialItem: false,
            canUseActivityPotentialItem: false,
            potentialItemId: None,
            activityPotentialItemId: None,
            classicPotentialItemId: None,
            nationId: None,
            groupId: None,
            teamId: None,
            mainPower: None,
            subPower: None,
            displayNumber: None,
            appellation: None,
            position: enum__Torappu_BuildableType::NONE,
            tagList: None,
            itemUsage: None,
            itemDesc: None,
            itemObtainApproach: None,
            isNotObtainable: false,
            isSpChar: false,
            maxPotentialLevel: 0,
            rarity: enum__Torappu_RarityRank::TIER_1,
            profession: enum__Torappu_ProfessionCategory::NONE,
            subProfessionId: None,
            trait_: None,
            phases: None,
            skills: None,
            displayTokenDict: None,
            talents: None,
            potentialRanks: None,
            favorKeyFrames: None,
            allSkillLvlup: None,
        }
    }
}

impl Serialize for clz_Torappu_CharacterData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharacterData", 36)?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        s.serialize_field("sortIndex", &self.sortIndex())?;
        s.serialize_field("spTargetType", &self.spTargetType())?;
        if let Some(f) = self.spTargetId() {
            s.serialize_field("spTargetId", &f)?;
        } else {
            s.skip_field("spTargetId")?;
        }
        s.serialize_field(
            "canUseGeneralPotentialItem",
            &self.canUseGeneralPotentialItem(),
        )?;
        s.serialize_field(
            "canUseActivityPotentialItem",
            &self.canUseActivityPotentialItem(),
        )?;
        if let Some(f) = self.potentialItemId() {
            s.serialize_field("potentialItemId", &f)?;
        } else {
            s.skip_field("potentialItemId")?;
        }
        if let Some(f) = self.activityPotentialItemId() {
            s.serialize_field("activityPotentialItemId", &f)?;
        } else {
            s.skip_field("activityPotentialItemId")?;
        }
        if let Some(f) = self.classicPotentialItemId() {
            s.serialize_field("classicPotentialItemId", &f)?;
        } else {
            s.skip_field("classicPotentialItemId")?;
        }
        if let Some(f) = self.nationId() {
            s.serialize_field("nationId", &f)?;
        } else {
            s.skip_field("nationId")?;
        }
        if let Some(f) = self.groupId() {
            s.serialize_field("groupId", &f)?;
        } else {
            s.skip_field("groupId")?;
        }
        if let Some(f) = self.teamId() {
            s.serialize_field("teamId", &f)?;
        } else {
            s.skip_field("teamId")?;
        }
        if let Some(f) = self.mainPower() {
            s.serialize_field("mainPower", &f)?;
        } else {
            s.skip_field("mainPower")?;
        }
        if let Some(f) = self.subPower() {
            s.serialize_field("subPower", &f)?;
        } else {
            s.skip_field("subPower")?;
        }
        if let Some(f) = self.displayNumber() {
            s.serialize_field("displayNumber", &f)?;
        } else {
            s.skip_field("displayNumber")?;
        }
        if let Some(f) = self.appellation() {
            s.serialize_field("appellation", &f)?;
        } else {
            s.skip_field("appellation")?;
        }
        s.serialize_field("position", &self.position())?;
        if let Some(f) = self.tagList() {
            s.serialize_field("tagList", &f)?;
        } else {
            s.skip_field("tagList")?;
        }
        if let Some(f) = self.itemUsage() {
            s.serialize_field("itemUsage", &f)?;
        } else {
            s.skip_field("itemUsage")?;
        }
        if let Some(f) = self.itemDesc() {
            s.serialize_field("itemDesc", &f)?;
        } else {
            s.skip_field("itemDesc")?;
        }
        if let Some(f) = self.itemObtainApproach() {
            s.serialize_field("itemObtainApproach", &f)?;
        } else {
            s.skip_field("itemObtainApproach")?;
        }
        s.serialize_field("isNotObtainable", &self.isNotObtainable())?;
        s.serialize_field("isSpChar", &self.isSpChar())?;
        s.serialize_field("maxPotentialLevel", &self.maxPotentialLevel())?;
        s.serialize_field("rarity", &self.rarity())?;
        s.serialize_field("profession", &self.profession())?;
        if let Some(f) = self.subProfessionId() {
            s.serialize_field("subProfessionId", &f)?;
        } else {
            s.skip_field("subProfessionId")?;
        }
        if let Some(f) = self.trait_() {
            s.serialize_field("trait_", &f)?;
        } else {
            s.skip_field("trait_")?;
        }
        if let Some(f) = self.phases() {
            s.serialize_field("phases", &f)?;
        } else {
            s.skip_field("phases")?;
        }
        if let Some(f) = self.skills() {
            s.serialize_field("skills", &f)?;
        } else {
            s.skip_field("skills")?;
        }
        if let Some(f) = self.displayTokenDict() {
            s.serialize_field("displayTokenDict", &f)?;
        } else {
            s.skip_field("displayTokenDict")?;
        }
        if let Some(f) = self.talents() {
            s.serialize_field("talents", &f)?;
        } else {
            s.skip_field("talents")?;
        }
        if let Some(f) = self.potentialRanks() {
            s.serialize_field("potentialRanks", &f)?;
        } else {
            s.skip_field("potentialRanks")?;
        }
        if let Some(f) = self.favorKeyFrames() {
            s.serialize_field("favorKeyFrames", &f)?;
        } else {
            s.skip_field("favorKeyFrames")?;
        }
        if let Some(f) = self.allSkillLvlup() {
            s.serialize_field("allSkillLvlup", &f)?;
        } else {
            s.skip_field("allSkillLvlup")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CharacterDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_CharacterDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_sortIndex(&mut self, sortIndex: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_CharacterData::VT_SORTINDEX, sortIndex, 0);
    }
    #[inline]
    pub fn add_spTargetType(&mut self, spTargetType: enum__Torappu_SpecialOperatorTargetType) {
        self.fbb_
            .push_slot::<enum__Torappu_SpecialOperatorTargetType>(
                clz_Torappu_CharacterData::VT_SPTARGETTYPE,
                spTargetType,
                enum__Torappu_SpecialOperatorTargetType::NONE,
            );
    }
    #[inline]
    pub fn add_spTargetId(&mut self, spTargetId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_SPTARGETID,
            spTargetId,
        );
    }
    #[inline]
    pub fn add_canUseGeneralPotentialItem(&mut self, canUseGeneralPotentialItem: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_CharacterData::VT_CANUSEGENERALPOTENTIALITEM,
            canUseGeneralPotentialItem,
            false,
        );
    }
    #[inline]
    pub fn add_canUseActivityPotentialItem(&mut self, canUseActivityPotentialItem: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_CharacterData::VT_CANUSEACTIVITYPOTENTIALITEM,
            canUseActivityPotentialItem,
            false,
        );
    }
    #[inline]
    pub fn add_potentialItemId(&mut self, potentialItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_POTENTIALITEMID,
            potentialItemId,
        );
    }
    #[inline]
    pub fn add_activityPotentialItemId(
        &mut self,
        activityPotentialItemId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_ACTIVITYPOTENTIALITEMID,
            activityPotentialItemId,
        );
    }
    #[inline]
    pub fn add_classicPotentialItemId(
        &mut self,
        classicPotentialItemId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_CLASSICPOTENTIALITEMID,
            classicPotentialItemId,
        );
    }
    #[inline]
    pub fn add_nationId(&mut self, nationId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_NATIONID,
            nationId,
        );
    }
    #[inline]
    pub fn add_groupId(&mut self, groupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_GROUPID,
            groupId,
        );
    }
    #[inline]
    pub fn add_teamId(&mut self, teamId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_TEAMID,
            teamId,
        );
    }
    #[inline]
    pub fn add_mainPower(
        &mut self,
        mainPower: flatbuffers::WIPOffset<clz_Torappu_CharacterData_PowerData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharacterData_PowerData>>(
                clz_Torappu_CharacterData::VT_MAINPOWER,
                mainPower,
            );
    }
    #[inline]
    pub fn add_subPower(
        &mut self,
        subPower: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_PowerData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_SUBPOWER,
            subPower,
        );
    }
    #[inline]
    pub fn add_displayNumber(&mut self, displayNumber: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_DISPLAYNUMBER,
            displayNumber,
        );
    }
    #[inline]
    pub fn add_appellation(&mut self, appellation: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_APPELLATION,
            appellation,
        );
    }
    #[inline]
    pub fn add_position(&mut self, position: enum__Torappu_BuildableType) {
        self.fbb_.push_slot::<enum__Torappu_BuildableType>(
            clz_Torappu_CharacterData::VT_POSITION,
            position,
            enum__Torappu_BuildableType::NONE,
        );
    }
    #[inline]
    pub fn add_tagList(
        &mut self,
        tagList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_TAGLIST,
            tagList,
        );
    }
    #[inline]
    pub fn add_itemUsage(&mut self, itemUsage: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_ITEMUSAGE,
            itemUsage,
        );
    }
    #[inline]
    pub fn add_itemDesc(&mut self, itemDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_ITEMDESC,
            itemDesc,
        );
    }
    #[inline]
    pub fn add_itemObtainApproach(&mut self, itemObtainApproach: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_ITEMOBTAINAPPROACH,
            itemObtainApproach,
        );
    }
    #[inline]
    pub fn add_isNotObtainable(&mut self, isNotObtainable: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_CharacterData::VT_ISNOTOBTAINABLE,
            isNotObtainable,
            false,
        );
    }
    #[inline]
    pub fn add_isSpChar(&mut self, isSpChar: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_CharacterData::VT_ISSPCHAR, isSpChar, false);
    }
    #[inline]
    pub fn add_maxPotentialLevel(&mut self, maxPotentialLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_CharacterData::VT_MAXPOTENTIALLEVEL,
            maxPotentialLevel,
            0,
        );
    }
    #[inline]
    pub fn add_rarity(&mut self, rarity: enum__Torappu_RarityRank) {
        self.fbb_.push_slot::<enum__Torappu_RarityRank>(
            clz_Torappu_CharacterData::VT_RARITY,
            rarity,
            enum__Torappu_RarityRank::TIER_1,
        );
    }
    #[inline]
    pub fn add_profession(&mut self, profession: enum__Torappu_ProfessionCategory) {
        self.fbb_.push_slot::<enum__Torappu_ProfessionCategory>(
            clz_Torappu_CharacterData::VT_PROFESSION,
            profession,
            enum__Torappu_ProfessionCategory::NONE,
        );
    }
    #[inline]
    pub fn add_subProfessionId(&mut self, subProfessionId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_SUBPROFESSIONID,
            subProfessionId,
        );
    }
    #[inline]
    pub fn add_trait_(
        &mut self,
        trait_: flatbuffers::WIPOffset<clz_Torappu_CharacterData_TraitDataBundle<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharacterData_TraitDataBundle>>(
                clz_Torappu_CharacterData::VT_TRAIT_,
                trait_,
            );
    }
    #[inline]
    pub fn add_phases(
        &mut self,
        phases: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_PhaseData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_PHASES,
            phases,
        );
    }
    #[inline]
    pub fn add_skills(
        &mut self,
        skills: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MainSkill<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_SKILLS,
            skills,
        );
    }
    #[inline]
    pub fn add_displayTokenDict(
        &mut self,
        displayTokenDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__bool<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_DISPLAYTOKENDICT,
            displayTokenDict,
        );
    }
    #[inline]
    pub fn add_talents(
        &mut self,
        talents: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_TalentDataBundle<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_TALENTS,
            talents,
        );
    }
    #[inline]
    pub fn add_potentialRanks(
        &mut self,
        potentialRanks: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_PotentialRank<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_POTENTIALRANKS,
            potentialRanks,
        );
    }
    #[inline]
    pub fn add_favorKeyFrames(
        &mut self,
        favorKeyFrames: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_<'b >>>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_FAVORKEYFRAMES,
            favorKeyFrames,
        );
    }
    #[inline]
    pub fn add_allSkillLvlup(
        &mut self,
        allSkillLvlup: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_SkillLevelCost<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData::VT_ALLSKILLLVLUP,
            allSkillLvlup,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharacterDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharacterDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharacterData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharacterData");
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.field("sortIndex", &self.sortIndex());
        ds.field("spTargetType", &self.spTargetType());
        ds.field("spTargetId", &self.spTargetId());
        ds.field(
            "canUseGeneralPotentialItem",
            &self.canUseGeneralPotentialItem(),
        );
        ds.field(
            "canUseActivityPotentialItem",
            &self.canUseActivityPotentialItem(),
        );
        ds.field("potentialItemId", &self.potentialItemId());
        ds.field("activityPotentialItemId", &self.activityPotentialItemId());
        ds.field("classicPotentialItemId", &self.classicPotentialItemId());
        ds.field("nationId", &self.nationId());
        ds.field("groupId", &self.groupId());
        ds.field("teamId", &self.teamId());
        ds.field("mainPower", &self.mainPower());
        ds.field("subPower", &self.subPower());
        ds.field("displayNumber", &self.displayNumber());
        ds.field("appellation", &self.appellation());
        ds.field("position", &self.position());
        ds.field("tagList", &self.tagList());
        ds.field("itemUsage", &self.itemUsage());
        ds.field("itemDesc", &self.itemDesc());
        ds.field("itemObtainApproach", &self.itemObtainApproach());
        ds.field("isNotObtainable", &self.isNotObtainable());
        ds.field("isSpChar", &self.isSpChar());
        ds.field("maxPotentialLevel", &self.maxPotentialLevel());
        ds.field("rarity", &self.rarity());
        ds.field("profession", &self.profession());
        ds.field("subProfessionId", &self.subProfessionId());
        ds.field("trait_", &self.trait_());
        ds.field("phases", &self.phases());
        ds.field("skills", &self.skills());
        ds.field("displayTokenDict", &self.displayTokenDict());
        ds.field("talents", &self.talents());
        ds.field("potentialRanks", &self.potentialRanks());
        ds.field("favorKeyFrames", &self.favorKeyFrames());
        ds.field("allSkillLvlup", &self.allSkillLvlup());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharacterDataT {
    pub name: Option<String>,
    pub description: Option<String>,
    pub sortIndex: i32,
    pub spTargetType: enum__Torappu_SpecialOperatorTargetType,
    pub spTargetId: Option<String>,
    pub canUseGeneralPotentialItem: bool,
    pub canUseActivityPotentialItem: bool,
    pub potentialItemId: Option<String>,
    pub activityPotentialItemId: Option<String>,
    pub classicPotentialItemId: Option<String>,
    pub nationId: Option<String>,
    pub groupId: Option<String>,
    pub teamId: Option<String>,
    pub mainPower: Option<Box<clz_Torappu_CharacterData_PowerDataT>>,
    pub subPower: Option<Vec<clz_Torappu_CharacterData_PowerDataT>>,
    pub displayNumber: Option<String>,
    pub appellation: Option<String>,
    pub position: enum__Torappu_BuildableType,
    pub tagList: Option<Vec<String>>,
    pub itemUsage: Option<String>,
    pub itemDesc: Option<String>,
    pub itemObtainApproach: Option<String>,
    pub isNotObtainable: bool,
    pub isSpChar: bool,
    pub maxPotentialLevel: i32,
    pub rarity: enum__Torappu_RarityRank,
    pub profession: enum__Torappu_ProfessionCategory,
    pub subProfessionId: Option<String>,
    pub trait_: Option<Box<clz_Torappu_CharacterData_TraitDataBundleT>>,
    pub phases: Option<Vec<clz_Torappu_CharacterData_PhaseDataT>>,
    pub skills: Option<Vec<clz_Torappu_CharacterData_MainSkillT>>,
    pub displayTokenDict: Option<Vec<dict__string__boolT>>,
    pub talents: Option<Vec<clz_Torappu_CharacterData_TalentDataBundleT>>,
    pub potentialRanks: Option<Vec<clz_Torappu_CharacterData_PotentialRankT>>,
    pub favorKeyFrames: Option<
        Vec<clz_Torappu_KeyFrames_2_KeyFrame_Torappu_AttributesDeltaData_Torappu_AttributesData_T>,
    >,
    pub allSkillLvlup: Option<Vec<clz_Torappu_CharacterData_SkillLevelCostT>>,
}
impl Default for clz_Torappu_CharacterDataT {
    fn default() -> Self {
        Self {
            name: None,
            description: None,
            sortIndex: 0,
            spTargetType: enum__Torappu_SpecialOperatorTargetType::NONE,
            spTargetId: None,
            canUseGeneralPotentialItem: false,
            canUseActivityPotentialItem: false,
            potentialItemId: None,
            activityPotentialItemId: None,
            classicPotentialItemId: None,
            nationId: None,
            groupId: None,
            teamId: None,
            mainPower: None,
            subPower: None,
            displayNumber: None,
            appellation: None,
            position: enum__Torappu_BuildableType::NONE,
            tagList: None,
            itemUsage: None,
            itemDesc: None,
            itemObtainApproach: None,
            isNotObtainable: false,
            isSpChar: false,
            maxPotentialLevel: 0,
            rarity: enum__Torappu_RarityRank::TIER_1,
            profession: enum__Torappu_ProfessionCategory::NONE,
            subProfessionId: None,
            trait_: None,
            phases: None,
            skills: None,
            displayTokenDict: None,
            talents: None,
            potentialRanks: None,
            favorKeyFrames: None,
            allSkillLvlup: None,
        }
    }
}
impl clz_Torappu_CharacterDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData<'b>> {
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let sortIndex = self.sortIndex;
        let spTargetType = self.spTargetType;
        let spTargetId = self.spTargetId.as_ref().map(|x| _fbb.create_string(x));
        let canUseGeneralPotentialItem = self.canUseGeneralPotentialItem;
        let canUseActivityPotentialItem = self.canUseActivityPotentialItem;
        let potentialItemId = self.potentialItemId.as_ref().map(|x| _fbb.create_string(x));
        let activityPotentialItemId = self
            .activityPotentialItemId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let classicPotentialItemId = self
            .classicPotentialItemId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let nationId = self.nationId.as_ref().map(|x| _fbb.create_string(x));
        let groupId = self.groupId.as_ref().map(|x| _fbb.create_string(x));
        let teamId = self.teamId.as_ref().map(|x| _fbb.create_string(x));
        let mainPower = self.mainPower.as_ref().map(|x| x.pack(_fbb));
        let subPower = self.subPower.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let displayNumber = self.displayNumber.as_ref().map(|x| _fbb.create_string(x));
        let appellation = self.appellation.as_ref().map(|x| _fbb.create_string(x));
        let position = self.position;
        let tagList = self.tagList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let itemUsage = self.itemUsage.as_ref().map(|x| _fbb.create_string(x));
        let itemDesc = self.itemDesc.as_ref().map(|x| _fbb.create_string(x));
        let itemObtainApproach = self
            .itemObtainApproach
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let isNotObtainable = self.isNotObtainable;
        let isSpChar = self.isSpChar;
        let maxPotentialLevel = self.maxPotentialLevel;
        let rarity = self.rarity;
        let profession = self.profession;
        let subProfessionId = self.subProfessionId.as_ref().map(|x| _fbb.create_string(x));
        let trait_ = self.trait_.as_ref().map(|x| x.pack(_fbb));
        let phases = self.phases.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let skills = self.skills.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let displayTokenDict = self.displayTokenDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let talents = self.talents.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let potentialRanks = self.potentialRanks.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let favorKeyFrames = self.favorKeyFrames.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let allSkillLvlup = self.allSkillLvlup.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_CharacterData::create(
            _fbb,
            &clz_Torappu_CharacterDataArgs {
                name,
                description,
                sortIndex,
                spTargetType,
                spTargetId,
                canUseGeneralPotentialItem,
                canUseActivityPotentialItem,
                potentialItemId,
                activityPotentialItemId,
                classicPotentialItemId,
                nationId,
                groupId,
                teamId,
                mainPower,
                subPower,
                displayNumber,
                appellation,
                position,
                tagList,
                itemUsage,
                itemDesc,
                itemObtainApproach,
                isNotObtainable,
                isSpChar,
                maxPotentialLevel,
                rarity,
                profession,
                subProfessionId,
                trait_,
                phases,
                skills,
                displayTokenDict,
                talents,
                potentialRanks,
                favorKeyFrames,
                allSkillLvlup,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_CharacterDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_CharacterData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_CharacterData<'a> {
    type Inner = dict__string__clz_Torappu_CharacterData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_CharacterData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_CharacterData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_CharacterDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharacterData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_CharacterDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_CharacterDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_CharacterDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_CharacterData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_CharacterData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_CharacterData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData>>(
                    dict__string__clz_Torappu_CharacterData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_CharacterData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_CharacterDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_CharacterData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_CharacterDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_CharacterDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_CharacterData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_CharacterData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_CharacterDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_CharacterDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_CharacterData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_CharacterData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharacterData>>(
                dict__string__clz_Torappu_CharacterData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_CharacterDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_CharacterDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharacterData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_CharacterData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_CharacterData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_CharacterData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_CharacterDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_CharacterDataT>>,
}
impl Default for dict__string__clz_Torappu_CharacterDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_CharacterDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharacterData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_CharacterData::create(
            _fbb,
            &dict__string__clz_Torappu_CharacterDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_CharPatchData_UnlockCond_ItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharPatchData_UnlockCond_Item<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharPatchData_UnlockCond_Item<'a> {
    type Inner = clz_Torappu_CharPatchData_UnlockCond_Item<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharPatchData_UnlockCond_Item<'a> {
    pub const VT_STAGEID: flatbuffers::VOffsetT = 4;
    pub const VT_COMPLETESTATE: flatbuffers::VOffsetT = 6;
    pub const VT_UNLOCKTS: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharPatchData_UnlockCond_Item { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharPatchData_UnlockCond_ItemArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharPatchData_UnlockCond_Item<'bldr>> {
        let mut builder = clz_Torappu_CharPatchData_UnlockCond_ItemBuilder::new(_fbb);
        builder.add_unlockTs(args.unlockTs);
        builder.add_completeState(args.completeState);
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharPatchData_UnlockCond_ItemT {
        let stageId = self.stageId().map(|x| x.to_string());
        let completeState = self.completeState();
        let unlockTs = self.unlockTs();
        clz_Torappu_CharPatchData_UnlockCond_ItemT {
            stageId,
            completeState,
            unlockTs,
        }
    }

    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharPatchData_UnlockCond_Item::VT_STAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn completeState(&self) -> enum__Torappu_PlayerBattleRank {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_PlayerBattleRank>(
                    clz_Torappu_CharPatchData_UnlockCond_Item::VT_COMPLETESTATE,
                    Some(enum__Torappu_PlayerBattleRank::ERR_ZERO),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_CharPatchData_UnlockCond_Item::VT_UNLOCKTS,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharPatchData_UnlockCond_Item<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .visit_field::<enum__Torappu_PlayerBattleRank>(
                "completeState",
                Self::VT_COMPLETESTATE,
                false,
            )?
            .visit_field::<i64>("unlockTs", Self::VT_UNLOCKTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharPatchData_UnlockCond_ItemArgs<'a> {
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub completeState: enum__Torappu_PlayerBattleRank,
    pub unlockTs: i64,
}
impl<'a> Default for clz_Torappu_CharPatchData_UnlockCond_ItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharPatchData_UnlockCond_ItemArgs {
            stageId: None,
            completeState: enum__Torappu_PlayerBattleRank::ERR_ZERO,
            unlockTs: 0,
        }
    }
}

impl Serialize for clz_Torappu_CharPatchData_UnlockCond_Item<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharPatchData_UnlockCond_Item", 3)?;
        if let Some(f) = self.stageId() {
            s.serialize_field("stageId", &f)?;
        } else {
            s.skip_field("stageId")?;
        }
        s.serialize_field("completeState", &self.completeState())?;
        s.serialize_field("unlockTs", &self.unlockTs())?;
        s.end()
    }
}

pub struct clz_Torappu_CharPatchData_UnlockCond_ItemBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharPatchData_UnlockCond_ItemBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharPatchData_UnlockCond_Item::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn add_completeState(&mut self, completeState: enum__Torappu_PlayerBattleRank) {
        self.fbb_.push_slot::<enum__Torappu_PlayerBattleRank>(
            clz_Torappu_CharPatchData_UnlockCond_Item::VT_COMPLETESTATE,
            completeState,
            enum__Torappu_PlayerBattleRank::ERR_ZERO,
        );
    }
    #[inline]
    pub fn add_unlockTs(&mut self, unlockTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_CharPatchData_UnlockCond_Item::VT_UNLOCKTS,
            unlockTs,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharPatchData_UnlockCond_ItemBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharPatchData_UnlockCond_ItemBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharPatchData_UnlockCond_Item<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharPatchData_UnlockCond_Item<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharPatchData_UnlockCond_Item");
        ds.field("stageId", &self.stageId());
        ds.field("completeState", &self.completeState());
        ds.field("unlockTs", &self.unlockTs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharPatchData_UnlockCond_ItemT {
    pub stageId: Option<String>,
    pub completeState: enum__Torappu_PlayerBattleRank,
    pub unlockTs: i64,
}
impl Default for clz_Torappu_CharPatchData_UnlockCond_ItemT {
    fn default() -> Self {
        Self {
            stageId: None,
            completeState: enum__Torappu_PlayerBattleRank::ERR_ZERO,
            unlockTs: 0,
        }
    }
}
impl clz_Torappu_CharPatchData_UnlockCond_ItemT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharPatchData_UnlockCond_Item<'b>> {
        let stageId = self.stageId.as_ref().map(|x| _fbb.create_string(x));
        let completeState = self.completeState;
        let unlockTs = self.unlockTs;
        clz_Torappu_CharPatchData_UnlockCond_Item::create(
            _fbb,
            &clz_Torappu_CharPatchData_UnlockCond_ItemArgs {
                stageId,
                completeState,
                unlockTs,
            },
        )
    }
}
pub enum clz_Torappu_CharPatchData_UnlockCondOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharPatchData_UnlockCond<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharPatchData_UnlockCond<'a> {
    type Inner = clz_Torappu_CharPatchData_UnlockCond<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharPatchData_UnlockCond<'a> {
    pub const VT_CONDS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharPatchData_UnlockCond { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharPatchData_UnlockCondArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharPatchData_UnlockCond<'bldr>> {
        let mut builder = clz_Torappu_CharPatchData_UnlockCondBuilder::new(_fbb);
        if let Some(x) = args.conds {
            builder.add_conds(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharPatchData_UnlockCondT {
        let conds = self.conds().map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_CharPatchData_UnlockCondT { conds }
    }

    #[inline]
    pub fn conds(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_CharPatchData_UnlockCond_Item<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharPatchData_UnlockCond_Item>,
                >,
            >>(clz_Torappu_CharPatchData_UnlockCond::VT_CONDS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharPatchData_UnlockCond<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharPatchData_UnlockCond_Item>,
                >,
            >>("conds", Self::VT_CONDS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharPatchData_UnlockCondArgs<'a> {
    pub conds: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharPatchData_UnlockCond_Item<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_CharPatchData_UnlockCondArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharPatchData_UnlockCondArgs { conds: None }
    }
}

impl Serialize for clz_Torappu_CharPatchData_UnlockCond<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharPatchData_UnlockCond", 1)?;
        if let Some(f) = self.conds() {
            s.serialize_field("conds", &f)?;
        } else {
            s.skip_field("conds")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CharPatchData_UnlockCondBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharPatchData_UnlockCondBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_conds(
        &mut self,
        conds: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharPatchData_UnlockCond_Item<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharPatchData_UnlockCond::VT_CONDS,
            conds,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharPatchData_UnlockCondBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharPatchData_UnlockCondBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharPatchData_UnlockCond<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharPatchData_UnlockCond<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharPatchData_UnlockCond");
        ds.field("conds", &self.conds());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharPatchData_UnlockCondT {
    pub conds: Option<Vec<clz_Torappu_CharPatchData_UnlockCond_ItemT>>,
}
impl Default for clz_Torappu_CharPatchData_UnlockCondT {
    fn default() -> Self {
        Self { conds: None }
    }
}
impl clz_Torappu_CharPatchData_UnlockCondT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharPatchData_UnlockCond<'b>> {
        let conds = self.conds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_CharPatchData_UnlockCond::create(
            _fbb,
            &clz_Torappu_CharPatchData_UnlockCondArgs { conds },
        )
    }
}
pub enum dict__string__clz_Torappu_CharPatchData_UnlockCondOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_CharPatchData_UnlockCond<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_CharPatchData_UnlockCond<'a> {
    type Inner = dict__string__clz_Torappu_CharPatchData_UnlockCond<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_CharPatchData_UnlockCond<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_CharPatchData_UnlockCond { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_CharPatchData_UnlockCondArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharPatchData_UnlockCond<'bldr>> {
        let mut builder = dict__string__clz_Torappu_CharPatchData_UnlockCondBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_CharPatchData_UnlockCondT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_CharPatchData_UnlockCondT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_CharPatchData_UnlockCond::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_CharPatchData_UnlockCond,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_CharPatchData_UnlockCond<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharPatchData_UnlockCond>>(
                    dict__string__clz_Torappu_CharPatchData_UnlockCond::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_CharPatchData_UnlockCond<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharPatchData_UnlockCond>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_CharPatchData_UnlockCondArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_CharPatchData_UnlockCond<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_CharPatchData_UnlockCondArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_CharPatchData_UnlockCondArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_CharPatchData_UnlockCond<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_CharPatchData_UnlockCond", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_CharPatchData_UnlockCondBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_CharPatchData_UnlockCondBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_CharPatchData_UnlockCond::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_CharPatchData_UnlockCond<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharPatchData_UnlockCond>>(
                dict__string__clz_Torappu_CharPatchData_UnlockCond::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_CharPatchData_UnlockCondBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_CharPatchData_UnlockCondBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharPatchData_UnlockCond<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_CharPatchData_UnlockCond::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_CharPatchData_UnlockCond<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_CharPatchData_UnlockCond");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_CharPatchData_UnlockCondT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_CharPatchData_UnlockCondT>>,
}
impl Default for dict__string__clz_Torappu_CharPatchData_UnlockCondT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_CharPatchData_UnlockCondT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharPatchData_UnlockCond<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_CharPatchData_UnlockCond::create(
            _fbb,
            &dict__string__clz_Torappu_CharPatchData_UnlockCondArgs { key, value },
        )
    }
}
pub enum clz_Torappu_CharPatchData_PatchDetailInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharPatchData_PatchDetailInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharPatchData_PatchDetailInfo<'a> {
    type Inner = clz_Torappu_CharPatchData_PatchDetailInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharPatchData_PatchDetailInfo<'a> {
    pub const VT_PATCHID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_INFOPARAM: flatbuffers::VOffsetT = 8;
    pub const VT_TRANSSORTID: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharPatchData_PatchDetailInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharPatchData_PatchDetailInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharPatchData_PatchDetailInfo<'bldr>> {
        let mut builder = clz_Torappu_CharPatchData_PatchDetailInfoBuilder::new(_fbb);
        builder.add_transSortId(args.transSortId);
        if let Some(x) = args.infoParam {
            builder.add_infoParam(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.patchId {
            builder.add_patchId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharPatchData_PatchDetailInfoT {
        let patchId = self.patchId().map(|x| x.to_string());
        let sortId = self.sortId();
        let infoParam = self.infoParam().map(|x| x.to_string());
        let transSortId = self.transSortId();
        clz_Torappu_CharPatchData_PatchDetailInfoT {
            patchId,
            sortId,
            infoParam,
            transSortId,
        }
    }

    #[inline]
    pub fn patchId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharPatchData_PatchDetailInfo::VT_PATCHID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_CharPatchData_PatchDetailInfo::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn infoParam(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharPatchData_PatchDetailInfo::VT_INFOPARAM,
                None,
            )
        }
    }
    #[inline]
    pub fn transSortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_CharPatchData_PatchDetailInfo::VT_TRANSSORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharPatchData_PatchDetailInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("patchId", Self::VT_PATCHID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "infoParam",
                Self::VT_INFOPARAM,
                false,
            )?
            .visit_field::<i32>("transSortId", Self::VT_TRANSSORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharPatchData_PatchDetailInfoArgs<'a> {
    pub patchId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub infoParam: Option<flatbuffers::WIPOffset<&'a str>>,
    pub transSortId: i32,
}
impl<'a> Default for clz_Torappu_CharPatchData_PatchDetailInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharPatchData_PatchDetailInfoArgs {
            patchId: None,
            sortId: 0,
            infoParam: None,
            transSortId: 0,
        }
    }
}

impl Serialize for clz_Torappu_CharPatchData_PatchDetailInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharPatchData_PatchDetailInfo", 4)?;
        if let Some(f) = self.patchId() {
            s.serialize_field("patchId", &f)?;
        } else {
            s.skip_field("patchId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.infoParam() {
            s.serialize_field("infoParam", &f)?;
        } else {
            s.skip_field("infoParam")?;
        }
        s.serialize_field("transSortId", &self.transSortId())?;
        s.end()
    }
}

pub struct clz_Torappu_CharPatchData_PatchDetailInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharPatchData_PatchDetailInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_patchId(&mut self, patchId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharPatchData_PatchDetailInfo::VT_PATCHID,
            patchId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_CharPatchData_PatchDetailInfo::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn add_infoParam(&mut self, infoParam: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharPatchData_PatchDetailInfo::VT_INFOPARAM,
            infoParam,
        );
    }
    #[inline]
    pub fn add_transSortId(&mut self, transSortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_CharPatchData_PatchDetailInfo::VT_TRANSSORTID,
            transSortId,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharPatchData_PatchDetailInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharPatchData_PatchDetailInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharPatchData_PatchDetailInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharPatchData_PatchDetailInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharPatchData_PatchDetailInfo");
        ds.field("patchId", &self.patchId());
        ds.field("sortId", &self.sortId());
        ds.field("infoParam", &self.infoParam());
        ds.field("transSortId", &self.transSortId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharPatchData_PatchDetailInfoT {
    pub patchId: Option<String>,
    pub sortId: i32,
    pub infoParam: Option<String>,
    pub transSortId: i32,
}
impl Default for clz_Torappu_CharPatchData_PatchDetailInfoT {
    fn default() -> Self {
        Self {
            patchId: None,
            sortId: 0,
            infoParam: None,
            transSortId: 0,
        }
    }
}
impl clz_Torappu_CharPatchData_PatchDetailInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharPatchData_PatchDetailInfo<'b>> {
        let patchId = self.patchId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let infoParam = self.infoParam.as_ref().map(|x| _fbb.create_string(x));
        let transSortId = self.transSortId;
        clz_Torappu_CharPatchData_PatchDetailInfo::create(
            _fbb,
            &clz_Torappu_CharPatchData_PatchDetailInfoArgs {
                patchId,
                sortId,
                infoParam,
                transSortId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_CharPatchData_PatchDetailInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_CharPatchData_PatchDetailInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_CharPatchData_PatchDetailInfo<'a> {
    type Inner = dict__string__clz_Torappu_CharPatchData_PatchDetailInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_CharPatchData_PatchDetailInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_CharPatchData_PatchDetailInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_CharPatchData_PatchDetailInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharPatchData_PatchDetailInfo<'bldr>>
    {
        let mut builder = dict__string__clz_Torappu_CharPatchData_PatchDetailInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_CharPatchData_PatchDetailInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_CharPatchData_PatchDetailInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_CharPatchData_PatchDetailInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_CharPatchData_PatchDetailInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_CharPatchData_PatchDetailInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharPatchData_PatchDetailInfo>>(
                    dict__string__clz_Torappu_CharPatchData_PatchDetailInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_CharPatchData_PatchDetailInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharPatchData_PatchDetailInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_CharPatchData_PatchDetailInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_CharPatchData_PatchDetailInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_CharPatchData_PatchDetailInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_CharPatchData_PatchDetailInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_CharPatchData_PatchDetailInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_CharPatchData_PatchDetailInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_CharPatchData_PatchDetailInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_CharPatchData_PatchDetailInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_CharPatchData_PatchDetailInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_CharPatchData_PatchDetailInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharPatchData_PatchDetailInfo>>(
                dict__string__clz_Torappu_CharPatchData_PatchDetailInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_CharPatchData_PatchDetailInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_CharPatchData_PatchDetailInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharPatchData_PatchDetailInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_CharPatchData_PatchDetailInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_CharPatchData_PatchDetailInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_CharPatchData_PatchDetailInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_CharPatchData_PatchDetailInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_CharPatchData_PatchDetailInfoT>>,
}
impl Default for dict__string__clz_Torappu_CharPatchData_PatchDetailInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_CharPatchData_PatchDetailInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharPatchData_PatchDetailInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_CharPatchData_PatchDetailInfo::create(
            _fbb,
            &dict__string__clz_Torappu_CharPatchData_PatchDetailInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_CharPatchDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharPatchData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharPatchData<'a> {
    type Inner = clz_Torappu_CharPatchData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharPatchData<'a> {
    pub const VT_INFOS: flatbuffers::VOffsetT = 4;
    pub const VT_PATCHCHARS: flatbuffers::VOffsetT = 6;
    pub const VT_UNLOCKCONDS: flatbuffers::VOffsetT = 8;
    pub const VT_PATCHDETAILINFOLIST: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharPatchData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharPatchDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharPatchData<'bldr>> {
        let mut builder = clz_Torappu_CharPatchDataBuilder::new(_fbb);
        if let Some(x) = args.patchDetailInfoList {
            builder.add_patchDetailInfoList(x);
        }
        if let Some(x) = args.unlockConds {
            builder.add_unlockConds(x);
        }
        if let Some(x) = args.patchChars {
            builder.add_patchChars(x);
        }
        if let Some(x) = args.infos {
            builder.add_infos(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharPatchDataT {
        let infos = self.infos().map(|x| x.iter().map(|t| t.unpack()).collect());
        let patchChars = self
            .patchChars()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let unlockConds = self
            .unlockConds()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let patchDetailInfoList = self
            .patchDetailInfoList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_CharPatchDataT {
            infos,
            patchChars,
            unlockConds,
            patchDetailInfoList,
        }
    }

    #[inline]
    pub fn infos(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharPatchData_PatchInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharPatchData_PatchInfo>,
                >,
            >>(clz_Torappu_CharPatchData::VT_INFOS, None)
        }
    }
    #[inline]
    pub fn patchChars(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharacterData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharacterData>,
                >,
            >>(clz_Torappu_CharPatchData::VT_PATCHCHARS, None)
        }
    }
    #[inline]
    pub fn unlockConds(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharPatchData_UnlockCond<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_CharPatchData_UnlockCond,
                    >,
                >,
            >>(clz_Torappu_CharPatchData::VT_UNLOCKCONDS, None)
        }
    }
    #[inline]
    pub fn patchDetailInfoList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_CharPatchData_PatchDetailInfo<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_CharPatchData_PatchDetailInfo,
                    >,
                >,
            >>(clz_Torappu_CharPatchData::VT_PATCHDETAILINFOLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharPatchData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharPatchData_PatchInfo>,
                >,
            >>("infos", Self::VT_INFOS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharacterData>,
                >,
            >>("patchChars", Self::VT_PATCHCHARS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_CharPatchData_UnlockCond,
                    >,
                >,
            >>("unlockConds", Self::VT_UNLOCKCONDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_CharPatchData_PatchDetailInfo,
                    >,
                >,
            >>("patchDetailInfoList", Self::VT_PATCHDETAILINFOLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharPatchDataArgs<'a> {
    pub infos: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharPatchData_PatchInfo<'a>>,
            >,
        >,
    >,
    pub patchChars: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharacterData<'a>>,
            >,
        >,
    >,
    pub unlockConds: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_CharPatchData_UnlockCond<'a>,
                >,
            >,
        >,
    >,
    pub patchDetailInfoList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_CharPatchData_PatchDetailInfo<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_CharPatchDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharPatchDataArgs {
            infos: None,
            patchChars: None,
            unlockConds: None,
            patchDetailInfoList: None,
        }
    }
}

impl Serialize for clz_Torappu_CharPatchData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharPatchData", 4)?;
        if let Some(f) = self.infos() {
            s.serialize_field("infos", &f)?;
        } else {
            s.skip_field("infos")?;
        }
        if let Some(f) = self.patchChars() {
            s.serialize_field("patchChars", &f)?;
        } else {
            s.skip_field("patchChars")?;
        }
        if let Some(f) = self.unlockConds() {
            s.serialize_field("unlockConds", &f)?;
        } else {
            s.skip_field("unlockConds")?;
        }
        if let Some(f) = self.patchDetailInfoList() {
            s.serialize_field("patchDetailInfoList", &f)?;
        } else {
            s.skip_field("patchDetailInfoList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CharPatchDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_CharPatchDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_infos(
        &mut self,
        infos: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharPatchData_PatchInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharPatchData::VT_INFOS,
            infos,
        );
    }
    #[inline]
    pub fn add_patchChars(
        &mut self,
        patchChars: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharacterData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharPatchData::VT_PATCHCHARS,
            patchChars,
        );
    }
    #[inline]
    pub fn add_unlockConds(
        &mut self,
        unlockConds: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_CharPatchData_UnlockCond<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharPatchData::VT_UNLOCKCONDS,
            unlockConds,
        );
    }
    #[inline]
    pub fn add_patchDetailInfoList(
        &mut self,
        patchDetailInfoList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_CharPatchData_PatchDetailInfo<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharPatchData::VT_PATCHDETAILINFOLIST,
            patchDetailInfoList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharPatchDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharPatchDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharPatchData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharPatchData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharPatchData");
        ds.field("infos", &self.infos());
        ds.field("patchChars", &self.patchChars());
        ds.field("unlockConds", &self.unlockConds());
        ds.field("patchDetailInfoList", &self.patchDetailInfoList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharPatchDataT {
    pub infos: Option<Vec<dict__string__clz_Torappu_CharPatchData_PatchInfoT>>,
    pub patchChars: Option<Vec<dict__string__clz_Torappu_CharacterDataT>>,
    pub unlockConds: Option<Vec<dict__string__clz_Torappu_CharPatchData_UnlockCondT>>,
    pub patchDetailInfoList: Option<Vec<dict__string__clz_Torappu_CharPatchData_PatchDetailInfoT>>,
}
impl Default for clz_Torappu_CharPatchDataT {
    fn default() -> Self {
        Self {
            infos: None,
            patchChars: None,
            unlockConds: None,
            patchDetailInfoList: None,
        }
    }
}
impl clz_Torappu_CharPatchDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharPatchData<'b>> {
        let infos = self.infos.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let patchChars = self.patchChars.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let unlockConds = self.unlockConds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let patchDetailInfoList = self.patchDetailInfoList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_CharPatchData::create(
            _fbb,
            &clz_Torappu_CharPatchDataArgs {
                infos,
                patchChars,
                unlockConds,
                patchDetailInfoList,
            },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_CharPatchData`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_char_patch_data_unchecked`.
pub fn root_as_clz_torappu_char_patch_data(
    buf: &[u8],
) -> Result<clz_Torappu_CharPatchData<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_CharPatchData>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_CharPatchData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_char_patch_data_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_char_patch_data(
    buf: &[u8],
) -> Result<clz_Torappu_CharPatchData<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_CharPatchData>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_CharPatchData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_char_patch_data_unchecked`.
pub fn root_as_clz_torappu_char_patch_data_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_CharPatchData<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_CharPatchData<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_CharPatchData` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_char_patch_data_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_char_patch_data_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_CharPatchData<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_CharPatchData<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_CharPatchData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_CharPatchData`.
pub unsafe fn root_as_clz_torappu_char_patch_data_unchecked(
    buf: &[u8],
) -> clz_Torappu_CharPatchData<'_> {
    unsafe { flatbuffers::root_unchecked::<clz_Torappu_CharPatchData>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_CharPatchData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_CharPatchData`.
pub unsafe fn size_prefixed_root_as_clz_torappu_char_patch_data_unchecked(
    buf: &[u8],
) -> clz_Torappu_CharPatchData<'_> {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_CharPatchData>(buf) }
}
#[inline]
pub fn finish_clz_torappu_char_patch_data_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_CharPatchData<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_char_patch_data_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_CharPatchData<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
