// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SOURCE_APPLY_WAY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SOURCE_APPLY_WAY: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SOURCE_APPLY_WAY: [enum__Torappu_SourceApplyWay; 4] = [
    enum__Torappu_SourceApplyWay::NONE,
    enum__Torappu_SourceApplyWay::MELEE,
    enum__Torappu_SourceApplyWay::RANGED,
    enum__Torappu_SourceApplyWay::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SourceApplyWay(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SourceApplyWay {
    pub const NONE: Self = Self(0);
    pub const MELEE: Self = Self(1);
    pub const RANGED: Self = Self(2);
    pub const ALL: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::MELEE, Self::RANGED, Self::ALL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MELEE => Some("MELEE"),
            Self::RANGED => Some("RANGED"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SourceApplyWay {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SourceApplyWay {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SourceApplyWay",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SourceApplyWay {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SourceApplyWay {
    type Output = enum__Torappu_SourceApplyWay;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SourceApplyWay {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SourceApplyWay {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SourceApplyWay {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_MOTION_MODE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_MOTION_MODE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_MOTION_MODE: [enum__Torappu_MotionMode; 3] = [
    enum__Torappu_MotionMode::WALK,
    enum__Torappu_MotionMode::FLY,
    enum__Torappu_MotionMode::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_MotionMode(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_MotionMode {
    pub const WALK: Self = Self(0);
    pub const FLY: Self = Self(1);
    pub const E_NUM: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::WALK, Self::FLY, Self::E_NUM];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::WALK => Some("WALK"),
            Self::FLY => Some("FLY"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_MotionMode {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_MotionMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_MotionMode",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_MotionMode {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_MotionMode {
    type Output = enum__Torappu_MotionMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_MotionMode {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_MotionMode {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_MotionMode {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ENEMY_LEVEL_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ENEMY_LEVEL_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ENEMY_LEVEL_TYPE: [enum__Torappu_EnemyLevelType; 4] = [
    enum__Torappu_EnemyLevelType::NORMAL,
    enum__Torappu_EnemyLevelType::ELITE,
    enum__Torappu_EnemyLevelType::BOSS,
    enum__Torappu_EnemyLevelType::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_EnemyLevelType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_EnemyLevelType {
    pub const NORMAL: Self = Self(0);
    pub const ELITE: Self = Self(1);
    pub const BOSS: Self = Self(2);
    pub const E_NUM: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NORMAL, Self::ELITE, Self::BOSS, Self::E_NUM];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NORMAL => Some("NORMAL"),
            Self::ELITE => Some("ELITE"),
            Self::BOSS => Some("BOSS"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_EnemyLevelType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_EnemyLevelType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_EnemyLevelType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_EnemyLevelType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_EnemyLevelType {
    type Output = enum__Torappu_EnemyLevelType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_EnemyLevelType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_EnemyLevelType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_EnemyLevelType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SP_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SP_TYPE: i32 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SP_TYPE: [enum__Torappu_SpType; 6] = [
    enum__Torappu_SpType::NONE,
    enum__Torappu_SpType::INCREASE_WITH_TIME,
    enum__Torappu_SpType::INCREASE_WHEN_ATTACK,
    enum__Torappu_SpType::INCREASE_WHEN_TAKEN_DAMAGE,
    enum__Torappu_SpType::ATTACK_OR_DAMAGE,
    enum__Torappu_SpType::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SpType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SpType {
    pub const NONE: Self = Self(0);
    pub const INCREASE_WITH_TIME: Self = Self(1);
    pub const INCREASE_WHEN_ATTACK: Self = Self(2);
    pub const INCREASE_WHEN_TAKEN_DAMAGE: Self = Self(4);
    pub const ATTACK_OR_DAMAGE: Self = Self(6);
    pub const ALL: Self = Self(7);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 7;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::INCREASE_WITH_TIME,
        Self::INCREASE_WHEN_ATTACK,
        Self::INCREASE_WHEN_TAKEN_DAMAGE,
        Self::ATTACK_OR_DAMAGE,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::INCREASE_WITH_TIME => Some("INCREASE_WITH_TIME"),
            Self::INCREASE_WHEN_ATTACK => Some("INCREASE_WHEN_ATTACK"),
            Self::INCREASE_WHEN_TAKEN_DAMAGE => Some("INCREASE_WHEN_TAKEN_DAMAGE"),
            Self::ATTACK_OR_DAMAGE => Some("ATTACK_OR_DAMAGE"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SpType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SpType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SpType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SpType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SpType {
    type Output = enum__Torappu_SpType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SpType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SpType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SpType {}
pub enum clz_Torappu_Undefinable_1_System_String_Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Undefinable_1_System_String_<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Undefinable_1_System_String_<'a> {
    type Inner = clz_Torappu_Undefinable_1_System_String_<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Undefinable_1_System_String_<'a> {
    pub const VT_M_DEFINED: flatbuffers::VOffsetT = 4;
    pub const VT_M_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Undefinable_1_System_String_ { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Undefinable_1_System_String_Args<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_<'bldr>> {
        let mut builder = clz_Torappu_Undefinable_1_System_String_Builder::new(_fbb);
        if let Some(x) = args.m_value {
            builder.add_m_value(x);
        }
        builder.add_m_defined(args.m_defined);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Undefinable_1_System_String_T {
        let m_defined = self.m_defined();
        let m_value = self.m_value().map(|x| x.to_string());
        clz_Torappu_Undefinable_1_System_String_T { m_defined, m_value }
    }

    #[inline]
    pub fn m_defined(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Undefinable_1_System_String_::VT_M_DEFINED,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn m_value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Undefinable_1_System_String_::VT_M_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Undefinable_1_System_String_<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("m_defined", Self::VT_M_DEFINED, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("m_value", Self::VT_M_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Undefinable_1_System_String_Args<'a> {
    pub m_defined: bool,
    pub m_value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Undefinable_1_System_String_Args<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Undefinable_1_System_String_Args {
            m_defined: false,
            m_value: None,
        }
    }
}

impl Serialize for clz_Torappu_Undefinable_1_System_String_<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Undefinable_1_System_String_", 2)?;
        s.serialize_field("m_defined", &self.m_defined())?;
        if let Some(f) = self.m_value() {
            s.serialize_field("m_value", &f)?;
        } else {
            s.skip_field("m_value")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Undefinable_1_System_String_Builder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Undefinable_1_System_String_Builder<'a, 'b, A>
{
    #[inline]
    pub fn add_m_defined(&mut self, m_defined: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Undefinable_1_System_String_::VT_M_DEFINED,
            m_defined,
            false,
        );
    }
    #[inline]
    pub fn add_m_value(&mut self, m_value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Undefinable_1_System_String_::VT_M_VALUE,
            m_value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Undefinable_1_System_String_Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Undefinable_1_System_String_Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Undefinable_1_System_String_<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Undefinable_1_System_String_");
        ds.field("m_defined", &self.m_defined());
        ds.field("m_value", &self.m_value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Undefinable_1_System_String_T {
    pub m_defined: bool,
    pub m_value: Option<String>,
}
impl Default for clz_Torappu_Undefinable_1_System_String_T {
    fn default() -> Self {
        Self {
            m_defined: false,
            m_value: None,
        }
    }
}
impl clz_Torappu_Undefinable_1_System_String_T {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_<'b>> {
        let m_defined = self.m_defined;
        let m_value = self.m_value.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Undefinable_1_System_String_::create(
            _fbb,
            &clz_Torappu_Undefinable_1_System_String_Args { m_defined, m_value },
        )
    }
}
pub enum clz_Torappu_Undefinable_1_System_Int32_Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Undefinable_1_System_Int32_<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Undefinable_1_System_Int32_<'a> {
    type Inner = clz_Torappu_Undefinable_1_System_Int32_<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Undefinable_1_System_Int32_<'a> {
    pub const VT_M_DEFINED: flatbuffers::VOffsetT = 4;
    pub const VT_M_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Undefinable_1_System_Int32_ { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Undefinable_1_System_Int32_Args,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'bldr>> {
        let mut builder = clz_Torappu_Undefinable_1_System_Int32_Builder::new(_fbb);
        builder.add_m_value(args.m_value);
        builder.add_m_defined(args.m_defined);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Undefinable_1_System_Int32_T {
        let m_defined = self.m_defined();
        let m_value = self.m_value();
        clz_Torappu_Undefinable_1_System_Int32_T { m_defined, m_value }
    }

    #[inline]
    pub fn m_defined(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Undefinable_1_System_Int32_::VT_M_DEFINED,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn m_value(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_Undefinable_1_System_Int32_::VT_M_VALUE, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Undefinable_1_System_Int32_<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("m_defined", Self::VT_M_DEFINED, false)?
            .visit_field::<i32>("m_value", Self::VT_M_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Undefinable_1_System_Int32_Args {
    pub m_defined: bool,
    pub m_value: i32,
}
impl<'a> Default for clz_Torappu_Undefinable_1_System_Int32_Args {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Undefinable_1_System_Int32_Args {
            m_defined: false,
            m_value: 0,
        }
    }
}

impl Serialize for clz_Torappu_Undefinable_1_System_Int32_<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Undefinable_1_System_Int32_", 2)?;
        s.serialize_field("m_defined", &self.m_defined())?;
        s.serialize_field("m_value", &self.m_value())?;
        s.end()
    }
}

pub struct clz_Torappu_Undefinable_1_System_Int32_Builder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Undefinable_1_System_Int32_Builder<'a, 'b, A>
{
    #[inline]
    pub fn add_m_defined(&mut self, m_defined: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Undefinable_1_System_Int32_::VT_M_DEFINED,
            m_defined,
            false,
        );
    }
    #[inline]
    pub fn add_m_value(&mut self, m_value: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_Undefinable_1_System_Int32_::VT_M_VALUE,
            m_value,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Undefinable_1_System_Int32_Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Undefinable_1_System_Int32_Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Undefinable_1_System_Int32_<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Undefinable_1_System_Int32_");
        ds.field("m_defined", &self.m_defined());
        ds.field("m_value", &self.m_value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Undefinable_1_System_Int32_T {
    pub m_defined: bool,
    pub m_value: i32,
}
impl Default for clz_Torappu_Undefinable_1_System_Int32_T {
    fn default() -> Self {
        Self {
            m_defined: false,
            m_value: 0,
        }
    }
}
impl clz_Torappu_Undefinable_1_System_Int32_T {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>> {
        let m_defined = self.m_defined;
        let m_value = self.m_value;
        clz_Torappu_Undefinable_1_System_Int32_::create(
            _fbb,
            &clz_Torappu_Undefinable_1_System_Int32_Args { m_defined, m_value },
        )
    }
}
pub enum clz_Torappu_Undefinable_1_System_Single_Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Undefinable_1_System_Single_<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Undefinable_1_System_Single_<'a> {
    type Inner = clz_Torappu_Undefinable_1_System_Single_<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Undefinable_1_System_Single_<'a> {
    pub const VT_M_DEFINED: flatbuffers::VOffsetT = 4;
    pub const VT_M_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Undefinable_1_System_Single_ { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Undefinable_1_System_Single_Args,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'bldr>> {
        let mut builder = clz_Torappu_Undefinable_1_System_Single_Builder::new(_fbb);
        builder.add_m_value(args.m_value);
        builder.add_m_defined(args.m_defined);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Undefinable_1_System_Single_T {
        let m_defined = self.m_defined();
        let m_value = self.m_value();
        clz_Torappu_Undefinable_1_System_Single_T { m_defined, m_value }
    }

    #[inline]
    pub fn m_defined(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Undefinable_1_System_Single_::VT_M_DEFINED,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn m_value(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_Undefinable_1_System_Single_::VT_M_VALUE,
                    Some(0.0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Undefinable_1_System_Single_<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("m_defined", Self::VT_M_DEFINED, false)?
            .visit_field::<f32>("m_value", Self::VT_M_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Undefinable_1_System_Single_Args {
    pub m_defined: bool,
    pub m_value: f32,
}
impl<'a> Default for clz_Torappu_Undefinable_1_System_Single_Args {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Undefinable_1_System_Single_Args {
            m_defined: false,
            m_value: 0.0,
        }
    }
}

impl Serialize for clz_Torappu_Undefinable_1_System_Single_<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Undefinable_1_System_Single_", 2)?;
        s.serialize_field("m_defined", &self.m_defined())?;
        s.serialize_field("m_value", &self.m_value())?;
        s.end()
    }
}

pub struct clz_Torappu_Undefinable_1_System_Single_Builder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Undefinable_1_System_Single_Builder<'a, 'b, A>
{
    #[inline]
    pub fn add_m_defined(&mut self, m_defined: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Undefinable_1_System_Single_::VT_M_DEFINED,
            m_defined,
            false,
        );
    }
    #[inline]
    pub fn add_m_value(&mut self, m_value: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_Undefinable_1_System_Single_::VT_M_VALUE,
            m_value,
            0.0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Undefinable_1_System_Single_Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Undefinable_1_System_Single_Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Undefinable_1_System_Single_<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Undefinable_1_System_Single_");
        ds.field("m_defined", &self.m_defined());
        ds.field("m_value", &self.m_value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Undefinable_1_System_Single_T {
    pub m_defined: bool,
    pub m_value: f32,
}
impl Default for clz_Torappu_Undefinable_1_System_Single_T {
    fn default() -> Self {
        Self {
            m_defined: false,
            m_value: 0.0,
        }
    }
}
impl clz_Torappu_Undefinable_1_System_Single_T {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>> {
        let m_defined = self.m_defined;
        let m_value = self.m_value;
        clz_Torappu_Undefinable_1_System_Single_::create(
            _fbb,
            &clz_Torappu_Undefinable_1_System_Single_Args { m_defined, m_value },
        )
    }
}
pub enum clz_Torappu_Undefinable_1_System_Boolean_Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Undefinable_1_System_Boolean_<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Undefinable_1_System_Boolean_<'a> {
    type Inner = clz_Torappu_Undefinable_1_System_Boolean_<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Undefinable_1_System_Boolean_<'a> {
    pub const VT_M_DEFINED: flatbuffers::VOffsetT = 4;
    pub const VT_M_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Undefinable_1_System_Boolean_ { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Undefinable_1_System_Boolean_Args,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'bldr>> {
        let mut builder = clz_Torappu_Undefinable_1_System_Boolean_Builder::new(_fbb);
        builder.add_m_value(args.m_value);
        builder.add_m_defined(args.m_defined);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Undefinable_1_System_Boolean_T {
        let m_defined = self.m_defined();
        let m_value = self.m_value();
        clz_Torappu_Undefinable_1_System_Boolean_T { m_defined, m_value }
    }

    #[inline]
    pub fn m_defined(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Undefinable_1_System_Boolean_::VT_M_DEFINED,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn m_value(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Undefinable_1_System_Boolean_::VT_M_VALUE,
                    Some(false),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Undefinable_1_System_Boolean_<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("m_defined", Self::VT_M_DEFINED, false)?
            .visit_field::<bool>("m_value", Self::VT_M_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Undefinable_1_System_Boolean_Args {
    pub m_defined: bool,
    pub m_value: bool,
}
impl<'a> Default for clz_Torappu_Undefinable_1_System_Boolean_Args {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Undefinable_1_System_Boolean_Args {
            m_defined: false,
            m_value: false,
        }
    }
}

impl Serialize for clz_Torappu_Undefinable_1_System_Boolean_<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Undefinable_1_System_Boolean_", 2)?;
        s.serialize_field("m_defined", &self.m_defined())?;
        s.serialize_field("m_value", &self.m_value())?;
        s.end()
    }
}

pub struct clz_Torappu_Undefinable_1_System_Boolean_Builder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Undefinable_1_System_Boolean_Builder<'a, 'b, A>
{
    #[inline]
    pub fn add_m_defined(&mut self, m_defined: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Undefinable_1_System_Boolean_::VT_M_DEFINED,
            m_defined,
            false,
        );
    }
    #[inline]
    pub fn add_m_value(&mut self, m_value: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Undefinable_1_System_Boolean_::VT_M_VALUE,
            m_value,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Undefinable_1_System_Boolean_Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Undefinable_1_System_Boolean_Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Undefinable_1_System_Boolean_<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Undefinable_1_System_Boolean_");
        ds.field("m_defined", &self.m_defined());
        ds.field("m_value", &self.m_value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Undefinable_1_System_Boolean_T {
    pub m_defined: bool,
    pub m_value: bool,
}
impl Default for clz_Torappu_Undefinable_1_System_Boolean_T {
    fn default() -> Self {
        Self {
            m_defined: false,
            m_value: false,
        }
    }
}
impl clz_Torappu_Undefinable_1_System_Boolean_T {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'b>> {
        let m_defined = self.m_defined;
        let m_value = self.m_value;
        clz_Torappu_Undefinable_1_System_Boolean_::create(
            _fbb,
            &clz_Torappu_Undefinable_1_System_Boolean_Args { m_defined, m_value },
        )
    }
}
pub enum clz_Torappu_EnemyDatabase_AttributesDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_EnemyDatabase_AttributesData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_EnemyDatabase_AttributesData<'a> {
    type Inner = clz_Torappu_EnemyDatabase_AttributesData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_EnemyDatabase_AttributesData<'a> {
    pub const VT_MAXHP: flatbuffers::VOffsetT = 4;
    pub const VT_ATK: flatbuffers::VOffsetT = 6;
    pub const VT_DEF: flatbuffers::VOffsetT = 8;
    pub const VT_MAGICRESISTANCE: flatbuffers::VOffsetT = 10;
    pub const VT_COST: flatbuffers::VOffsetT = 12;
    pub const VT_BLOCKCNT: flatbuffers::VOffsetT = 14;
    pub const VT_MOVESPEED: flatbuffers::VOffsetT = 16;
    pub const VT_ATTACKSPEED: flatbuffers::VOffsetT = 18;
    pub const VT_BASEATTACKTIME: flatbuffers::VOffsetT = 20;
    pub const VT_RESPAWNTIME: flatbuffers::VOffsetT = 22;
    pub const VT_HPRECOVERYPERSEC: flatbuffers::VOffsetT = 24;
    pub const VT_SPRECOVERYPERSEC: flatbuffers::VOffsetT = 26;
    pub const VT_MAXDEPLOYCOUNT: flatbuffers::VOffsetT = 28;
    pub const VT_MASSLEVEL: flatbuffers::VOffsetT = 30;
    pub const VT_BASEFORCELEVEL: flatbuffers::VOffsetT = 32;
    pub const VT_TAUNTLEVEL: flatbuffers::VOffsetT = 34;
    pub const VT_EPDAMAGERESISTANCE: flatbuffers::VOffsetT = 36;
    pub const VT_EPRESISTANCE: flatbuffers::VOffsetT = 38;
    pub const VT_DAMAGEHITRATEPHYSICAL: flatbuffers::VOffsetT = 40;
    pub const VT_DAMAGEHITRATEMAGICAL: flatbuffers::VOffsetT = 42;
    pub const VT_EPBREAKRECOVERSPEED: flatbuffers::VOffsetT = 44;
    pub const VT_STUNIMMUNE: flatbuffers::VOffsetT = 46;
    pub const VT_SILENCEIMMUNE: flatbuffers::VOffsetT = 48;
    pub const VT_SLEEPIMMUNE: flatbuffers::VOffsetT = 50;
    pub const VT_FROZENIMMUNE: flatbuffers::VOffsetT = 52;
    pub const VT_LEVITATEIMMUNE: flatbuffers::VOffsetT = 54;
    pub const VT_DISARMEDCOMBATIMMUNE: flatbuffers::VOffsetT = 56;
    pub const VT_FEAREDIMMUNE: flatbuffers::VOffsetT = 58;
    pub const VT_PALSYIMMUNE: flatbuffers::VOffsetT = 60;
    pub const VT_ATTRACTIMMUNE: flatbuffers::VOffsetT = 62;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_EnemyDatabase_AttributesData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_EnemyDatabase_AttributesDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_AttributesData<'bldr>> {
        let mut builder = clz_Torappu_EnemyDatabase_AttributesDataBuilder::new(_fbb);
        if let Some(x) = args.attractImmune {
            builder.add_attractImmune(x);
        }
        if let Some(x) = args.palsyImmune {
            builder.add_palsyImmune(x);
        }
        if let Some(x) = args.fearedImmune {
            builder.add_fearedImmune(x);
        }
        if let Some(x) = args.disarmedCombatImmune {
            builder.add_disarmedCombatImmune(x);
        }
        if let Some(x) = args.levitateImmune {
            builder.add_levitateImmune(x);
        }
        if let Some(x) = args.frozenImmune {
            builder.add_frozenImmune(x);
        }
        if let Some(x) = args.sleepImmune {
            builder.add_sleepImmune(x);
        }
        if let Some(x) = args.silenceImmune {
            builder.add_silenceImmune(x);
        }
        if let Some(x) = args.stunImmune {
            builder.add_stunImmune(x);
        }
        if let Some(x) = args.epBreakRecoverSpeed {
            builder.add_epBreakRecoverSpeed(x);
        }
        if let Some(x) = args.damageHitrateMagical {
            builder.add_damageHitrateMagical(x);
        }
        if let Some(x) = args.damageHitratePhysical {
            builder.add_damageHitratePhysical(x);
        }
        if let Some(x) = args.epResistance {
            builder.add_epResistance(x);
        }
        if let Some(x) = args.epDamageResistance {
            builder.add_epDamageResistance(x);
        }
        if let Some(x) = args.tauntLevel {
            builder.add_tauntLevel(x);
        }
        if let Some(x) = args.baseForceLevel {
            builder.add_baseForceLevel(x);
        }
        if let Some(x) = args.massLevel {
            builder.add_massLevel(x);
        }
        if let Some(x) = args.maxDeployCount {
            builder.add_maxDeployCount(x);
        }
        if let Some(x) = args.spRecoveryPerSec {
            builder.add_spRecoveryPerSec(x);
        }
        if let Some(x) = args.hpRecoveryPerSec {
            builder.add_hpRecoveryPerSec(x);
        }
        if let Some(x) = args.respawnTime {
            builder.add_respawnTime(x);
        }
        if let Some(x) = args.baseAttackTime {
            builder.add_baseAttackTime(x);
        }
        if let Some(x) = args.attackSpeed {
            builder.add_attackSpeed(x);
        }
        if let Some(x) = args.moveSpeed {
            builder.add_moveSpeed(x);
        }
        if let Some(x) = args.blockCnt {
            builder.add_blockCnt(x);
        }
        if let Some(x) = args.cost {
            builder.add_cost(x);
        }
        if let Some(x) = args.magicResistance {
            builder.add_magicResistance(x);
        }
        if let Some(x) = args.def {
            builder.add_def(x);
        }
        if let Some(x) = args.atk {
            builder.add_atk(x);
        }
        if let Some(x) = args.maxHp {
            builder.add_maxHp(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_EnemyDatabase_AttributesDataT {
        let maxHp = self.maxHp().map(|x| Box::new(x.unpack()));
        let atk = self.atk().map(|x| Box::new(x.unpack()));
        let def = self.def().map(|x| Box::new(x.unpack()));
        let magicResistance = self.magicResistance().map(|x| Box::new(x.unpack()));
        let cost = self.cost().map(|x| Box::new(x.unpack()));
        let blockCnt = self.blockCnt().map(|x| Box::new(x.unpack()));
        let moveSpeed = self.moveSpeed().map(|x| Box::new(x.unpack()));
        let attackSpeed = self.attackSpeed().map(|x| Box::new(x.unpack()));
        let baseAttackTime = self.baseAttackTime().map(|x| Box::new(x.unpack()));
        let respawnTime = self.respawnTime().map(|x| Box::new(x.unpack()));
        let hpRecoveryPerSec = self.hpRecoveryPerSec().map(|x| Box::new(x.unpack()));
        let spRecoveryPerSec = self.spRecoveryPerSec().map(|x| Box::new(x.unpack()));
        let maxDeployCount = self.maxDeployCount().map(|x| Box::new(x.unpack()));
        let massLevel = self.massLevel().map(|x| Box::new(x.unpack()));
        let baseForceLevel = self.baseForceLevel().map(|x| Box::new(x.unpack()));
        let tauntLevel = self.tauntLevel().map(|x| Box::new(x.unpack()));
        let epDamageResistance = self.epDamageResistance().map(|x| Box::new(x.unpack()));
        let epResistance = self.epResistance().map(|x| Box::new(x.unpack()));
        let damageHitratePhysical = self.damageHitratePhysical().map(|x| Box::new(x.unpack()));
        let damageHitrateMagical = self.damageHitrateMagical().map(|x| Box::new(x.unpack()));
        let epBreakRecoverSpeed = self.epBreakRecoverSpeed().map(|x| Box::new(x.unpack()));
        let stunImmune = self.stunImmune().map(|x| Box::new(x.unpack()));
        let silenceImmune = self.silenceImmune().map(|x| Box::new(x.unpack()));
        let sleepImmune = self.sleepImmune().map(|x| Box::new(x.unpack()));
        let frozenImmune = self.frozenImmune().map(|x| Box::new(x.unpack()));
        let levitateImmune = self.levitateImmune().map(|x| Box::new(x.unpack()));
        let disarmedCombatImmune = self.disarmedCombatImmune().map(|x| Box::new(x.unpack()));
        let fearedImmune = self.fearedImmune().map(|x| Box::new(x.unpack()));
        let palsyImmune = self.palsyImmune().map(|x| Box::new(x.unpack()));
        let attractImmune = self.attractImmune().map(|x| Box::new(x.unpack()));
        clz_Torappu_EnemyDatabase_AttributesDataT {
            maxHp,
            atk,
            def,
            magicResistance,
            cost,
            blockCnt,
            moveSpeed,
            attackSpeed,
            baseAttackTime,
            respawnTime,
            hpRecoveryPerSec,
            spRecoveryPerSec,
            maxDeployCount,
            massLevel,
            baseForceLevel,
            tauntLevel,
            epDamageResistance,
            epResistance,
            damageHitratePhysical,
            damageHitrateMagical,
            epBreakRecoverSpeed,
            stunImmune,
            silenceImmune,
            sleepImmune,
            frozenImmune,
            levitateImmune,
            disarmedCombatImmune,
            fearedImmune,
            palsyImmune,
            attractImmune,
        }
    }

    #[inline]
    pub fn maxHp(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_MAXHP,
                    None,
                )
        }
    }
    #[inline]
    pub fn atk(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_ATK,
                    None,
                )
        }
    }
    #[inline]
    pub fn def(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_DEF,
                    None,
                )
        }
    }
    #[inline]
    pub fn magicResistance(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_MAGICRESISTANCE,
                    None,
                )
        }
    }
    #[inline]
    pub fn cost(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_COST,
                    None,
                )
        }
    }
    #[inline]
    pub fn blockCnt(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_BLOCKCNT,
                    None,
                )
        }
    }
    #[inline]
    pub fn moveSpeed(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_MOVESPEED,
                    None,
                )
        }
    }
    #[inline]
    pub fn attackSpeed(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_ATTACKSPEED,
                    None,
                )
        }
    }
    #[inline]
    pub fn baseAttackTime(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_BASEATTACKTIME,
                    None,
                )
        }
    }
    #[inline]
    pub fn respawnTime(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_RESPAWNTIME,
                    None,
                )
        }
    }
    #[inline]
    pub fn hpRecoveryPerSec(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_HPRECOVERYPERSEC,
                    None,
                )
        }
    }
    #[inline]
    pub fn spRecoveryPerSec(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_SPRECOVERYPERSEC,
                    None,
                )
        }
    }
    #[inline]
    pub fn maxDeployCount(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_MAXDEPLOYCOUNT,
                    None,
                )
        }
    }
    #[inline]
    pub fn massLevel(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_MASSLEVEL,
                    None,
                )
        }
    }
    #[inline]
    pub fn baseForceLevel(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_BASEFORCELEVEL,
                    None,
                )
        }
    }
    #[inline]
    pub fn tauntLevel(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_TAUNTLEVEL,
                    None,
                )
        }
    }
    #[inline]
    pub fn epDamageResistance(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_EPDAMAGERESISTANCE,
                    None,
                )
        }
    }
    #[inline]
    pub fn epResistance(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_EPRESISTANCE,
                    None,
                )
        }
    }
    #[inline]
    pub fn damageHitratePhysical(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_DAMAGEHITRATEPHYSICAL,
                    None,
                )
        }
    }
    #[inline]
    pub fn damageHitrateMagical(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_DAMAGEHITRATEMAGICAL,
                    None,
                )
        }
    }
    #[inline]
    pub fn epBreakRecoverSpeed(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_EPBREAKRECOVERSPEED,
                    None,
                )
        }
    }
    #[inline]
    pub fn stunImmune(&self) -> Option<clz_Torappu_Undefinable_1_System_Boolean_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_STUNIMMUNE,
                    None,
                )
        }
    }
    #[inline]
    pub fn silenceImmune(&self) -> Option<clz_Torappu_Undefinable_1_System_Boolean_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_SILENCEIMMUNE,
                    None,
                )
        }
    }
    #[inline]
    pub fn sleepImmune(&self) -> Option<clz_Torappu_Undefinable_1_System_Boolean_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_SLEEPIMMUNE,
                    None,
                )
        }
    }
    #[inline]
    pub fn frozenImmune(&self) -> Option<clz_Torappu_Undefinable_1_System_Boolean_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_FROZENIMMUNE,
                    None,
                )
        }
    }
    #[inline]
    pub fn levitateImmune(&self) -> Option<clz_Torappu_Undefinable_1_System_Boolean_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_LEVITATEIMMUNE,
                    None,
                )
        }
    }
    #[inline]
    pub fn disarmedCombatImmune(&self) -> Option<clz_Torappu_Undefinable_1_System_Boolean_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_DISARMEDCOMBATIMMUNE,
                    None,
                )
        }
    }
    #[inline]
    pub fn fearedImmune(&self) -> Option<clz_Torappu_Undefinable_1_System_Boolean_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_FEAREDIMMUNE,
                    None,
                )
        }
    }
    #[inline]
    pub fn palsyImmune(&self) -> Option<clz_Torappu_Undefinable_1_System_Boolean_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_PALSYIMMUNE,
                    None,
                )
        }
    }
    #[inline]
    pub fn attractImmune(&self) -> Option<clz_Torappu_Undefinable_1_System_Boolean_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_ATTRACTIMMUNE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_EnemyDatabase_AttributesData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                "maxHp",
                Self::VT_MAXHP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                "atk",
                Self::VT_ATK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                "def",
                Self::VT_DEF,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                "magicResistance",
                Self::VT_MAGICRESISTANCE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                "cost",
                Self::VT_COST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                "blockCnt",
                Self::VT_BLOCKCNT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                "moveSpeed",
                Self::VT_MOVESPEED,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                "attackSpeed",
                Self::VT_ATTACKSPEED,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                "baseAttackTime",
                Self::VT_BASEATTACKTIME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                "respawnTime",
                Self::VT_RESPAWNTIME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                "hpRecoveryPerSec",
                Self::VT_HPRECOVERYPERSEC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                "spRecoveryPerSec",
                Self::VT_SPRECOVERYPERSEC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                "maxDeployCount",
                Self::VT_MAXDEPLOYCOUNT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                "massLevel",
                Self::VT_MASSLEVEL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                "baseForceLevel",
                Self::VT_BASEFORCELEVEL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                "tauntLevel",
                Self::VT_TAUNTLEVEL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                "epDamageResistance",
                Self::VT_EPDAMAGERESISTANCE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                "epResistance",
                Self::VT_EPRESISTANCE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                "damageHitratePhysical",
                Self::VT_DAMAGEHITRATEPHYSICAL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                "damageHitrateMagical",
                Self::VT_DAMAGEHITRATEMAGICAL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                "epBreakRecoverSpeed",
                Self::VT_EPBREAKRECOVERSPEED,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                "stunImmune",
                Self::VT_STUNIMMUNE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                "silenceImmune",
                Self::VT_SILENCEIMMUNE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                "sleepImmune",
                Self::VT_SLEEPIMMUNE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                "frozenImmune",
                Self::VT_FROZENIMMUNE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                "levitateImmune",
                Self::VT_LEVITATEIMMUNE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                "disarmedCombatImmune",
                Self::VT_DISARMEDCOMBATIMMUNE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                "fearedImmune",
                Self::VT_FEAREDIMMUNE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                "palsyImmune",
                Self::VT_PALSYIMMUNE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                "attractImmune",
                Self::VT_ATTRACTIMMUNE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_EnemyDatabase_AttributesDataArgs<'a> {
    pub maxHp: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub atk: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub def: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub magicResistance:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub cost: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub blockCnt: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub moveSpeed: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub attackSpeed: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub baseAttackTime:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub respawnTime: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub hpRecoveryPerSec:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub spRecoveryPerSec:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub maxDeployCount: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub massLevel: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub baseForceLevel: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub tauntLevel: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub epDamageResistance:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub epResistance: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub damageHitratePhysical:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub damageHitrateMagical:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub epBreakRecoverSpeed:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub stunImmune: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'a>>>,
    pub silenceImmune:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'a>>>,
    pub sleepImmune: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'a>>>,
    pub frozenImmune: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'a>>>,
    pub levitateImmune:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'a>>>,
    pub disarmedCombatImmune:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'a>>>,
    pub fearedImmune: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'a>>>,
    pub palsyImmune: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'a>>>,
    pub attractImmune:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'a>>>,
}
impl<'a> Default for clz_Torappu_EnemyDatabase_AttributesDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_EnemyDatabase_AttributesDataArgs {
            maxHp: None,
            atk: None,
            def: None,
            magicResistance: None,
            cost: None,
            blockCnt: None,
            moveSpeed: None,
            attackSpeed: None,
            baseAttackTime: None,
            respawnTime: None,
            hpRecoveryPerSec: None,
            spRecoveryPerSec: None,
            maxDeployCount: None,
            massLevel: None,
            baseForceLevel: None,
            tauntLevel: None,
            epDamageResistance: None,
            epResistance: None,
            damageHitratePhysical: None,
            damageHitrateMagical: None,
            epBreakRecoverSpeed: None,
            stunImmune: None,
            silenceImmune: None,
            sleepImmune: None,
            frozenImmune: None,
            levitateImmune: None,
            disarmedCombatImmune: None,
            fearedImmune: None,
            palsyImmune: None,
            attractImmune: None,
        }
    }
}

impl Serialize for clz_Torappu_EnemyDatabase_AttributesData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_EnemyDatabase_AttributesData", 30)?;
        if let Some(f) = self.maxHp() {
            s.serialize_field("maxHp", &f)?;
        } else {
            s.skip_field("maxHp")?;
        }
        if let Some(f) = self.atk() {
            s.serialize_field("atk", &f)?;
        } else {
            s.skip_field("atk")?;
        }
        if let Some(f) = self.def() {
            s.serialize_field("def", &f)?;
        } else {
            s.skip_field("def")?;
        }
        if let Some(f) = self.magicResistance() {
            s.serialize_field("magicResistance", &f)?;
        } else {
            s.skip_field("magicResistance")?;
        }
        if let Some(f) = self.cost() {
            s.serialize_field("cost", &f)?;
        } else {
            s.skip_field("cost")?;
        }
        if let Some(f) = self.blockCnt() {
            s.serialize_field("blockCnt", &f)?;
        } else {
            s.skip_field("blockCnt")?;
        }
        if let Some(f) = self.moveSpeed() {
            s.serialize_field("moveSpeed", &f)?;
        } else {
            s.skip_field("moveSpeed")?;
        }
        if let Some(f) = self.attackSpeed() {
            s.serialize_field("attackSpeed", &f)?;
        } else {
            s.skip_field("attackSpeed")?;
        }
        if let Some(f) = self.baseAttackTime() {
            s.serialize_field("baseAttackTime", &f)?;
        } else {
            s.skip_field("baseAttackTime")?;
        }
        if let Some(f) = self.respawnTime() {
            s.serialize_field("respawnTime", &f)?;
        } else {
            s.skip_field("respawnTime")?;
        }
        if let Some(f) = self.hpRecoveryPerSec() {
            s.serialize_field("hpRecoveryPerSec", &f)?;
        } else {
            s.skip_field("hpRecoveryPerSec")?;
        }
        if let Some(f) = self.spRecoveryPerSec() {
            s.serialize_field("spRecoveryPerSec", &f)?;
        } else {
            s.skip_field("spRecoveryPerSec")?;
        }
        if let Some(f) = self.maxDeployCount() {
            s.serialize_field("maxDeployCount", &f)?;
        } else {
            s.skip_field("maxDeployCount")?;
        }
        if let Some(f) = self.massLevel() {
            s.serialize_field("massLevel", &f)?;
        } else {
            s.skip_field("massLevel")?;
        }
        if let Some(f) = self.baseForceLevel() {
            s.serialize_field("baseForceLevel", &f)?;
        } else {
            s.skip_field("baseForceLevel")?;
        }
        if let Some(f) = self.tauntLevel() {
            s.serialize_field("tauntLevel", &f)?;
        } else {
            s.skip_field("tauntLevel")?;
        }
        if let Some(f) = self.epDamageResistance() {
            s.serialize_field("epDamageResistance", &f)?;
        } else {
            s.skip_field("epDamageResistance")?;
        }
        if let Some(f) = self.epResistance() {
            s.serialize_field("epResistance", &f)?;
        } else {
            s.skip_field("epResistance")?;
        }
        if let Some(f) = self.damageHitratePhysical() {
            s.serialize_field("damageHitratePhysical", &f)?;
        } else {
            s.skip_field("damageHitratePhysical")?;
        }
        if let Some(f) = self.damageHitrateMagical() {
            s.serialize_field("damageHitrateMagical", &f)?;
        } else {
            s.skip_field("damageHitrateMagical")?;
        }
        if let Some(f) = self.epBreakRecoverSpeed() {
            s.serialize_field("epBreakRecoverSpeed", &f)?;
        } else {
            s.skip_field("epBreakRecoverSpeed")?;
        }
        if let Some(f) = self.stunImmune() {
            s.serialize_field("stunImmune", &f)?;
        } else {
            s.skip_field("stunImmune")?;
        }
        if let Some(f) = self.silenceImmune() {
            s.serialize_field("silenceImmune", &f)?;
        } else {
            s.skip_field("silenceImmune")?;
        }
        if let Some(f) = self.sleepImmune() {
            s.serialize_field("sleepImmune", &f)?;
        } else {
            s.skip_field("sleepImmune")?;
        }
        if let Some(f) = self.frozenImmune() {
            s.serialize_field("frozenImmune", &f)?;
        } else {
            s.skip_field("frozenImmune")?;
        }
        if let Some(f) = self.levitateImmune() {
            s.serialize_field("levitateImmune", &f)?;
        } else {
            s.skip_field("levitateImmune")?;
        }
        if let Some(f) = self.disarmedCombatImmune() {
            s.serialize_field("disarmedCombatImmune", &f)?;
        } else {
            s.skip_field("disarmedCombatImmune")?;
        }
        if let Some(f) = self.fearedImmune() {
            s.serialize_field("fearedImmune", &f)?;
        } else {
            s.skip_field("fearedImmune")?;
        }
        if let Some(f) = self.palsyImmune() {
            s.serialize_field("palsyImmune", &f)?;
        } else {
            s.skip_field("palsyImmune")?;
        }
        if let Some(f) = self.attractImmune() {
            s.serialize_field("attractImmune", &f)?;
        } else {
            s.skip_field("attractImmune")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_EnemyDatabase_AttributesDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_EnemyDatabase_AttributesDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_maxHp(
        &mut self,
        maxHp: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_MAXHP,
                maxHp,
            );
    }
    #[inline]
    pub fn add_atk(
        &mut self,
        atk: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_ATK,
                atk,
            );
    }
    #[inline]
    pub fn add_def(
        &mut self,
        def: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_DEF,
                def,
            );
    }
    #[inline]
    pub fn add_magicResistance(
        &mut self,
        magicResistance: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_MAGICRESISTANCE,
                magicResistance,
            );
    }
    #[inline]
    pub fn add_cost(
        &mut self,
        cost: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_COST,
                cost,
            );
    }
    #[inline]
    pub fn add_blockCnt(
        &mut self,
        blockCnt: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_BLOCKCNT,
                blockCnt,
            );
    }
    #[inline]
    pub fn add_moveSpeed(
        &mut self,
        moveSpeed: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_MOVESPEED,
                moveSpeed,
            );
    }
    #[inline]
    pub fn add_attackSpeed(
        &mut self,
        attackSpeed: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_ATTACKSPEED,
                attackSpeed,
            );
    }
    #[inline]
    pub fn add_baseAttackTime(
        &mut self,
        baseAttackTime: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_BASEATTACKTIME,
                baseAttackTime,
            );
    }
    #[inline]
    pub fn add_respawnTime(
        &mut self,
        respawnTime: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_RESPAWNTIME,
                respawnTime,
            );
    }
    #[inline]
    pub fn add_hpRecoveryPerSec(
        &mut self,
        hpRecoveryPerSec: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_HPRECOVERYPERSEC,
                hpRecoveryPerSec,
            );
    }
    #[inline]
    pub fn add_spRecoveryPerSec(
        &mut self,
        spRecoveryPerSec: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_SPRECOVERYPERSEC,
                spRecoveryPerSec,
            );
    }
    #[inline]
    pub fn add_maxDeployCount(
        &mut self,
        maxDeployCount: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_MAXDEPLOYCOUNT,
                maxDeployCount,
            );
    }
    #[inline]
    pub fn add_massLevel(
        &mut self,
        massLevel: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_MASSLEVEL,
                massLevel,
            );
    }
    #[inline]
    pub fn add_baseForceLevel(
        &mut self,
        baseForceLevel: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_BASEFORCELEVEL,
                baseForceLevel,
            );
    }
    #[inline]
    pub fn add_tauntLevel(
        &mut self,
        tauntLevel: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_TAUNTLEVEL,
                tauntLevel,
            );
    }
    #[inline]
    pub fn add_epDamageResistance(
        &mut self,
        epDamageResistance: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_EPDAMAGERESISTANCE,
                epDamageResistance,
            );
    }
    #[inline]
    pub fn add_epResistance(
        &mut self,
        epResistance: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_EPRESISTANCE,
                epResistance,
            );
    }
    #[inline]
    pub fn add_damageHitratePhysical(
        &mut self,
        damageHitratePhysical: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_DAMAGEHITRATEPHYSICAL,
                damageHitratePhysical,
            );
    }
    #[inline]
    pub fn add_damageHitrateMagical(
        &mut self,
        damageHitrateMagical: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_DAMAGEHITRATEMAGICAL,
                damageHitrateMagical,
            );
    }
    #[inline]
    pub fn add_epBreakRecoverSpeed(
        &mut self,
        epBreakRecoverSpeed: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_EPBREAKRECOVERSPEED,
                epBreakRecoverSpeed,
            );
    }
    #[inline]
    pub fn add_stunImmune(
        &mut self,
        stunImmune: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_STUNIMMUNE,
                stunImmune,
            );
    }
    #[inline]
    pub fn add_silenceImmune(
        &mut self,
        silenceImmune: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_SILENCEIMMUNE,
                silenceImmune,
            );
    }
    #[inline]
    pub fn add_sleepImmune(
        &mut self,
        sleepImmune: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_SLEEPIMMUNE,
                sleepImmune,
            );
    }
    #[inline]
    pub fn add_frozenImmune(
        &mut self,
        frozenImmune: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_FROZENIMMUNE,
                frozenImmune,
            );
    }
    #[inline]
    pub fn add_levitateImmune(
        &mut self,
        levitateImmune: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_LEVITATEIMMUNE,
                levitateImmune,
            );
    }
    #[inline]
    pub fn add_disarmedCombatImmune(
        &mut self,
        disarmedCombatImmune: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_DISARMEDCOMBATIMMUNE,
                disarmedCombatImmune,
            );
    }
    #[inline]
    pub fn add_fearedImmune(
        &mut self,
        fearedImmune: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_FEAREDIMMUNE,
                fearedImmune,
            );
    }
    #[inline]
    pub fn add_palsyImmune(
        &mut self,
        palsyImmune: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_PALSYIMMUNE,
                palsyImmune,
            );
    }
    #[inline]
    pub fn add_attractImmune(
        &mut self,
        attractImmune: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_ATTRACTIMMUNE,
                attractImmune,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_EnemyDatabase_AttributesDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_EnemyDatabase_AttributesDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_AttributesData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_EnemyDatabase_AttributesData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_EnemyDatabase_AttributesData");
        ds.field("maxHp", &self.maxHp());
        ds.field("atk", &self.atk());
        ds.field("def", &self.def());
        ds.field("magicResistance", &self.magicResistance());
        ds.field("cost", &self.cost());
        ds.field("blockCnt", &self.blockCnt());
        ds.field("moveSpeed", &self.moveSpeed());
        ds.field("attackSpeed", &self.attackSpeed());
        ds.field("baseAttackTime", &self.baseAttackTime());
        ds.field("respawnTime", &self.respawnTime());
        ds.field("hpRecoveryPerSec", &self.hpRecoveryPerSec());
        ds.field("spRecoveryPerSec", &self.spRecoveryPerSec());
        ds.field("maxDeployCount", &self.maxDeployCount());
        ds.field("massLevel", &self.massLevel());
        ds.field("baseForceLevel", &self.baseForceLevel());
        ds.field("tauntLevel", &self.tauntLevel());
        ds.field("epDamageResistance", &self.epDamageResistance());
        ds.field("epResistance", &self.epResistance());
        ds.field("damageHitratePhysical", &self.damageHitratePhysical());
        ds.field("damageHitrateMagical", &self.damageHitrateMagical());
        ds.field("epBreakRecoverSpeed", &self.epBreakRecoverSpeed());
        ds.field("stunImmune", &self.stunImmune());
        ds.field("silenceImmune", &self.silenceImmune());
        ds.field("sleepImmune", &self.sleepImmune());
        ds.field("frozenImmune", &self.frozenImmune());
        ds.field("levitateImmune", &self.levitateImmune());
        ds.field("disarmedCombatImmune", &self.disarmedCombatImmune());
        ds.field("fearedImmune", &self.fearedImmune());
        ds.field("palsyImmune", &self.palsyImmune());
        ds.field("attractImmune", &self.attractImmune());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_EnemyDatabase_AttributesDataT {
    pub maxHp: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub atk: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub def: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub magicResistance: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub cost: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub blockCnt: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub moveSpeed: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub attackSpeed: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub baseAttackTime: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub respawnTime: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub hpRecoveryPerSec: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub spRecoveryPerSec: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub maxDeployCount: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub massLevel: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub baseForceLevel: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub tauntLevel: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub epDamageResistance: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub epResistance: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub damageHitratePhysical: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub damageHitrateMagical: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub epBreakRecoverSpeed: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub stunImmune: Option<Box<clz_Torappu_Undefinable_1_System_Boolean_T>>,
    pub silenceImmune: Option<Box<clz_Torappu_Undefinable_1_System_Boolean_T>>,
    pub sleepImmune: Option<Box<clz_Torappu_Undefinable_1_System_Boolean_T>>,
    pub frozenImmune: Option<Box<clz_Torappu_Undefinable_1_System_Boolean_T>>,
    pub levitateImmune: Option<Box<clz_Torappu_Undefinable_1_System_Boolean_T>>,
    pub disarmedCombatImmune: Option<Box<clz_Torappu_Undefinable_1_System_Boolean_T>>,
    pub fearedImmune: Option<Box<clz_Torappu_Undefinable_1_System_Boolean_T>>,
    pub palsyImmune: Option<Box<clz_Torappu_Undefinable_1_System_Boolean_T>>,
    pub attractImmune: Option<Box<clz_Torappu_Undefinable_1_System_Boolean_T>>,
}
impl Default for clz_Torappu_EnemyDatabase_AttributesDataT {
    fn default() -> Self {
        Self {
            maxHp: None,
            atk: None,
            def: None,
            magicResistance: None,
            cost: None,
            blockCnt: None,
            moveSpeed: None,
            attackSpeed: None,
            baseAttackTime: None,
            respawnTime: None,
            hpRecoveryPerSec: None,
            spRecoveryPerSec: None,
            maxDeployCount: None,
            massLevel: None,
            baseForceLevel: None,
            tauntLevel: None,
            epDamageResistance: None,
            epResistance: None,
            damageHitratePhysical: None,
            damageHitrateMagical: None,
            epBreakRecoverSpeed: None,
            stunImmune: None,
            silenceImmune: None,
            sleepImmune: None,
            frozenImmune: None,
            levitateImmune: None,
            disarmedCombatImmune: None,
            fearedImmune: None,
            palsyImmune: None,
            attractImmune: None,
        }
    }
}
impl clz_Torappu_EnemyDatabase_AttributesDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_AttributesData<'b>> {
        let maxHp = self.maxHp.as_ref().map(|x| x.pack(_fbb));
        let atk = self.atk.as_ref().map(|x| x.pack(_fbb));
        let def = self.def.as_ref().map(|x| x.pack(_fbb));
        let magicResistance = self.magicResistance.as_ref().map(|x| x.pack(_fbb));
        let cost = self.cost.as_ref().map(|x| x.pack(_fbb));
        let blockCnt = self.blockCnt.as_ref().map(|x| x.pack(_fbb));
        let moveSpeed = self.moveSpeed.as_ref().map(|x| x.pack(_fbb));
        let attackSpeed = self.attackSpeed.as_ref().map(|x| x.pack(_fbb));
        let baseAttackTime = self.baseAttackTime.as_ref().map(|x| x.pack(_fbb));
        let respawnTime = self.respawnTime.as_ref().map(|x| x.pack(_fbb));
        let hpRecoveryPerSec = self.hpRecoveryPerSec.as_ref().map(|x| x.pack(_fbb));
        let spRecoveryPerSec = self.spRecoveryPerSec.as_ref().map(|x| x.pack(_fbb));
        let maxDeployCount = self.maxDeployCount.as_ref().map(|x| x.pack(_fbb));
        let massLevel = self.massLevel.as_ref().map(|x| x.pack(_fbb));
        let baseForceLevel = self.baseForceLevel.as_ref().map(|x| x.pack(_fbb));
        let tauntLevel = self.tauntLevel.as_ref().map(|x| x.pack(_fbb));
        let epDamageResistance = self.epDamageResistance.as_ref().map(|x| x.pack(_fbb));
        let epResistance = self.epResistance.as_ref().map(|x| x.pack(_fbb));
        let damageHitratePhysical = self.damageHitratePhysical.as_ref().map(|x| x.pack(_fbb));
        let damageHitrateMagical = self.damageHitrateMagical.as_ref().map(|x| x.pack(_fbb));
        let epBreakRecoverSpeed = self.epBreakRecoverSpeed.as_ref().map(|x| x.pack(_fbb));
        let stunImmune = self.stunImmune.as_ref().map(|x| x.pack(_fbb));
        let silenceImmune = self.silenceImmune.as_ref().map(|x| x.pack(_fbb));
        let sleepImmune = self.sleepImmune.as_ref().map(|x| x.pack(_fbb));
        let frozenImmune = self.frozenImmune.as_ref().map(|x| x.pack(_fbb));
        let levitateImmune = self.levitateImmune.as_ref().map(|x| x.pack(_fbb));
        let disarmedCombatImmune = self.disarmedCombatImmune.as_ref().map(|x| x.pack(_fbb));
        let fearedImmune = self.fearedImmune.as_ref().map(|x| x.pack(_fbb));
        let palsyImmune = self.palsyImmune.as_ref().map(|x| x.pack(_fbb));
        let attractImmune = self.attractImmune.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_EnemyDatabase_AttributesData::create(
            _fbb,
            &clz_Torappu_EnemyDatabase_AttributesDataArgs {
                maxHp,
                atk,
                def,
                magicResistance,
                cost,
                blockCnt,
                moveSpeed,
                attackSpeed,
                baseAttackTime,
                respawnTime,
                hpRecoveryPerSec,
                spRecoveryPerSec,
                maxDeployCount,
                massLevel,
                baseForceLevel,
                tauntLevel,
                epDamageResistance,
                epResistance,
                damageHitratePhysical,
                damageHitrateMagical,
                epBreakRecoverSpeed,
                stunImmune,
                silenceImmune,
                sleepImmune,
                frozenImmune,
                levitateImmune,
                disarmedCombatImmune,
                fearedImmune,
                palsyImmune,
                attractImmune,
            },
        )
    }
}
pub enum clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'a> {
    type Inner = clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'a> {
    pub const VT_M_DEFINED: flatbuffers::VOffsetT = 4;
    pub const VT_M_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_ { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_Args,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'bldr>> {
        let mut builder = clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_Builder::new(_fbb);
        builder.add_m_value(args.m_value);
        builder.add_m_defined(args.m_defined);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_T {
        let m_defined = self.m_defined();
        let m_value = self.m_value();
        clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_T { m_defined, m_value }
    }

    #[inline]
    pub fn m_defined(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_::VT_M_DEFINED,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn m_value(&self) -> enum__Torappu_SourceApplyWay {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SourceApplyWay>(
                    clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_::VT_M_VALUE,
                    Some(enum__Torappu_SourceApplyWay::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("m_defined", Self::VT_M_DEFINED, false)?
            .visit_field::<enum__Torappu_SourceApplyWay>("m_value", Self::VT_M_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_Args {
    pub m_defined: bool,
    pub m_value: enum__Torappu_SourceApplyWay,
}
impl<'a> Default for clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_Args {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_Args {
            m_defined: false,
            m_value: enum__Torappu_SourceApplyWay::NONE,
        }
    }
}

impl Serialize for clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_", 2)?;
        s.serialize_field("m_defined", &self.m_defined())?;
        s.serialize_field("m_value", &self.m_value())?;
        s.end()
    }
}

pub struct clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_Builder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_Builder<'a, 'b, A>
{
    #[inline]
    pub fn add_m_defined(&mut self, m_defined: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_::VT_M_DEFINED,
            m_defined,
            false,
        );
    }
    #[inline]
    pub fn add_m_value(&mut self, m_value: enum__Torappu_SourceApplyWay) {
        self.fbb_.push_slot::<enum__Torappu_SourceApplyWay>(
            clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_::VT_M_VALUE,
            m_value,
            enum__Torappu_SourceApplyWay::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_");
        ds.field("m_defined", &self.m_defined());
        ds.field("m_value", &self.m_value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_T {
    pub m_defined: bool,
    pub m_value: enum__Torappu_SourceApplyWay,
}
impl Default for clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_T {
    fn default() -> Self {
        Self {
            m_defined: false,
            m_value: enum__Torappu_SourceApplyWay::NONE,
        }
    }
}
impl clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_T {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'b>> {
        let m_defined = self.m_defined;
        let m_value = self.m_value;
        clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_::create(
            _fbb,
            &clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_Args { m_defined, m_value },
        )
    }
}
pub enum clz_Torappu_Undefinable_1_Torappu_MotionMode_Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Undefinable_1_Torappu_MotionMode_<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Undefinable_1_Torappu_MotionMode_<'a> {
    type Inner = clz_Torappu_Undefinable_1_Torappu_MotionMode_<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Undefinable_1_Torappu_MotionMode_<'a> {
    pub const VT_M_DEFINED: flatbuffers::VOffsetT = 4;
    pub const VT_M_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Undefinable_1_Torappu_MotionMode_ { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Undefinable_1_Torappu_MotionMode_Args,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_MotionMode_<'bldr>> {
        let mut builder = clz_Torappu_Undefinable_1_Torappu_MotionMode_Builder::new(_fbb);
        builder.add_m_value(args.m_value);
        builder.add_m_defined(args.m_defined);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Undefinable_1_Torappu_MotionMode_T {
        let m_defined = self.m_defined();
        let m_value = self.m_value();
        clz_Torappu_Undefinable_1_Torappu_MotionMode_T { m_defined, m_value }
    }

    #[inline]
    pub fn m_defined(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Undefinable_1_Torappu_MotionMode_::VT_M_DEFINED,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn m_value(&self) -> enum__Torappu_MotionMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_MotionMode>(
                    clz_Torappu_Undefinable_1_Torappu_MotionMode_::VT_M_VALUE,
                    Some(enum__Torappu_MotionMode::WALK),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Undefinable_1_Torappu_MotionMode_<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("m_defined", Self::VT_M_DEFINED, false)?
            .visit_field::<enum__Torappu_MotionMode>("m_value", Self::VT_M_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Undefinable_1_Torappu_MotionMode_Args {
    pub m_defined: bool,
    pub m_value: enum__Torappu_MotionMode,
}
impl<'a> Default for clz_Torappu_Undefinable_1_Torappu_MotionMode_Args {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Undefinable_1_Torappu_MotionMode_Args {
            m_defined: false,
            m_value: enum__Torappu_MotionMode::WALK,
        }
    }
}

impl Serialize for clz_Torappu_Undefinable_1_Torappu_MotionMode_<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_Undefinable_1_Torappu_MotionMode_", 2)?;
        s.serialize_field("m_defined", &self.m_defined())?;
        s.serialize_field("m_value", &self.m_value())?;
        s.end()
    }
}

pub struct clz_Torappu_Undefinable_1_Torappu_MotionMode_Builder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Undefinable_1_Torappu_MotionMode_Builder<'a, 'b, A>
{
    #[inline]
    pub fn add_m_defined(&mut self, m_defined: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Undefinable_1_Torappu_MotionMode_::VT_M_DEFINED,
            m_defined,
            false,
        );
    }
    #[inline]
    pub fn add_m_value(&mut self, m_value: enum__Torappu_MotionMode) {
        self.fbb_.push_slot::<enum__Torappu_MotionMode>(
            clz_Torappu_Undefinable_1_Torappu_MotionMode_::VT_M_VALUE,
            m_value,
            enum__Torappu_MotionMode::WALK,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Undefinable_1_Torappu_MotionMode_Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Undefinable_1_Torappu_MotionMode_Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_MotionMode_<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Undefinable_1_Torappu_MotionMode_<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Undefinable_1_Torappu_MotionMode_");
        ds.field("m_defined", &self.m_defined());
        ds.field("m_value", &self.m_value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Undefinable_1_Torappu_MotionMode_T {
    pub m_defined: bool,
    pub m_value: enum__Torappu_MotionMode,
}
impl Default for clz_Torappu_Undefinable_1_Torappu_MotionMode_T {
    fn default() -> Self {
        Self {
            m_defined: false,
            m_value: enum__Torappu_MotionMode::WALK,
        }
    }
}
impl clz_Torappu_Undefinable_1_Torappu_MotionMode_T {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_MotionMode_<'b>> {
        let m_defined = self.m_defined;
        let m_value = self.m_value;
        clz_Torappu_Undefinable_1_Torappu_MotionMode_::create(
            _fbb,
            &clz_Torappu_Undefinable_1_Torappu_MotionMode_Args { m_defined, m_value },
        )
    }
}
pub enum clz_Torappu_Undefinable_1_System_String___Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Undefinable_1_System_String___<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Undefinable_1_System_String___<'a> {
    type Inner = clz_Torappu_Undefinable_1_System_String___<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Undefinable_1_System_String___<'a> {
    pub const VT_M_DEFINED: flatbuffers::VOffsetT = 4;
    pub const VT_M_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Undefinable_1_System_String___ { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Undefinable_1_System_String___Args<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String___<'bldr>> {
        let mut builder = clz_Torappu_Undefinable_1_System_String___Builder::new(_fbb);
        if let Some(x) = args.m_value {
            builder.add_m_value(x);
        }
        builder.add_m_defined(args.m_defined);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Undefinable_1_System_String___T {
        let m_defined = self.m_defined();
        let m_value = self
            .m_value()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_Undefinable_1_System_String___T { m_defined, m_value }
    }

    #[inline]
    pub fn m_defined(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Undefinable_1_System_String___::VT_M_DEFINED,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn m_value(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_Undefinable_1_System_String___::VT_M_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Undefinable_1_System_String___<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("m_defined", Self::VT_M_DEFINED, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("m_value", Self::VT_M_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Undefinable_1_System_String___Args<'a> {
    pub m_defined: bool,
    pub m_value: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_Undefinable_1_System_String___Args<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Undefinable_1_System_String___Args {
            m_defined: false,
            m_value: None,
        }
    }
}

impl Serialize for clz_Torappu_Undefinable_1_System_String___<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Undefinable_1_System_String___", 2)?;
        s.serialize_field("m_defined", &self.m_defined())?;
        if let Some(f) = self.m_value() {
            s.serialize_field("m_value", &f)?;
        } else {
            s.skip_field("m_value")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Undefinable_1_System_String___Builder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Undefinable_1_System_String___Builder<'a, 'b, A>
{
    #[inline]
    pub fn add_m_defined(&mut self, m_defined: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Undefinable_1_System_String___::VT_M_DEFINED,
            m_defined,
            false,
        );
    }
    #[inline]
    pub fn add_m_value(
        &mut self,
        m_value: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Undefinable_1_System_String___::VT_M_VALUE,
            m_value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Undefinable_1_System_String___Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Undefinable_1_System_String___Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String___<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Undefinable_1_System_String___<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Undefinable_1_System_String___");
        ds.field("m_defined", &self.m_defined());
        ds.field("m_value", &self.m_value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Undefinable_1_System_String___T {
    pub m_defined: bool,
    pub m_value: Option<Vec<String>>,
}
impl Default for clz_Torappu_Undefinable_1_System_String___T {
    fn default() -> Self {
        Self {
            m_defined: false,
            m_value: None,
        }
    }
}
impl clz_Torappu_Undefinable_1_System_String___T {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String___<'b>> {
        let m_defined = self.m_defined;
        let m_value = self.m_value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_Undefinable_1_System_String___::create(
            _fbb,
            &clz_Torappu_Undefinable_1_System_String___Args { m_defined, m_value },
        )
    }
}
pub enum clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'a> {
    type Inner = clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'a> {
    pub const VT_M_DEFINED: flatbuffers::VOffsetT = 4;
    pub const VT_M_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_ { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_Args,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'bldr>> {
        let mut builder = clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_Builder::new(_fbb);
        builder.add_m_value(args.m_value);
        builder.add_m_defined(args.m_defined);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_T {
        let m_defined = self.m_defined();
        let m_value = self.m_value();
        clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_T { m_defined, m_value }
    }

    #[inline]
    pub fn m_defined(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_::VT_M_DEFINED,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn m_value(&self) -> enum__Torappu_EnemyLevelType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_EnemyLevelType>(
                    clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_::VT_M_VALUE,
                    Some(enum__Torappu_EnemyLevelType::NORMAL),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("m_defined", Self::VT_M_DEFINED, false)?
            .visit_field::<enum__Torappu_EnemyLevelType>("m_value", Self::VT_M_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_Args {
    pub m_defined: bool,
    pub m_value: enum__Torappu_EnemyLevelType,
}
impl<'a> Default for clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_Args {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_Args {
            m_defined: false,
            m_value: enum__Torappu_EnemyLevelType::NORMAL,
        }
    }
}

impl Serialize for clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_", 2)?;
        s.serialize_field("m_defined", &self.m_defined())?;
        s.serialize_field("m_value", &self.m_value())?;
        s.end()
    }
}

pub struct clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_Builder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_Builder<'a, 'b, A>
{
    #[inline]
    pub fn add_m_defined(&mut self, m_defined: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_::VT_M_DEFINED,
            m_defined,
            false,
        );
    }
    #[inline]
    pub fn add_m_value(&mut self, m_value: enum__Torappu_EnemyLevelType) {
        self.fbb_.push_slot::<enum__Torappu_EnemyLevelType>(
            clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_::VT_M_VALUE,
            m_value,
            enum__Torappu_EnemyLevelType::NORMAL,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_");
        ds.field("m_defined", &self.m_defined());
        ds.field("m_value", &self.m_value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_T {
    pub m_defined: bool,
    pub m_value: enum__Torappu_EnemyLevelType,
}
impl Default for clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_T {
    fn default() -> Self {
        Self {
            m_defined: false,
            m_value: enum__Torappu_EnemyLevelType::NORMAL,
        }
    }
}
impl clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_T {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'b>> {
        let m_defined = self.m_defined;
        let m_value = self.m_value;
        clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_::create(
            _fbb,
            &clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_Args { m_defined, m_value },
        )
    }
}
pub enum clz_Torappu_Blackboard_DataPairOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Blackboard_DataPair<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Blackboard_DataPair<'a> {
    type Inner = clz_Torappu_Blackboard_DataPair<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Blackboard_DataPair<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;
    pub const VT_VALUESTR: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Blackboard_DataPair { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Blackboard_DataPairArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'bldr>> {
        let mut builder = clz_Torappu_Blackboard_DataPairBuilder::new(_fbb);
        if let Some(x) = args.valueStr {
            builder.add_valueStr(x);
        }
        builder.add_value(args.value);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Blackboard_DataPairT {
        let key = self.key().map(|x| x.to_string());
        let value = self.value();
        let valueStr = self.valueStr().map(|x| x.to_string());
        clz_Torappu_Blackboard_DataPairT {
            key,
            value,
            valueStr,
        }
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_KEY,
                None,
            )
        }
    }
    #[inline]
    pub fn value(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn valueStr(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Blackboard_DataPair<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<f32>("value", Self::VT_VALUE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "valueStr",
                Self::VT_VALUESTR,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Blackboard_DataPairArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: f32,
    pub valueStr: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Blackboard_DataPairArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Blackboard_DataPairArgs {
            key: None,
            value: 0.0,
            valueStr: None,
        }
    }
}

impl Serialize for clz_Torappu_Blackboard_DataPair<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Blackboard_DataPair", 3)?;
        if let Some(f) = self.key() {
            s.serialize_field("key", &f)?;
        } else {
            s.skip_field("key")?;
        }
        s.serialize_field("value", &self.value())?;
        if let Some(f) = self.valueStr() {
            s.serialize_field("valueStr", &f)?;
        } else {
            s.skip_field("valueStr")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Blackboard_DataPairBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, value, 0.0);
    }
    #[inline]
    pub fn add_valueStr(&mut self, valueStr: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
            valueStr,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Blackboard_DataPairBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Blackboard_DataPair<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Blackboard_DataPair");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.field("valueStr", &self.valueStr());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Blackboard_DataPairT {
    pub key: Option<String>,
    pub value: f32,
    pub valueStr: Option<String>,
}
impl Default for clz_Torappu_Blackboard_DataPairT {
    fn default() -> Self {
        Self {
            key: None,
            value: 0.0,
            valueStr: None,
        }
    }
}
impl clz_Torappu_Blackboard_DataPairT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'b>> {
        let key = self.key.as_ref().map(|x| _fbb.create_string(x));
        let value = self.value;
        let valueStr = self.valueStr.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Blackboard_DataPair::create(
            _fbb,
            &clz_Torappu_Blackboard_DataPairArgs {
                key,
                value,
                valueStr,
            },
        )
    }
}
pub enum clz_Torappu_LevelData_EnemyData_ESkillDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LevelData_EnemyData_ESkillData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LevelData_EnemyData_ESkillData<'a> {
    type Inner = clz_Torappu_LevelData_EnemyData_ESkillData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_LevelData_EnemyData_ESkillData<'a> {
    pub const VT_PREFABKEY: flatbuffers::VOffsetT = 4;
    pub const VT_PRIORITY: flatbuffers::VOffsetT = 6;
    pub const VT_COOLDOWN: flatbuffers::VOffsetT = 8;
    pub const VT_INITCOOLDOWN: flatbuffers::VOffsetT = 10;
    pub const VT_SPCOST: flatbuffers::VOffsetT = 12;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LevelData_EnemyData_ESkillData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LevelData_EnemyData_ESkillDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData_ESkillData<'bldr>> {
        let mut builder = clz_Torappu_LevelData_EnemyData_ESkillDataBuilder::new(_fbb);
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        builder.add_spCost(args.spCost);
        builder.add_initCooldown(args.initCooldown);
        builder.add_cooldown(args.cooldown);
        builder.add_priority(args.priority);
        if let Some(x) = args.prefabKey {
            builder.add_prefabKey(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_LevelData_EnemyData_ESkillDataT {
        let prefabKey = self.prefabKey().map(|x| x.to_string());
        let priority = self.priority();
        let cooldown = self.cooldown();
        let initCooldown = self.initCooldown();
        let spCost = self.spCost();
        let blackboard = self
            .blackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_LevelData_EnemyData_ESkillDataT {
            prefabKey,
            priority,
            cooldown,
            initCooldown,
            spCost,
            blackboard,
        }
    }

    #[inline]
    pub fn prefabKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_EnemyData_ESkillData::VT_PREFABKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn priority(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_LevelData_EnemyData_ESkillData::VT_PRIORITY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn cooldown(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_LevelData_EnemyData_ESkillData::VT_COOLDOWN,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn initCooldown(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_LevelData_EnemyData_ESkillData::VT_INITCOOLDOWN,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn spCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_LevelData_EnemyData_ESkillData::VT_SPCOST,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(
                clz_Torappu_LevelData_EnemyData_ESkillData::VT_BLACKBOARD,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LevelData_EnemyData_ESkillData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "prefabKey",
                Self::VT_PREFABKEY,
                false,
            )?
            .visit_field::<i32>("priority", Self::VT_PRIORITY, false)?
            .visit_field::<f32>("cooldown", Self::VT_COOLDOWN, false)?
            .visit_field::<f32>("initCooldown", Self::VT_INITCOOLDOWN, false)?
            .visit_field::<i32>("spCost", Self::VT_SPCOST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LevelData_EnemyData_ESkillDataArgs<'a> {
    pub prefabKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub priority: i32,
    pub cooldown: f32,
    pub initCooldown: f32,
    pub spCost: i32,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_LevelData_EnemyData_ESkillDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LevelData_EnemyData_ESkillDataArgs {
            prefabKey: None,
            priority: 0,
            cooldown: 0.0,
            initCooldown: 0.0,
            spCost: 0,
            blackboard: None,
        }
    }
}

impl Serialize for clz_Torappu_LevelData_EnemyData_ESkillData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_LevelData_EnemyData_ESkillData", 6)?;
        if let Some(f) = self.prefabKey() {
            s.serialize_field("prefabKey", &f)?;
        } else {
            s.skip_field("prefabKey")?;
        }
        s.serialize_field("priority", &self.priority())?;
        s.serialize_field("cooldown", &self.cooldown())?;
        s.serialize_field("initCooldown", &self.initCooldown())?;
        s.serialize_field("spCost", &self.spCost())?;
        if let Some(f) = self.blackboard() {
            s.serialize_field("blackboard", &f)?;
        } else {
            s.skip_field("blackboard")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_LevelData_EnemyData_ESkillDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_LevelData_EnemyData_ESkillDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_prefabKey(&mut self, prefabKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_EnemyData_ESkillData::VT_PREFABKEY,
            prefabKey,
        );
    }
    #[inline]
    pub fn add_priority(&mut self, priority: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_LevelData_EnemyData_ESkillData::VT_PRIORITY,
            priority,
            0,
        );
    }
    #[inline]
    pub fn add_cooldown(&mut self, cooldown: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_LevelData_EnemyData_ESkillData::VT_COOLDOWN,
            cooldown,
            0.0,
        );
    }
    #[inline]
    pub fn add_initCooldown(&mut self, initCooldown: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_LevelData_EnemyData_ESkillData::VT_INITCOOLDOWN,
            initCooldown,
            0.0,
        );
    }
    #[inline]
    pub fn add_spCost(&mut self, spCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_LevelData_EnemyData_ESkillData::VT_SPCOST,
            spCost,
            0,
        );
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_EnemyData_ESkillData::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LevelData_EnemyData_ESkillDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LevelData_EnemyData_ESkillDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData_ESkillData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LevelData_EnemyData_ESkillData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LevelData_EnemyData_ESkillData");
        ds.field("prefabKey", &self.prefabKey());
        ds.field("priority", &self.priority());
        ds.field("cooldown", &self.cooldown());
        ds.field("initCooldown", &self.initCooldown());
        ds.field("spCost", &self.spCost());
        ds.field("blackboard", &self.blackboard());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_LevelData_EnemyData_ESkillDataT {
    pub prefabKey: Option<String>,
    pub priority: i32,
    pub cooldown: f32,
    pub initCooldown: f32,
    pub spCost: i32,
    pub blackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
}
impl Default for clz_Torappu_LevelData_EnemyData_ESkillDataT {
    fn default() -> Self {
        Self {
            prefabKey: None,
            priority: 0,
            cooldown: 0.0,
            initCooldown: 0.0,
            spCost: 0,
            blackboard: None,
        }
    }
}
impl clz_Torappu_LevelData_EnemyData_ESkillDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData_ESkillData<'b>> {
        let prefabKey = self.prefabKey.as_ref().map(|x| _fbb.create_string(x));
        let priority = self.priority;
        let cooldown = self.cooldown;
        let initCooldown = self.initCooldown;
        let spCost = self.spCost;
        let blackboard = self.blackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_LevelData_EnemyData_ESkillData::create(
            _fbb,
            &clz_Torappu_LevelData_EnemyData_ESkillDataArgs {
                prefabKey,
                priority,
                cooldown,
                initCooldown,
                spCost,
                blackboard,
            },
        )
    }
}
pub enum clz_Torappu_LevelData_EnemyData_ESpDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LevelData_EnemyData_ESpData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LevelData_EnemyData_ESpData<'a> {
    type Inner = clz_Torappu_LevelData_EnemyData_ESpData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_LevelData_EnemyData_ESpData<'a> {
    pub const VT_SPTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_MAXSP: flatbuffers::VOffsetT = 6;
    pub const VT_INITSP: flatbuffers::VOffsetT = 8;
    pub const VT_INCREMENT: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LevelData_EnemyData_ESpData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LevelData_EnemyData_ESpDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData_ESpData<'bldr>> {
        let mut builder = clz_Torappu_LevelData_EnemyData_ESpDataBuilder::new(_fbb);
        builder.add_increment(args.increment);
        builder.add_initSp(args.initSp);
        builder.add_maxSp(args.maxSp);
        builder.add_spType(args.spType);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_LevelData_EnemyData_ESpDataT {
        let spType = self.spType();
        let maxSp = self.maxSp();
        let initSp = self.initSp();
        let increment = self.increment();
        clz_Torappu_LevelData_EnemyData_ESpDataT {
            spType,
            maxSp,
            initSp,
            increment,
        }
    }

    #[inline]
    pub fn spType(&self) -> enum__Torappu_SpType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SpType>(
                    clz_Torappu_LevelData_EnemyData_ESpData::VT_SPTYPE,
                    Some(enum__Torappu_SpType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxSp(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_LevelData_EnemyData_ESpData::VT_MAXSP, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn initSp(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_LevelData_EnemyData_ESpData::VT_INITSP, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn increment(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_LevelData_EnemyData_ESpData::VT_INCREMENT,
                    Some(0.0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LevelData_EnemyData_ESpData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SpType>("spType", Self::VT_SPTYPE, false)?
            .visit_field::<i32>("maxSp", Self::VT_MAXSP, false)?
            .visit_field::<i32>("initSp", Self::VT_INITSP, false)?
            .visit_field::<f32>("increment", Self::VT_INCREMENT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LevelData_EnemyData_ESpDataArgs {
    pub spType: enum__Torappu_SpType,
    pub maxSp: i32,
    pub initSp: i32,
    pub increment: f32,
}
impl<'a> Default for clz_Torappu_LevelData_EnemyData_ESpDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LevelData_EnemyData_ESpDataArgs {
            spType: enum__Torappu_SpType::NONE,
            maxSp: 0,
            initSp: 0,
            increment: 0.0,
        }
    }
}

impl Serialize for clz_Torappu_LevelData_EnemyData_ESpData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_LevelData_EnemyData_ESpData", 4)?;
        s.serialize_field("spType", &self.spType())?;
        s.serialize_field("maxSp", &self.maxSp())?;
        s.serialize_field("initSp", &self.initSp())?;
        s.serialize_field("increment", &self.increment())?;
        s.end()
    }
}

pub struct clz_Torappu_LevelData_EnemyData_ESpDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_LevelData_EnemyData_ESpDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_spType(&mut self, spType: enum__Torappu_SpType) {
        self.fbb_.push_slot::<enum__Torappu_SpType>(
            clz_Torappu_LevelData_EnemyData_ESpData::VT_SPTYPE,
            spType,
            enum__Torappu_SpType::NONE,
        );
    }
    #[inline]
    pub fn add_maxSp(&mut self, maxSp: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_LevelData_EnemyData_ESpData::VT_MAXSP, maxSp, 0);
    }
    #[inline]
    pub fn add_initSp(&mut self, initSp: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_LevelData_EnemyData_ESpData::VT_INITSP,
            initSp,
            0,
        );
    }
    #[inline]
    pub fn add_increment(&mut self, increment: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_LevelData_EnemyData_ESpData::VT_INCREMENT,
            increment,
            0.0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LevelData_EnemyData_ESpDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LevelData_EnemyData_ESpDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData_ESpData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LevelData_EnemyData_ESpData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LevelData_EnemyData_ESpData");
        ds.field("spType", &self.spType());
        ds.field("maxSp", &self.maxSp());
        ds.field("initSp", &self.initSp());
        ds.field("increment", &self.increment());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_LevelData_EnemyData_ESpDataT {
    pub spType: enum__Torappu_SpType,
    pub maxSp: i32,
    pub initSp: i32,
    pub increment: f32,
}
impl Default for clz_Torappu_LevelData_EnemyData_ESpDataT {
    fn default() -> Self {
        Self {
            spType: enum__Torappu_SpType::NONE,
            maxSp: 0,
            initSp: 0,
            increment: 0.0,
        }
    }
}
impl clz_Torappu_LevelData_EnemyData_ESpDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData_ESpData<'b>> {
        let spType = self.spType;
        let maxSp = self.maxSp;
        let initSp = self.initSp;
        let increment = self.increment;
        clz_Torappu_LevelData_EnemyData_ESpData::create(
            _fbb,
            &clz_Torappu_LevelData_EnemyData_ESpDataArgs {
                spType,
                maxSp,
                initSp,
                increment,
            },
        )
    }
}
pub enum clz_Torappu_EnemyDatabase_EnemyDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_EnemyDatabase_EnemyData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_EnemyDatabase_EnemyData<'a> {
    type Inner = clz_Torappu_EnemyDatabase_EnemyData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_EnemyDatabase_EnemyData<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
    pub const VT_PREFABKEY: flatbuffers::VOffsetT = 8;
    pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 10;
    pub const VT_APPLYWAY: flatbuffers::VOffsetT = 12;
    pub const VT_MOTION: flatbuffers::VOffsetT = 14;
    pub const VT_ENEMYTAGS: flatbuffers::VOffsetT = 16;
    pub const VT_LIFEPOINTREDUCE: flatbuffers::VOffsetT = 18;
    pub const VT_LEVELTYPE: flatbuffers::VOffsetT = 20;
    pub const VT_RANGERADIUS: flatbuffers::VOffsetT = 22;
    pub const VT_NUMOFEXTRADROPS: flatbuffers::VOffsetT = 24;
    pub const VT_VIEWRADIUS: flatbuffers::VOffsetT = 26;
    pub const VT_NOTCOUNTINTOTAL: flatbuffers::VOffsetT = 28;
    pub const VT_TALENTBLACKBOARD: flatbuffers::VOffsetT = 30;
    pub const VT_SKILLS: flatbuffers::VOffsetT = 32;
    pub const VT_SPDATA: flatbuffers::VOffsetT = 34;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_EnemyDatabase_EnemyData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_EnemyDatabase_EnemyDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_EnemyData<'bldr>> {
        let mut builder = clz_Torappu_EnemyDatabase_EnemyDataBuilder::new(_fbb);
        if let Some(x) = args.spData {
            builder.add_spData(x);
        }
        if let Some(x) = args.skills {
            builder.add_skills(x);
        }
        if let Some(x) = args.talentBlackboard {
            builder.add_talentBlackboard(x);
        }
        if let Some(x) = args.notCountInTotal {
            builder.add_notCountInTotal(x);
        }
        if let Some(x) = args.viewRadius {
            builder.add_viewRadius(x);
        }
        if let Some(x) = args.numOfExtraDrops {
            builder.add_numOfExtraDrops(x);
        }
        if let Some(x) = args.rangeRadius {
            builder.add_rangeRadius(x);
        }
        if let Some(x) = args.levelType {
            builder.add_levelType(x);
        }
        if let Some(x) = args.lifePointReduce {
            builder.add_lifePointReduce(x);
        }
        if let Some(x) = args.enemyTags {
            builder.add_enemyTags(x);
        }
        if let Some(x) = args.motion {
            builder.add_motion(x);
        }
        if let Some(x) = args.applyWay {
            builder.add_applyWay(x);
        }
        if let Some(x) = args.attributes {
            builder.add_attributes(x);
        }
        if let Some(x) = args.prefabKey {
            builder.add_prefabKey(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_EnemyDatabase_EnemyDataT {
        let name = self.name().map(|x| Box::new(x.unpack()));
        let description = self.description().map(|x| Box::new(x.unpack()));
        let prefabKey = self.prefabKey().map(|x| Box::new(x.unpack()));
        let attributes = self.attributes().map(|x| Box::new(x.unpack()));
        let applyWay = self.applyWay().map(|x| Box::new(x.unpack()));
        let motion = self.motion().map(|x| Box::new(x.unpack()));
        let enemyTags = self.enemyTags().map(|x| Box::new(x.unpack()));
        let lifePointReduce = self.lifePointReduce().map(|x| Box::new(x.unpack()));
        let levelType = self.levelType().map(|x| Box::new(x.unpack()));
        let rangeRadius = self.rangeRadius().map(|x| Box::new(x.unpack()));
        let numOfExtraDrops = self.numOfExtraDrops().map(|x| Box::new(x.unpack()));
        let viewRadius = self.viewRadius().map(|x| Box::new(x.unpack()));
        let notCountInTotal = self.notCountInTotal().map(|x| Box::new(x.unpack()));
        let talentBlackboard = self
            .talentBlackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let skills = self
            .skills()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let spData = self.spData().map(|x| Box::new(x.unpack()));
        clz_Torappu_EnemyDatabase_EnemyDataT {
            name,
            description,
            prefabKey,
            attributes,
            applyWay,
            motion,
            enemyTags,
            lifePointReduce,
            levelType,
            rangeRadius,
            numOfExtraDrops,
            viewRadius,
            notCountInTotal,
            talentBlackboard,
            skills,
            spData,
        }
    }

    #[inline]
    pub fn name(&self) -> Option<clz_Torappu_Undefinable_1_System_String_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_String_>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_NAME,
                    None,
                )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<clz_Torappu_Undefinable_1_System_String_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_String_>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_DESCRIPTION,
                    None,
                )
        }
    }
    #[inline]
    pub fn prefabKey(&self) -> Option<clz_Torappu_Undefinable_1_System_String_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_String_>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_PREFABKEY,
                    None,
                )
        }
    }
    #[inline]
    pub fn attributes(&self) -> Option<clz_Torappu_EnemyDatabase_AttributesData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyDatabase_AttributesData>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_ATTRIBUTES,
                    None,
                )
        }
    }
    #[inline]
    pub fn applyWay(&self) -> Option<clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_>>(clz_Torappu_EnemyDatabase_EnemyData::VT_APPLYWAY, None)
        }
    }
    #[inline]
    pub fn motion(&self) -> Option<clz_Torappu_Undefinable_1_Torappu_MotionMode_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_Torappu_MotionMode_>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_MOTION,
                    None,
                )
        }
    }
    #[inline]
    pub fn enemyTags(&self) -> Option<clz_Torappu_Undefinable_1_System_String___<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_String___>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_ENEMYTAGS,
                    None,
                )
        }
    }
    #[inline]
    pub fn lifePointReduce(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_LIFEPOINTREDUCE,
                    None,
                )
        }
    }
    #[inline]
    pub fn levelType(&self) -> Option<clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_>>(clz_Torappu_EnemyDatabase_EnemyData::VT_LEVELTYPE, None)
        }
    }
    #[inline]
    pub fn rangeRadius(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_RANGERADIUS,
                    None,
                )
        }
    }
    #[inline]
    pub fn numOfExtraDrops(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_NUMOFEXTRADROPS,
                    None,
                )
        }
    }
    #[inline]
    pub fn viewRadius(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_VIEWRADIUS,
                    None,
                )
        }
    }
    #[inline]
    pub fn notCountInTotal(&self) -> Option<clz_Torappu_Undefinable_1_System_Boolean_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_NOTCOUNTINTOTAL,
                    None,
                )
        }
    }
    #[inline]
    pub fn talentBlackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_TALENTBLACKBOARD,
                None,
            )
        }
    }
    #[inline]
    pub fn skills(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData_ESkillData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData_ESkillData>,
                >,
            >>(clz_Torappu_EnemyDatabase_EnemyData::VT_SKILLS, None)
        }
    }
    #[inline]
    pub fn spData(&self) -> Option<clz_Torappu_LevelData_EnemyData_ESpData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData_ESpData>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_SPDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_EnemyDatabase_EnemyData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_String_>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_String_>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_String_>>("prefabKey", Self::VT_PREFABKEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyDatabase_AttributesData>>("attributes", Self::VT_ATTRIBUTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_>>("applyWay", Self::VT_APPLYWAY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_Torappu_MotionMode_>>("motion", Self::VT_MOTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_String___>>("enemyTags", Self::VT_ENEMYTAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>("lifePointReduce", Self::VT_LIFEPOINTREDUCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_>>("levelType", Self::VT_LEVELTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>("rangeRadius", Self::VT_RANGERADIUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>("numOfExtraDrops", Self::VT_NUMOFEXTRADROPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>("viewRadius", Self::VT_VIEWRADIUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>("notCountInTotal", Self::VT_NOTCOUNTINTOTAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>>>>("talentBlackboard", Self::VT_TALENTBLACKBOARD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData_ESkillData>>>>("skills", Self::VT_SKILLS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData_ESpData>>("spData", Self::VT_SPDATA, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_EnemyDatabase_EnemyDataArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_<'a>>>,
    pub description: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_<'a>>>,
    pub prefabKey: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_<'a>>>,
    pub attributes: Option<flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_AttributesData<'a>>>,
    pub applyWay:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'a>>>,
    pub motion: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_MotionMode_<'a>>>,
    pub enemyTags: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String___<'a>>>,
    pub lifePointReduce:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub levelType:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'a>>>,
    pub rangeRadius: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub numOfExtraDrops:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub viewRadius: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub notCountInTotal:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'a>>>,
    pub talentBlackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
    pub skills: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData_ESkillData<'a>>,
            >,
        >,
    >,
    pub spData: Option<flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData_ESpData<'a>>>,
}
impl<'a> Default for clz_Torappu_EnemyDatabase_EnemyDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_EnemyDatabase_EnemyDataArgs {
            name: None,
            description: None,
            prefabKey: None,
            attributes: None,
            applyWay: None,
            motion: None,
            enemyTags: None,
            lifePointReduce: None,
            levelType: None,
            rangeRadius: None,
            numOfExtraDrops: None,
            viewRadius: None,
            notCountInTotal: None,
            talentBlackboard: None,
            skills: None,
            spData: None,
        }
    }
}

impl Serialize for clz_Torappu_EnemyDatabase_EnemyData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_EnemyDatabase_EnemyData", 16)?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        if let Some(f) = self.prefabKey() {
            s.serialize_field("prefabKey", &f)?;
        } else {
            s.skip_field("prefabKey")?;
        }
        if let Some(f) = self.attributes() {
            s.serialize_field("attributes", &f)?;
        } else {
            s.skip_field("attributes")?;
        }
        if let Some(f) = self.applyWay() {
            s.serialize_field("applyWay", &f)?;
        } else {
            s.skip_field("applyWay")?;
        }
        if let Some(f) = self.motion() {
            s.serialize_field("motion", &f)?;
        } else {
            s.skip_field("motion")?;
        }
        if let Some(f) = self.enemyTags() {
            s.serialize_field("enemyTags", &f)?;
        } else {
            s.skip_field("enemyTags")?;
        }
        if let Some(f) = self.lifePointReduce() {
            s.serialize_field("lifePointReduce", &f)?;
        } else {
            s.skip_field("lifePointReduce")?;
        }
        if let Some(f) = self.levelType() {
            s.serialize_field("levelType", &f)?;
        } else {
            s.skip_field("levelType")?;
        }
        if let Some(f) = self.rangeRadius() {
            s.serialize_field("rangeRadius", &f)?;
        } else {
            s.skip_field("rangeRadius")?;
        }
        if let Some(f) = self.numOfExtraDrops() {
            s.serialize_field("numOfExtraDrops", &f)?;
        } else {
            s.skip_field("numOfExtraDrops")?;
        }
        if let Some(f) = self.viewRadius() {
            s.serialize_field("viewRadius", &f)?;
        } else {
            s.skip_field("viewRadius")?;
        }
        if let Some(f) = self.notCountInTotal() {
            s.serialize_field("notCountInTotal", &f)?;
        } else {
            s.skip_field("notCountInTotal")?;
        }
        if let Some(f) = self.talentBlackboard() {
            s.serialize_field("talentBlackboard", &f)?;
        } else {
            s.skip_field("talentBlackboard")?;
        }
        if let Some(f) = self.skills() {
            s.serialize_field("skills", &f)?;
        } else {
            s.skip_field("skills")?;
        }
        if let Some(f) = self.spData() {
            s.serialize_field("spData", &f)?;
        } else {
            s.skip_field("spData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_EnemyDatabase_EnemyDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_EnemyDatabase_EnemyDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_name(
        &mut self,
        name: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_>>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_NAME,
                name,
            );
    }
    #[inline]
    pub fn add_description(
        &mut self,
        description: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_>>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_DESCRIPTION,
                description,
            );
    }
    #[inline]
    pub fn add_prefabKey(
        &mut self,
        prefabKey: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_>>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_PREFABKEY,
                prefabKey,
            );
    }
    #[inline]
    pub fn add_attributes(
        &mut self,
        attributes: flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_AttributesData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_AttributesData>>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_ATTRIBUTES,
                attributes,
            );
    }
    #[inline]
    pub fn add_applyWay(
        &mut self,
        applyWay: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_>>(clz_Torappu_EnemyDatabase_EnemyData::VT_APPLYWAY, applyWay);
    }
    #[inline]
    pub fn add_motion(
        &mut self,
        motion: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_MotionMode_<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_MotionMode_>>(clz_Torappu_EnemyDatabase_EnemyData::VT_MOTION, motion);
    }
    #[inline]
    pub fn add_enemyTags(
        &mut self,
        enemyTags: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String___<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String___>>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_ENEMYTAGS,
                enemyTags,
            );
    }
    #[inline]
    pub fn add_lifePointReduce(
        &mut self,
        lifePointReduce: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_LIFEPOINTREDUCE,
                lifePointReduce,
            );
    }
    #[inline]
    pub fn add_levelType(
        &mut self,
        levelType: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_>>(clz_Torappu_EnemyDatabase_EnemyData::VT_LEVELTYPE, levelType);
    }
    #[inline]
    pub fn add_rangeRadius(
        &mut self,
        rangeRadius: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_RANGERADIUS,
                rangeRadius,
            );
    }
    #[inline]
    pub fn add_numOfExtraDrops(
        &mut self,
        numOfExtraDrops: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_NUMOFEXTRADROPS,
                numOfExtraDrops,
            );
    }
    #[inline]
    pub fn add_viewRadius(
        &mut self,
        viewRadius: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_VIEWRADIUS,
                viewRadius,
            );
    }
    #[inline]
    pub fn add_notCountInTotal(
        &mut self,
        notCountInTotal: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_NOTCOUNTINTOTAL,
                notCountInTotal,
            );
    }
    #[inline]
    pub fn add_talentBlackboard(
        &mut self,
        talentBlackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyDatabase_EnemyData::VT_TALENTBLACKBOARD,
            talentBlackboard,
        );
    }
    #[inline]
    pub fn add_skills(
        &mut self,
        skills: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData_ESkillData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyDatabase_EnemyData::VT_SKILLS,
            skills,
        );
    }
    #[inline]
    pub fn add_spData(
        &mut self,
        spData: flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData_ESpData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData_ESpData>>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_SPDATA,
                spData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_EnemyDatabase_EnemyDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_EnemyDatabase_EnemyDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_EnemyData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_EnemyDatabase_EnemyData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_EnemyDatabase_EnemyData");
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.field("prefabKey", &self.prefabKey());
        ds.field("attributes", &self.attributes());
        ds.field("applyWay", &self.applyWay());
        ds.field("motion", &self.motion());
        ds.field("enemyTags", &self.enemyTags());
        ds.field("lifePointReduce", &self.lifePointReduce());
        ds.field("levelType", &self.levelType());
        ds.field("rangeRadius", &self.rangeRadius());
        ds.field("numOfExtraDrops", &self.numOfExtraDrops());
        ds.field("viewRadius", &self.viewRadius());
        ds.field("notCountInTotal", &self.notCountInTotal());
        ds.field("talentBlackboard", &self.talentBlackboard());
        ds.field("skills", &self.skills());
        ds.field("spData", &self.spData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_EnemyDatabase_EnemyDataT {
    pub name: Option<Box<clz_Torappu_Undefinable_1_System_String_T>>,
    pub description: Option<Box<clz_Torappu_Undefinable_1_System_String_T>>,
    pub prefabKey: Option<Box<clz_Torappu_Undefinable_1_System_String_T>>,
    pub attributes: Option<Box<clz_Torappu_EnemyDatabase_AttributesDataT>>,
    pub applyWay: Option<Box<clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_T>>,
    pub motion: Option<Box<clz_Torappu_Undefinable_1_Torappu_MotionMode_T>>,
    pub enemyTags: Option<Box<clz_Torappu_Undefinable_1_System_String___T>>,
    pub lifePointReduce: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub levelType: Option<Box<clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_T>>,
    pub rangeRadius: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub numOfExtraDrops: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub viewRadius: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub notCountInTotal: Option<Box<clz_Torappu_Undefinable_1_System_Boolean_T>>,
    pub talentBlackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
    pub skills: Option<Vec<clz_Torappu_LevelData_EnemyData_ESkillDataT>>,
    pub spData: Option<Box<clz_Torappu_LevelData_EnemyData_ESpDataT>>,
}
impl Default for clz_Torappu_EnemyDatabase_EnemyDataT {
    fn default() -> Self {
        Self {
            name: None,
            description: None,
            prefabKey: None,
            attributes: None,
            applyWay: None,
            motion: None,
            enemyTags: None,
            lifePointReduce: None,
            levelType: None,
            rangeRadius: None,
            numOfExtraDrops: None,
            viewRadius: None,
            notCountInTotal: None,
            talentBlackboard: None,
            skills: None,
            spData: None,
        }
    }
}
impl clz_Torappu_EnemyDatabase_EnemyDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_EnemyData<'b>> {
        let name = self.name.as_ref().map(|x| x.pack(_fbb));
        let description = self.description.as_ref().map(|x| x.pack(_fbb));
        let prefabKey = self.prefabKey.as_ref().map(|x| x.pack(_fbb));
        let attributes = self.attributes.as_ref().map(|x| x.pack(_fbb));
        let applyWay = self.applyWay.as_ref().map(|x| x.pack(_fbb));
        let motion = self.motion.as_ref().map(|x| x.pack(_fbb));
        let enemyTags = self.enemyTags.as_ref().map(|x| x.pack(_fbb));
        let lifePointReduce = self.lifePointReduce.as_ref().map(|x| x.pack(_fbb));
        let levelType = self.levelType.as_ref().map(|x| x.pack(_fbb));
        let rangeRadius = self.rangeRadius.as_ref().map(|x| x.pack(_fbb));
        let numOfExtraDrops = self.numOfExtraDrops.as_ref().map(|x| x.pack(_fbb));
        let viewRadius = self.viewRadius.as_ref().map(|x| x.pack(_fbb));
        let notCountInTotal = self.notCountInTotal.as_ref().map(|x| x.pack(_fbb));
        let talentBlackboard = self.talentBlackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let skills = self.skills.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let spData = self.spData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_EnemyDatabase_EnemyData::create(
            _fbb,
            &clz_Torappu_EnemyDatabase_EnemyDataArgs {
                name,
                description,
                prefabKey,
                attributes,
                applyWay,
                motion,
                enemyTags,
                lifePointReduce,
                levelType,
                rangeRadius,
                numOfExtraDrops,
                viewRadius,
                notCountInTotal,
                talentBlackboard,
                skills,
                spData,
            },
        )
    }
}
pub enum clz_Torappu_EnemyDatabase_EnemyLevelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_EnemyDatabase_EnemyLevel<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_EnemyDatabase_EnemyLevel<'a> {
    type Inner = clz_Torappu_EnemyDatabase_EnemyLevel<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_EnemyDatabase_EnemyLevel<'a> {
    pub const VT_LEVEL: flatbuffers::VOffsetT = 4;
    pub const VT_ENEMYDATA: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_EnemyDatabase_EnemyLevel { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_EnemyDatabase_EnemyLevelArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_EnemyLevel<'bldr>> {
        let mut builder = clz_Torappu_EnemyDatabase_EnemyLevelBuilder::new(_fbb);
        if let Some(x) = args.enemyData {
            builder.add_enemyData(x);
        }
        builder.add_level(args.level);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_EnemyDatabase_EnemyLevelT {
        let level = self.level();
        let enemyData = self.enemyData().map(|x| Box::new(x.unpack()));
        clz_Torappu_EnemyDatabase_EnemyLevelT { level, enemyData }
    }

    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_EnemyDatabase_EnemyLevel::VT_LEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn enemyData(&self) -> Option<clz_Torappu_EnemyDatabase_EnemyData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyDatabase_EnemyData>>(
                    clz_Torappu_EnemyDatabase_EnemyLevel::VT_ENEMYDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_EnemyDatabase_EnemyLevel<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyDatabase_EnemyData>>(
                "enemyData",
                Self::VT_ENEMYDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_EnemyDatabase_EnemyLevelArgs<'a> {
    pub level: i32,
    pub enemyData: Option<flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_EnemyData<'a>>>,
}
impl<'a> Default for clz_Torappu_EnemyDatabase_EnemyLevelArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_EnemyDatabase_EnemyLevelArgs {
            level: 0,
            enemyData: None,
        }
    }
}

impl Serialize for clz_Torappu_EnemyDatabase_EnemyLevel<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_EnemyDatabase_EnemyLevel", 2)?;
        s.serialize_field("level", &self.level())?;
        if let Some(f) = self.enemyData() {
            s.serialize_field("enemyData", &f)?;
        } else {
            s.skip_field("enemyData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_EnemyDatabase_EnemyLevelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_EnemyDatabase_EnemyLevelBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_EnemyDatabase_EnemyLevel::VT_LEVEL, level, 0);
    }
    #[inline]
    pub fn add_enemyData(
        &mut self,
        enemyData: flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_EnemyData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_EnemyData>>(
                clz_Torappu_EnemyDatabase_EnemyLevel::VT_ENEMYDATA,
                enemyData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_EnemyDatabase_EnemyLevelBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_EnemyDatabase_EnemyLevelBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_EnemyLevel<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_EnemyDatabase_EnemyLevel<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_EnemyDatabase_EnemyLevel");
        ds.field("level", &self.level());
        ds.field("enemyData", &self.enemyData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_EnemyDatabase_EnemyLevelT {
    pub level: i32,
    pub enemyData: Option<Box<clz_Torappu_EnemyDatabase_EnemyDataT>>,
}
impl Default for clz_Torappu_EnemyDatabase_EnemyLevelT {
    fn default() -> Self {
        Self {
            level: 0,
            enemyData: None,
        }
    }
}
impl clz_Torappu_EnemyDatabase_EnemyLevelT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_EnemyLevel<'b>> {
        let level = self.level;
        let enemyData = self.enemyData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_EnemyDatabase_EnemyLevel::create(
            _fbb,
            &clz_Torappu_EnemyDatabase_EnemyLevelArgs { level, enemyData },
        )
    }
}
pub enum kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel<'a> {
    type Inner = kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevelArgs<'args>,
    ) -> flatbuffers::WIPOffset<kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel<'bldr>> {
        let mut builder = kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevelBuilder::new(_fbb);
        if let Some(x) = args.Value {
            builder.add_Value(x);
        }
        if let Some(x) = args.Key {
            builder.add_Key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevelT {
        let Key = {
            let x = self.Key();
            x.to_string()
        };
        let Value = self.Value().map(|x| x.iter().map(|t| t.unpack()).collect());
        kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevelT { Key, Value }
    }

    #[inline]
    pub fn Key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel,
    ) -> bool {
        self.Key() < o.Key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.Key();
        key.cmp(val)
    }
    #[inline]
    pub fn Value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_EnemyDatabase_EnemyLevel<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_EnemyDatabase_EnemyLevel>,
                >,
            >>(
                kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("Key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_EnemyDatabase_EnemyLevel>,
                >,
            >>("Value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevelArgs<'a> {
    pub Key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub Value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_EnemyDatabase_EnemyLevel<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevelArgs<'a> {
    #[inline]
    fn default() -> Self {
        kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevelArgs {
            Key: None, // required field
            Value: None,
        }
    }
}

impl Serialize for kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel", 2)?;
        s.serialize_field("Key", &self.Key())?;
        if let Some(f) = self.Value() {
            s.serialize_field("Value", &f)?;
        } else {
            s.skip_field("Value")?;
        }
        s.end()
    }
}

pub struct kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevelBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevelBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_Key(&mut self, Key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel::VT_KEY,
            Key,
        );
    }
    #[inline]
    pub fn add_Value(
        &mut self,
        Value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_EnemyDatabase_EnemyLevel<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel::VT_VALUE,
            Value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevelBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevelBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel::VT_KEY,
            "Key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel");
        ds.field("Key", &self.Key());
        ds.field("Value", &self.Value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevelT {
    pub Key: String,
    pub Value: Option<Vec<clz_Torappu_EnemyDatabase_EnemyLevelT>>,
}
impl Default for kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevelT {
    fn default() -> Self {
        Self {
            Key: "".to_string(),
            Value: None,
        }
    }
}
impl kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevelT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel<'b>> {
        let Key = Some({
            let x = &self.Key;
            _fbb.create_string(x)
        });
        let Value = self.Value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel::create(
            _fbb,
            &kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevelArgs { Key, Value },
        )
    }
}
pub enum clz_Torappu_EnemyDatabaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_EnemyDatabase<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_EnemyDatabase<'a> {
    type Inner = clz_Torappu_EnemyDatabase<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_EnemyDatabase<'a> {
    pub const VT_ENEMIES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_EnemyDatabase { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_EnemyDatabaseArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase<'bldr>> {
        let mut builder = clz_Torappu_EnemyDatabaseBuilder::new(_fbb);
        if let Some(x) = args.enemies {
            builder.add_enemies(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_EnemyDatabaseT {
        let enemies = self
            .enemies()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_EnemyDatabaseT { enemies }
    }

    #[inline]
    pub fn enemies(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel,
                    >,
                >,
            >>(clz_Torappu_EnemyDatabase::VT_ENEMIES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_EnemyDatabase<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel,
                    >,
                >,
            >>("enemies", Self::VT_ENEMIES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_EnemyDatabaseArgs<'a> {
    pub enemies: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_EnemyDatabaseArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_EnemyDatabaseArgs { enemies: None }
    }
}

impl Serialize for clz_Torappu_EnemyDatabase<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_EnemyDatabase", 1)?;
        if let Some(f) = self.enemies() {
            s.serialize_field("enemies", &f)?;
        } else {
            s.skip_field("enemies")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_EnemyDatabaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_EnemyDatabaseBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_enemies(
        &mut self,
        enemies: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevel<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyDatabase::VT_ENEMIES,
            enemies,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_EnemyDatabaseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_EnemyDatabaseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_EnemyDatabase<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_EnemyDatabase");
        ds.field("enemies", &self.enemies());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_EnemyDatabaseT {
    pub enemies: Option<Vec<kvp__string__list_clz_Torappu_EnemyDatabase_EnemyLevelT>>,
}
impl Default for clz_Torappu_EnemyDatabaseT {
    fn default() -> Self {
        Self { enemies: None }
    }
}
impl clz_Torappu_EnemyDatabaseT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase<'b>> {
        let enemies = self.enemies.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_EnemyDatabase::create(_fbb, &clz_Torappu_EnemyDatabaseArgs { enemies })
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_EnemyDatabase`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_enemy_database_unchecked`.
pub fn root_as_clz_torappu_enemy_database(
    buf: &[u8],
) -> Result<clz_Torappu_EnemyDatabase<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_EnemyDatabase>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_EnemyDatabase` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_enemy_database_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_enemy_database(
    buf: &[u8],
) -> Result<clz_Torappu_EnemyDatabase<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_EnemyDatabase>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_EnemyDatabase` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_enemy_database_unchecked`.
pub fn root_as_clz_torappu_enemy_database_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_EnemyDatabase<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_EnemyDatabase<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_EnemyDatabase` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_enemy_database_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_enemy_database_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_EnemyDatabase<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_EnemyDatabase<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_EnemyDatabase and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_EnemyDatabase`.
pub unsafe fn root_as_clz_torappu_enemy_database_unchecked(
    buf: &[u8],
) -> clz_Torappu_EnemyDatabase<'_> {
    unsafe { flatbuffers::root_unchecked::<clz_Torappu_EnemyDatabase>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_EnemyDatabase and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_EnemyDatabase`.
pub unsafe fn size_prefixed_root_as_clz_torappu_enemy_database_unchecked(
    buf: &[u8],
) -> clz_Torappu_EnemyDatabase<'_> {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_EnemyDatabase>(buf) }
}
#[inline]
pub fn finish_clz_torappu_enemy_database_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_enemy_database_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
