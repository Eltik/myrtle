// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_MINI_ACT_TRIAL_DATA_RULE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_MINI_ACT_TRIAL_DATA_RULE_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_MINI_ACT_TRIAL_DATA_RULE_TYPE:
    [enum__Torappu_MiniActTrialData_RuleType; 3] = [
    enum__Torappu_MiniActTrialData_RuleType::NONE,
    enum__Torappu_MiniActTrialData_RuleType::TITLE,
    enum__Torappu_MiniActTrialData_RuleType::CONTENT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_MiniActTrialData_RuleType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_MiniActTrialData_RuleType {
    pub const NONE: Self = Self(0);
    pub const TITLE: Self = Self(1);
    pub const CONTENT: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::TITLE, Self::CONTENT];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::TITLE => Some("TITLE"),
            Self::CONTENT => Some("CONTENT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_MiniActTrialData_RuleType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_MiniActTrialData_RuleType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_MiniActTrialData_RuleType {
    type Output = enum__Torappu_MiniActTrialData_RuleType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_MiniActTrialData_RuleType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_MiniActTrialData_RuleType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_MiniActTrialData_RuleType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ITEM_TYPE: i32 = 90;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ITEM_TYPE: [enum__Torappu_ItemType; 91] = [
    enum__Torappu_ItemType::NONE,
    enum__Torappu_ItemType::CHAR,
    enum__Torappu_ItemType::CARD_EXP,
    enum__Torappu_ItemType::MATERIAL,
    enum__Torappu_ItemType::GOLD,
    enum__Torappu_ItemType::EXP_PLAYER,
    enum__Torappu_ItemType::TKT_TRY,
    enum__Torappu_ItemType::TKT_RECRUIT,
    enum__Torappu_ItemType::TKT_INST_FIN,
    enum__Torappu_ItemType::TKT_GACHA,
    enum__Torappu_ItemType::ACTIVITY_COIN,
    enum__Torappu_ItemType::DIAMOND,
    enum__Torappu_ItemType::DIAMOND_SHD,
    enum__Torappu_ItemType::HGG_SHD,
    enum__Torappu_ItemType::LGG_SHD,
    enum__Torappu_ItemType::FURN,
    enum__Torappu_ItemType::AP_GAMEPLAY,
    enum__Torappu_ItemType::AP_BASE,
    enum__Torappu_ItemType::SOCIAL_PT,
    enum__Torappu_ItemType::CHAR_SKIN,
    enum__Torappu_ItemType::TKT_GACHA_10,
    enum__Torappu_ItemType::TKT_GACHA_PRSV,
    enum__Torappu_ItemType::AP_ITEM,
    enum__Torappu_ItemType::AP_SUPPLY,
    enum__Torappu_ItemType::RENAMING_CARD,
    enum__Torappu_ItemType::RENAMING_CARD_2,
    enum__Torappu_ItemType::ET_STAGE,
    enum__Torappu_ItemType::ACTIVITY_ITEM,
    enum__Torappu_ItemType::VOUCHER_PICK,
    enum__Torappu_ItemType::VOUCHER_CGACHA,
    enum__Torappu_ItemType::VOUCHER_MGACHA,
    enum__Torappu_ItemType::CRS_SHOP_COIN,
    enum__Torappu_ItemType::CRS_RUNE_COIN,
    enum__Torappu_ItemType::LMTGS_COIN,
    enum__Torappu_ItemType::EPGS_COIN,
    enum__Torappu_ItemType::LIMITED_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_FREE_GACHA,
    enum__Torappu_ItemType::REP_COIN,
    enum__Torappu_ItemType::ROGUELIKE,
    enum__Torappu_ItemType::LINKAGE_TKT_GACHA_10,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_4,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_5,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_6,
    enum__Torappu_ItemType::VOUCHER_SKIN,
    enum__Torappu_ItemType::RETRO_COIN,
    enum__Torappu_ItemType::PLAYER_AVATAR,
    enum__Torappu_ItemType::UNI_COLLECTION,
    enum__Torappu_ItemType::VOUCHER_FULL_POTENTIAL,
    enum__Torappu_ItemType::RL_COIN,
    enum__Torappu_ItemType::RETURN_CREDIT,
    enum__Torappu_ItemType::MEDAL,
    enum__Torappu_ItemType::CHARM,
    enum__Torappu_ItemType::HOME_BACKGROUND,
    enum__Torappu_ItemType::EXTERMINATION_AGENT,
    enum__Torappu_ItemType::OPTIONAL_VOUCHER_PICK,
    enum__Torappu_ItemType::ACT_CART_COMPONENT,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_4,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_4,
    enum__Torappu_ItemType::ACTIVITY_POTENTIAL,
    enum__Torappu_ItemType::ITEM_PACK,
    enum__Torappu_ItemType::SANDBOX,
    enum__Torappu_ItemType::FAVOR_ADD_ITEM,
    enum__Torappu_ItemType::CLASSIC_SHD,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_BUFF,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_5,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_6,
    enum__Torappu_ItemType::RETURN_PROGRESS,
    enum__Torappu_ItemType::NEW_PROGRESS,
    enum__Torappu_ItemType::MCARD_VOUCHER,
    enum__Torappu_ItemType::MATERIAL_ISSUE_VOUCHER,
    enum__Torappu_ItemType::CRS_SHOP_COIN_V2,
    enum__Torappu_ItemType::HOME_THEME,
    enum__Torappu_ItemType::SANDBOX_PERM,
    enum__Torappu_ItemType::SANDBOX_TOKEN,
    enum__Torappu_ItemType::TEMPLATE_TRAP,
    enum__Torappu_ItemType::NAME_CARD_SKIN,
    enum__Torappu_ItemType::EMOTICON_SET,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA_10,
    enum__Torappu_ItemType::SO_CHAR_EXP,
    enum__Torappu_ItemType::GIFTPACKAGE_TKT,
    enum__Torappu_ItemType::VOUCHER_SKIN_V2,
    enum__Torappu_ItemType::RANDOM_VOUCHER_SKIN,
    enum__Torappu_ItemType::ACT1VHALFIDLE_ITEM,
    enum__Torappu_ItemType::PLOT_ITEM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ItemType {
    pub const NONE: Self = Self(0);
    pub const CHAR: Self = Self(1);
    pub const CARD_EXP: Self = Self(2);
    pub const MATERIAL: Self = Self(3);
    pub const GOLD: Self = Self(4);
    pub const EXP_PLAYER: Self = Self(5);
    pub const TKT_TRY: Self = Self(6);
    pub const TKT_RECRUIT: Self = Self(7);
    pub const TKT_INST_FIN: Self = Self(8);
    pub const TKT_GACHA: Self = Self(9);
    pub const ACTIVITY_COIN: Self = Self(10);
    pub const DIAMOND: Self = Self(11);
    pub const DIAMOND_SHD: Self = Self(12);
    pub const HGG_SHD: Self = Self(13);
    pub const LGG_SHD: Self = Self(14);
    pub const FURN: Self = Self(15);
    pub const AP_GAMEPLAY: Self = Self(16);
    pub const AP_BASE: Self = Self(17);
    pub const SOCIAL_PT: Self = Self(18);
    pub const CHAR_SKIN: Self = Self(19);
    pub const TKT_GACHA_10: Self = Self(20);
    pub const TKT_GACHA_PRSV: Self = Self(21);
    pub const AP_ITEM: Self = Self(22);
    pub const AP_SUPPLY: Self = Self(23);
    pub const RENAMING_CARD: Self = Self(24);
    pub const RENAMING_CARD_2: Self = Self(25);
    pub const ET_STAGE: Self = Self(26);
    pub const ACTIVITY_ITEM: Self = Self(27);
    pub const VOUCHER_PICK: Self = Self(28);
    pub const VOUCHER_CGACHA: Self = Self(29);
    pub const VOUCHER_MGACHA: Self = Self(30);
    pub const CRS_SHOP_COIN: Self = Self(31);
    pub const CRS_RUNE_COIN: Self = Self(32);
    pub const LMTGS_COIN: Self = Self(33);
    pub const EPGS_COIN: Self = Self(34);
    pub const LIMITED_TKT_GACHA_10: Self = Self(35);
    pub const LIMITED_FREE_GACHA: Self = Self(36);
    pub const REP_COIN: Self = Self(37);
    pub const ROGUELIKE: Self = Self(38);
    pub const LINKAGE_TKT_GACHA_10: Self = Self(39);
    pub const VOUCHER_ELITE_II_4: Self = Self(40);
    pub const VOUCHER_ELITE_II_5: Self = Self(41);
    pub const VOUCHER_ELITE_II_6: Self = Self(42);
    pub const VOUCHER_SKIN: Self = Self(43);
    pub const RETRO_COIN: Self = Self(44);
    pub const PLAYER_AVATAR: Self = Self(45);
    pub const UNI_COLLECTION: Self = Self(46);
    pub const VOUCHER_FULL_POTENTIAL: Self = Self(47);
    pub const RL_COIN: Self = Self(48);
    pub const RETURN_CREDIT: Self = Self(49);
    pub const MEDAL: Self = Self(50);
    pub const CHARM: Self = Self(51);
    pub const HOME_BACKGROUND: Self = Self(52);
    pub const EXTERMINATION_AGENT: Self = Self(53);
    pub const OPTIONAL_VOUCHER_PICK: Self = Self(54);
    pub const ACT_CART_COMPONENT: Self = Self(55);
    pub const VOUCHER_LEVELMAX_6: Self = Self(56);
    pub const VOUCHER_LEVELMAX_5: Self = Self(57);
    pub const VOUCHER_LEVELMAX_4: Self = Self(58);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_6: Self = Self(59);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_5: Self = Self(60);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_4: Self = Self(61);
    pub const ACTIVITY_POTENTIAL: Self = Self(62);
    pub const ITEM_PACK: Self = Self(63);
    pub const SANDBOX: Self = Self(64);
    pub const FAVOR_ADD_ITEM: Self = Self(65);
    pub const CLASSIC_SHD: Self = Self(66);
    pub const CLASSIC_TKT_GACHA: Self = Self(67);
    pub const CLASSIC_TKT_GACHA_10: Self = Self(68);
    pub const LIMITED_BUFF: Self = Self(69);
    pub const CLASSIC_FES_PICK_TIER_5: Self = Self(70);
    pub const CLASSIC_FES_PICK_TIER_6: Self = Self(71);
    pub const RETURN_PROGRESS: Self = Self(72);
    pub const NEW_PROGRESS: Self = Self(73);
    pub const MCARD_VOUCHER: Self = Self(74);
    pub const MATERIAL_ISSUE_VOUCHER: Self = Self(75);
    pub const CRS_SHOP_COIN_V2: Self = Self(76);
    pub const HOME_THEME: Self = Self(77);
    pub const SANDBOX_PERM: Self = Self(78);
    pub const SANDBOX_TOKEN: Self = Self(79);
    pub const TEMPLATE_TRAP: Self = Self(80);
    pub const NAME_CARD_SKIN: Self = Self(81);
    pub const EMOTICON_SET: Self = Self(82);
    pub const EXCLUSIVE_TKT_GACHA: Self = Self(83);
    pub const EXCLUSIVE_TKT_GACHA_10: Self = Self(84);
    pub const SO_CHAR_EXP: Self = Self(85);
    pub const GIFTPACKAGE_TKT: Self = Self(86);
    pub const VOUCHER_SKIN_V2: Self = Self(87);
    pub const RANDOM_VOUCHER_SKIN: Self = Self(88);
    pub const ACT1VHALFIDLE_ITEM: Self = Self(89);
    pub const PLOT_ITEM: Self = Self(90);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 90;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::CHAR,
        Self::CARD_EXP,
        Self::MATERIAL,
        Self::GOLD,
        Self::EXP_PLAYER,
        Self::TKT_TRY,
        Self::TKT_RECRUIT,
        Self::TKT_INST_FIN,
        Self::TKT_GACHA,
        Self::ACTIVITY_COIN,
        Self::DIAMOND,
        Self::DIAMOND_SHD,
        Self::HGG_SHD,
        Self::LGG_SHD,
        Self::FURN,
        Self::AP_GAMEPLAY,
        Self::AP_BASE,
        Self::SOCIAL_PT,
        Self::CHAR_SKIN,
        Self::TKT_GACHA_10,
        Self::TKT_GACHA_PRSV,
        Self::AP_ITEM,
        Self::AP_SUPPLY,
        Self::RENAMING_CARD,
        Self::RENAMING_CARD_2,
        Self::ET_STAGE,
        Self::ACTIVITY_ITEM,
        Self::VOUCHER_PICK,
        Self::VOUCHER_CGACHA,
        Self::VOUCHER_MGACHA,
        Self::CRS_SHOP_COIN,
        Self::CRS_RUNE_COIN,
        Self::LMTGS_COIN,
        Self::EPGS_COIN,
        Self::LIMITED_TKT_GACHA_10,
        Self::LIMITED_FREE_GACHA,
        Self::REP_COIN,
        Self::ROGUELIKE,
        Self::LINKAGE_TKT_GACHA_10,
        Self::VOUCHER_ELITE_II_4,
        Self::VOUCHER_ELITE_II_5,
        Self::VOUCHER_ELITE_II_6,
        Self::VOUCHER_SKIN,
        Self::RETRO_COIN,
        Self::PLAYER_AVATAR,
        Self::UNI_COLLECTION,
        Self::VOUCHER_FULL_POTENTIAL,
        Self::RL_COIN,
        Self::RETURN_CREDIT,
        Self::MEDAL,
        Self::CHARM,
        Self::HOME_BACKGROUND,
        Self::EXTERMINATION_AGENT,
        Self::OPTIONAL_VOUCHER_PICK,
        Self::ACT_CART_COMPONENT,
        Self::VOUCHER_LEVELMAX_6,
        Self::VOUCHER_LEVELMAX_5,
        Self::VOUCHER_LEVELMAX_4,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_6,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_5,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_4,
        Self::ACTIVITY_POTENTIAL,
        Self::ITEM_PACK,
        Self::SANDBOX,
        Self::FAVOR_ADD_ITEM,
        Self::CLASSIC_SHD,
        Self::CLASSIC_TKT_GACHA,
        Self::CLASSIC_TKT_GACHA_10,
        Self::LIMITED_BUFF,
        Self::CLASSIC_FES_PICK_TIER_5,
        Self::CLASSIC_FES_PICK_TIER_6,
        Self::RETURN_PROGRESS,
        Self::NEW_PROGRESS,
        Self::MCARD_VOUCHER,
        Self::MATERIAL_ISSUE_VOUCHER,
        Self::CRS_SHOP_COIN_V2,
        Self::HOME_THEME,
        Self::SANDBOX_PERM,
        Self::SANDBOX_TOKEN,
        Self::TEMPLATE_TRAP,
        Self::NAME_CARD_SKIN,
        Self::EMOTICON_SET,
        Self::EXCLUSIVE_TKT_GACHA,
        Self::EXCLUSIVE_TKT_GACHA_10,
        Self::SO_CHAR_EXP,
        Self::GIFTPACKAGE_TKT,
        Self::VOUCHER_SKIN_V2,
        Self::RANDOM_VOUCHER_SKIN,
        Self::ACT1VHALFIDLE_ITEM,
        Self::PLOT_ITEM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::CHAR => Some("CHAR"),
            Self::CARD_EXP => Some("CARD_EXP"),
            Self::MATERIAL => Some("MATERIAL"),
            Self::GOLD => Some("GOLD"),
            Self::EXP_PLAYER => Some("EXP_PLAYER"),
            Self::TKT_TRY => Some("TKT_TRY"),
            Self::TKT_RECRUIT => Some("TKT_RECRUIT"),
            Self::TKT_INST_FIN => Some("TKT_INST_FIN"),
            Self::TKT_GACHA => Some("TKT_GACHA"),
            Self::ACTIVITY_COIN => Some("ACTIVITY_COIN"),
            Self::DIAMOND => Some("DIAMOND"),
            Self::DIAMOND_SHD => Some("DIAMOND_SHD"),
            Self::HGG_SHD => Some("HGG_SHD"),
            Self::LGG_SHD => Some("LGG_SHD"),
            Self::FURN => Some("FURN"),
            Self::AP_GAMEPLAY => Some("AP_GAMEPLAY"),
            Self::AP_BASE => Some("AP_BASE"),
            Self::SOCIAL_PT => Some("SOCIAL_PT"),
            Self::CHAR_SKIN => Some("CHAR_SKIN"),
            Self::TKT_GACHA_10 => Some("TKT_GACHA_10"),
            Self::TKT_GACHA_PRSV => Some("TKT_GACHA_PRSV"),
            Self::AP_ITEM => Some("AP_ITEM"),
            Self::AP_SUPPLY => Some("AP_SUPPLY"),
            Self::RENAMING_CARD => Some("RENAMING_CARD"),
            Self::RENAMING_CARD_2 => Some("RENAMING_CARD_2"),
            Self::ET_STAGE => Some("ET_STAGE"),
            Self::ACTIVITY_ITEM => Some("ACTIVITY_ITEM"),
            Self::VOUCHER_PICK => Some("VOUCHER_PICK"),
            Self::VOUCHER_CGACHA => Some("VOUCHER_CGACHA"),
            Self::VOUCHER_MGACHA => Some("VOUCHER_MGACHA"),
            Self::CRS_SHOP_COIN => Some("CRS_SHOP_COIN"),
            Self::CRS_RUNE_COIN => Some("CRS_RUNE_COIN"),
            Self::LMTGS_COIN => Some("LMTGS_COIN"),
            Self::EPGS_COIN => Some("EPGS_COIN"),
            Self::LIMITED_TKT_GACHA_10 => Some("LIMITED_TKT_GACHA_10"),
            Self::LIMITED_FREE_GACHA => Some("LIMITED_FREE_GACHA"),
            Self::REP_COIN => Some("REP_COIN"),
            Self::ROGUELIKE => Some("ROGUELIKE"),
            Self::LINKAGE_TKT_GACHA_10 => Some("LINKAGE_TKT_GACHA_10"),
            Self::VOUCHER_ELITE_II_4 => Some("VOUCHER_ELITE_II_4"),
            Self::VOUCHER_ELITE_II_5 => Some("VOUCHER_ELITE_II_5"),
            Self::VOUCHER_ELITE_II_6 => Some("VOUCHER_ELITE_II_6"),
            Self::VOUCHER_SKIN => Some("VOUCHER_SKIN"),
            Self::RETRO_COIN => Some("RETRO_COIN"),
            Self::PLAYER_AVATAR => Some("PLAYER_AVATAR"),
            Self::UNI_COLLECTION => Some("UNI_COLLECTION"),
            Self::VOUCHER_FULL_POTENTIAL => Some("VOUCHER_FULL_POTENTIAL"),
            Self::RL_COIN => Some("RL_COIN"),
            Self::RETURN_CREDIT => Some("RETURN_CREDIT"),
            Self::MEDAL => Some("MEDAL"),
            Self::CHARM => Some("CHARM"),
            Self::HOME_BACKGROUND => Some("HOME_BACKGROUND"),
            Self::EXTERMINATION_AGENT => Some("EXTERMINATION_AGENT"),
            Self::OPTIONAL_VOUCHER_PICK => Some("OPTIONAL_VOUCHER_PICK"),
            Self::ACT_CART_COMPONENT => Some("ACT_CART_COMPONENT"),
            Self::VOUCHER_LEVELMAX_6 => Some("VOUCHER_LEVELMAX_6"),
            Self::VOUCHER_LEVELMAX_5 => Some("VOUCHER_LEVELMAX_5"),
            Self::VOUCHER_LEVELMAX_4 => Some("VOUCHER_LEVELMAX_4"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_6 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_6"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_5 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_5"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_4 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_4"),
            Self::ACTIVITY_POTENTIAL => Some("ACTIVITY_POTENTIAL"),
            Self::ITEM_PACK => Some("ITEM_PACK"),
            Self::SANDBOX => Some("SANDBOX"),
            Self::FAVOR_ADD_ITEM => Some("FAVOR_ADD_ITEM"),
            Self::CLASSIC_SHD => Some("CLASSIC_SHD"),
            Self::CLASSIC_TKT_GACHA => Some("CLASSIC_TKT_GACHA"),
            Self::CLASSIC_TKT_GACHA_10 => Some("CLASSIC_TKT_GACHA_10"),
            Self::LIMITED_BUFF => Some("LIMITED_BUFF"),
            Self::CLASSIC_FES_PICK_TIER_5 => Some("CLASSIC_FES_PICK_TIER_5"),
            Self::CLASSIC_FES_PICK_TIER_6 => Some("CLASSIC_FES_PICK_TIER_6"),
            Self::RETURN_PROGRESS => Some("RETURN_PROGRESS"),
            Self::NEW_PROGRESS => Some("NEW_PROGRESS"),
            Self::MCARD_VOUCHER => Some("MCARD_VOUCHER"),
            Self::MATERIAL_ISSUE_VOUCHER => Some("MATERIAL_ISSUE_VOUCHER"),
            Self::CRS_SHOP_COIN_V2 => Some("CRS_SHOP_COIN_V2"),
            Self::HOME_THEME => Some("HOME_THEME"),
            Self::SANDBOX_PERM => Some("SANDBOX_PERM"),
            Self::SANDBOX_TOKEN => Some("SANDBOX_TOKEN"),
            Self::TEMPLATE_TRAP => Some("TEMPLATE_TRAP"),
            Self::NAME_CARD_SKIN => Some("NAME_CARD_SKIN"),
            Self::EMOTICON_SET => Some("EMOTICON_SET"),
            Self::EXCLUSIVE_TKT_GACHA => Some("EXCLUSIVE_TKT_GACHA"),
            Self::EXCLUSIVE_TKT_GACHA_10 => Some("EXCLUSIVE_TKT_GACHA_10"),
            Self::SO_CHAR_EXP => Some("SO_CHAR_EXP"),
            Self::GIFTPACKAGE_TKT => Some("GIFTPACKAGE_TKT"),
            Self::VOUCHER_SKIN_V2 => Some("VOUCHER_SKIN_V2"),
            Self::RANDOM_VOUCHER_SKIN => Some("RANDOM_VOUCHER_SKIN"),
            Self::ACT1VHALFIDLE_ITEM => Some("ACT1VHALFIDLE_ITEM"),
            Self::PLOT_ITEM => Some("PLOT_ITEM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ItemType {
    type Output = enum__Torappu_ItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ACT_ARCHIVE_PIC_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ACT_ARCHIVE_PIC_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ACT_ARCHIVE_PIC_TYPE: [enum__Torappu_ActArchivePicType; 4] = [
    enum__Torappu_ActArchivePicType::IMAGE,
    enum__Torappu_ActArchivePicType::BACKGROUND,
    enum__Torappu_ActArchivePicType::ENDING_IMAGE,
    enum__Torappu_ActArchivePicType::ROGUE_IMAGE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ActArchivePicType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ActArchivePicType {
    pub const IMAGE: Self = Self(0);
    pub const BACKGROUND: Self = Self(1);
    pub const ENDING_IMAGE: Self = Self(2);
    pub const ROGUE_IMAGE: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::IMAGE,
        Self::BACKGROUND,
        Self::ENDING_IMAGE,
        Self::ROGUE_IMAGE,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::IMAGE => Some("IMAGE"),
            Self::BACKGROUND => Some("BACKGROUND"),
            Self::ENDING_IMAGE => Some("ENDING_IMAGE"),
            Self::ROGUE_IMAGE => Some("ROGUE_IMAGE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ActArchivePicType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ActArchivePicType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ActArchivePicType {
    type Output = enum__Torappu_ActArchivePicType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ActArchivePicType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ActArchivePicType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ActArchivePicType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ACT_ARCHIVE_RES_DATA_ARCHIVE_NEWS_LINE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ACT_ARCHIVE_RES_DATA_ARCHIVE_NEWS_LINE_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ACT_ARCHIVE_RES_DATA_ARCHIVE_NEWS_LINE_TYPE:
    [enum__Torappu_ActArchiveResData_ArchiveNewsLineType; 2] = [
    enum__Torappu_ActArchiveResData_ArchiveNewsLineType::TextContent,
    enum__Torappu_ActArchiveResData_ArchiveNewsLineType::ImageContent,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ActArchiveResData_ArchiveNewsLineType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ActArchiveResData_ArchiveNewsLineType {
    pub const TextContent: Self = Self(0);
    pub const ImageContent: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::TextContent, Self::ImageContent];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::TextContent => Some("TextContent"),
            Self::ImageContent => Some("ImageContent"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ActArchiveResData_ArchiveNewsLineType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ActArchiveResData_ArchiveNewsLineType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ActArchiveResData_ArchiveNewsLineType {
    type Output = enum__Torappu_ActArchiveResData_ArchiveNewsLineType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ActArchiveResData_ArchiveNewsLineType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ActArchiveResData_ArchiveNewsLineType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ActArchiveResData_ArchiveNewsLineType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ACT_17SIDE_DATA_CHAPTER_ICON_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ACT_17SIDE_DATA_CHAPTER_ICON_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ACT_17SIDE_DATA_CHAPTER_ICON_TYPE:
    [enum__Torappu_Act17sideData_ChapterIconType; 3] = [
    enum__Torappu_Act17sideData_ChapterIconType::NORMAL,
    enum__Torappu_Act17sideData_ChapterIconType::EX,
    enum__Torappu_Act17sideData_ChapterIconType::HARD,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_Act17sideData_ChapterIconType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_Act17sideData_ChapterIconType {
    pub const NORMAL: Self = Self(0);
    pub const EX: Self = Self(1);
    pub const HARD: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NORMAL, Self::EX, Self::HARD];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NORMAL => Some("NORMAL"),
            Self::EX => Some("EX"),
            Self::HARD => Some("HARD"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_Act17sideData_ChapterIconType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_Act17sideData_ChapterIconType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_Act17sideData_ChapterIconType {
    type Output = enum__Torappu_Act17sideData_ChapterIconType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_Act17sideData_ChapterIconType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_Act17sideData_ChapterIconType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_Act17sideData_ChapterIconType {}
pub enum clz_Torappu_MiniActTrialData_RuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_MiniActTrialData_RuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_MiniActTrialData_RuleData<'a> {
    type Inner = clz_Torappu_MiniActTrialData_RuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_MiniActTrialData_RuleData<'a> {
    pub const VT_RULETYPE: flatbuffers::VOffsetT = 4;
    pub const VT_RULETEXT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_MiniActTrialData_RuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_MiniActTrialData_RuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MiniActTrialData_RuleData<'bldr>> {
        let mut builder = clz_Torappu_MiniActTrialData_RuleDataBuilder::new(_fbb);
        if let Some(x) = args.ruleText {
            builder.add_ruleText(x);
        }
        builder.add_ruleType(args.ruleType);
        builder.finish()
    }

    #[inline]
    pub fn ruleType(&self) -> enum__Torappu_MiniActTrialData_RuleType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_MiniActTrialData_RuleType>(
                    clz_Torappu_MiniActTrialData_RuleData::VT_RULETYPE,
                    Some(enum__Torappu_MiniActTrialData_RuleType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn ruleText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MiniActTrialData_RuleData::VT_RULETEXT,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_MiniActTrialData_RuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_MiniActTrialData_RuleType>(
                "ruleType",
                Self::VT_RULETYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "ruleText",
                Self::VT_RULETEXT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_MiniActTrialData_RuleDataArgs<'a> {
    pub ruleType: enum__Torappu_MiniActTrialData_RuleType,
    pub ruleText: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_MiniActTrialData_RuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_MiniActTrialData_RuleDataArgs {
            ruleType: enum__Torappu_MiniActTrialData_RuleType::NONE,
            ruleText: None,
        }
    }
}

pub struct clz_Torappu_MiniActTrialData_RuleDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_MiniActTrialData_RuleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_ruleType(&mut self, ruleType: enum__Torappu_MiniActTrialData_RuleType) {
        self.fbb_
            .push_slot::<enum__Torappu_MiniActTrialData_RuleType>(
                clz_Torappu_MiniActTrialData_RuleData::VT_RULETYPE,
                ruleType,
                enum__Torappu_MiniActTrialData_RuleType::NONE,
            );
    }
    #[inline]
    pub fn add_ruleText(&mut self, ruleText: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MiniActTrialData_RuleData::VT_RULETEXT,
            ruleText,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_MiniActTrialData_RuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_MiniActTrialData_RuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_MiniActTrialData_RuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_MiniActTrialData_RuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_MiniActTrialData_RuleData");
        ds.field("ruleType", &self.ruleType());
        ds.field("ruleText", &self.ruleText());
        ds.finish()
    }
}
pub enum clz_Torappu_ItemBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ItemBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ItemBundle<'a> {
    type Inner = clz_Torappu_ItemBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ItemBundle<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_COUNT: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ItemBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ItemBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'bldr>> {
        let mut builder = clz_Torappu_ItemBundleBuilder::new(_fbb);
        builder.add_type_(args.type_);
        builder.add_count(args.count);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_ItemBundle::VT_ID, None)
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ItemBundle::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_ItemBundle::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ItemBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ItemBundleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl<'a> Default for clz_Torappu_ItemBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ItemBundleArgs {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}

pub struct clz_Torappu_ItemBundleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ItemBundle::VT_ID, id);
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ItemBundle::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_ItemBundle::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ItemBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ItemBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ItemBundle");
        ds.field("id", &self.id());
        ds.field("count", &self.count());
        ds.field("type_", &self.type_());
        ds.finish()
    }
}
pub enum clz_Torappu_MiniActTrialData_MiniActTrialRewardDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_MiniActTrialData_MiniActTrialRewardData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_MiniActTrialData_MiniActTrialRewardData<'a> {
    type Inner = clz_Torappu_MiniActTrialData_MiniActTrialRewardData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_MiniActTrialData_MiniActTrialRewardData<'a> {
    pub const VT_TRIALREWARDID: flatbuffers::VOffsetT = 4;
    pub const VT_ORDERID: flatbuffers::VOffsetT = 6;
    pub const VT_ACTID: flatbuffers::VOffsetT = 8;
    pub const VT_TARGETSTORYCOUNT: flatbuffers::VOffsetT = 10;
    pub const VT_ITEM: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_MiniActTrialData_MiniActTrialRewardData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_MiniActTrialData_MiniActTrialRewardDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MiniActTrialData_MiniActTrialRewardData<'bldr>> {
        let mut builder = clz_Torappu_MiniActTrialData_MiniActTrialRewardDataBuilder::new(_fbb);
        if let Some(x) = args.item {
            builder.add_item(x);
        }
        builder.add_targetStoryCount(args.targetStoryCount);
        if let Some(x) = args.actId {
            builder.add_actId(x);
        }
        builder.add_orderId(args.orderId);
        if let Some(x) = args.trialRewardId {
            builder.add_trialRewardId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn trialRewardId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MiniActTrialData_MiniActTrialRewardData::VT_TRIALREWARDID,
                None,
            )
        }
    }
    #[inline]
    pub fn orderId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_MiniActTrialData_MiniActTrialRewardData::VT_ORDERID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn actId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MiniActTrialData_MiniActTrialRewardData::VT_ACTID,
                None,
            )
        }
    }
    #[inline]
    pub fn targetStoryCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_MiniActTrialData_MiniActTrialRewardData::VT_TARGETSTORYCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn item(&self) -> Option<clz_Torappu_ItemBundle<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>(
                    clz_Torappu_MiniActTrialData_MiniActTrialRewardData::VT_ITEM,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_MiniActTrialData_MiniActTrialRewardData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "trialRewardId",
                Self::VT_TRIALREWARDID,
                false,
            )?
            .visit_field::<i32>("orderId", Self::VT_ORDERID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("actId", Self::VT_ACTID, false)?
            .visit_field::<i32>("targetStoryCount", Self::VT_TARGETSTORYCOUNT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>(
                "item",
                Self::VT_ITEM,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_MiniActTrialData_MiniActTrialRewardDataArgs<'a> {
    pub trialRewardId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub orderId: i32,
    pub actId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub targetStoryCount: i32,
    pub item: Option<flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'a>>>,
}
impl<'a> Default for clz_Torappu_MiniActTrialData_MiniActTrialRewardDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_MiniActTrialData_MiniActTrialRewardDataArgs {
            trialRewardId: None,
            orderId: 0,
            actId: None,
            targetStoryCount: 0,
            item: None,
        }
    }
}

pub struct clz_Torappu_MiniActTrialData_MiniActTrialRewardDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_MiniActTrialData_MiniActTrialRewardDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_trialRewardId(&mut self, trialRewardId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MiniActTrialData_MiniActTrialRewardData::VT_TRIALREWARDID,
            trialRewardId,
        );
    }
    #[inline]
    pub fn add_orderId(&mut self, orderId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_MiniActTrialData_MiniActTrialRewardData::VT_ORDERID,
            orderId,
            0,
        );
    }
    #[inline]
    pub fn add_actId(&mut self, actId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MiniActTrialData_MiniActTrialRewardData::VT_ACTID,
            actId,
        );
    }
    #[inline]
    pub fn add_targetStoryCount(&mut self, targetStoryCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_MiniActTrialData_MiniActTrialRewardData::VT_TARGETSTORYCOUNT,
            targetStoryCount,
            0,
        );
    }
    #[inline]
    pub fn add_item(&mut self, item: flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ItemBundle>>(
                clz_Torappu_MiniActTrialData_MiniActTrialRewardData::VT_ITEM,
                item,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_MiniActTrialData_MiniActTrialRewardDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_MiniActTrialData_MiniActTrialRewardDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MiniActTrialData_MiniActTrialRewardData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_MiniActTrialData_MiniActTrialRewardData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_MiniActTrialData_MiniActTrialRewardData");
        ds.field("trialRewardId", &self.trialRewardId());
        ds.field("orderId", &self.orderId());
        ds.field("actId", &self.actId());
        ds.field("targetStoryCount", &self.targetStoryCount());
        ds.field("item", &self.item());
        ds.finish()
    }
}
pub enum clz_Torappu_MiniActTrialData_MiniActTrialSingleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_MiniActTrialData_MiniActTrialSingleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_MiniActTrialData_MiniActTrialSingleData<'a> {
    type Inner = clz_Torappu_MiniActTrialData_MiniActTrialSingleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_MiniActTrialData_MiniActTrialSingleData<'a> {
    pub const VT_ACTID: flatbuffers::VOffsetT = 4;
    pub const VT_REWARDSTARTTIME: flatbuffers::VOffsetT = 6;
    pub const VT_THEMECOLOR: flatbuffers::VOffsetT = 8;
    pub const VT_REWARDLIST: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_MiniActTrialData_MiniActTrialSingleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_MiniActTrialData_MiniActTrialSingleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MiniActTrialData_MiniActTrialSingleData<'bldr>> {
        let mut builder = clz_Torappu_MiniActTrialData_MiniActTrialSingleDataBuilder::new(_fbb);
        builder.add_rewardStartTime(args.rewardStartTime);
        if let Some(x) = args.rewardList {
            builder.add_rewardList(x);
        }
        if let Some(x) = args.themeColor {
            builder.add_themeColor(x);
        }
        if let Some(x) = args.actId {
            builder.add_actId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn actId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MiniActTrialData_MiniActTrialSingleData::VT_ACTID,
                None,
            )
        }
    }
    #[inline]
    pub fn rewardStartTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_MiniActTrialData_MiniActTrialSingleData::VT_REWARDSTARTTIME,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn themeColor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MiniActTrialData_MiniActTrialSingleData::VT_THEMECOLOR,
                None,
            )
        }
    }
    #[inline]
    pub fn rewardList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_MiniActTrialData_MiniActTrialRewardData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_MiniActTrialData_MiniActTrialRewardData,
                    >,
                >,
            >>(
                clz_Torappu_MiniActTrialData_MiniActTrialSingleData::VT_REWARDLIST,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_MiniActTrialData_MiniActTrialSingleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("actId", Self::VT_ACTID, false)?
            .visit_field::<i64>("rewardStartTime", Self::VT_REWARDSTARTTIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "themeColor",
                Self::VT_THEMECOLOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_MiniActTrialData_MiniActTrialRewardData,
                    >,
                >,
            >>("rewardList", Self::VT_REWARDLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_MiniActTrialData_MiniActTrialSingleDataArgs<'a> {
    pub actId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewardStartTime: i64,
    pub themeColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewardList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_MiniActTrialData_MiniActTrialRewardData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_MiniActTrialData_MiniActTrialSingleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_MiniActTrialData_MiniActTrialSingleDataArgs {
            actId: None,
            rewardStartTime: 0,
            themeColor: None,
            rewardList: None,
        }
    }
}

pub struct clz_Torappu_MiniActTrialData_MiniActTrialSingleDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_MiniActTrialData_MiniActTrialSingleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_actId(&mut self, actId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MiniActTrialData_MiniActTrialSingleData::VT_ACTID,
            actId,
        );
    }
    #[inline]
    pub fn add_rewardStartTime(&mut self, rewardStartTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_MiniActTrialData_MiniActTrialSingleData::VT_REWARDSTARTTIME,
            rewardStartTime,
            0,
        );
    }
    #[inline]
    pub fn add_themeColor(&mut self, themeColor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MiniActTrialData_MiniActTrialSingleData::VT_THEMECOLOR,
            themeColor,
        );
    }
    #[inline]
    pub fn add_rewardList(
        &mut self,
        rewardList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_MiniActTrialData_MiniActTrialRewardData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MiniActTrialData_MiniActTrialSingleData::VT_REWARDLIST,
            rewardList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_MiniActTrialData_MiniActTrialSingleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_MiniActTrialData_MiniActTrialSingleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MiniActTrialData_MiniActTrialSingleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_MiniActTrialData_MiniActTrialSingleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_MiniActTrialData_MiniActTrialSingleData");
        ds.field("actId", &self.actId());
        ds.field("rewardStartTime", &self.rewardStartTime());
        ds.field("themeColor", &self.themeColor());
        ds.field("rewardList", &self.rewardList());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleData<'a>
{
    type Inner = dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleData<'bldr>,
    > {
        let mut builder =
            dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_MiniActTrialData_MiniActTrialSingleData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                clz_Torappu_MiniActTrialData_MiniActTrialSingleData,
            >>(
                dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_MiniActTrialData_MiniActTrialSingleData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value:
        Option<flatbuffers::WIPOffset<clz_Torappu_MiniActTrialData_MiniActTrialSingleData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_MiniActTrialData_MiniActTrialSingleData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_MiniActTrialData_MiniActTrialSingleData>>(dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_MiniActTrialDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_MiniActTrialData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_MiniActTrialData<'a> {
    type Inner = clz_Torappu_MiniActTrialData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_MiniActTrialData<'a> {
    pub const VT_PRESHOWDAYS: flatbuffers::VOffsetT = 4;
    pub const VT_RULEDATALIST: flatbuffers::VOffsetT = 6;
    pub const VT_MINIACTTRIALDATAMAP: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_MiniActTrialData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_MiniActTrialDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MiniActTrialData<'bldr>> {
        let mut builder = clz_Torappu_MiniActTrialDataBuilder::new(_fbb);
        if let Some(x) = args.miniActTrialDataMap {
            builder.add_miniActTrialDataMap(x);
        }
        if let Some(x) = args.ruleDataList {
            builder.add_ruleDataList(x);
        }
        builder.add_preShowDays(args.preShowDays);
        builder.finish()
    }

    #[inline]
    pub fn preShowDays(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_MiniActTrialData::VT_PRESHOWDAYS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn ruleDataList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_MiniActTrialData_RuleData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_MiniActTrialData_RuleData>,
                >,
            >>(clz_Torappu_MiniActTrialData::VT_RULEDATALIST, None)
        }
    }
    #[inline]
    pub fn miniActTrialDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleData,
                    >,
                >,
            >>(clz_Torappu_MiniActTrialData::VT_MINIACTTRIALDATAMAP, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_MiniActTrialData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("preShowDays", Self::VT_PRESHOWDAYS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_MiniActTrialData_RuleData>,
                >,
            >>("ruleDataList", Self::VT_RULEDATALIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleData,
                    >,
                >,
            >>("miniActTrialDataMap", Self::VT_MINIACTTRIALDATAMAP, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_MiniActTrialDataArgs<'a> {
    pub preShowDays: i32,
    pub ruleDataList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_MiniActTrialData_RuleData<'a>>,
            >,
        >,
    >,
    pub miniActTrialDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_MiniActTrialDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_MiniActTrialDataArgs {
            preShowDays: 0,
            ruleDataList: None,
            miniActTrialDataMap: None,
        }
    }
}

pub struct clz_Torappu_MiniActTrialDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_MiniActTrialDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_preShowDays(&mut self, preShowDays: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_MiniActTrialData::VT_PRESHOWDAYS, preShowDays, 0);
    }
    #[inline]
    pub fn add_ruleDataList(
        &mut self,
        ruleDataList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_MiniActTrialData_RuleData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MiniActTrialData::VT_RULEDATALIST,
            ruleDataList,
        );
    }
    #[inline]
    pub fn add_miniActTrialDataMap(
        &mut self,
        miniActTrialDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_MiniActTrialData_MiniActTrialSingleData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MiniActTrialData::VT_MINIACTTRIALDATAMAP,
            miniActTrialDataMap,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_MiniActTrialDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_MiniActTrialDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_MiniActTrialData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_MiniActTrialData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_MiniActTrialData");
        ds.field("preShowDays", &self.preShowDays());
        ds.field("ruleDataList", &self.ruleDataList());
        ds.field("miniActTrialDataMap", &self.miniActTrialDataMap());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveResData_PicArchiveResItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveResData_PicArchiveResItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveResData_PicArchiveResItemData<'a> {
    type Inner = clz_Torappu_ActArchiveResData_PicArchiveResItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveResData_PicArchiveResItemData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DESC: flatbuffers::VOffsetT = 6;
    pub const VT_ASSETPATH: flatbuffers::VOffsetT = 8;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 10;
    pub const VT_SUBTYPE: flatbuffers::VOffsetT = 12;
    pub const VT_PICDESCRIPTION: flatbuffers::VOffsetT = 14;
    pub const VT_KVID: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveResData_PicArchiveResItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveResData_PicArchiveResItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_PicArchiveResItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveResData_PicArchiveResItemDataBuilder::new(_fbb);
        if let Some(x) = args.kvId {
            builder.add_kvId(x);
        }
        if let Some(x) = args.picDescription {
            builder.add_picDescription(x);
        }
        if let Some(x) = args.subType {
            builder.add_subType(x);
        }
        builder.add_type_(args.type_);
        if let Some(x) = args.assetPath {
            builder.add_assetPath(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_PicArchiveResItemData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_PicArchiveResItemData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn assetPath(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_PicArchiveResItemData::VT_ASSETPATH,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ActArchivePicType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ActArchivePicType>(
                    clz_Torappu_ActArchiveResData_PicArchiveResItemData::VT_TYPE_,
                    Some(enum__Torappu_ActArchivePicType::IMAGE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn subType(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_PicArchiveResItemData::VT_SUBTYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn picDescription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_PicArchiveResItemData::VT_PICDESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn kvId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_PicArchiveResItemData::VT_KVID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveResData_PicArchiveResItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "assetPath",
                Self::VT_ASSETPATH,
                false,
            )?
            .visit_field::<enum__Torappu_ActArchivePicType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("subType", Self::VT_SUBTYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "picDescription",
                Self::VT_PICDESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("kvId", Self::VT_KVID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveResData_PicArchiveResItemDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub assetPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_ActArchivePicType,
    pub subType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub picDescription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub kvId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ActArchiveResData_PicArchiveResItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveResData_PicArchiveResItemDataArgs {
            id: None,
            desc: None,
            assetPath: None,
            type_: enum__Torappu_ActArchivePicType::IMAGE,
            subType: None,
            picDescription: None,
            kvId: None,
        }
    }
}

pub struct clz_Torappu_ActArchiveResData_PicArchiveResItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveResData_PicArchiveResItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_PicArchiveResItemData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_PicArchiveResItemData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_assetPath(&mut self, assetPath: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_PicArchiveResItemData::VT_ASSETPATH,
            assetPath,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ActArchivePicType) {
        self.fbb_.push_slot::<enum__Torappu_ActArchivePicType>(
            clz_Torappu_ActArchiveResData_PicArchiveResItemData::VT_TYPE_,
            type_,
            enum__Torappu_ActArchivePicType::IMAGE,
        );
    }
    #[inline]
    pub fn add_subType(&mut self, subType: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_PicArchiveResItemData::VT_SUBTYPE,
            subType,
        );
    }
    #[inline]
    pub fn add_picDescription(&mut self, picDescription: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_PicArchiveResItemData::VT_PICDESCRIPTION,
            picDescription,
        );
    }
    #[inline]
    pub fn add_kvId(&mut self, kvId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_PicArchiveResItemData::VT_KVID,
            kvId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveResData_PicArchiveResItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveResData_PicArchiveResItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_PicArchiveResItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveResData_PicArchiveResItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveResData_PicArchiveResItemData");
        ds.field("id", &self.id());
        ds.field("desc", &self.desc());
        ds.field("assetPath", &self.assetPath());
        ds.field("type_", &self.type_());
        ds.field("subType", &self.subType());
        ds.field("picDescription", &self.picDescription());
        ds.field("kvId", &self.kvId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemData<'a>
{
    type Inner = dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemData<'bldr>,
    > {
        let mut builder =
            dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveResData_PicArchiveResItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                clz_Torappu_ActArchiveResData_PicArchiveResItemData,
            >>(
                dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveResData_PicArchiveResItemData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value:
        Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_PicArchiveResItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_PicArchiveResItemData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_PicArchiveResItemData>>(dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveResData_AudioArchiveResItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveResData_AudioArchiveResItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveResData_AudioArchiveResItemData<'a> {
    type Inner = clz_Torappu_ActArchiveResData_AudioArchiveResItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveResData_AudioArchiveResItemData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DESC: flatbuffers::VOffsetT = 6;
    pub const VT_NAME: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveResData_AudioArchiveResItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveResData_AudioArchiveResItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_AudioArchiveResItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveResData_AudioArchiveResItemDataBuilder::new(_fbb);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_AudioArchiveResItemData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_AudioArchiveResItemData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_AudioArchiveResItemData::VT_NAME,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveResData_AudioArchiveResItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveResData_AudioArchiveResItemDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ActArchiveResData_AudioArchiveResItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveResData_AudioArchiveResItemDataArgs {
            id: None,
            desc: None,
            name: None,
        }
    }
}

pub struct clz_Torappu_ActArchiveResData_AudioArchiveResItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveResData_AudioArchiveResItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_AudioArchiveResItemData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_AudioArchiveResItemData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_AudioArchiveResItemData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveResData_AudioArchiveResItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveResData_AudioArchiveResItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_AudioArchiveResItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveResData_AudioArchiveResItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveResData_AudioArchiveResItemData");
        ds.field("id", &self.id());
        ds.field("desc", &self.desc());
        ds.field("name", &self.name());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemData<'a>
{
    type Inner = dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemData<'bldr>,
    > {
        let mut builder =
            dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveResData_AudioArchiveResItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                clz_Torappu_ActArchiveResData_AudioArchiveResItemData,
            >>(
                dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveResData_AudioArchiveResItemData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value:
        Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_AudioArchiveResItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_AudioArchiveResItemData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_AudioArchiveResItemData>>(dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemData<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveResData_AvgArchiveResItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveResData_AvgArchiveResItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveResData_AvgArchiveResItemData<'a> {
    type Inner = clz_Torappu_ActArchiveResData_AvgArchiveResItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveResData_AvgArchiveResItemData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DESC: flatbuffers::VOffsetT = 6;
    pub const VT_BREIFPATH: flatbuffers::VOffsetT = 8;
    pub const VT_CONTENTPATH: flatbuffers::VOffsetT = 10;
    pub const VT_IMAGEPATH: flatbuffers::VOffsetT = 12;
    pub const VT_RAWBRIEF: flatbuffers::VOffsetT = 14;
    pub const VT_TITLEICONPATH: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveResData_AvgArchiveResItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveResData_AvgArchiveResItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_AvgArchiveResItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveResData_AvgArchiveResItemDataBuilder::new(_fbb);
        if let Some(x) = args.titleIconPath {
            builder.add_titleIconPath(x);
        }
        if let Some(x) = args.rawBrief {
            builder.add_rawBrief(x);
        }
        if let Some(x) = args.imagePath {
            builder.add_imagePath(x);
        }
        if let Some(x) = args.contentPath {
            builder.add_contentPath(x);
        }
        if let Some(x) = args.breifPath {
            builder.add_breifPath(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_AvgArchiveResItemData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_AvgArchiveResItemData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn breifPath(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_AvgArchiveResItemData::VT_BREIFPATH,
                None,
            )
        }
    }
    #[inline]
    pub fn contentPath(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_AvgArchiveResItemData::VT_CONTENTPATH,
                None,
            )
        }
    }
    #[inline]
    pub fn imagePath(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_AvgArchiveResItemData::VT_IMAGEPATH,
                None,
            )
        }
    }
    #[inline]
    pub fn rawBrief(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_AvgArchiveResItemData::VT_RAWBRIEF,
                None,
            )
        }
    }
    #[inline]
    pub fn titleIconPath(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_AvgArchiveResItemData::VT_TITLEICONPATH,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveResData_AvgArchiveResItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "breifPath",
                Self::VT_BREIFPATH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "contentPath",
                Self::VT_CONTENTPATH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "imagePath",
                Self::VT_IMAGEPATH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rawBrief",
                Self::VT_RAWBRIEF,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "titleIconPath",
                Self::VT_TITLEICONPATH,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveResData_AvgArchiveResItemDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub breifPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub contentPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub imagePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rawBrief: Option<flatbuffers::WIPOffset<&'a str>>,
    pub titleIconPath: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ActArchiveResData_AvgArchiveResItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveResData_AvgArchiveResItemDataArgs {
            id: None,
            desc: None,
            breifPath: None,
            contentPath: None,
            imagePath: None,
            rawBrief: None,
            titleIconPath: None,
        }
    }
}

pub struct clz_Torappu_ActArchiveResData_AvgArchiveResItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveResData_AvgArchiveResItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_AvgArchiveResItemData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_AvgArchiveResItemData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_breifPath(&mut self, breifPath: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_AvgArchiveResItemData::VT_BREIFPATH,
            breifPath,
        );
    }
    #[inline]
    pub fn add_contentPath(&mut self, contentPath: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_AvgArchiveResItemData::VT_CONTENTPATH,
            contentPath,
        );
    }
    #[inline]
    pub fn add_imagePath(&mut self, imagePath: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_AvgArchiveResItemData::VT_IMAGEPATH,
            imagePath,
        );
    }
    #[inline]
    pub fn add_rawBrief(&mut self, rawBrief: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_AvgArchiveResItemData::VT_RAWBRIEF,
            rawBrief,
        );
    }
    #[inline]
    pub fn add_titleIconPath(&mut self, titleIconPath: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_AvgArchiveResItemData::VT_TITLEICONPATH,
            titleIconPath,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveResData_AvgArchiveResItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveResData_AvgArchiveResItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_AvgArchiveResItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveResData_AvgArchiveResItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveResData_AvgArchiveResItemData");
        ds.field("id", &self.id());
        ds.field("desc", &self.desc());
        ds.field("breifPath", &self.breifPath());
        ds.field("contentPath", &self.contentPath());
        ds.field("imagePath", &self.imagePath());
        ds.field("rawBrief", &self.rawBrief());
        ds.field("titleIconPath", &self.titleIconPath());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemData<'a>
{
    type Inner = dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemData<'bldr>,
    > {
        let mut builder =
            dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveResData_AvgArchiveResItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                clz_Torappu_ActArchiveResData_AvgArchiveResItemData,
            >>(
                dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveResData_AvgArchiveResItemData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value:
        Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_AvgArchiveResItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_AvgArchiveResItemData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_AvgArchiveResItemData>>(dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveResData_StoryArchiveResItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveResData_StoryArchiveResItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveResData_StoryArchiveResItemData<'a> {
    type Inner = clz_Torappu_ActArchiveResData_StoryArchiveResItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveResData_StoryArchiveResItemData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DESC: flatbuffers::VOffsetT = 6;
    pub const VT_DATE: flatbuffers::VOffsetT = 8;
    pub const VT_PIC: flatbuffers::VOffsetT = 10;
    pub const VT_TEXT: flatbuffers::VOffsetT = 12;
    pub const VT_TITLEPIC: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveResData_StoryArchiveResItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveResData_StoryArchiveResItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_StoryArchiveResItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveResData_StoryArchiveResItemDataBuilder::new(_fbb);
        if let Some(x) = args.titlePic {
            builder.add_titlePic(x);
        }
        if let Some(x) = args.text {
            builder.add_text(x);
        }
        if let Some(x) = args.pic {
            builder.add_pic(x);
        }
        if let Some(x) = args.date {
            builder.add_date(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_StoryArchiveResItemData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_StoryArchiveResItemData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn date(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_StoryArchiveResItemData::VT_DATE,
                None,
            )
        }
    }
    #[inline]
    pub fn pic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_StoryArchiveResItemData::VT_PIC,
                None,
            )
        }
    }
    #[inline]
    pub fn text(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_StoryArchiveResItemData::VT_TEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn titlePic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_StoryArchiveResItemData::VT_TITLEPIC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveResData_StoryArchiveResItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("date", Self::VT_DATE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pic", Self::VT_PIC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "titlePic",
                Self::VT_TITLEPIC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveResData_StoryArchiveResItemDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub date: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub titlePic: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ActArchiveResData_StoryArchiveResItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveResData_StoryArchiveResItemDataArgs {
            id: None,
            desc: None,
            date: None,
            pic: None,
            text: None,
            titlePic: None,
        }
    }
}

pub struct clz_Torappu_ActArchiveResData_StoryArchiveResItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveResData_StoryArchiveResItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_StoryArchiveResItemData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_StoryArchiveResItemData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_date(&mut self, date: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_StoryArchiveResItemData::VT_DATE,
            date,
        );
    }
    #[inline]
    pub fn add_pic(&mut self, pic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_StoryArchiveResItemData::VT_PIC,
            pic,
        );
    }
    #[inline]
    pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_StoryArchiveResItemData::VT_TEXT,
            text,
        );
    }
    #[inline]
    pub fn add_titlePic(&mut self, titlePic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_StoryArchiveResItemData::VT_TITLEPIC,
            titlePic,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveResData_StoryArchiveResItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveResData_StoryArchiveResItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_StoryArchiveResItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveResData_StoryArchiveResItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveResData_StoryArchiveResItemData");
        ds.field("id", &self.id());
        ds.field("desc", &self.desc());
        ds.field("date", &self.date());
        ds.field("pic", &self.pic());
        ds.field("text", &self.text());
        ds.field("titlePic", &self.titlePic());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemData<'a>
{
    type Inner = dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemData<'bldr>,
    > {
        let mut builder =
            dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveResData_StoryArchiveResItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                clz_Torappu_ActArchiveResData_StoryArchiveResItemData,
            >>(
                dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveResData_StoryArchiveResItemData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value:
        Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_StoryArchiveResItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_StoryArchiveResItemData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_StoryArchiveResItemData>>(dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemData<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveResData_NewsFormatDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveResData_NewsFormatData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveResData_NewsFormatData<'a> {
    type Inner = clz_Torappu_ActArchiveResData_NewsFormatData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveResData_NewsFormatData<'a> {
    pub const VT_TYPEID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPENAME: flatbuffers::VOffsetT = 6;
    pub const VT_TYPELOGO: flatbuffers::VOffsetT = 8;
    pub const VT_TYPEMAINLOGO: flatbuffers::VOffsetT = 10;
    pub const VT_TYPEMAINSEALING: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveResData_NewsFormatData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveResData_NewsFormatDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_NewsFormatData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveResData_NewsFormatDataBuilder::new(_fbb);
        if let Some(x) = args.typeMainSealing {
            builder.add_typeMainSealing(x);
        }
        if let Some(x) = args.typeMainLogo {
            builder.add_typeMainLogo(x);
        }
        if let Some(x) = args.typeLogo {
            builder.add_typeLogo(x);
        }
        if let Some(x) = args.typeName {
            builder.add_typeName(x);
        }
        if let Some(x) = args.typeId {
            builder.add_typeId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn typeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_NewsFormatData::VT_TYPEID,
                None,
            )
        }
    }
    #[inline]
    pub fn typeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_NewsFormatData::VT_TYPENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn typeLogo(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_NewsFormatData::VT_TYPELOGO,
                None,
            )
        }
    }
    #[inline]
    pub fn typeMainLogo(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_NewsFormatData::VT_TYPEMAINLOGO,
                None,
            )
        }
    }
    #[inline]
    pub fn typeMainSealing(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_NewsFormatData::VT_TYPEMAINSEALING,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveResData_NewsFormatData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("typeId", Self::VT_TYPEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "typeName",
                Self::VT_TYPENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "typeLogo",
                Self::VT_TYPELOGO,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "typeMainLogo",
                Self::VT_TYPEMAINLOGO,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "typeMainSealing",
                Self::VT_TYPEMAINSEALING,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveResData_NewsFormatDataArgs<'a> {
    pub typeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub typeName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub typeLogo: Option<flatbuffers::WIPOffset<&'a str>>,
    pub typeMainLogo: Option<flatbuffers::WIPOffset<&'a str>>,
    pub typeMainSealing: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ActArchiveResData_NewsFormatDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveResData_NewsFormatDataArgs {
            typeId: None,
            typeName: None,
            typeLogo: None,
            typeMainLogo: None,
            typeMainSealing: None,
        }
    }
}

pub struct clz_Torappu_ActArchiveResData_NewsFormatDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveResData_NewsFormatDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_typeId(&mut self, typeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_NewsFormatData::VT_TYPEID,
            typeId,
        );
    }
    #[inline]
    pub fn add_typeName(&mut self, typeName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_NewsFormatData::VT_TYPENAME,
            typeName,
        );
    }
    #[inline]
    pub fn add_typeLogo(&mut self, typeLogo: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_NewsFormatData::VT_TYPELOGO,
            typeLogo,
        );
    }
    #[inline]
    pub fn add_typeMainLogo(&mut self, typeMainLogo: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_NewsFormatData::VT_TYPEMAINLOGO,
            typeMainLogo,
        );
    }
    #[inline]
    pub fn add_typeMainSealing(&mut self, typeMainSealing: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_NewsFormatData::VT_TYPEMAINSEALING,
            typeMainSealing,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveResData_NewsFormatDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveResData_NewsFormatDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_NewsFormatData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveResData_NewsFormatData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveResData_NewsFormatData");
        ds.field("typeId", &self.typeId());
        ds.field("typeName", &self.typeName());
        ds.field("typeLogo", &self.typeLogo());
        ds.field("typeMainLogo", &self.typeMainLogo());
        ds.field("typeMainSealing", &self.typeMainSealing());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveResData_ActivityNewsLineOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveResData_ActivityNewsLine<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveResData_ActivityNewsLine<'a> {
    type Inner = clz_Torappu_ActArchiveResData_ActivityNewsLine<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveResData_ActivityNewsLine<'a> {
    pub const VT_LINETYPE: flatbuffers::VOffsetT = 4;
    pub const VT_CONTENT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveResData_ActivityNewsLine { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveResData_ActivityNewsLineArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_ActivityNewsLine<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveResData_ActivityNewsLineBuilder::new(_fbb);
        if let Some(x) = args.content {
            builder.add_content(x);
        }
        builder.add_lineType(args.lineType);
        builder.finish()
    }

    #[inline]
    pub fn lineType(&self) -> enum__Torappu_ActArchiveResData_ArchiveNewsLineType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ActArchiveResData_ArchiveNewsLineType>(
                    clz_Torappu_ActArchiveResData_ActivityNewsLine::VT_LINETYPE,
                    Some(enum__Torappu_ActArchiveResData_ArchiveNewsLineType::TextContent),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn content(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_ActivityNewsLine::VT_CONTENT,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveResData_ActivityNewsLine<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_ActArchiveResData_ArchiveNewsLineType>(
                "lineType",
                Self::VT_LINETYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("content", Self::VT_CONTENT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveResData_ActivityNewsLineArgs<'a> {
    pub lineType: enum__Torappu_ActArchiveResData_ArchiveNewsLineType,
    pub content: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ActArchiveResData_ActivityNewsLineArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveResData_ActivityNewsLineArgs {
            lineType: enum__Torappu_ActArchiveResData_ArchiveNewsLineType::TextContent,
            content: None,
        }
    }
}

pub struct clz_Torappu_ActArchiveResData_ActivityNewsLineBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveResData_ActivityNewsLineBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_lineType(&mut self, lineType: enum__Torappu_ActArchiveResData_ArchiveNewsLineType) {
        self.fbb_
            .push_slot::<enum__Torappu_ActArchiveResData_ArchiveNewsLineType>(
                clz_Torappu_ActArchiveResData_ActivityNewsLine::VT_LINETYPE,
                lineType,
                enum__Torappu_ActArchiveResData_ArchiveNewsLineType::TextContent,
            );
    }
    #[inline]
    pub fn add_content(&mut self, content: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_ActivityNewsLine::VT_CONTENT,
            content,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveResData_ActivityNewsLineBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveResData_ActivityNewsLineBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_ActivityNewsLine<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveResData_ActivityNewsLine<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveResData_ActivityNewsLine");
        ds.field("lineType", &self.lineType());
        ds.field("content", &self.content());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveResData_NewsArchiveResItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveResData_NewsArchiveResItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveResData_NewsArchiveResItemData<'a> {
    type Inner = clz_Torappu_ActArchiveResData_NewsArchiveResItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveResData_NewsArchiveResItemData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DESC: flatbuffers::VOffsetT = 6;
    pub const VT_NEWSTYPE: flatbuffers::VOffsetT = 8;
    pub const VT_NEWSFORMAT: flatbuffers::VOffsetT = 10;
    pub const VT_NEWSTEXT: flatbuffers::VOffsetT = 12;
    pub const VT_NEWSAUTHOR: flatbuffers::VOffsetT = 14;
    pub const VT_PARAMP0: flatbuffers::VOffsetT = 16;
    pub const VT_PARAMK: flatbuffers::VOffsetT = 18;
    pub const VT_PARAMR: flatbuffers::VOffsetT = 20;
    pub const VT_NEWSLINES: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveResData_NewsArchiveResItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveResData_NewsArchiveResItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_NewsArchiveResItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveResData_NewsArchiveResItemDataBuilder::new(_fbb);
        if let Some(x) = args.newsLines {
            builder.add_newsLines(x);
        }
        builder.add_paramR(args.paramR);
        builder.add_paramK(args.paramK);
        builder.add_paramP0(args.paramP0);
        if let Some(x) = args.newsAuthor {
            builder.add_newsAuthor(x);
        }
        if let Some(x) = args.newsText {
            builder.add_newsText(x);
        }
        if let Some(x) = args.newsFormat {
            builder.add_newsFormat(x);
        }
        if let Some(x) = args.newsType {
            builder.add_newsType(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn newsType(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_NEWSTYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn newsFormat(&self) -> Option<clz_Torappu_ActArchiveResData_NewsFormatData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveResData_NewsFormatData>>(
                    clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_NEWSFORMAT,
                    None,
                )
        }
    }
    #[inline]
    pub fn newsText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_NEWSTEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn newsAuthor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_NEWSAUTHOR,
                None,
            )
        }
    }
    #[inline]
    pub fn paramP0(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_PARAMP0,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn paramK(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_PARAMK,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn paramR(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_PARAMR,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn newsLines(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveResData_ActivityNewsLine<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveResData_ActivityNewsLine>,
                >,
            >>(
                clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_NEWSLINES,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveResData_NewsArchiveResItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("newsType", Self::VT_NEWSTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveResData_NewsFormatData>>("newsFormat", Self::VT_NEWSFORMAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("newsText", Self::VT_NEWSTEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("newsAuthor", Self::VT_NEWSAUTHOR, false)?
     .visit_field::<i32>("paramP0", Self::VT_PARAMP0, false)?
     .visit_field::<i32>("paramK", Self::VT_PARAMK, false)?
     .visit_field::<f32>("paramR", Self::VT_PARAMR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveResData_ActivityNewsLine>>>>("newsLines", Self::VT_NEWSLINES, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveResData_NewsArchiveResItemDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub newsType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub newsFormat:
        Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_NewsFormatData<'a>>>,
    pub newsText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub newsAuthor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub paramP0: i32,
    pub paramK: i32,
    pub paramR: f32,
    pub newsLines: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveResData_ActivityNewsLine<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveResData_NewsArchiveResItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveResData_NewsArchiveResItemDataArgs {
            id: None,
            desc: None,
            newsType: None,
            newsFormat: None,
            newsText: None,
            newsAuthor: None,
            paramP0: 0,
            paramK: 0,
            paramR: 0.0,
            newsLines: None,
        }
    }
}

pub struct clz_Torappu_ActArchiveResData_NewsArchiveResItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveResData_NewsArchiveResItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_newsType(&mut self, newsType: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_NEWSTYPE,
            newsType,
        );
    }
    #[inline]
    pub fn add_newsFormat(
        &mut self,
        newsFormat: flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_NewsFormatData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_NewsFormatData>>(clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_NEWSFORMAT, newsFormat);
    }
    #[inline]
    pub fn add_newsText(&mut self, newsText: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_NEWSTEXT,
            newsText,
        );
    }
    #[inline]
    pub fn add_newsAuthor(&mut self, newsAuthor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_NEWSAUTHOR,
            newsAuthor,
        );
    }
    #[inline]
    pub fn add_paramP0(&mut self, paramP0: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_PARAMP0,
            paramP0,
            0,
        );
    }
    #[inline]
    pub fn add_paramK(&mut self, paramK: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_PARAMK,
            paramK,
            0,
        );
    }
    #[inline]
    pub fn add_paramR(&mut self, paramR: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_PARAMR,
            paramR,
            0.0,
        );
    }
    #[inline]
    pub fn add_newsLines(
        &mut self,
        newsLines: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveResData_ActivityNewsLine<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_NEWSLINES,
            newsLines,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveResData_NewsArchiveResItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveResData_NewsArchiveResItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_NewsArchiveResItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveResData_NewsArchiveResItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveResData_NewsArchiveResItemData");
        ds.field("id", &self.id());
        ds.field("desc", &self.desc());
        ds.field("newsType", &self.newsType());
        ds.field("newsFormat", &self.newsFormat());
        ds.field("newsText", &self.newsText());
        ds.field("newsAuthor", &self.newsAuthor());
        ds.field("paramP0", &self.paramP0());
        ds.field("paramK", &self.paramK());
        ds.field("paramR", &self.paramR());
        ds.field("newsLines", &self.newsLines());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemData<'a>
{
    type Inner = dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemData<'bldr>,
    > {
        let mut builder =
            dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveResData_NewsArchiveResItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                clz_Torappu_ActArchiveResData_NewsArchiveResItemData,
            >>(
                dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveResData_NewsArchiveResItemData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value:
        Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_NewsArchiveResItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_NewsArchiveResItemData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_NewsArchiveResItemData>>(dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemData<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveResData_LandmarkArchiveResItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData<'a> {
    type Inner = clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData<'a> {
    pub const VT_LANDMARKID: flatbuffers::VOffsetT = 4;
    pub const VT_LANDMARKNAME: flatbuffers::VOffsetT = 6;
    pub const VT_LANDMARKPIC: flatbuffers::VOffsetT = 8;
    pub const VT_LANDMARKDESC: flatbuffers::VOffsetT = 10;
    pub const VT_LANDMARKENGNAME: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveResData_LandmarkArchiveResItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData<'bldr>>
    {
        let mut builder =
            clz_Torappu_ActArchiveResData_LandmarkArchiveResItemDataBuilder::new(_fbb);
        if let Some(x) = args.landmarkEngName {
            builder.add_landmarkEngName(x);
        }
        if let Some(x) = args.landmarkDesc {
            builder.add_landmarkDesc(x);
        }
        if let Some(x) = args.landmarkPic {
            builder.add_landmarkPic(x);
        }
        if let Some(x) = args.landmarkName {
            builder.add_landmarkName(x);
        }
        if let Some(x) = args.landmarkId {
            builder.add_landmarkId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn landmarkId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData::VT_LANDMARKID,
                None,
            )
        }
    }
    #[inline]
    pub fn landmarkName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData::VT_LANDMARKNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn landmarkPic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData::VT_LANDMARKPIC,
                None,
            )
        }
    }
    #[inline]
    pub fn landmarkDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData::VT_LANDMARKDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn landmarkEngName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData::VT_LANDMARKENGNAME,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "landmarkId",
                Self::VT_LANDMARKID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "landmarkName",
                Self::VT_LANDMARKNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "landmarkPic",
                Self::VT_LANDMARKPIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "landmarkDesc",
                Self::VT_LANDMARKDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "landmarkEngName",
                Self::VT_LANDMARKENGNAME,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveResData_LandmarkArchiveResItemDataArgs<'a> {
    pub landmarkId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub landmarkName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub landmarkPic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub landmarkDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub landmarkEngName: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ActArchiveResData_LandmarkArchiveResItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveResData_LandmarkArchiveResItemDataArgs {
            landmarkId: None,
            landmarkName: None,
            landmarkPic: None,
            landmarkDesc: None,
            landmarkEngName: None,
        }
    }
}

pub struct clz_Torappu_ActArchiveResData_LandmarkArchiveResItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveResData_LandmarkArchiveResItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_landmarkId(&mut self, landmarkId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData::VT_LANDMARKID,
            landmarkId,
        );
    }
    #[inline]
    pub fn add_landmarkName(&mut self, landmarkName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData::VT_LANDMARKNAME,
            landmarkName,
        );
    }
    #[inline]
    pub fn add_landmarkPic(&mut self, landmarkPic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData::VT_LANDMARKPIC,
            landmarkPic,
        );
    }
    #[inline]
    pub fn add_landmarkDesc(&mut self, landmarkDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData::VT_LANDMARKDESC,
            landmarkDesc,
        );
    }
    #[inline]
    pub fn add_landmarkEngName(&mut self, landmarkEngName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData::VT_LANDMARKENGNAME,
            landmarkEngName,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveResData_LandmarkArchiveResItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveResData_LandmarkArchiveResItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData");
        ds.field("landmarkId", &self.landmarkId());
        ds.field("landmarkName", &self.landmarkName());
        ds.field("landmarkPic", &self.landmarkPic());
        ds.field("landmarkDesc", &self.landmarkDesc());
        ds.field("landmarkEngName", &self.landmarkEngName());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData<'a>
{
    type Inner = dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemDataArgs<
            'args,
        >,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData<'bldr>,
    > {
        let mut builder =
            dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemDataBuilder::new(
                _fbb,
            );
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData,
            >>(
                dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData<'a>>,
    >,
}
impl<'a> Default
    for dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemDataArgs<'a>
{
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData>>(dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemDataBuilder<'a, 'b, A>
    {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f
            .debug_struct("dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveResData_LogArchiveResItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveResData_LogArchiveResItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveResData_LogArchiveResItemData<'a> {
    type Inner = clz_Torappu_ActArchiveResData_LogArchiveResItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveResData_LogArchiveResItemData<'a> {
    pub const VT_LOGID: flatbuffers::VOffsetT = 4;
    pub const VT_LOGDESC: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveResData_LogArchiveResItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveResData_LogArchiveResItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_LogArchiveResItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveResData_LogArchiveResItemDataBuilder::new(_fbb);
        if let Some(x) = args.logDesc {
            builder.add_logDesc(x);
        }
        if let Some(x) = args.logId {
            builder.add_logId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn logId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_LogArchiveResItemData::VT_LOGID,
                None,
            )
        }
    }
    #[inline]
    pub fn logDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_LogArchiveResItemData::VT_LOGDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveResData_LogArchiveResItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("logId", Self::VT_LOGID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("logDesc", Self::VT_LOGDESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveResData_LogArchiveResItemDataArgs<'a> {
    pub logId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub logDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ActArchiveResData_LogArchiveResItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveResData_LogArchiveResItemDataArgs {
            logId: None,
            logDesc: None,
        }
    }
}

pub struct clz_Torappu_ActArchiveResData_LogArchiveResItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveResData_LogArchiveResItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_logId(&mut self, logId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_LogArchiveResItemData::VT_LOGID,
            logId,
        );
    }
    #[inline]
    pub fn add_logDesc(&mut self, logDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_LogArchiveResItemData::VT_LOGDESC,
            logDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveResData_LogArchiveResItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveResData_LogArchiveResItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_LogArchiveResItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveResData_LogArchiveResItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveResData_LogArchiveResItemData");
        ds.field("logId", &self.logId());
        ds.field("logDesc", &self.logDesc());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemData<'a>
{
    type Inner = dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemData<'bldr>,
    > {
        let mut builder =
            dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveResData_LogArchiveResItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                clz_Torappu_ActArchiveResData_LogArchiveResItemData,
            >>(
                dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveResData_LogArchiveResItemData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value:
        Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_LogArchiveResItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_LogArchiveResItemData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_LogArchiveResItemData>>(dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData<'a>
{
    type Inner = clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData<'a> {
    pub const VT_STORYID: flatbuffers::VOffsetT = 4;
    pub const VT_TITLENAME: flatbuffers::VOffsetT = 6;
    pub const VT_STORYNAME: flatbuffers::VOffsetT = 8;
    pub const VT_TEXTID: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData<'bldr>>
    {
        let mut builder =
            clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemDataBuilder::new(_fbb);
        if let Some(x) = args.textId {
            builder.add_textId(x);
        }
        if let Some(x) = args.storyName {
            builder.add_storyName(x);
        }
        if let Some(x) = args.titleName {
            builder.add_titleName(x);
        }
        if let Some(x) = args.storyId {
            builder.add_storyId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn storyId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData::VT_STORYID,
                None,
            )
        }
    }
    #[inline]
    pub fn titleName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData::VT_TITLENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn storyName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData::VT_STORYNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn textId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData::VT_TEXTID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("storyId", Self::VT_STORYID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "titleName",
                Self::VT_TITLENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "storyName",
                Self::VT_STORYNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("textId", Self::VT_TEXTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemDataArgs<'a> {
    pub storyId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub titleName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub storyName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub textId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemDataArgs {
            storyId: None,
            titleName: None,
            storyName: None,
            textId: None,
        }
    }
}

pub struct clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_storyId(&mut self, storyId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData::VT_STORYID,
            storyId,
        );
    }
    #[inline]
    pub fn add_titleName(&mut self, titleName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData::VT_TITLENAME,
            titleName,
        );
    }
    #[inline]
    pub fn add_storyName(&mut self, storyName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData::VT_STORYNAME,
            storyName,
        );
    }
    #[inline]
    pub fn add_textId(&mut self, textId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData::VT_TEXTID,
            textId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData");
        ds.field("storyId", &self.storyId());
        ds.field("titleName", &self.titleName());
        ds.field("storyName", &self.storyName());
        ds.field("textId", &self.textId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData<'a>
{
    type Inner = dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData<'bldr>,
    > {
        let mut builder =
            dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemDataBuilder::new(
                _fbb,
            );
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData::VT_KEY, None).unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData>>(dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData<'a>>,
    >,
}
impl<'a> Default
    for dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemDataArgs<'a>
{
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<
            clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData,
        >>(
            dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemDataBuilder<'a, 'b, A>
    {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct(
            "dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData",
        );
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveResDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveResData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveResData<'a> {
    type Inner = clz_Torappu_ActArchiveResData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveResData<'a> {
    pub const VT_PICS: flatbuffers::VOffsetT = 4;
    pub const VT_AUDIOS: flatbuffers::VOffsetT = 6;
    pub const VT_AVGS: flatbuffers::VOffsetT = 8;
    pub const VT_STORIES: flatbuffers::VOffsetT = 10;
    pub const VT_NEWS: flatbuffers::VOffsetT = 12;
    pub const VT_LANDMARKS: flatbuffers::VOffsetT = 14;
    pub const VT_LOGS: flatbuffers::VOffsetT = 16;
    pub const VT_CHALLENGEBOOKS: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveResData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveResDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveResDataBuilder::new(_fbb);
        if let Some(x) = args.challengeBooks {
            builder.add_challengeBooks(x);
        }
        if let Some(x) = args.logs {
            builder.add_logs(x);
        }
        if let Some(x) = args.landmarks {
            builder.add_landmarks(x);
        }
        if let Some(x) = args.news {
            builder.add_news(x);
        }
        if let Some(x) = args.stories {
            builder.add_stories(x);
        }
        if let Some(x) = args.avgs {
            builder.add_avgs(x);
        }
        if let Some(x) = args.audios {
            builder.add_audios(x);
        }
        if let Some(x) = args.pics {
            builder.add_pics(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn pics(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemData,
                    >,
                >,
            >>(clz_Torappu_ActArchiveResData::VT_PICS, None)
        }
    }
    #[inline]
    pub fn audios(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemData,
                    >,
                >,
            >>(clz_Torappu_ActArchiveResData::VT_AUDIOS, None)
        }
    }
    #[inline]
    pub fn avgs(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemData,
                    >,
                >,
            >>(clz_Torappu_ActArchiveResData::VT_AVGS, None)
        }
    }
    #[inline]
    pub fn stories(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemData,
                    >,
                >,
            >>(clz_Torappu_ActArchiveResData::VT_STORIES, None)
        }
    }
    #[inline]
    pub fn news(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemData,
                    >,
                >,
            >>(clz_Torappu_ActArchiveResData::VT_NEWS, None)
        }
    }
    #[inline]
    pub fn landmarks(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData,
                    >,
                >,
            >>(clz_Torappu_ActArchiveResData::VT_LANDMARKS, None)
        }
    }
    #[inline]
    pub fn logs(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemData,
                    >,
                >,
            >>(clz_Torappu_ActArchiveResData::VT_LOGS, None)
        }
    }
    #[inline]
    pub fn challengeBooks(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData,
                    >,
                >,
            >>(clz_Torappu_ActArchiveResData::VT_CHALLENGEBOOKS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveResData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemData,
                    >,
                >,
            >>("pics", Self::VT_PICS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemData,
                    >,
                >,
            >>("audios", Self::VT_AUDIOS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemData,
                    >,
                >,
            >>("avgs", Self::VT_AVGS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemData,
                    >,
                >,
            >>("stories", Self::VT_STORIES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemData,
                    >,
                >,
            >>("news", Self::VT_NEWS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData,
                    >,
                >,
            >>("landmarks", Self::VT_LANDMARKS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemData,
                    >,
                >,
            >>("logs", Self::VT_LOGS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData,
                    >,
                >,
            >>("challengeBooks", Self::VT_CHALLENGEBOOKS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveResDataArgs<'a> {
    pub pics: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemData<'a>,
                >,
            >,
        >,
    >,
    pub audios: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemData<'a>,
                >,
            >,
        >,
    >,
    pub avgs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemData<'a>,
                >,
            >,
        >,
    >,
    pub stories: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemData<'a>,
                >,
            >,
        >,
    >,
    pub news: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemData<'a>,
                >,
            >,
        >,
    >,
    pub landmarks: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData<'a>,
                >,
            >,
        >,
    >,
    pub logs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemData<'a>,
                >,
            >,
        >,
    >,
    pub challengeBooks: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveResDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveResDataArgs {
            pics: None,
            audios: None,
            avgs: None,
            stories: None,
            news: None,
            landmarks: None,
            logs: None,
            challengeBooks: None,
        }
    }
}

pub struct clz_Torappu_ActArchiveResDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ActArchiveResDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_pics(
        &mut self,
        pics: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveResData_PicArchiveResItemData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData::VT_PICS,
            pics,
        );
    }
    #[inline]
    pub fn add_audios(
        &mut self,
        audios: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveResData_AudioArchiveResItemData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData::VT_AUDIOS,
            audios,
        );
    }
    #[inline]
    pub fn add_avgs(
        &mut self,
        avgs: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveResData_AvgArchiveResItemData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData::VT_AVGS,
            avgs,
        );
    }
    #[inline]
    pub fn add_stories(
        &mut self,
        stories: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveResData_StoryArchiveResItemData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData::VT_STORIES,
            stories,
        );
    }
    #[inline]
    pub fn add_news(
        &mut self,
        news: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveResData_NewsArchiveResItemData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData::VT_NEWS,
            news,
        );
    }
    #[inline]
    pub fn add_landmarks(
        &mut self,
        landmarks: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveResData_LandmarkArchiveResItemData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData::VT_LANDMARKS,
            landmarks,
        );
    }
    #[inline]
    pub fn add_logs(
        &mut self,
        logs: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveResData_LogArchiveResItemData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData::VT_LOGS,
            logs,
        );
    }
    #[inline]
    pub fn add_challengeBooks(
        &mut self,
        challengeBooks: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveResData_ChallengeBookArchiveResItemData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveResData::VT_CHALLENGEBOOKS,
            challengeBooks,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveResDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveResDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveResData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveResData");
        ds.field("pics", &self.pics());
        ds.field("audios", &self.audios());
        ds.field("avgs", &self.avgs());
        ds.field("stories", &self.stories());
        ds.field("news", &self.news());
        ds.field("landmarks", &self.landmarks());
        ds.field("logs", &self.logs());
        ds.field("challengeBooks", &self.challengeBooks());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveTimelineItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveTimelineItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveTimelineItemData<'a> {
    type Inner = clz_Torappu_ActArchiveTimelineItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveTimelineItemData<'a> {
    pub const VT_TIMELINEID: flatbuffers::VOffsetT = 4;
    pub const VT_TIMELINESORTID: flatbuffers::VOffsetT = 6;
    pub const VT_TIMELINETITLE: flatbuffers::VOffsetT = 8;
    pub const VT_TIMELINEDES: flatbuffers::VOffsetT = 10;
    pub const VT_PICIDLIST: flatbuffers::VOffsetT = 12;
    pub const VT_AUDIOIDLIST: flatbuffers::VOffsetT = 14;
    pub const VT_AVGIDLIST: flatbuffers::VOffsetT = 16;
    pub const VT_STORYIDLIST: flatbuffers::VOffsetT = 18;
    pub const VT_NEWSIDLIST: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveTimelineItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveTimelineItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveTimelineItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveTimelineItemDataBuilder::new(_fbb);
        if let Some(x) = args.newsIdList {
            builder.add_newsIdList(x);
        }
        if let Some(x) = args.storyIdList {
            builder.add_storyIdList(x);
        }
        if let Some(x) = args.avgIdList {
            builder.add_avgIdList(x);
        }
        if let Some(x) = args.audioIdList {
            builder.add_audioIdList(x);
        }
        if let Some(x) = args.picIdList {
            builder.add_picIdList(x);
        }
        if let Some(x) = args.timelineDes {
            builder.add_timelineDes(x);
        }
        if let Some(x) = args.timelineTitle {
            builder.add_timelineTitle(x);
        }
        builder.add_timelineSortId(args.timelineSortId);
        if let Some(x) = args.timelineId {
            builder.add_timelineId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn timelineId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveTimelineItemData::VT_TIMELINEID,
                None,
            )
        }
    }
    #[inline]
    pub fn timelineSortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ActArchiveTimelineItemData::VT_TIMELINESORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn timelineTitle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveTimelineItemData::VT_TIMELINETITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn timelineDes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveTimelineItemData::VT_TIMELINEDES,
                None,
            )
        }
    }
    #[inline]
    pub fn picIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ActArchiveTimelineItemData::VT_PICIDLIST, None)
        }
    }
    #[inline]
    pub fn audioIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ActArchiveTimelineItemData::VT_AUDIOIDLIST, None)
        }
    }
    #[inline]
    pub fn avgIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ActArchiveTimelineItemData::VT_AVGIDLIST, None)
        }
    }
    #[inline]
    pub fn storyIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ActArchiveTimelineItemData::VT_STORYIDLIST, None)
        }
    }
    #[inline]
    pub fn newsIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ActArchiveTimelineItemData::VT_NEWSIDLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveTimelineItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "timelineId",
                Self::VT_TIMELINEID,
                false,
            )?
            .visit_field::<i32>("timelineSortId", Self::VT_TIMELINESORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "timelineTitle",
                Self::VT_TIMELINETITLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "timelineDes",
                Self::VT_TIMELINEDES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("picIdList", Self::VT_PICIDLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("audioIdList", Self::VT_AUDIOIDLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("avgIdList", Self::VT_AVGIDLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("storyIdList", Self::VT_STORYIDLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("newsIdList", Self::VT_NEWSIDLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveTimelineItemDataArgs<'a> {
    pub timelineId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timelineSortId: i32,
    pub timelineTitle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timelineDes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub picIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub audioIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub avgIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub storyIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub newsIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveTimelineItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveTimelineItemDataArgs {
            timelineId: None,
            timelineSortId: 0,
            timelineTitle: None,
            timelineDes: None,
            picIdList: None,
            audioIdList: None,
            avgIdList: None,
            storyIdList: None,
            newsIdList: None,
        }
    }
}

pub struct clz_Torappu_ActArchiveTimelineItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveTimelineItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_timelineId(&mut self, timelineId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveTimelineItemData::VT_TIMELINEID,
            timelineId,
        );
    }
    #[inline]
    pub fn add_timelineSortId(&mut self, timelineSortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ActArchiveTimelineItemData::VT_TIMELINESORTID,
            timelineSortId,
            0,
        );
    }
    #[inline]
    pub fn add_timelineTitle(&mut self, timelineTitle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveTimelineItemData::VT_TIMELINETITLE,
            timelineTitle,
        );
    }
    #[inline]
    pub fn add_timelineDes(&mut self, timelineDes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveTimelineItemData::VT_TIMELINEDES,
            timelineDes,
        );
    }
    #[inline]
    pub fn add_picIdList(
        &mut self,
        picIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveTimelineItemData::VT_PICIDLIST,
            picIdList,
        );
    }
    #[inline]
    pub fn add_audioIdList(
        &mut self,
        audioIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveTimelineItemData::VT_AUDIOIDLIST,
            audioIdList,
        );
    }
    #[inline]
    pub fn add_avgIdList(
        &mut self,
        avgIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveTimelineItemData::VT_AVGIDLIST,
            avgIdList,
        );
    }
    #[inline]
    pub fn add_storyIdList(
        &mut self,
        storyIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveTimelineItemData::VT_STORYIDLIST,
            storyIdList,
        );
    }
    #[inline]
    pub fn add_newsIdList(
        &mut self,
        newsIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveTimelineItemData::VT_NEWSIDLIST,
            newsIdList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveTimelineItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveTimelineItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveTimelineItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveTimelineItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveTimelineItemData");
        ds.field("timelineId", &self.timelineId());
        ds.field("timelineSortId", &self.timelineSortId());
        ds.field("timelineTitle", &self.timelineTitle());
        ds.field("timelineDes", &self.timelineDes());
        ds.field("picIdList", &self.picIdList());
        ds.field("audioIdList", &self.audioIdList());
        ds.field("avgIdList", &self.avgIdList());
        ds.field("storyIdList", &self.storyIdList());
        ds.field("newsIdList", &self.newsIdList());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveTimelineDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveTimelineData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveTimelineData<'a> {
    type Inner = clz_Torappu_ActArchiveTimelineData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveTimelineData<'a> {
    pub const VT_TIMELINELIST: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveTimelineData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveTimelineDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveTimelineData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveTimelineDataBuilder::new(_fbb);
        if let Some(x) = args.timelineList {
            builder.add_timelineList(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn timelineList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveTimelineItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveTimelineItemData>,
                >,
            >>(clz_Torappu_ActArchiveTimelineData::VT_TIMELINELIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveTimelineData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveTimelineItemData>,
                >,
            >>("timelineList", Self::VT_TIMELINELIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveTimelineDataArgs<'a> {
    pub timelineList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveTimelineItemData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveTimelineDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveTimelineDataArgs { timelineList: None }
    }
}

pub struct clz_Torappu_ActArchiveTimelineDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveTimelineDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_timelineList(
        &mut self,
        timelineList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveTimelineItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveTimelineData::VT_TIMELINELIST,
            timelineList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveTimelineDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveTimelineDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveTimelineData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveTimelineData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveTimelineData");
        ds.field("timelineList", &self.timelineList());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveMusicItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveMusicItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveMusicItemData<'a> {
    type Inner = clz_Torappu_ActArchiveMusicItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveMusicItemData<'a> {
    pub const VT_MUSICID: flatbuffers::VOffsetT = 4;
    pub const VT_MUSICSORTID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveMusicItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveMusicItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveMusicItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveMusicItemDataBuilder::new(_fbb);
        builder.add_musicSortId(args.musicSortId);
        if let Some(x) = args.musicId {
            builder.add_musicId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn musicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveMusicItemData::VT_MUSICID,
                None,
            )
        }
    }
    #[inline]
    pub fn musicSortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ActArchiveMusicItemData::VT_MUSICSORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveMusicItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("musicId", Self::VT_MUSICID, false)?
            .visit_field::<i32>("musicSortId", Self::VT_MUSICSORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveMusicItemDataArgs<'a> {
    pub musicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub musicSortId: i32,
}
impl<'a> Default for clz_Torappu_ActArchiveMusicItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveMusicItemDataArgs {
            musicId: None,
            musicSortId: 0,
        }
    }
}

pub struct clz_Torappu_ActArchiveMusicItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveMusicItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_musicId(&mut self, musicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveMusicItemData::VT_MUSICID,
            musicId,
        );
    }
    #[inline]
    pub fn add_musicSortId(&mut self, musicSortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ActArchiveMusicItemData::VT_MUSICSORTID,
            musicSortId,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveMusicItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveMusicItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveMusicItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveMusicItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveMusicItemData");
        ds.field("musicId", &self.musicId());
        ds.field("musicSortId", &self.musicSortId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_ActArchiveMusicItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveMusicItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveMusicItemData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveMusicItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveMusicItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveMusicItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveMusicItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveMusicItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActArchiveMusicItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveMusicItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveMusicItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveMusicItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveMusicItemData>>(
                    dict__string__clz_Torappu_ActArchiveMusicItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveMusicItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveMusicItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveMusicItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveMusicItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveMusicItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveMusicItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_ActArchiveMusicItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveMusicItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveMusicItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveMusicItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveMusicItemData>>(
                dict__string__clz_Torappu_ActArchiveMusicItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveMusicItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveMusicItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveMusicItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveMusicItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveMusicItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveMusicItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveMusicDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveMusicData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveMusicData<'a> {
    type Inner = clz_Torappu_ActArchiveMusicData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveMusicData<'a> {
    pub const VT_MUSICS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveMusicData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveMusicDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveMusicData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveMusicDataBuilder::new(_fbb);
        if let Some(x) = args.musics {
            builder.add_musics(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn musics(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveMusicItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveMusicItemData>,
                >,
            >>(clz_Torappu_ActArchiveMusicData::VT_MUSICS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveMusicData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveMusicItemData>,
                >,
            >>("musics", Self::VT_MUSICS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveMusicDataArgs<'a> {
    pub musics: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveMusicItemData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveMusicDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveMusicDataArgs { musics: None }
    }
}

pub struct clz_Torappu_ActArchiveMusicDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ActArchiveMusicDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_musics(
        &mut self,
        musics: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveMusicItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveMusicData::VT_MUSICS,
            musics,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveMusicDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveMusicDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveMusicData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveMusicData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveMusicData");
        ds.field("musics", &self.musics());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchivePicItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchivePicItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchivePicItemData<'a> {
    type Inner = clz_Torappu_ActArchivePicItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchivePicItemData<'a> {
    pub const VT_PICID: flatbuffers::VOffsetT = 4;
    pub const VT_PICSORTID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchivePicItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchivePicItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchivePicItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchivePicItemDataBuilder::new(_fbb);
        builder.add_picSortId(args.picSortId);
        if let Some(x) = args.picId {
            builder.add_picId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn picId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchivePicItemData::VT_PICID,
                None,
            )
        }
    }
    #[inline]
    pub fn picSortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ActArchivePicItemData::VT_PICSORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchivePicItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("picId", Self::VT_PICID, false)?
            .visit_field::<i32>("picSortId", Self::VT_PICSORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchivePicItemDataArgs<'a> {
    pub picId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub picSortId: i32,
}
impl<'a> Default for clz_Torappu_ActArchivePicItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchivePicItemDataArgs {
            picId: None,
            picSortId: 0,
        }
    }
}

pub struct clz_Torappu_ActArchivePicItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchivePicItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_picId(&mut self, picId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchivePicItemData::VT_PICID,
            picId,
        );
    }
    #[inline]
    pub fn add_picSortId(&mut self, picSortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ActArchivePicItemData::VT_PICSORTID,
            picSortId,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchivePicItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchivePicItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchivePicItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchivePicItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchivePicItemData");
        ds.field("picId", &self.picId());
        ds.field("picSortId", &self.picSortId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_ActArchivePicItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchivePicItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchivePicItemData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchivePicItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchivePicItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchivePicItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchivePicItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchivePicItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActArchivePicItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchivePicItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchivePicItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchivePicItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchivePicItemData>>(
                    dict__string__clz_Torappu_ActArchivePicItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchivePicItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchivePicItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchivePicItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchivePicItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchivePicItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchivePicItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_ActArchivePicItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchivePicItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchivePicItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchivePicItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchivePicItemData>>(
                dict__string__clz_Torappu_ActArchivePicItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchivePicItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchivePicItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchivePicItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchivePicItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchivePicItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchivePicItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchivePicDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchivePicData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchivePicData<'a> {
    type Inner = clz_Torappu_ActArchivePicData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchivePicData<'a> {
    pub const VT_PICS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchivePicData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchivePicDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchivePicData<'bldr>> {
        let mut builder = clz_Torappu_ActArchivePicDataBuilder::new(_fbb);
        if let Some(x) = args.pics {
            builder.add_pics(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn pics(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchivePicItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchivePicItemData>,
                >,
            >>(clz_Torappu_ActArchivePicData::VT_PICS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchivePicData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchivePicItemData>,
                >,
            >>("pics", Self::VT_PICS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchivePicDataArgs<'a> {
    pub pics: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchivePicItemData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchivePicDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchivePicDataArgs { pics: None }
    }
}

pub struct clz_Torappu_ActArchivePicDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ActArchivePicDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_pics(
        &mut self,
        pics: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchivePicItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchivePicData::VT_PICS,
            pics,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchivePicDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchivePicDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchivePicData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchivePicData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchivePicData");
        ds.field("pics", &self.pics());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveStoryItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveStoryItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveStoryItemData<'a> {
    type Inner = clz_Torappu_ActArchiveStoryItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveStoryItemData<'a> {
    pub const VT_STORYID: flatbuffers::VOffsetT = 4;
    pub const VT_STORYSORTID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveStoryItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveStoryItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveStoryItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveStoryItemDataBuilder::new(_fbb);
        builder.add_storySortId(args.storySortId);
        if let Some(x) = args.storyId {
            builder.add_storyId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn storyId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveStoryItemData::VT_STORYID,
                None,
            )
        }
    }
    #[inline]
    pub fn storySortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ActArchiveStoryItemData::VT_STORYSORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveStoryItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("storyId", Self::VT_STORYID, false)?
            .visit_field::<i32>("storySortId", Self::VT_STORYSORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveStoryItemDataArgs<'a> {
    pub storyId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub storySortId: i32,
}
impl<'a> Default for clz_Torappu_ActArchiveStoryItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveStoryItemDataArgs {
            storyId: None,
            storySortId: 0,
        }
    }
}

pub struct clz_Torappu_ActArchiveStoryItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveStoryItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_storyId(&mut self, storyId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveStoryItemData::VT_STORYID,
            storyId,
        );
    }
    #[inline]
    pub fn add_storySortId(&mut self, storySortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ActArchiveStoryItemData::VT_STORYSORTID,
            storySortId,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveStoryItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveStoryItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveStoryItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveStoryItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveStoryItemData");
        ds.field("storyId", &self.storyId());
        ds.field("storySortId", &self.storySortId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_ActArchiveStoryItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveStoryItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveStoryItemData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveStoryItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveStoryItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveStoryItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveStoryItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveStoryItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActArchiveStoryItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveStoryItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveStoryItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveStoryItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveStoryItemData>>(
                    dict__string__clz_Torappu_ActArchiveStoryItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveStoryItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveStoryItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveStoryItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveStoryItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveStoryItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveStoryItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_ActArchiveStoryItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveStoryItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveStoryItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveStoryItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveStoryItemData>>(
                dict__string__clz_Torappu_ActArchiveStoryItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveStoryItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveStoryItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveStoryItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveStoryItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveStoryItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveStoryItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveStoryDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveStoryData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveStoryData<'a> {
    type Inner = clz_Torappu_ActArchiveStoryData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveStoryData<'a> {
    pub const VT_STORIES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveStoryData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveStoryDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveStoryData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveStoryDataBuilder::new(_fbb);
        if let Some(x) = args.stories {
            builder.add_stories(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn stories(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveStoryItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveStoryItemData>,
                >,
            >>(clz_Torappu_ActArchiveStoryData::VT_STORIES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveStoryData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveStoryItemData>,
                >,
            >>("stories", Self::VT_STORIES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveStoryDataArgs<'a> {
    pub stories: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveStoryItemData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveStoryDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveStoryDataArgs { stories: None }
    }
}

pub struct clz_Torappu_ActArchiveStoryDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ActArchiveStoryDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_stories(
        &mut self,
        stories: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveStoryItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveStoryData::VT_STORIES,
            stories,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveStoryDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveStoryDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveStoryData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveStoryData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveStoryData");
        ds.field("stories", &self.stories());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveAvgItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveAvgItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveAvgItemData<'a> {
    type Inner = clz_Torappu_ActArchiveAvgItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveAvgItemData<'a> {
    pub const VT_AVGID: flatbuffers::VOffsetT = 4;
    pub const VT_AVGSORTID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveAvgItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveAvgItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveAvgItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveAvgItemDataBuilder::new(_fbb);
        builder.add_avgSortId(args.avgSortId);
        if let Some(x) = args.avgId {
            builder.add_avgId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn avgId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveAvgItemData::VT_AVGID,
                None,
            )
        }
    }
    #[inline]
    pub fn avgSortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ActArchiveAvgItemData::VT_AVGSORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveAvgItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("avgId", Self::VT_AVGID, false)?
            .visit_field::<i32>("avgSortId", Self::VT_AVGSORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveAvgItemDataArgs<'a> {
    pub avgId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub avgSortId: i32,
}
impl<'a> Default for clz_Torappu_ActArchiveAvgItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveAvgItemDataArgs {
            avgId: None,
            avgSortId: 0,
        }
    }
}

pub struct clz_Torappu_ActArchiveAvgItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveAvgItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_avgId(&mut self, avgId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveAvgItemData::VT_AVGID,
            avgId,
        );
    }
    #[inline]
    pub fn add_avgSortId(&mut self, avgSortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ActArchiveAvgItemData::VT_AVGSORTID,
            avgSortId,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveAvgItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveAvgItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveAvgItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveAvgItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveAvgItemData");
        ds.field("avgId", &self.avgId());
        ds.field("avgSortId", &self.avgSortId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_ActArchiveAvgItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveAvgItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveAvgItemData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveAvgItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveAvgItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveAvgItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveAvgItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveAvgItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActArchiveAvgItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveAvgItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveAvgItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveAvgItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveAvgItemData>>(
                    dict__string__clz_Torappu_ActArchiveAvgItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveAvgItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveAvgItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveAvgItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveAvgItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveAvgItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveAvgItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_ActArchiveAvgItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveAvgItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveAvgItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveAvgItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveAvgItemData>>(
                dict__string__clz_Torappu_ActArchiveAvgItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveAvgItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveAvgItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveAvgItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveAvgItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveAvgItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveAvgItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveAvgDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveAvgData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveAvgData<'a> {
    type Inner = clz_Torappu_ActArchiveAvgData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveAvgData<'a> {
    pub const VT_AVGS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveAvgData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveAvgDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveAvgData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveAvgDataBuilder::new(_fbb);
        if let Some(x) = args.avgs {
            builder.add_avgs(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn avgs(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveAvgItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveAvgItemData>,
                >,
            >>(clz_Torappu_ActArchiveAvgData::VT_AVGS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveAvgData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveAvgItemData>,
                >,
            >>("avgs", Self::VT_AVGS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveAvgDataArgs<'a> {
    pub avgs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveAvgItemData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveAvgDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveAvgDataArgs { avgs: None }
    }
}

pub struct clz_Torappu_ActArchiveAvgDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ActArchiveAvgDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_avgs(
        &mut self,
        avgs: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveAvgItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveAvgData::VT_AVGS,
            avgs,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveAvgDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveAvgDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveAvgData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveAvgData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveAvgData");
        ds.field("avgs", &self.avgs());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveNewsItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveNewsItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveNewsItemData<'a> {
    type Inner = clz_Torappu_ActArchiveNewsItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveNewsItemData<'a> {
    pub const VT_NEWSID: flatbuffers::VOffsetT = 4;
    pub const VT_NEWSSORTID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveNewsItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveNewsItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveNewsItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveNewsItemDataBuilder::new(_fbb);
        builder.add_newsSortId(args.newsSortId);
        if let Some(x) = args.newsId {
            builder.add_newsId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn newsId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveNewsItemData::VT_NEWSID,
                None,
            )
        }
    }
    #[inline]
    pub fn newsSortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ActArchiveNewsItemData::VT_NEWSSORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveNewsItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("newsId", Self::VT_NEWSID, false)?
            .visit_field::<i32>("newsSortId", Self::VT_NEWSSORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveNewsItemDataArgs<'a> {
    pub newsId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub newsSortId: i32,
}
impl<'a> Default for clz_Torappu_ActArchiveNewsItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveNewsItemDataArgs {
            newsId: None,
            newsSortId: 0,
        }
    }
}

pub struct clz_Torappu_ActArchiveNewsItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveNewsItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_newsId(&mut self, newsId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveNewsItemData::VT_NEWSID,
            newsId,
        );
    }
    #[inline]
    pub fn add_newsSortId(&mut self, newsSortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ActArchiveNewsItemData::VT_NEWSSORTID,
            newsSortId,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveNewsItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveNewsItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveNewsItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveNewsItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveNewsItemData");
        ds.field("newsId", &self.newsId());
        ds.field("newsSortId", &self.newsSortId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_ActArchiveNewsItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveNewsItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveNewsItemData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveNewsItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveNewsItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveNewsItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveNewsItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveNewsItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActArchiveNewsItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveNewsItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveNewsItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveNewsItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveNewsItemData>>(
                    dict__string__clz_Torappu_ActArchiveNewsItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveNewsItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveNewsItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveNewsItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveNewsItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveNewsItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveNewsItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_ActArchiveNewsItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveNewsItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveNewsItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveNewsItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveNewsItemData>>(
                dict__string__clz_Torappu_ActArchiveNewsItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveNewsItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveNewsItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveNewsItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveNewsItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveNewsItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveNewsItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveNewsDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveNewsData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveNewsData<'a> {
    type Inner = clz_Torappu_ActArchiveNewsData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveNewsData<'a> {
    pub const VT_NEWS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveNewsData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveNewsDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveNewsData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveNewsDataBuilder::new(_fbb);
        if let Some(x) = args.news {
            builder.add_news(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn news(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveNewsItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveNewsItemData>,
                >,
            >>(clz_Torappu_ActArchiveNewsData::VT_NEWS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveNewsData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveNewsItemData>,
                >,
            >>("news", Self::VT_NEWS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveNewsDataArgs<'a> {
    pub news: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveNewsItemData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveNewsDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveNewsDataArgs { news: None }
    }
}

pub struct clz_Torappu_ActArchiveNewsDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ActArchiveNewsDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_news(
        &mut self,
        news: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveNewsItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveNewsData::VT_NEWS,
            news,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveNewsDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveNewsDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveNewsData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveNewsData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveNewsData");
        ds.field("news", &self.news());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveLandmarkItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveLandmarkItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveLandmarkItemData<'a> {
    type Inner = clz_Torappu_ActArchiveLandmarkItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveLandmarkItemData<'a> {
    pub const VT_LANDMARKID: flatbuffers::VOffsetT = 4;
    pub const VT_LANDMARKSORTID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveLandmarkItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveLandmarkItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveLandmarkItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveLandmarkItemDataBuilder::new(_fbb);
        builder.add_landmarkSortId(args.landmarkSortId);
        if let Some(x) = args.landmarkId {
            builder.add_landmarkId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn landmarkId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveLandmarkItemData::VT_LANDMARKID,
                None,
            )
        }
    }
    #[inline]
    pub fn landmarkSortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ActArchiveLandmarkItemData::VT_LANDMARKSORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveLandmarkItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "landmarkId",
                Self::VT_LANDMARKID,
                false,
            )?
            .visit_field::<i32>("landmarkSortId", Self::VT_LANDMARKSORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveLandmarkItemDataArgs<'a> {
    pub landmarkId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub landmarkSortId: i32,
}
impl<'a> Default for clz_Torappu_ActArchiveLandmarkItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveLandmarkItemDataArgs {
            landmarkId: None,
            landmarkSortId: 0,
        }
    }
}

pub struct clz_Torappu_ActArchiveLandmarkItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveLandmarkItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_landmarkId(&mut self, landmarkId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveLandmarkItemData::VT_LANDMARKID,
            landmarkId,
        );
    }
    #[inline]
    pub fn add_landmarkSortId(&mut self, landmarkSortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ActArchiveLandmarkItemData::VT_LANDMARKSORTID,
            landmarkSortId,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveLandmarkItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveLandmarkItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveLandmarkItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveLandmarkItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveLandmarkItemData");
        ds.field("landmarkId", &self.landmarkId());
        ds.field("landmarkSortId", &self.landmarkSortId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_ActArchiveLandmarkItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveLandmarkItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveLandmarkItemData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveLandmarkItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveLandmarkItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveLandmarkItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveLandmarkItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveLandmarkItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActArchiveLandmarkItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveLandmarkItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveLandmarkItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveLandmarkItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveLandmarkItemData>>(
                    dict__string__clz_Torappu_ActArchiveLandmarkItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveLandmarkItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveLandmarkItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveLandmarkItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveLandmarkItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveLandmarkItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveLandmarkItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_ActArchiveLandmarkItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveLandmarkItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveLandmarkItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveLandmarkItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveLandmarkItemData>>(
                dict__string__clz_Torappu_ActArchiveLandmarkItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveLandmarkItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveLandmarkItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveLandmarkItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveLandmarkItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveLandmarkItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveLandmarkItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveChapterLogDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveChapterLogData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveChapterLogData<'a> {
    type Inner = clz_Torappu_ActArchiveChapterLogData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveChapterLogData<'a> {
    pub const VT_CHAPTERNAME: flatbuffers::VOffsetT = 4;
    pub const VT_DISPLAYID: flatbuffers::VOffsetT = 6;
    pub const VT_UNLOCKDES: flatbuffers::VOffsetT = 8;
    pub const VT_LOGS: flatbuffers::VOffsetT = 10;
    pub const VT_CHAPTERICON: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveChapterLogData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveChapterLogDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveChapterLogData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveChapterLogDataBuilder::new(_fbb);
        builder.add_chapterIcon(args.chapterIcon);
        if let Some(x) = args.logs {
            builder.add_logs(x);
        }
        if let Some(x) = args.unlockDes {
            builder.add_unlockDes(x);
        }
        if let Some(x) = args.displayId {
            builder.add_displayId(x);
        }
        if let Some(x) = args.chapterName {
            builder.add_chapterName(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn chapterName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveChapterLogData::VT_CHAPTERNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn displayId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveChapterLogData::VT_DISPLAYID,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockDes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveChapterLogData::VT_UNLOCKDES,
                None,
            )
        }
    }
    #[inline]
    pub fn logs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ActArchiveChapterLogData::VT_LOGS, None)
        }
    }
    #[inline]
    pub fn chapterIcon(&self) -> enum__Torappu_Act17sideData_ChapterIconType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_Act17sideData_ChapterIconType>(
                    clz_Torappu_ActArchiveChapterLogData::VT_CHAPTERICON,
                    Some(enum__Torappu_Act17sideData_ChapterIconType::NORMAL),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveChapterLogData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "chapterName",
                Self::VT_CHAPTERNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "displayId",
                Self::VT_DISPLAYID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockDes",
                Self::VT_UNLOCKDES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("logs", Self::VT_LOGS, false)?
            .visit_field::<enum__Torappu_Act17sideData_ChapterIconType>(
                "chapterIcon",
                Self::VT_CHAPTERICON,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveChapterLogDataArgs<'a> {
    pub chapterName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub displayId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockDes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub logs: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub chapterIcon: enum__Torappu_Act17sideData_ChapterIconType,
}
impl<'a> Default for clz_Torappu_ActArchiveChapterLogDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveChapterLogDataArgs {
            chapterName: None,
            displayId: None,
            unlockDes: None,
            logs: None,
            chapterIcon: enum__Torappu_Act17sideData_ChapterIconType::NORMAL,
        }
    }
}

pub struct clz_Torappu_ActArchiveChapterLogDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveChapterLogDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_chapterName(&mut self, chapterName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveChapterLogData::VT_CHAPTERNAME,
            chapterName,
        );
    }
    #[inline]
    pub fn add_displayId(&mut self, displayId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveChapterLogData::VT_DISPLAYID,
            displayId,
        );
    }
    #[inline]
    pub fn add_unlockDes(&mut self, unlockDes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveChapterLogData::VT_UNLOCKDES,
            unlockDes,
        );
    }
    #[inline]
    pub fn add_logs(
        &mut self,
        logs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveChapterLogData::VT_LOGS,
            logs,
        );
    }
    #[inline]
    pub fn add_chapterIcon(&mut self, chapterIcon: enum__Torappu_Act17sideData_ChapterIconType) {
        self.fbb_
            .push_slot::<enum__Torappu_Act17sideData_ChapterIconType>(
                clz_Torappu_ActArchiveChapterLogData::VT_CHAPTERICON,
                chapterIcon,
                enum__Torappu_Act17sideData_ChapterIconType::NORMAL,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveChapterLogDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveChapterLogDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveChapterLogData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveChapterLogData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveChapterLogData");
        ds.field("chapterName", &self.chapterName());
        ds.field("displayId", &self.displayId());
        ds.field("unlockDes", &self.unlockDes());
        ds.field("logs", &self.logs());
        ds.field("chapterIcon", &self.chapterIcon());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_ActArchiveChapterLogDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveChapterLogData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveChapterLogData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveChapterLogData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveChapterLogData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveChapterLogData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveChapterLogDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveChapterLogData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActArchiveChapterLogDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveChapterLogData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveChapterLogData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveChapterLogData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveChapterLogData>>(
                    dict__string__clz_Torappu_ActArchiveChapterLogData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveChapterLogData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveChapterLogData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveChapterLogDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveChapterLogData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveChapterLogDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveChapterLogDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_ActArchiveChapterLogDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveChapterLogDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveChapterLogData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveChapterLogData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveChapterLogData>>(
                dict__string__clz_Torappu_ActArchiveChapterLogData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveChapterLogDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveChapterLogDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveChapterLogData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveChapterLogData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveChapterLogData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveChapterLogData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveChallengeBookItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveChallengeBookItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveChallengeBookItemData<'a> {
    type Inner = clz_Torappu_ActArchiveChallengeBookItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveChallengeBookItemData<'a> {
    pub const VT_STORYID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveChallengeBookItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveChallengeBookItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveChallengeBookItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveChallengeBookItemDataBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.storyId {
            builder.add_storyId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn storyId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveChallengeBookItemData::VT_STORYID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ActArchiveChallengeBookItemData::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveChallengeBookItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("storyId", Self::VT_STORYID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveChallengeBookItemDataArgs<'a> {
    pub storyId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_ActArchiveChallengeBookItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveChallengeBookItemDataArgs {
            storyId: None,
            sortId: 0,
        }
    }
}

pub struct clz_Torappu_ActArchiveChallengeBookItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveChallengeBookItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_storyId(&mut self, storyId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveChallengeBookItemData::VT_STORYID,
            storyId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ActArchiveChallengeBookItemData::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveChallengeBookItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveChallengeBookItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveChallengeBookItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveChallengeBookItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveChallengeBookItemData");
        ds.field("storyId", &self.storyId());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_ActArchiveChallengeBookItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveChallengeBookItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveChallengeBookItemData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveChallengeBookItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveChallengeBookItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveChallengeBookItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveChallengeBookItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveChallengeBookItemData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_ActArchiveChallengeBookItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveChallengeBookItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveChallengeBookItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveChallengeBookItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveChallengeBookItemData>>(
                    dict__string__clz_Torappu_ActArchiveChallengeBookItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveChallengeBookItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveChallengeBookItemData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveChallengeBookItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveChallengeBookItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveChallengeBookItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveChallengeBookItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_ActArchiveChallengeBookItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveChallengeBookItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveChallengeBookItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveChallengeBookItemData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveChallengeBookItemData>>(dict__string__clz_Torappu_ActArchiveChallengeBookItemData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveChallengeBookItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveChallengeBookItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveChallengeBookItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveChallengeBookItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveChallengeBookItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveChallengeBookItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveChallengeBookDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveChallengeBookData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveChallengeBookData<'a> {
    type Inner = clz_Torappu_ActArchiveChallengeBookData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveChallengeBookData<'a> {
    pub const VT_STORIES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveChallengeBookData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveChallengeBookDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveChallengeBookData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveChallengeBookDataBuilder::new(_fbb);
        if let Some(x) = args.stories {
            builder.add_stories(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn stories(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_ActArchiveChallengeBookItemData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveChallengeBookItemData,
                    >,
                >,
            >>(clz_Torappu_ActArchiveChallengeBookData::VT_STORIES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveChallengeBookData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveChallengeBookItemData,
                    >,
                >,
            >>("stories", Self::VT_STORIES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveChallengeBookDataArgs<'a> {
    pub stories: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveChallengeBookItemData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveChallengeBookDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveChallengeBookDataArgs { stories: None }
    }
}

pub struct clz_Torappu_ActArchiveChallengeBookDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveChallengeBookDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_stories(
        &mut self,
        stories: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveChallengeBookItemData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveChallengeBookData::VT_STORIES,
            stories,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveChallengeBookDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveChallengeBookDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveChallengeBookData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveChallengeBookData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveChallengeBookData");
        ds.field("stories", &self.stories());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveComponentDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveComponentData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveComponentData<'a> {
    type Inner = clz_Torappu_ActArchiveComponentData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveComponentData<'a> {
    pub const VT_TIMELINE: flatbuffers::VOffsetT = 4;
    pub const VT_MUSIC: flatbuffers::VOffsetT = 6;
    pub const VT_PIC: flatbuffers::VOffsetT = 8;
    pub const VT_STORY: flatbuffers::VOffsetT = 10;
    pub const VT_AVG: flatbuffers::VOffsetT = 12;
    pub const VT_NEWS: flatbuffers::VOffsetT = 14;
    pub const VT_LANDMARK: flatbuffers::VOffsetT = 16;
    pub const VT_LOG: flatbuffers::VOffsetT = 18;
    pub const VT_CHALLENGEBOOK: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveComponentData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveComponentDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveComponentData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveComponentDataBuilder::new(_fbb);
        if let Some(x) = args.challengeBook {
            builder.add_challengeBook(x);
        }
        if let Some(x) = args.log {
            builder.add_log(x);
        }
        if let Some(x) = args.landmark {
            builder.add_landmark(x);
        }
        if let Some(x) = args.news {
            builder.add_news(x);
        }
        if let Some(x) = args.avg {
            builder.add_avg(x);
        }
        if let Some(x) = args.story {
            builder.add_story(x);
        }
        if let Some(x) = args.pic {
            builder.add_pic(x);
        }
        if let Some(x) = args.music {
            builder.add_music(x);
        }
        if let Some(x) = args.timeline {
            builder.add_timeline(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn timeline(&self) -> Option<clz_Torappu_ActArchiveTimelineData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveTimelineData>>(
                    clz_Torappu_ActArchiveComponentData::VT_TIMELINE,
                    None,
                )
        }
    }
    #[inline]
    pub fn music(&self) -> Option<clz_Torappu_ActArchiveMusicData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveMusicData>>(
                    clz_Torappu_ActArchiveComponentData::VT_MUSIC,
                    None,
                )
        }
    }
    #[inline]
    pub fn pic(&self) -> Option<clz_Torappu_ActArchivePicData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchivePicData>>(
                    clz_Torappu_ActArchiveComponentData::VT_PIC,
                    None,
                )
        }
    }
    #[inline]
    pub fn story(&self) -> Option<clz_Torappu_ActArchiveStoryData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveStoryData>>(
                    clz_Torappu_ActArchiveComponentData::VT_STORY,
                    None,
                )
        }
    }
    #[inline]
    pub fn avg(&self) -> Option<clz_Torappu_ActArchiveAvgData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveAvgData>>(
                    clz_Torappu_ActArchiveComponentData::VT_AVG,
                    None,
                )
        }
    }
    #[inline]
    pub fn news(&self) -> Option<clz_Torappu_ActArchiveNewsData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveNewsData>>(
                    clz_Torappu_ActArchiveComponentData::VT_NEWS,
                    None,
                )
        }
    }
    #[inline]
    pub fn landmark(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveLandmarkItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveLandmarkItemData,
                    >,
                >,
            >>(clz_Torappu_ActArchiveComponentData::VT_LANDMARK, None)
        }
    }
    #[inline]
    pub fn log(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveChapterLogData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveChapterLogData,
                    >,
                >,
            >>(clz_Torappu_ActArchiveComponentData::VT_LOG, None)
        }
    }
    #[inline]
    pub fn challengeBook(&self) -> Option<clz_Torappu_ActArchiveChallengeBookData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveChallengeBookData>>(
                    clz_Torappu_ActArchiveComponentData::VT_CHALLENGEBOOK,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveComponentData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveTimelineData>>(
                "timeline",
                Self::VT_TIMELINE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveMusicData>>(
                "music",
                Self::VT_MUSIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchivePicData>>(
                "pic",
                Self::VT_PIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveStoryData>>(
                "story",
                Self::VT_STORY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveAvgData>>(
                "avg",
                Self::VT_AVG,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveNewsData>>(
                "news",
                Self::VT_NEWS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveLandmarkItemData,
                    >,
                >,
            >>("landmark", Self::VT_LANDMARK, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveChapterLogData,
                    >,
                >,
            >>("log", Self::VT_LOG, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveChallengeBookData>>(
                "challengeBook",
                Self::VT_CHALLENGEBOOK,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveComponentDataArgs<'a> {
    pub timeline: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveTimelineData<'a>>>,
    pub music: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveMusicData<'a>>>,
    pub pic: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchivePicData<'a>>>,
    pub story: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveStoryData<'a>>>,
    pub avg: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveAvgData<'a>>>,
    pub news: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveNewsData<'a>>>,
    pub landmark: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveLandmarkItemData<'a>,
                >,
            >,
        >,
    >,
    pub log: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveChapterLogData<'a>,
                >,
            >,
        >,
    >,
    pub challengeBook: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveChallengeBookData<'a>>>,
}
impl<'a> Default for clz_Torappu_ActArchiveComponentDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveComponentDataArgs {
            timeline: None,
            music: None,
            pic: None,
            story: None,
            avg: None,
            news: None,
            landmark: None,
            log: None,
            challengeBook: None,
        }
    }
}

pub struct clz_Torappu_ActArchiveComponentDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveComponentDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_timeline(
        &mut self,
        timeline: flatbuffers::WIPOffset<clz_Torappu_ActArchiveTimelineData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveTimelineData>>(
                clz_Torappu_ActArchiveComponentData::VT_TIMELINE,
                timeline,
            );
    }
    #[inline]
    pub fn add_music(
        &mut self,
        music: flatbuffers::WIPOffset<clz_Torappu_ActArchiveMusicData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveMusicData>>(
                clz_Torappu_ActArchiveComponentData::VT_MUSIC,
                music,
            );
    }
    #[inline]
    pub fn add_pic(&mut self, pic: flatbuffers::WIPOffset<clz_Torappu_ActArchivePicData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchivePicData>>(
                clz_Torappu_ActArchiveComponentData::VT_PIC,
                pic,
            );
    }
    #[inline]
    pub fn add_story(
        &mut self,
        story: flatbuffers::WIPOffset<clz_Torappu_ActArchiveStoryData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveStoryData>>(
                clz_Torappu_ActArchiveComponentData::VT_STORY,
                story,
            );
    }
    #[inline]
    pub fn add_avg(&mut self, avg: flatbuffers::WIPOffset<clz_Torappu_ActArchiveAvgData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveAvgData>>(
                clz_Torappu_ActArchiveComponentData::VT_AVG,
                avg,
            );
    }
    #[inline]
    pub fn add_news(&mut self, news: flatbuffers::WIPOffset<clz_Torappu_ActArchiveNewsData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveNewsData>>(
                clz_Torappu_ActArchiveComponentData::VT_NEWS,
                news,
            );
    }
    #[inline]
    pub fn add_landmark(
        &mut self,
        landmark: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveLandmarkItemData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveComponentData::VT_LANDMARK,
            landmark,
        );
    }
    #[inline]
    pub fn add_log(
        &mut self,
        log: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveChapterLogData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveComponentData::VT_LOG,
            log,
        );
    }
    #[inline]
    pub fn add_challengeBook(
        &mut self,
        challengeBook: flatbuffers::WIPOffset<clz_Torappu_ActArchiveChallengeBookData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveChallengeBookData>>(
                clz_Torappu_ActArchiveComponentData::VT_CHALLENGEBOOK,
                challengeBook,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveComponentDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveComponentDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveComponentData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveComponentData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveComponentData");
        ds.field("timeline", &self.timeline());
        ds.field("music", &self.music());
        ds.field("pic", &self.pic());
        ds.field("story", &self.story());
        ds.field("avg", &self.avg());
        ds.field("news", &self.news());
        ds.field("landmark", &self.landmark());
        ds.field("log", &self.log());
        ds.field("challengeBook", &self.challengeBook());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_ActArchiveComponentDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveComponentData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveComponentData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveComponentData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveComponentData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveComponentData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveComponentDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveComponentData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActArchiveComponentDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveComponentData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveComponentData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveComponentData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveComponentData>>(
                    dict__string__clz_Torappu_ActArchiveComponentData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveComponentData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveComponentData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveComponentDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveComponentData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveComponentDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveComponentDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_ActArchiveComponentDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveComponentDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveComponentData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveComponentData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveComponentData>>(
                dict__string__clz_Torappu_ActArchiveComponentData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveComponentDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveComponentDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveComponentData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveComponentData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveComponentData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveComponentData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_ActArchiveComponentTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveComponentTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveComponentTable<'a> {
    type Inner = clz_Torappu_ActArchiveComponentTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ActArchiveComponentTable<'a> {
    pub const VT_COMPONENTS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveComponentTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveComponentTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveComponentTable<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveComponentTableBuilder::new(_fbb);
        if let Some(x) = args.components {
            builder.add_components(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn components(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveComponentData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveComponentData>,
                >,
            >>(clz_Torappu_ActArchiveComponentTable::VT_COMPONENTS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveComponentTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveComponentData>,
                >,
            >>("components", Self::VT_COMPONENTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveComponentTableArgs<'a> {
    pub components: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveComponentData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveComponentTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveComponentTableArgs { components: None }
    }
}

pub struct clz_Torappu_ActArchiveComponentTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveComponentTableBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_components(
        &mut self,
        components: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveComponentData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveComponentTable::VT_COMPONENTS,
            components,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveComponentTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveComponentTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveComponentTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveComponentTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveComponentTable");
        ds.field("components", &self.components());
        ds.finish()
    }
}
pub enum clz_Torappu_TrainingCampStageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_TrainingCampStageData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_TrainingCampStageData<'a> {
    type Inner = clz_Torappu_TrainingCampStageData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_TrainingCampStageData<'a> {
    pub const VT_STAGEID: flatbuffers::VOffsetT = 4;
    pub const VT_STAGEICONID: flatbuffers::VOffsetT = 6;
    pub const VT_SORTID: flatbuffers::VOffsetT = 8;
    pub const VT_LEVELID: flatbuffers::VOffsetT = 10;
    pub const VT_CODE: flatbuffers::VOffsetT = 12;
    pub const VT_NAME: flatbuffers::VOffsetT = 14;
    pub const VT_LOADINGPICID: flatbuffers::VOffsetT = 16;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 18;
    pub const VT_ENDCHARID: flatbuffers::VOffsetT = 20;
    pub const VT_UPDATETS: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_TrainingCampStageData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_TrainingCampStageDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TrainingCampStageData<'bldr>> {
        let mut builder = clz_Torappu_TrainingCampStageDataBuilder::new(_fbb);
        builder.add_updateTs(args.updateTs);
        if let Some(x) = args.endCharId {
            builder.add_endCharId(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.loadingPicId {
            builder.add_loadingPicId(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.code {
            builder.add_code(x);
        }
        if let Some(x) = args.levelId {
            builder.add_levelId(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.stageIconId {
            builder.add_stageIconId(x);
        }
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TrainingCampStageData::VT_STAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn stageIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TrainingCampStageData::VT_STAGEICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_TrainingCampStageData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn levelId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TrainingCampStageData::VT_LEVELID,
                None,
            )
        }
    }
    #[inline]
    pub fn code(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TrainingCampStageData::VT_CODE,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TrainingCampStageData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn loadingPicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TrainingCampStageData::VT_LOADINGPICID,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TrainingCampStageData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn endCharId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TrainingCampStageData::VT_ENDCHARID,
                None,
            )
        }
    }
    #[inline]
    pub fn updateTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_TrainingCampStageData::VT_UPDATETS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_TrainingCampStageData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "stageIconId",
                Self::VT_STAGEICONID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("levelId", Self::VT_LEVELID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("code", Self::VT_CODE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "loadingPicId",
                Self::VT_LOADINGPICID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "endCharId",
                Self::VT_ENDCHARID,
                false,
            )?
            .visit_field::<i64>("updateTs", Self::VT_UPDATETS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_TrainingCampStageDataArgs<'a> {
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stageIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub levelId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub code: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub loadingPicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub endCharId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updateTs: i64,
}
impl<'a> Default for clz_Torappu_TrainingCampStageDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_TrainingCampStageDataArgs {
            stageId: None,
            stageIconId: None,
            sortId: 0,
            levelId: None,
            code: None,
            name: None,
            loadingPicId: None,
            description: None,
            endCharId: None,
            updateTs: 0,
        }
    }
}

pub struct clz_Torappu_TrainingCampStageDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_TrainingCampStageDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TrainingCampStageData::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn add_stageIconId(&mut self, stageIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TrainingCampStageData::VT_STAGEICONID,
            stageIconId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_TrainingCampStageData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_levelId(&mut self, levelId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TrainingCampStageData::VT_LEVELID,
            levelId,
        );
    }
    #[inline]
    pub fn add_code(&mut self, code: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TrainingCampStageData::VT_CODE,
            code,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TrainingCampStageData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_loadingPicId(&mut self, loadingPicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TrainingCampStageData::VT_LOADINGPICID,
            loadingPicId,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TrainingCampStageData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_endCharId(&mut self, endCharId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TrainingCampStageData::VT_ENDCHARID,
            endCharId,
        );
    }
    #[inline]
    pub fn add_updateTs(&mut self, updateTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_TrainingCampStageData::VT_UPDATETS, updateTs, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_TrainingCampStageDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_TrainingCampStageDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_TrainingCampStageData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_TrainingCampStageData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_TrainingCampStageData");
        ds.field("stageId", &self.stageId());
        ds.field("stageIconId", &self.stageIconId());
        ds.field("sortId", &self.sortId());
        ds.field("levelId", &self.levelId());
        ds.field("code", &self.code());
        ds.field("name", &self.name());
        ds.field("loadingPicId", &self.loadingPicId());
        ds.field("description", &self.description());
        ds.field("endCharId", &self.endCharId());
        ds.field("updateTs", &self.updateTs());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_TrainingCampStageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_TrainingCampStageData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_TrainingCampStageData<'a> {
    type Inner = dict__string__clz_Torappu_TrainingCampStageData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_TrainingCampStageData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_TrainingCampStageData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_TrainingCampStageDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_TrainingCampStageData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_TrainingCampStageDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_TrainingCampStageData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_TrainingCampStageData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_TrainingCampStageData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_TrainingCampStageData>>(
                    dict__string__clz_Torappu_TrainingCampStageData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_TrainingCampStageData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_TrainingCampStageData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_TrainingCampStageDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_TrainingCampStageData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_TrainingCampStageDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_TrainingCampStageDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_TrainingCampStageDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_TrainingCampStageDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_TrainingCampStageData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_TrainingCampStageData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_TrainingCampStageData>>(
                dict__string__clz_Torappu_TrainingCampStageData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_TrainingCampStageDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_TrainingCampStageDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_TrainingCampStageData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_TrainingCampStageData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_TrainingCampStageData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_TrainingCampStageData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_NewTrainingCampStageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_NewTrainingCampStageData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_NewTrainingCampStageData<'a> {
    type Inner = clz_Torappu_NewTrainingCampStageData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_NewTrainingCampStageData<'a> {
    pub const VT_UPDATETS: flatbuffers::VOffsetT = 4;
    pub const VT_STAGES: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_NewTrainingCampStageData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_NewTrainingCampStageDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_NewTrainingCampStageData<'bldr>> {
        let mut builder = clz_Torappu_NewTrainingCampStageDataBuilder::new(_fbb);
        builder.add_updateTs(args.updateTs);
        if let Some(x) = args.stages {
            builder.add_stages(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn updateTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_NewTrainingCampStageData::VT_UPDATETS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn stages(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_NewTrainingCampStageData::VT_STAGES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_NewTrainingCampStageData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("updateTs", Self::VT_UPDATETS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("stages", Self::VT_STAGES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_NewTrainingCampStageDataArgs<'a> {
    pub updateTs: i64,
    pub stages: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_NewTrainingCampStageDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_NewTrainingCampStageDataArgs {
            updateTs: 0,
            stages: None,
        }
    }
}

pub struct clz_Torappu_NewTrainingCampStageDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_NewTrainingCampStageDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_updateTs(&mut self, updateTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_NewTrainingCampStageData::VT_UPDATETS,
            updateTs,
            0,
        );
    }
    #[inline]
    pub fn add_stages(
        &mut self,
        stages: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_NewTrainingCampStageData::VT_STAGES,
            stages,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_NewTrainingCampStageDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_NewTrainingCampStageDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_NewTrainingCampStageData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_NewTrainingCampStageData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_NewTrainingCampStageData");
        ds.field("updateTs", &self.updateTs());
        ds.field("stages", &self.stages());
        ds.finish()
    }
}
pub enum clz_Torappu_TrainingCampConstsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_TrainingCampConsts<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_TrainingCampConsts<'a> {
    type Inner = clz_Torappu_TrainingCampConsts<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_TrainingCampConsts<'a> {
    pub const VT_UNLOCKSTAGEID: flatbuffers::VOffsetT = 4;
    pub const VT_UPDATEDESC: flatbuffers::VOffsetT = 6;
    pub const VT_REWARDITEM: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_TrainingCampConsts { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_TrainingCampConstsArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TrainingCampConsts<'bldr>> {
        let mut builder = clz_Torappu_TrainingCampConstsBuilder::new(_fbb);
        if let Some(x) = args.rewardItem {
            builder.add_rewardItem(x);
        }
        if let Some(x) = args.updateDesc {
            builder.add_updateDesc(x);
        }
        if let Some(x) = args.unlockStageId {
            builder.add_unlockStageId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn unlockStageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TrainingCampConsts::VT_UNLOCKSTAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn updateDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TrainingCampConsts::VT_UPDATEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn rewardItem(&self) -> Option<clz_Torappu_ItemBundle<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>(
                    clz_Torappu_TrainingCampConsts::VT_REWARDITEM,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_TrainingCampConsts<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockStageId",
                Self::VT_UNLOCKSTAGEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "updateDesc",
                Self::VT_UPDATEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>(
                "rewardItem",
                Self::VT_REWARDITEM,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_TrainingCampConstsArgs<'a> {
    pub unlockStageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updateDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewardItem: Option<flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'a>>>,
}
impl<'a> Default for clz_Torappu_TrainingCampConstsArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_TrainingCampConstsArgs {
            unlockStageId: None,
            updateDesc: None,
            rewardItem: None,
        }
    }
}

pub struct clz_Torappu_TrainingCampConstsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_TrainingCampConstsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_unlockStageId(&mut self, unlockStageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TrainingCampConsts::VT_UNLOCKSTAGEID,
            unlockStageId,
        );
    }
    #[inline]
    pub fn add_updateDesc(&mut self, updateDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TrainingCampConsts::VT_UPDATEDESC,
            updateDesc,
        );
    }
    #[inline]
    pub fn add_rewardItem(
        &mut self,
        rewardItem: flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ItemBundle>>(
                clz_Torappu_TrainingCampConsts::VT_REWARDITEM,
                rewardItem,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_TrainingCampConstsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_TrainingCampConstsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_TrainingCampConsts<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_TrainingCampConsts<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_TrainingCampConsts");
        ds.field("unlockStageId", &self.unlockStageId());
        ds.field("updateDesc", &self.updateDesc());
        ds.field("rewardItem", &self.rewardItem());
        ds.finish()
    }
}
pub enum clz_Torappu_TrainingCampDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_TrainingCampData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_TrainingCampData<'a> {
    type Inner = clz_Torappu_TrainingCampData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_TrainingCampData<'a> {
    pub const VT_STAGEDATA: flatbuffers::VOffsetT = 4;
    pub const VT_NEWTRAININGCAMPSTAGES: flatbuffers::VOffsetT = 6;
    pub const VT_CONSTS: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_TrainingCampData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_TrainingCampDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TrainingCampData<'bldr>> {
        let mut builder = clz_Torappu_TrainingCampDataBuilder::new(_fbb);
        if let Some(x) = args.consts {
            builder.add_consts(x);
        }
        if let Some(x) = args.newTrainingCampStages {
            builder.add_newTrainingCampStages(x);
        }
        if let Some(x) = args.stageData {
            builder.add_stageData(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn stageData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_TrainingCampStageData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_TrainingCampStageData>,
                >,
            >>(clz_Torappu_TrainingCampData::VT_STAGEDATA, None)
        }
    }
    #[inline]
    pub fn newTrainingCampStages(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_NewTrainingCampStageData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_NewTrainingCampStageData>,
                >,
            >>(clz_Torappu_TrainingCampData::VT_NEWTRAININGCAMPSTAGES, None)
        }
    }
    #[inline]
    pub fn consts(&self) -> Option<clz_Torappu_TrainingCampConsts<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_TrainingCampConsts>>(
                    clz_Torappu_TrainingCampData::VT_CONSTS,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_TrainingCampData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_TrainingCampStageData>,
                >,
            >>("stageData", Self::VT_STAGEDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_NewTrainingCampStageData>,
                >,
            >>(
                "newTrainingCampStages",
                Self::VT_NEWTRAININGCAMPSTAGES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_TrainingCampConsts>>(
                "consts",
                Self::VT_CONSTS,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_TrainingCampDataArgs<'a> {
    pub stageData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_TrainingCampStageData<'a>>,
            >,
        >,
    >,
    pub newTrainingCampStages: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_NewTrainingCampStageData<'a>>,
            >,
        >,
    >,
    pub consts: Option<flatbuffers::WIPOffset<clz_Torappu_TrainingCampConsts<'a>>>,
}
impl<'a> Default for clz_Torappu_TrainingCampDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_TrainingCampDataArgs {
            stageData: None,
            newTrainingCampStages: None,
            consts: None,
        }
    }
}

pub struct clz_Torappu_TrainingCampDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_TrainingCampDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_stageData(
        &mut self,
        stageData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_TrainingCampStageData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TrainingCampData::VT_STAGEDATA,
            stageData,
        );
    }
    #[inline]
    pub fn add_newTrainingCampStages(
        &mut self,
        newTrainingCampStages: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_NewTrainingCampStageData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TrainingCampData::VT_NEWTRAININGCAMPSTAGES,
            newTrainingCampStages,
        );
    }
    #[inline]
    pub fn add_consts(
        &mut self,
        consts: flatbuffers::WIPOffset<clz_Torappu_TrainingCampConsts<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_TrainingCampConsts>>(
                clz_Torappu_TrainingCampData::VT_CONSTS,
                consts,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_TrainingCampDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_TrainingCampDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_TrainingCampData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_TrainingCampData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_TrainingCampData");
        ds.field("stageData", &self.stageData());
        ds.field("newTrainingCampStages", &self.newTrainingCampStages());
        ds.field("consts", &self.consts());
        ds.finish()
    }
}
pub enum clz_Torappu_StoryReviewMetaTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StoryReviewMetaTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StoryReviewMetaTable<'a> {
    type Inner = clz_Torappu_StoryReviewMetaTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_StoryReviewMetaTable<'a> {
    pub const VT_MINIACTTRIALDATA: flatbuffers::VOffsetT = 4;
    pub const VT_ACTARCHIVERESDATA: flatbuffers::VOffsetT = 6;
    pub const VT_ACTARCHIVEDATA: flatbuffers::VOffsetT = 8;
    pub const VT_TRAININGCAMPDATA: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StoryReviewMetaTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StoryReviewMetaTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StoryReviewMetaTable<'bldr>> {
        let mut builder = clz_Torappu_StoryReviewMetaTableBuilder::new(_fbb);
        if let Some(x) = args.trainingCampData {
            builder.add_trainingCampData(x);
        }
        if let Some(x) = args.actArchiveData {
            builder.add_actArchiveData(x);
        }
        if let Some(x) = args.actArchiveResData {
            builder.add_actArchiveResData(x);
        }
        if let Some(x) = args.miniActTrialData {
            builder.add_miniActTrialData(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn miniActTrialData(&self) -> Option<clz_Torappu_MiniActTrialData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_MiniActTrialData>>(
                    clz_Torappu_StoryReviewMetaTable::VT_MINIACTTRIALDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn actArchiveResData(&self) -> Option<clz_Torappu_ActArchiveResData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveResData>>(
                    clz_Torappu_StoryReviewMetaTable::VT_ACTARCHIVERESDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn actArchiveData(&self) -> Option<clz_Torappu_ActArchiveComponentTable<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveComponentTable>>(
                    clz_Torappu_StoryReviewMetaTable::VT_ACTARCHIVEDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn trainingCampData(&self) -> Option<clz_Torappu_TrainingCampData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_TrainingCampData>>(
                    clz_Torappu_StoryReviewMetaTable::VT_TRAININGCAMPDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StoryReviewMetaTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_MiniActTrialData>>(
                "miniActTrialData",
                Self::VT_MINIACTTRIALDATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveResData>>(
                "actArchiveResData",
                Self::VT_ACTARCHIVERESDATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveComponentTable>>(
                "actArchiveData",
                Self::VT_ACTARCHIVEDATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_TrainingCampData>>(
                "trainingCampData",
                Self::VT_TRAININGCAMPDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StoryReviewMetaTableArgs<'a> {
    pub miniActTrialData: Option<flatbuffers::WIPOffset<clz_Torappu_MiniActTrialData<'a>>>,
    pub actArchiveResData: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData<'a>>>,
    pub actArchiveData: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveComponentTable<'a>>>,
    pub trainingCampData: Option<flatbuffers::WIPOffset<clz_Torappu_TrainingCampData<'a>>>,
}
impl<'a> Default for clz_Torappu_StoryReviewMetaTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StoryReviewMetaTableArgs {
            miniActTrialData: None,
            actArchiveResData: None,
            actArchiveData: None,
            trainingCampData: None,
        }
    }
}

pub struct clz_Torappu_StoryReviewMetaTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StoryReviewMetaTableBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_miniActTrialData(
        &mut self,
        miniActTrialData: flatbuffers::WIPOffset<clz_Torappu_MiniActTrialData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_MiniActTrialData>>(
                clz_Torappu_StoryReviewMetaTable::VT_MINIACTTRIALDATA,
                miniActTrialData,
            );
    }
    #[inline]
    pub fn add_actArchiveResData(
        &mut self,
        actArchiveResData: flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveResData>>(
                clz_Torappu_StoryReviewMetaTable::VT_ACTARCHIVERESDATA,
                actArchiveResData,
            );
    }
    #[inline]
    pub fn add_actArchiveData(
        &mut self,
        actArchiveData: flatbuffers::WIPOffset<clz_Torappu_ActArchiveComponentTable<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveComponentTable>>(
                clz_Torappu_StoryReviewMetaTable::VT_ACTARCHIVEDATA,
                actArchiveData,
            );
    }
    #[inline]
    pub fn add_trainingCampData(
        &mut self,
        trainingCampData: flatbuffers::WIPOffset<clz_Torappu_TrainingCampData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_TrainingCampData>>(
                clz_Torappu_StoryReviewMetaTable::VT_TRAININGCAMPDATA,
                trainingCampData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StoryReviewMetaTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StoryReviewMetaTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StoryReviewMetaTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StoryReviewMetaTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StoryReviewMetaTable");
        ds.field("miniActTrialData", &self.miniActTrialData());
        ds.field("actArchiveResData", &self.actArchiveResData());
        ds.field("actArchiveData", &self.actArchiveData());
        ds.field("trainingCampData", &self.trainingCampData());
        ds.finish()
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_StoryReviewMetaTable`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_story_review_meta_table_unchecked`.
pub fn root_as_clz_torappu_story_review_meta_table(
    buf: &[u8],
) -> Result<clz_Torappu_StoryReviewMetaTable, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_StoryReviewMetaTable>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_StoryReviewMetaTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_story_review_meta_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_story_review_meta_table(
    buf: &[u8],
) -> Result<clz_Torappu_StoryReviewMetaTable, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_StoryReviewMetaTable>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_StoryReviewMetaTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_story_review_meta_table_unchecked`.
pub fn root_as_clz_torappu_story_review_meta_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_StoryReviewMetaTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_StoryReviewMetaTable<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_StoryReviewMetaTable` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_story_review_meta_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_story_review_meta_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_StoryReviewMetaTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_StoryReviewMetaTable<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_StoryReviewMetaTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_StoryReviewMetaTable`.
pub unsafe fn root_as_clz_torappu_story_review_meta_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_StoryReviewMetaTable {
    flatbuffers::root_unchecked::<clz_Torappu_StoryReviewMetaTable>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_StoryReviewMetaTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_StoryReviewMetaTable`.
pub unsafe fn size_prefixed_root_as_clz_torappu_story_review_meta_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_StoryReviewMetaTable {
    flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_StoryReviewMetaTable>(buf)
}
#[inline]
pub fn finish_clz_torappu_story_review_meta_table_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_StoryReviewMetaTable<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_story_review_meta_table_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_StoryReviewMetaTable<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
