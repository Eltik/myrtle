// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_PLAYER_AVATAR_GROUP_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_PLAYER_AVATAR_GROUP_TYPE: i32 = 5;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_PLAYER_AVATAR_GROUP_TYPE:
    [enum__Torappu_PlayerAvatarGroupType; 6] = [
    enum__Torappu_PlayerAvatarGroupType::NONE,
    enum__Torappu_PlayerAvatarGroupType::ASSISTANT,
    enum__Torappu_PlayerAvatarGroupType::DEFAULT,
    enum__Torappu_PlayerAvatarGroupType::SPECIAL,
    enum__Torappu_PlayerAvatarGroupType::ACTIVITY,
    enum__Torappu_PlayerAvatarGroupType::DYNAMIC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_PlayerAvatarGroupType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_PlayerAvatarGroupType {
    pub const NONE: Self = Self(0);
    pub const ASSISTANT: Self = Self(1);
    pub const DEFAULT: Self = Self(2);
    pub const SPECIAL: Self = Self(3);
    pub const ACTIVITY: Self = Self(4);
    pub const DYNAMIC: Self = Self(5);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 5;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ASSISTANT,
        Self::DEFAULT,
        Self::SPECIAL,
        Self::ACTIVITY,
        Self::DYNAMIC,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ASSISTANT => Some("ASSISTANT"),
            Self::DEFAULT => Some("DEFAULT"),
            Self::SPECIAL => Some("SPECIAL"),
            Self::ACTIVITY => Some("ACTIVITY"),
            Self::DYNAMIC => Some("DYNAMIC"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_PlayerAvatarGroupType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_PlayerAvatarGroupType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_PlayerAvatarGroupType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_PlayerAvatarGroupType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_PlayerAvatarGroupType {
    type Output = enum__Torappu_PlayerAvatarGroupType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_PlayerAvatarGroupType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_PlayerAvatarGroupType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_PlayerAvatarGroupType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_HOME_MULTI_FORM_CHANGE_RULE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_HOME_MULTI_FORM_CHANGE_RULE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_HOME_MULTI_FORM_CHANGE_RULE:
    [enum__Torappu_HomeMultiFormChangeRule; 2] = [
    enum__Torappu_HomeMultiFormChangeRule::NONE,
    enum__Torappu_HomeMultiFormChangeRule::TIME,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_HomeMultiFormChangeRule(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_HomeMultiFormChangeRule {
    pub const NONE: Self = Self(0);
    pub const TIME: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::TIME];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::TIME => Some("TIME"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_HomeMultiFormChangeRule {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_HomeMultiFormChangeRule {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_HomeMultiFormChangeRule",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_HomeMultiFormChangeRule {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_HomeMultiFormChangeRule {
    type Output = enum__Torappu_HomeMultiFormChangeRule;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_HomeMultiFormChangeRule {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_HomeMultiFormChangeRule {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_HomeMultiFormChangeRule {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ITEM_RARITY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ITEM_RARITY: i32 = 6;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ITEM_RARITY: [enum__Torappu_ItemRarity; 7] = [
    enum__Torappu_ItemRarity::TIER_1,
    enum__Torappu_ItemRarity::TIER_2,
    enum__Torappu_ItemRarity::TIER_3,
    enum__Torappu_ItemRarity::TIER_4,
    enum__Torappu_ItemRarity::TIER_5,
    enum__Torappu_ItemRarity::TIER_6,
    enum__Torappu_ItemRarity::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ItemRarity(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ItemRarity {
    pub const TIER_1: Self = Self(0);
    pub const TIER_2: Self = Self(1);
    pub const TIER_3: Self = Self(2);
    pub const TIER_4: Self = Self(3);
    pub const TIER_5: Self = Self(4);
    pub const TIER_6: Self = Self(5);
    pub const E_NUM: Self = Self(6);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 6;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::TIER_1,
        Self::TIER_2,
        Self::TIER_3,
        Self::TIER_4,
        Self::TIER_5,
        Self::TIER_6,
        Self::E_NUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::TIER_1 => Some("TIER_1"),
            Self::TIER_2 => Some("TIER_2"),
            Self::TIER_3 => Some("TIER_3"),
            Self::TIER_4 => Some("TIER_4"),
            Self::TIER_5 => Some("TIER_5"),
            Self::TIER_6 => Some("TIER_6"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ItemRarity {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ItemRarity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ItemRarity",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ItemRarity {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ItemRarity {
    type Output = enum__Torappu_ItemRarity;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ItemRarity {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ItemRarity {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ItemRarity {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_NAME_CARD_V_2_MODULE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_NAME_CARD_V_2_MODULE_TYPE: i32 = 6;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_NAME_CARD_V_2_MODULE_TYPE:
    [enum__Torappu_NameCardV2ModuleType; 7] = [
    enum__Torappu_NameCardV2ModuleType::NONE,
    enum__Torappu_NameCardV2ModuleType::BACKGROUND,
    enum__Torappu_NameCardV2ModuleType::ILLUST,
    enum__Torappu_NameCardV2ModuleType::COLLECT,
    enum__Torappu_NameCardV2ModuleType::AVATAR,
    enum__Torappu_NameCardV2ModuleType::REMOVABLE,
    enum__Torappu_NameCardV2ModuleType::AVATAR_SIMPLE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_NameCardV2ModuleType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_NameCardV2ModuleType {
    pub const NONE: Self = Self(0);
    pub const BACKGROUND: Self = Self(1);
    pub const ILLUST: Self = Self(2);
    pub const COLLECT: Self = Self(3);
    pub const AVATAR: Self = Self(4);
    pub const REMOVABLE: Self = Self(5);
    pub const AVATAR_SIMPLE: Self = Self(6);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 6;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::BACKGROUND,
        Self::ILLUST,
        Self::COLLECT,
        Self::AVATAR,
        Self::REMOVABLE,
        Self::AVATAR_SIMPLE,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::BACKGROUND => Some("BACKGROUND"),
            Self::ILLUST => Some("ILLUST"),
            Self::COLLECT => Some("COLLECT"),
            Self::AVATAR => Some("AVATAR"),
            Self::REMOVABLE => Some("REMOVABLE"),
            Self::AVATAR_SIMPLE => Some("AVATAR_SIMPLE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_NameCardV2ModuleType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_NameCardV2ModuleType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_NameCardV2ModuleType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_NameCardV2ModuleType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_NameCardV2ModuleType {
    type Output = enum__Torappu_NameCardV2ModuleType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_NameCardV2ModuleType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_NameCardV2ModuleType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_NameCardV2ModuleType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_NAME_CARD_V_2_MODULE_SUB_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_NAME_CARD_V_2_MODULE_SUB_TYPE: i32 = 5;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_NAME_CARD_V_2_MODULE_SUB_TYPE:
    [enum__Torappu_NameCardV2ModuleSubType; 6] = [
    enum__Torappu_NameCardV2ModuleSubType::NONE,
    enum__Torappu_NameCardV2ModuleSubType::SIGN,
    enum__Torappu_NameCardV2ModuleSubType::ASSIST,
    enum__Torappu_NameCardV2ModuleSubType::MEDAL,
    enum__Torappu_NameCardV2ModuleSubType::MAINLINE,
    enum__Torappu_NameCardV2ModuleSubType::EQUIPMENT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_NameCardV2ModuleSubType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_NameCardV2ModuleSubType {
    pub const NONE: Self = Self(0);
    pub const SIGN: Self = Self(1);
    pub const ASSIST: Self = Self(2);
    pub const MEDAL: Self = Self(3);
    pub const MAINLINE: Self = Self(4);
    pub const EQUIPMENT: Self = Self(5);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 5;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::SIGN,
        Self::ASSIST,
        Self::MEDAL,
        Self::MAINLINE,
        Self::EQUIPMENT,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::SIGN => Some("SIGN"),
            Self::ASSIST => Some("ASSIST"),
            Self::MEDAL => Some("MEDAL"),
            Self::MAINLINE => Some("MAINLINE"),
            Self::EQUIPMENT => Some("EQUIPMENT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_NameCardV2ModuleSubType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_NameCardV2ModuleSubType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_NameCardV2ModuleSubType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_NameCardV2ModuleSubType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_NameCardV2ModuleSubType {
    type Output = enum__Torappu_NameCardV2ModuleSubType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_NameCardV2ModuleSubType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_NameCardV2ModuleSubType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_NameCardV2ModuleSubType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_NAME_CARD_V_2_SKIN_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_NAME_CARD_V_2_SKIN_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_NAME_CARD_V_2_SKIN_TYPE: [enum__Torappu_NameCardV2SkinType; 3] = [
    enum__Torappu_NameCardV2SkinType::NONE,
    enum__Torappu_NameCardV2SkinType::MAINLINE,
    enum__Torappu_NameCardV2SkinType::ACTIVITY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_NameCardV2SkinType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_NameCardV2SkinType {
    pub const NONE: Self = Self(0);
    pub const MAINLINE: Self = Self(1);
    pub const ACTIVITY: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::MAINLINE, Self::ACTIVITY];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MAINLINE => Some("MAINLINE"),
            Self::ACTIVITY => Some("ACTIVITY"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_NameCardV2SkinType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_NameCardV2SkinType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_NameCardV2SkinType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_NameCardV2SkinType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_NameCardV2SkinType {
    type Output = enum__Torappu_NameCardV2SkinType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_NameCardV2SkinType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_NameCardV2SkinType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_NameCardV2SkinType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_MAIL_ARCHIVE_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_MAIL_ARCHIVE_ITEM_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_MAIL_ARCHIVE_ITEM_TYPE: [enum__Torappu_MailArchiveItemType; 3] = [
    enum__Torappu_MailArchiveItemType::NORMAL,
    enum__Torappu_MailArchiveItemType::BIRTHDAY,
    enum__Torappu_MailArchiveItemType::OPEN_SERVER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_MailArchiveItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_MailArchiveItemType {
    pub const NORMAL: Self = Self(0);
    pub const BIRTHDAY: Self = Self(1);
    pub const OPEN_SERVER: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NORMAL, Self::BIRTHDAY, Self::OPEN_SERVER];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NORMAL => Some("NORMAL"),
            Self::BIRTHDAY => Some("BIRTHDAY"),
            Self::OPEN_SERVER => Some("OPEN_SERVER"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_MailArchiveItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_MailArchiveItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_MailArchiveItemType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_MailArchiveItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_MailArchiveItemType {
    type Output = enum__Torappu_MailArchiveItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_MailArchiveItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_MailArchiveItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_MailArchiveItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ITEM_TYPE: i32 = 90;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ITEM_TYPE: [enum__Torappu_ItemType; 91] = [
    enum__Torappu_ItemType::NONE,
    enum__Torappu_ItemType::CHAR,
    enum__Torappu_ItemType::CARD_EXP,
    enum__Torappu_ItemType::MATERIAL,
    enum__Torappu_ItemType::GOLD,
    enum__Torappu_ItemType::EXP_PLAYER,
    enum__Torappu_ItemType::TKT_TRY,
    enum__Torappu_ItemType::TKT_RECRUIT,
    enum__Torappu_ItemType::TKT_INST_FIN,
    enum__Torappu_ItemType::TKT_GACHA,
    enum__Torappu_ItemType::ACTIVITY_COIN,
    enum__Torappu_ItemType::DIAMOND,
    enum__Torappu_ItemType::DIAMOND_SHD,
    enum__Torappu_ItemType::HGG_SHD,
    enum__Torappu_ItemType::LGG_SHD,
    enum__Torappu_ItemType::FURN,
    enum__Torappu_ItemType::AP_GAMEPLAY,
    enum__Torappu_ItemType::AP_BASE,
    enum__Torappu_ItemType::SOCIAL_PT,
    enum__Torappu_ItemType::CHAR_SKIN,
    enum__Torappu_ItemType::TKT_GACHA_10,
    enum__Torappu_ItemType::TKT_GACHA_PRSV,
    enum__Torappu_ItemType::AP_ITEM,
    enum__Torappu_ItemType::AP_SUPPLY,
    enum__Torappu_ItemType::RENAMING_CARD,
    enum__Torappu_ItemType::RENAMING_CARD_2,
    enum__Torappu_ItemType::ET_STAGE,
    enum__Torappu_ItemType::ACTIVITY_ITEM,
    enum__Torappu_ItemType::VOUCHER_PICK,
    enum__Torappu_ItemType::VOUCHER_CGACHA,
    enum__Torappu_ItemType::VOUCHER_MGACHA,
    enum__Torappu_ItemType::CRS_SHOP_COIN,
    enum__Torappu_ItemType::CRS_RUNE_COIN,
    enum__Torappu_ItemType::LMTGS_COIN,
    enum__Torappu_ItemType::EPGS_COIN,
    enum__Torappu_ItemType::LIMITED_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_FREE_GACHA,
    enum__Torappu_ItemType::REP_COIN,
    enum__Torappu_ItemType::ROGUELIKE,
    enum__Torappu_ItemType::LINKAGE_TKT_GACHA_10,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_4,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_5,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_6,
    enum__Torappu_ItemType::VOUCHER_SKIN,
    enum__Torappu_ItemType::RETRO_COIN,
    enum__Torappu_ItemType::PLAYER_AVATAR,
    enum__Torappu_ItemType::UNI_COLLECTION,
    enum__Torappu_ItemType::VOUCHER_FULL_POTENTIAL,
    enum__Torappu_ItemType::RL_COIN,
    enum__Torappu_ItemType::RETURN_CREDIT,
    enum__Torappu_ItemType::MEDAL,
    enum__Torappu_ItemType::CHARM,
    enum__Torappu_ItemType::HOME_BACKGROUND,
    enum__Torappu_ItemType::EXTERMINATION_AGENT,
    enum__Torappu_ItemType::OPTIONAL_VOUCHER_PICK,
    enum__Torappu_ItemType::ACT_CART_COMPONENT,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_4,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_4,
    enum__Torappu_ItemType::ACTIVITY_POTENTIAL,
    enum__Torappu_ItemType::ITEM_PACK,
    enum__Torappu_ItemType::SANDBOX,
    enum__Torappu_ItemType::FAVOR_ADD_ITEM,
    enum__Torappu_ItemType::CLASSIC_SHD,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_BUFF,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_5,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_6,
    enum__Torappu_ItemType::RETURN_PROGRESS,
    enum__Torappu_ItemType::NEW_PROGRESS,
    enum__Torappu_ItemType::MCARD_VOUCHER,
    enum__Torappu_ItemType::MATERIAL_ISSUE_VOUCHER,
    enum__Torappu_ItemType::CRS_SHOP_COIN_V2,
    enum__Torappu_ItemType::HOME_THEME,
    enum__Torappu_ItemType::SANDBOX_PERM,
    enum__Torappu_ItemType::SANDBOX_TOKEN,
    enum__Torappu_ItemType::TEMPLATE_TRAP,
    enum__Torappu_ItemType::NAME_CARD_SKIN,
    enum__Torappu_ItemType::EMOTICON_SET,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA_10,
    enum__Torappu_ItemType::SO_CHAR_EXP,
    enum__Torappu_ItemType::GIFTPACKAGE_TKT,
    enum__Torappu_ItemType::VOUCHER_SKIN_V2,
    enum__Torappu_ItemType::RANDOM_VOUCHER_SKIN,
    enum__Torappu_ItemType::ACT1VHALFIDLE_ITEM,
    enum__Torappu_ItemType::PLOT_ITEM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ItemType {
    pub const NONE: Self = Self(0);
    pub const CHAR: Self = Self(1);
    pub const CARD_EXP: Self = Self(2);
    pub const MATERIAL: Self = Self(3);
    pub const GOLD: Self = Self(4);
    pub const EXP_PLAYER: Self = Self(5);
    pub const TKT_TRY: Self = Self(6);
    pub const TKT_RECRUIT: Self = Self(7);
    pub const TKT_INST_FIN: Self = Self(8);
    pub const TKT_GACHA: Self = Self(9);
    pub const ACTIVITY_COIN: Self = Self(10);
    pub const DIAMOND: Self = Self(11);
    pub const DIAMOND_SHD: Self = Self(12);
    pub const HGG_SHD: Self = Self(13);
    pub const LGG_SHD: Self = Self(14);
    pub const FURN: Self = Self(15);
    pub const AP_GAMEPLAY: Self = Self(16);
    pub const AP_BASE: Self = Self(17);
    pub const SOCIAL_PT: Self = Self(18);
    pub const CHAR_SKIN: Self = Self(19);
    pub const TKT_GACHA_10: Self = Self(20);
    pub const TKT_GACHA_PRSV: Self = Self(21);
    pub const AP_ITEM: Self = Self(22);
    pub const AP_SUPPLY: Self = Self(23);
    pub const RENAMING_CARD: Self = Self(24);
    pub const RENAMING_CARD_2: Self = Self(25);
    pub const ET_STAGE: Self = Self(26);
    pub const ACTIVITY_ITEM: Self = Self(27);
    pub const VOUCHER_PICK: Self = Self(28);
    pub const VOUCHER_CGACHA: Self = Self(29);
    pub const VOUCHER_MGACHA: Self = Self(30);
    pub const CRS_SHOP_COIN: Self = Self(31);
    pub const CRS_RUNE_COIN: Self = Self(32);
    pub const LMTGS_COIN: Self = Self(33);
    pub const EPGS_COIN: Self = Self(34);
    pub const LIMITED_TKT_GACHA_10: Self = Self(35);
    pub const LIMITED_FREE_GACHA: Self = Self(36);
    pub const REP_COIN: Self = Self(37);
    pub const ROGUELIKE: Self = Self(38);
    pub const LINKAGE_TKT_GACHA_10: Self = Self(39);
    pub const VOUCHER_ELITE_II_4: Self = Self(40);
    pub const VOUCHER_ELITE_II_5: Self = Self(41);
    pub const VOUCHER_ELITE_II_6: Self = Self(42);
    pub const VOUCHER_SKIN: Self = Self(43);
    pub const RETRO_COIN: Self = Self(44);
    pub const PLAYER_AVATAR: Self = Self(45);
    pub const UNI_COLLECTION: Self = Self(46);
    pub const VOUCHER_FULL_POTENTIAL: Self = Self(47);
    pub const RL_COIN: Self = Self(48);
    pub const RETURN_CREDIT: Self = Self(49);
    pub const MEDAL: Self = Self(50);
    pub const CHARM: Self = Self(51);
    pub const HOME_BACKGROUND: Self = Self(52);
    pub const EXTERMINATION_AGENT: Self = Self(53);
    pub const OPTIONAL_VOUCHER_PICK: Self = Self(54);
    pub const ACT_CART_COMPONENT: Self = Self(55);
    pub const VOUCHER_LEVELMAX_6: Self = Self(56);
    pub const VOUCHER_LEVELMAX_5: Self = Self(57);
    pub const VOUCHER_LEVELMAX_4: Self = Self(58);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_6: Self = Self(59);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_5: Self = Self(60);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_4: Self = Self(61);
    pub const ACTIVITY_POTENTIAL: Self = Self(62);
    pub const ITEM_PACK: Self = Self(63);
    pub const SANDBOX: Self = Self(64);
    pub const FAVOR_ADD_ITEM: Self = Self(65);
    pub const CLASSIC_SHD: Self = Self(66);
    pub const CLASSIC_TKT_GACHA: Self = Self(67);
    pub const CLASSIC_TKT_GACHA_10: Self = Self(68);
    pub const LIMITED_BUFF: Self = Self(69);
    pub const CLASSIC_FES_PICK_TIER_5: Self = Self(70);
    pub const CLASSIC_FES_PICK_TIER_6: Self = Self(71);
    pub const RETURN_PROGRESS: Self = Self(72);
    pub const NEW_PROGRESS: Self = Self(73);
    pub const MCARD_VOUCHER: Self = Self(74);
    pub const MATERIAL_ISSUE_VOUCHER: Self = Self(75);
    pub const CRS_SHOP_COIN_V2: Self = Self(76);
    pub const HOME_THEME: Self = Self(77);
    pub const SANDBOX_PERM: Self = Self(78);
    pub const SANDBOX_TOKEN: Self = Self(79);
    pub const TEMPLATE_TRAP: Self = Self(80);
    pub const NAME_CARD_SKIN: Self = Self(81);
    pub const EMOTICON_SET: Self = Self(82);
    pub const EXCLUSIVE_TKT_GACHA: Self = Self(83);
    pub const EXCLUSIVE_TKT_GACHA_10: Self = Self(84);
    pub const SO_CHAR_EXP: Self = Self(85);
    pub const GIFTPACKAGE_TKT: Self = Self(86);
    pub const VOUCHER_SKIN_V2: Self = Self(87);
    pub const RANDOM_VOUCHER_SKIN: Self = Self(88);
    pub const ACT1VHALFIDLE_ITEM: Self = Self(89);
    pub const PLOT_ITEM: Self = Self(90);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 90;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::CHAR,
        Self::CARD_EXP,
        Self::MATERIAL,
        Self::GOLD,
        Self::EXP_PLAYER,
        Self::TKT_TRY,
        Self::TKT_RECRUIT,
        Self::TKT_INST_FIN,
        Self::TKT_GACHA,
        Self::ACTIVITY_COIN,
        Self::DIAMOND,
        Self::DIAMOND_SHD,
        Self::HGG_SHD,
        Self::LGG_SHD,
        Self::FURN,
        Self::AP_GAMEPLAY,
        Self::AP_BASE,
        Self::SOCIAL_PT,
        Self::CHAR_SKIN,
        Self::TKT_GACHA_10,
        Self::TKT_GACHA_PRSV,
        Self::AP_ITEM,
        Self::AP_SUPPLY,
        Self::RENAMING_CARD,
        Self::RENAMING_CARD_2,
        Self::ET_STAGE,
        Self::ACTIVITY_ITEM,
        Self::VOUCHER_PICK,
        Self::VOUCHER_CGACHA,
        Self::VOUCHER_MGACHA,
        Self::CRS_SHOP_COIN,
        Self::CRS_RUNE_COIN,
        Self::LMTGS_COIN,
        Self::EPGS_COIN,
        Self::LIMITED_TKT_GACHA_10,
        Self::LIMITED_FREE_GACHA,
        Self::REP_COIN,
        Self::ROGUELIKE,
        Self::LINKAGE_TKT_GACHA_10,
        Self::VOUCHER_ELITE_II_4,
        Self::VOUCHER_ELITE_II_5,
        Self::VOUCHER_ELITE_II_6,
        Self::VOUCHER_SKIN,
        Self::RETRO_COIN,
        Self::PLAYER_AVATAR,
        Self::UNI_COLLECTION,
        Self::VOUCHER_FULL_POTENTIAL,
        Self::RL_COIN,
        Self::RETURN_CREDIT,
        Self::MEDAL,
        Self::CHARM,
        Self::HOME_BACKGROUND,
        Self::EXTERMINATION_AGENT,
        Self::OPTIONAL_VOUCHER_PICK,
        Self::ACT_CART_COMPONENT,
        Self::VOUCHER_LEVELMAX_6,
        Self::VOUCHER_LEVELMAX_5,
        Self::VOUCHER_LEVELMAX_4,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_6,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_5,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_4,
        Self::ACTIVITY_POTENTIAL,
        Self::ITEM_PACK,
        Self::SANDBOX,
        Self::FAVOR_ADD_ITEM,
        Self::CLASSIC_SHD,
        Self::CLASSIC_TKT_GACHA,
        Self::CLASSIC_TKT_GACHA_10,
        Self::LIMITED_BUFF,
        Self::CLASSIC_FES_PICK_TIER_5,
        Self::CLASSIC_FES_PICK_TIER_6,
        Self::RETURN_PROGRESS,
        Self::NEW_PROGRESS,
        Self::MCARD_VOUCHER,
        Self::MATERIAL_ISSUE_VOUCHER,
        Self::CRS_SHOP_COIN_V2,
        Self::HOME_THEME,
        Self::SANDBOX_PERM,
        Self::SANDBOX_TOKEN,
        Self::TEMPLATE_TRAP,
        Self::NAME_CARD_SKIN,
        Self::EMOTICON_SET,
        Self::EXCLUSIVE_TKT_GACHA,
        Self::EXCLUSIVE_TKT_GACHA_10,
        Self::SO_CHAR_EXP,
        Self::GIFTPACKAGE_TKT,
        Self::VOUCHER_SKIN_V2,
        Self::RANDOM_VOUCHER_SKIN,
        Self::ACT1VHALFIDLE_ITEM,
        Self::PLOT_ITEM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::CHAR => Some("CHAR"),
            Self::CARD_EXP => Some("CARD_EXP"),
            Self::MATERIAL => Some("MATERIAL"),
            Self::GOLD => Some("GOLD"),
            Self::EXP_PLAYER => Some("EXP_PLAYER"),
            Self::TKT_TRY => Some("TKT_TRY"),
            Self::TKT_RECRUIT => Some("TKT_RECRUIT"),
            Self::TKT_INST_FIN => Some("TKT_INST_FIN"),
            Self::TKT_GACHA => Some("TKT_GACHA"),
            Self::ACTIVITY_COIN => Some("ACTIVITY_COIN"),
            Self::DIAMOND => Some("DIAMOND"),
            Self::DIAMOND_SHD => Some("DIAMOND_SHD"),
            Self::HGG_SHD => Some("HGG_SHD"),
            Self::LGG_SHD => Some("LGG_SHD"),
            Self::FURN => Some("FURN"),
            Self::AP_GAMEPLAY => Some("AP_GAMEPLAY"),
            Self::AP_BASE => Some("AP_BASE"),
            Self::SOCIAL_PT => Some("SOCIAL_PT"),
            Self::CHAR_SKIN => Some("CHAR_SKIN"),
            Self::TKT_GACHA_10 => Some("TKT_GACHA_10"),
            Self::TKT_GACHA_PRSV => Some("TKT_GACHA_PRSV"),
            Self::AP_ITEM => Some("AP_ITEM"),
            Self::AP_SUPPLY => Some("AP_SUPPLY"),
            Self::RENAMING_CARD => Some("RENAMING_CARD"),
            Self::RENAMING_CARD_2 => Some("RENAMING_CARD_2"),
            Self::ET_STAGE => Some("ET_STAGE"),
            Self::ACTIVITY_ITEM => Some("ACTIVITY_ITEM"),
            Self::VOUCHER_PICK => Some("VOUCHER_PICK"),
            Self::VOUCHER_CGACHA => Some("VOUCHER_CGACHA"),
            Self::VOUCHER_MGACHA => Some("VOUCHER_MGACHA"),
            Self::CRS_SHOP_COIN => Some("CRS_SHOP_COIN"),
            Self::CRS_RUNE_COIN => Some("CRS_RUNE_COIN"),
            Self::LMTGS_COIN => Some("LMTGS_COIN"),
            Self::EPGS_COIN => Some("EPGS_COIN"),
            Self::LIMITED_TKT_GACHA_10 => Some("LIMITED_TKT_GACHA_10"),
            Self::LIMITED_FREE_GACHA => Some("LIMITED_FREE_GACHA"),
            Self::REP_COIN => Some("REP_COIN"),
            Self::ROGUELIKE => Some("ROGUELIKE"),
            Self::LINKAGE_TKT_GACHA_10 => Some("LINKAGE_TKT_GACHA_10"),
            Self::VOUCHER_ELITE_II_4 => Some("VOUCHER_ELITE_II_4"),
            Self::VOUCHER_ELITE_II_5 => Some("VOUCHER_ELITE_II_5"),
            Self::VOUCHER_ELITE_II_6 => Some("VOUCHER_ELITE_II_6"),
            Self::VOUCHER_SKIN => Some("VOUCHER_SKIN"),
            Self::RETRO_COIN => Some("RETRO_COIN"),
            Self::PLAYER_AVATAR => Some("PLAYER_AVATAR"),
            Self::UNI_COLLECTION => Some("UNI_COLLECTION"),
            Self::VOUCHER_FULL_POTENTIAL => Some("VOUCHER_FULL_POTENTIAL"),
            Self::RL_COIN => Some("RL_COIN"),
            Self::RETURN_CREDIT => Some("RETURN_CREDIT"),
            Self::MEDAL => Some("MEDAL"),
            Self::CHARM => Some("CHARM"),
            Self::HOME_BACKGROUND => Some("HOME_BACKGROUND"),
            Self::EXTERMINATION_AGENT => Some("EXTERMINATION_AGENT"),
            Self::OPTIONAL_VOUCHER_PICK => Some("OPTIONAL_VOUCHER_PICK"),
            Self::ACT_CART_COMPONENT => Some("ACT_CART_COMPONENT"),
            Self::VOUCHER_LEVELMAX_6 => Some("VOUCHER_LEVELMAX_6"),
            Self::VOUCHER_LEVELMAX_5 => Some("VOUCHER_LEVELMAX_5"),
            Self::VOUCHER_LEVELMAX_4 => Some("VOUCHER_LEVELMAX_4"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_6 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_6"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_5 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_5"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_4 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_4"),
            Self::ACTIVITY_POTENTIAL => Some("ACTIVITY_POTENTIAL"),
            Self::ITEM_PACK => Some("ITEM_PACK"),
            Self::SANDBOX => Some("SANDBOX"),
            Self::FAVOR_ADD_ITEM => Some("FAVOR_ADD_ITEM"),
            Self::CLASSIC_SHD => Some("CLASSIC_SHD"),
            Self::CLASSIC_TKT_GACHA => Some("CLASSIC_TKT_GACHA"),
            Self::CLASSIC_TKT_GACHA_10 => Some("CLASSIC_TKT_GACHA_10"),
            Self::LIMITED_BUFF => Some("LIMITED_BUFF"),
            Self::CLASSIC_FES_PICK_TIER_5 => Some("CLASSIC_FES_PICK_TIER_5"),
            Self::CLASSIC_FES_PICK_TIER_6 => Some("CLASSIC_FES_PICK_TIER_6"),
            Self::RETURN_PROGRESS => Some("RETURN_PROGRESS"),
            Self::NEW_PROGRESS => Some("NEW_PROGRESS"),
            Self::MCARD_VOUCHER => Some("MCARD_VOUCHER"),
            Self::MATERIAL_ISSUE_VOUCHER => Some("MATERIAL_ISSUE_VOUCHER"),
            Self::CRS_SHOP_COIN_V2 => Some("CRS_SHOP_COIN_V2"),
            Self::HOME_THEME => Some("HOME_THEME"),
            Self::SANDBOX_PERM => Some("SANDBOX_PERM"),
            Self::SANDBOX_TOKEN => Some("SANDBOX_TOKEN"),
            Self::TEMPLATE_TRAP => Some("TEMPLATE_TRAP"),
            Self::NAME_CARD_SKIN => Some("NAME_CARD_SKIN"),
            Self::EMOTICON_SET => Some("EMOTICON_SET"),
            Self::EXCLUSIVE_TKT_GACHA => Some("EXCLUSIVE_TKT_GACHA"),
            Self::EXCLUSIVE_TKT_GACHA_10 => Some("EXCLUSIVE_TKT_GACHA_10"),
            Self::SO_CHAR_EXP => Some("SO_CHAR_EXP"),
            Self::GIFTPACKAGE_TKT => Some("GIFTPACKAGE_TKT"),
            Self::VOUCHER_SKIN_V2 => Some("VOUCHER_SKIN_V2"),
            Self::RANDOM_VOUCHER_SKIN => Some("RANDOM_VOUCHER_SKIN"),
            Self::ACT1VHALFIDLE_ITEM => Some("ACT1VHALFIDLE_ITEM"),
            Self::PLOT_ITEM => Some("PLOT_ITEM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ItemType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ItemType {
    type Output = enum__Torappu_ItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_EMOJI_SCENE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_EMOJI_SCENE_TYPE: i32 = 6;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_EMOJI_SCENE_TYPE: [enum__Torappu_EmojiSceneType; 7] = [
    enum__Torappu_EmojiSceneType::NONE,
    enum__Torappu_EmojiSceneType::ACTMULTIV3_ROOM,
    enum__Torappu_EmojiSceneType::ACTMULTIV3_PICK,
    enum__Torappu_EmojiSceneType::ACTMULTIV3_BATTLE,
    enum__Torappu_EmojiSceneType::ENEMYDUEL_BATTLE,
    enum__Torappu_EmojiSceneType::AUTOCHESS_ROOM,
    enum__Torappu_EmojiSceneType::AUTOCHESS_BATTLE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_EmojiSceneType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_EmojiSceneType {
    pub const NONE: Self = Self(0);
    pub const ACTMULTIV3_ROOM: Self = Self(1);
    pub const ACTMULTIV3_PICK: Self = Self(2);
    pub const ACTMULTIV3_BATTLE: Self = Self(3);
    pub const ENEMYDUEL_BATTLE: Self = Self(4);
    pub const AUTOCHESS_ROOM: Self = Self(5);
    pub const AUTOCHESS_BATTLE: Self = Self(6);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 6;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ACTMULTIV3_ROOM,
        Self::ACTMULTIV3_PICK,
        Self::ACTMULTIV3_BATTLE,
        Self::ENEMYDUEL_BATTLE,
        Self::AUTOCHESS_ROOM,
        Self::AUTOCHESS_BATTLE,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ACTMULTIV3_ROOM => Some("ACTMULTIV3_ROOM"),
            Self::ACTMULTIV3_PICK => Some("ACTMULTIV3_PICK"),
            Self::ACTMULTIV3_BATTLE => Some("ACTMULTIV3_BATTLE"),
            Self::ENEMYDUEL_BATTLE => Some("ENEMYDUEL_BATTLE"),
            Self::AUTOCHESS_ROOM => Some("AUTOCHESS_ROOM"),
            Self::AUTOCHESS_BATTLE => Some("AUTOCHESS_BATTLE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_EmojiSceneType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_EmojiSceneType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_EmojiSceneType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_EmojiSceneType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_EmojiSceneType {
    type Output = enum__Torappu_EmojiSceneType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_EmojiSceneType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_EmojiSceneType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_EmojiSceneType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_UIGUIDE_TARGET: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_UIGUIDE_TARGET: i32 = 50;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_UIGUIDE_TARGET: [enum__Torappu_UIGuideTarget; 49] = [
    enum__Torappu_UIGuideTarget::NONE,
    enum__Torappu_UIGuideTarget::BUILDING_CONTROL,
    enum__Torappu_UIGuideTarget::BUILDING_DORM,
    enum__Torappu_UIGuideTarget::BUILDING_HIRE,
    enum__Torappu_UIGuideTarget::BUILDING_MANUFACT,
    enum__Torappu_UIGuideTarget::BUILDING_MEETING,
    enum__Torappu_UIGuideTarget::BUILDING_TRADING,
    enum__Torappu_UIGuideTarget::CHAR_INFO,
    enum__Torappu_UIGuideTarget::FRIEND,
    enum__Torappu_UIGuideTarget::RECRUIT,
    enum__Torappu_UIGuideTarget::SHOP,
    enum__Torappu_UIGuideTarget::SQUAD_NORMAL,
    enum__Torappu_UIGuideTarget::SQUAD_BATTLE,
    enum__Torappu_UIGuideTarget::STAGE_MAINLINE,
    enum__Torappu_UIGuideTarget::BUILDING_POWER,
    enum__Torappu_UIGuideTarget::MISSION,
    enum__Torappu_UIGuideTarget::CHAR_SKILL_SELECT,
    enum__Torappu_UIGuideTarget::BUILDING_WORKSHOP,
    enum__Torappu_UIGuideTarget::STAGE_CAMPAIGN,
    enum__Torappu_UIGuideTarget::CHAR_EVOLVE,
    enum__Torappu_UIGuideTarget::HANDBOOK,
    enum__Torappu_UIGuideTarget::BUILDING_FURN_SHOP,
    enum__Torappu_UIGuideTarget::BUILDING_TRAINING,
    enum__Torappu_UIGuideTarget::STAGE_ACTIVITY,
    enum__Torappu_UIGuideTarget::CRISIS_STAGE,
    enum__Torappu_UIGuideTarget::ROGUELIKE_CHARSELECT,
    enum__Torappu_UIGuideTarget::ROGUELIKE_BP,
    enum__Torappu_UIGuideTarget::CLIMB_TOWER_ENTRY,
    enum__Torappu_UIGuideTarget::CLIMB_TOWER_LAYER,
    enum__Torappu_UIGuideTarget::ROGUELIKE_DUNGEON,
    enum__Torappu_UIGuideTarget::RL03_TOTEM,
    enum__Torappu_UIGuideTarget::GROCERY,
    enum__Torappu_UIGuideTarget::TUNING,
    enum__Torappu_UIGuideTarget::CRISIS_V2,
    enum__Torappu_UIGuideTarget::MISSION_ARCHIVE,
    enum__Torappu_UIGuideTarget::FIFTH_ANNIV_EXPLORE,
    enum__Torappu_UIGuideTarget::CARVING,
    enum__Torappu_UIGuideTarget::VEC_BREAK,
    enum__Torappu_UIGuideTarget::FIREWORK,
    enum__Torappu_UIGuideTarget::BUILDING_STATION_MANAGE,
    enum__Torappu_UIGuideTarget::ACT_MULTI_V3,
    enum__Torappu_UIGuideTarget::ENEMY_DUEL,
    enum__Torappu_UIGuideTarget::VEC_BREAK_V2,
    enum__Torappu_UIGuideTarget::GUN_TASK,
    enum__Torappu_UIGuideTarget::SPECIAL_OPERATOR,
    enum__Torappu_UIGuideTarget::INFORMANT,
    enum__Torappu_UIGuideTarget::ACT1VHALFIDLE,
    enum__Torappu_UIGuideTarget::MONOPOLY,
    enum__Torappu_UIGuideTarget::AUTO_CHESS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_UIGuideTarget(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_UIGuideTarget {
    pub const NONE: Self = Self(0);
    pub const BUILDING_CONTROL: Self = Self(1);
    pub const BUILDING_DORM: Self = Self(2);
    pub const BUILDING_HIRE: Self = Self(3);
    pub const BUILDING_MANUFACT: Self = Self(4);
    pub const BUILDING_MEETING: Self = Self(5);
    pub const BUILDING_TRADING: Self = Self(6);
    pub const CHAR_INFO: Self = Self(7);
    pub const FRIEND: Self = Self(8);
    pub const RECRUIT: Self = Self(9);
    pub const SHOP: Self = Self(10);
    pub const SQUAD_NORMAL: Self = Self(11);
    pub const SQUAD_BATTLE: Self = Self(12);
    pub const STAGE_MAINLINE: Self = Self(13);
    pub const BUILDING_POWER: Self = Self(14);
    pub const MISSION: Self = Self(15);
    pub const CHAR_SKILL_SELECT: Self = Self(16);
    pub const BUILDING_WORKSHOP: Self = Self(17);
    pub const STAGE_CAMPAIGN: Self = Self(18);
    pub const CHAR_EVOLVE: Self = Self(19);
    pub const HANDBOOK: Self = Self(20);
    pub const BUILDING_FURN_SHOP: Self = Self(21);
    pub const BUILDING_TRAINING: Self = Self(22);
    pub const STAGE_ACTIVITY: Self = Self(23);
    pub const CRISIS_STAGE: Self = Self(24);
    pub const ROGUELIKE_CHARSELECT: Self = Self(25);
    pub const ROGUELIKE_BP: Self = Self(26);
    pub const CLIMB_TOWER_ENTRY: Self = Self(27);
    pub const CLIMB_TOWER_LAYER: Self = Self(28);
    pub const ROGUELIKE_DUNGEON: Self = Self(31);
    pub const RL03_TOTEM: Self = Self(32);
    pub const GROCERY: Self = Self(33);
    pub const TUNING: Self = Self(34);
    pub const CRISIS_V2: Self = Self(35);
    pub const MISSION_ARCHIVE: Self = Self(36);
    pub const FIFTH_ANNIV_EXPLORE: Self = Self(37);
    pub const CARVING: Self = Self(38);
    pub const VEC_BREAK: Self = Self(39);
    pub const FIREWORK: Self = Self(40);
    pub const BUILDING_STATION_MANAGE: Self = Self(41);
    pub const ACT_MULTI_V3: Self = Self(42);
    pub const ENEMY_DUEL: Self = Self(43);
    pub const VEC_BREAK_V2: Self = Self(44);
    pub const GUN_TASK: Self = Self(45);
    pub const SPECIAL_OPERATOR: Self = Self(46);
    pub const INFORMANT: Self = Self(47);
    pub const ACT1VHALFIDLE: Self = Self(48);
    pub const MONOPOLY: Self = Self(49);
    pub const AUTO_CHESS: Self = Self(50);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 50;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::BUILDING_CONTROL,
        Self::BUILDING_DORM,
        Self::BUILDING_HIRE,
        Self::BUILDING_MANUFACT,
        Self::BUILDING_MEETING,
        Self::BUILDING_TRADING,
        Self::CHAR_INFO,
        Self::FRIEND,
        Self::RECRUIT,
        Self::SHOP,
        Self::SQUAD_NORMAL,
        Self::SQUAD_BATTLE,
        Self::STAGE_MAINLINE,
        Self::BUILDING_POWER,
        Self::MISSION,
        Self::CHAR_SKILL_SELECT,
        Self::BUILDING_WORKSHOP,
        Self::STAGE_CAMPAIGN,
        Self::CHAR_EVOLVE,
        Self::HANDBOOK,
        Self::BUILDING_FURN_SHOP,
        Self::BUILDING_TRAINING,
        Self::STAGE_ACTIVITY,
        Self::CRISIS_STAGE,
        Self::ROGUELIKE_CHARSELECT,
        Self::ROGUELIKE_BP,
        Self::CLIMB_TOWER_ENTRY,
        Self::CLIMB_TOWER_LAYER,
        Self::ROGUELIKE_DUNGEON,
        Self::RL03_TOTEM,
        Self::GROCERY,
        Self::TUNING,
        Self::CRISIS_V2,
        Self::MISSION_ARCHIVE,
        Self::FIFTH_ANNIV_EXPLORE,
        Self::CARVING,
        Self::VEC_BREAK,
        Self::FIREWORK,
        Self::BUILDING_STATION_MANAGE,
        Self::ACT_MULTI_V3,
        Self::ENEMY_DUEL,
        Self::VEC_BREAK_V2,
        Self::GUN_TASK,
        Self::SPECIAL_OPERATOR,
        Self::INFORMANT,
        Self::ACT1VHALFIDLE,
        Self::MONOPOLY,
        Self::AUTO_CHESS,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::BUILDING_CONTROL => Some("BUILDING_CONTROL"),
            Self::BUILDING_DORM => Some("BUILDING_DORM"),
            Self::BUILDING_HIRE => Some("BUILDING_HIRE"),
            Self::BUILDING_MANUFACT => Some("BUILDING_MANUFACT"),
            Self::BUILDING_MEETING => Some("BUILDING_MEETING"),
            Self::BUILDING_TRADING => Some("BUILDING_TRADING"),
            Self::CHAR_INFO => Some("CHAR_INFO"),
            Self::FRIEND => Some("FRIEND"),
            Self::RECRUIT => Some("RECRUIT"),
            Self::SHOP => Some("SHOP"),
            Self::SQUAD_NORMAL => Some("SQUAD_NORMAL"),
            Self::SQUAD_BATTLE => Some("SQUAD_BATTLE"),
            Self::STAGE_MAINLINE => Some("STAGE_MAINLINE"),
            Self::BUILDING_POWER => Some("BUILDING_POWER"),
            Self::MISSION => Some("MISSION"),
            Self::CHAR_SKILL_SELECT => Some("CHAR_SKILL_SELECT"),
            Self::BUILDING_WORKSHOP => Some("BUILDING_WORKSHOP"),
            Self::STAGE_CAMPAIGN => Some("STAGE_CAMPAIGN"),
            Self::CHAR_EVOLVE => Some("CHAR_EVOLVE"),
            Self::HANDBOOK => Some("HANDBOOK"),
            Self::BUILDING_FURN_SHOP => Some("BUILDING_FURN_SHOP"),
            Self::BUILDING_TRAINING => Some("BUILDING_TRAINING"),
            Self::STAGE_ACTIVITY => Some("STAGE_ACTIVITY"),
            Self::CRISIS_STAGE => Some("CRISIS_STAGE"),
            Self::ROGUELIKE_CHARSELECT => Some("ROGUELIKE_CHARSELECT"),
            Self::ROGUELIKE_BP => Some("ROGUELIKE_BP"),
            Self::CLIMB_TOWER_ENTRY => Some("CLIMB_TOWER_ENTRY"),
            Self::CLIMB_TOWER_LAYER => Some("CLIMB_TOWER_LAYER"),
            Self::ROGUELIKE_DUNGEON => Some("ROGUELIKE_DUNGEON"),
            Self::RL03_TOTEM => Some("RL03_TOTEM"),
            Self::GROCERY => Some("GROCERY"),
            Self::TUNING => Some("TUNING"),
            Self::CRISIS_V2 => Some("CRISIS_V2"),
            Self::MISSION_ARCHIVE => Some("MISSION_ARCHIVE"),
            Self::FIFTH_ANNIV_EXPLORE => Some("FIFTH_ANNIV_EXPLORE"),
            Self::CARVING => Some("CARVING"),
            Self::VEC_BREAK => Some("VEC_BREAK"),
            Self::FIREWORK => Some("FIREWORK"),
            Self::BUILDING_STATION_MANAGE => Some("BUILDING_STATION_MANAGE"),
            Self::ACT_MULTI_V3 => Some("ACT_MULTI_V3"),
            Self::ENEMY_DUEL => Some("ENEMY_DUEL"),
            Self::VEC_BREAK_V2 => Some("VEC_BREAK_V2"),
            Self::GUN_TASK => Some("GUN_TASK"),
            Self::SPECIAL_OPERATOR => Some("SPECIAL_OPERATOR"),
            Self::INFORMANT => Some("INFORMANT"),
            Self::ACT1VHALFIDLE => Some("ACT1VHALFIDLE"),
            Self::MONOPOLY => Some("MONOPOLY"),
            Self::AUTO_CHESS => Some("AUTO_CHESS"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_UIGuideTarget {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_UIGuideTarget {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_UIGuideTarget",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_UIGuideTarget {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_UIGuideTarget {
    type Output = enum__Torappu_UIGuideTarget;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_UIGuideTarget {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_UIGuideTarget {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_UIGuideTarget {}
pub enum clz_Torappu_PlayerAvatarPerDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_PlayerAvatarPerData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_PlayerAvatarPerData<'a> {
    type Inner = clz_Torappu_PlayerAvatarPerData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_PlayerAvatarPerData<'a> {
    pub const VT_AVATARID: flatbuffers::VOffsetT = 4;
    pub const VT_AVATARTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_AVATARIDSORT: flatbuffers::VOffsetT = 8;
    pub const VT_AVATARIDDESC: flatbuffers::VOffsetT = 10;
    pub const VT_AVATARITEMNAME: flatbuffers::VOffsetT = 12;
    pub const VT_AVATARITEMDESC: flatbuffers::VOffsetT = 14;
    pub const VT_AVATARITEMUSAGE: flatbuffers::VOffsetT = 16;
    pub const VT_OBTAINAPPROACH: flatbuffers::VOffsetT = 18;
    pub const VT_DYNAVATARID: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_PlayerAvatarPerData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_PlayerAvatarPerDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_PlayerAvatarPerData<'bldr>> {
        let mut builder = clz_Torappu_PlayerAvatarPerDataBuilder::new(_fbb);
        if let Some(x) = args.dynAvatarId {
            builder.add_dynAvatarId(x);
        }
        if let Some(x) = args.obtainApproach {
            builder.add_obtainApproach(x);
        }
        if let Some(x) = args.avatarItemUsage {
            builder.add_avatarItemUsage(x);
        }
        if let Some(x) = args.avatarItemDesc {
            builder.add_avatarItemDesc(x);
        }
        if let Some(x) = args.avatarItemName {
            builder.add_avatarItemName(x);
        }
        if let Some(x) = args.avatarIdDesc {
            builder.add_avatarIdDesc(x);
        }
        builder.add_avatarIdSort(args.avatarIdSort);
        builder.add_avatarType(args.avatarType);
        if let Some(x) = args.avatarId {
            builder.add_avatarId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_PlayerAvatarPerDataT {
        let avatarId = self.avatarId().map(|x| x.to_string());
        let avatarType = self.avatarType();
        let avatarIdSort = self.avatarIdSort();
        let avatarIdDesc = self.avatarIdDesc().map(|x| x.to_string());
        let avatarItemName = self.avatarItemName().map(|x| x.to_string());
        let avatarItemDesc = self.avatarItemDesc().map(|x| x.to_string());
        let avatarItemUsage = self.avatarItemUsage().map(|x| x.to_string());
        let obtainApproach = self.obtainApproach().map(|x| x.to_string());
        let dynAvatarId = self.dynAvatarId().map(|x| x.to_string());
        clz_Torappu_PlayerAvatarPerDataT {
            avatarId,
            avatarType,
            avatarIdSort,
            avatarIdDesc,
            avatarItemName,
            avatarItemDesc,
            avatarItemUsage,
            obtainApproach,
            dynAvatarId,
        }
    }

    #[inline]
    pub fn avatarId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_PlayerAvatarPerData::VT_AVATARID,
                None,
            )
        }
    }
    #[inline]
    pub fn avatarType(&self) -> enum__Torappu_PlayerAvatarGroupType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_PlayerAvatarGroupType>(
                    clz_Torappu_PlayerAvatarPerData::VT_AVATARTYPE,
                    Some(enum__Torappu_PlayerAvatarGroupType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn avatarIdSort(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_PlayerAvatarPerData::VT_AVATARIDSORT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn avatarIdDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_PlayerAvatarPerData::VT_AVATARIDDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn avatarItemName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_PlayerAvatarPerData::VT_AVATARITEMNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn avatarItemDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_PlayerAvatarPerData::VT_AVATARITEMDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn avatarItemUsage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_PlayerAvatarPerData::VT_AVATARITEMUSAGE,
                None,
            )
        }
    }
    #[inline]
    pub fn obtainApproach(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_PlayerAvatarPerData::VT_OBTAINAPPROACH,
                None,
            )
        }
    }
    #[inline]
    pub fn dynAvatarId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_PlayerAvatarPerData::VT_DYNAVATARID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_PlayerAvatarPerData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "avatarId",
                Self::VT_AVATARID,
                false,
            )?
            .visit_field::<enum__Torappu_PlayerAvatarGroupType>(
                "avatarType",
                Self::VT_AVATARTYPE,
                false,
            )?
            .visit_field::<i32>("avatarIdSort", Self::VT_AVATARIDSORT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "avatarIdDesc",
                Self::VT_AVATARIDDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "avatarItemName",
                Self::VT_AVATARITEMNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "avatarItemDesc",
                Self::VT_AVATARITEMDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "avatarItemUsage",
                Self::VT_AVATARITEMUSAGE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "obtainApproach",
                Self::VT_OBTAINAPPROACH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dynAvatarId",
                Self::VT_DYNAVATARID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_PlayerAvatarPerDataArgs<'a> {
    pub avatarId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub avatarType: enum__Torappu_PlayerAvatarGroupType,
    pub avatarIdSort: i32,
    pub avatarIdDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub avatarItemName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub avatarItemDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub avatarItemUsage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub obtainApproach: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dynAvatarId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_PlayerAvatarPerDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_PlayerAvatarPerDataArgs {
            avatarId: None,
            avatarType: enum__Torappu_PlayerAvatarGroupType::NONE,
            avatarIdSort: 0,
            avatarIdDesc: None,
            avatarItemName: None,
            avatarItemDesc: None,
            avatarItemUsage: None,
            obtainApproach: None,
            dynAvatarId: None,
        }
    }
}

impl Serialize for clz_Torappu_PlayerAvatarPerData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_PlayerAvatarPerData", 9)?;
        if let Some(f) = self.avatarId() {
            s.serialize_field("avatarId", &f)?;
        } else {
            s.skip_field("avatarId")?;
        }
        s.serialize_field("avatarType", &self.avatarType())?;
        s.serialize_field("avatarIdSort", &self.avatarIdSort())?;
        if let Some(f) = self.avatarIdDesc() {
            s.serialize_field("avatarIdDesc", &f)?;
        } else {
            s.skip_field("avatarIdDesc")?;
        }
        if let Some(f) = self.avatarItemName() {
            s.serialize_field("avatarItemName", &f)?;
        } else {
            s.skip_field("avatarItemName")?;
        }
        if let Some(f) = self.avatarItemDesc() {
            s.serialize_field("avatarItemDesc", &f)?;
        } else {
            s.skip_field("avatarItemDesc")?;
        }
        if let Some(f) = self.avatarItemUsage() {
            s.serialize_field("avatarItemUsage", &f)?;
        } else {
            s.skip_field("avatarItemUsage")?;
        }
        if let Some(f) = self.obtainApproach() {
            s.serialize_field("obtainApproach", &f)?;
        } else {
            s.skip_field("obtainApproach")?;
        }
        if let Some(f) = self.dynAvatarId() {
            s.serialize_field("dynAvatarId", &f)?;
        } else {
            s.skip_field("dynAvatarId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_PlayerAvatarPerDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_PlayerAvatarPerDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_avatarId(&mut self, avatarId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_PlayerAvatarPerData::VT_AVATARID,
            avatarId,
        );
    }
    #[inline]
    pub fn add_avatarType(&mut self, avatarType: enum__Torappu_PlayerAvatarGroupType) {
        self.fbb_.push_slot::<enum__Torappu_PlayerAvatarGroupType>(
            clz_Torappu_PlayerAvatarPerData::VT_AVATARTYPE,
            avatarType,
            enum__Torappu_PlayerAvatarGroupType::NONE,
        );
    }
    #[inline]
    pub fn add_avatarIdSort(&mut self, avatarIdSort: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_PlayerAvatarPerData::VT_AVATARIDSORT,
            avatarIdSort,
            0,
        );
    }
    #[inline]
    pub fn add_avatarIdDesc(&mut self, avatarIdDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_PlayerAvatarPerData::VT_AVATARIDDESC,
            avatarIdDesc,
        );
    }
    #[inline]
    pub fn add_avatarItemName(&mut self, avatarItemName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_PlayerAvatarPerData::VT_AVATARITEMNAME,
            avatarItemName,
        );
    }
    #[inline]
    pub fn add_avatarItemDesc(&mut self, avatarItemDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_PlayerAvatarPerData::VT_AVATARITEMDESC,
            avatarItemDesc,
        );
    }
    #[inline]
    pub fn add_avatarItemUsage(&mut self, avatarItemUsage: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_PlayerAvatarPerData::VT_AVATARITEMUSAGE,
            avatarItemUsage,
        );
    }
    #[inline]
    pub fn add_obtainApproach(&mut self, obtainApproach: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_PlayerAvatarPerData::VT_OBTAINAPPROACH,
            obtainApproach,
        );
    }
    #[inline]
    pub fn add_dynAvatarId(&mut self, dynAvatarId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_PlayerAvatarPerData::VT_DYNAVATARID,
            dynAvatarId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_PlayerAvatarPerDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_PlayerAvatarPerDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_PlayerAvatarPerData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_PlayerAvatarPerData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_PlayerAvatarPerData");
        ds.field("avatarId", &self.avatarId());
        ds.field("avatarType", &self.avatarType());
        ds.field("avatarIdSort", &self.avatarIdSort());
        ds.field("avatarIdDesc", &self.avatarIdDesc());
        ds.field("avatarItemName", &self.avatarItemName());
        ds.field("avatarItemDesc", &self.avatarItemDesc());
        ds.field("avatarItemUsage", &self.avatarItemUsage());
        ds.field("obtainApproach", &self.obtainApproach());
        ds.field("dynAvatarId", &self.dynAvatarId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_PlayerAvatarPerDataT {
    pub avatarId: Option<String>,
    pub avatarType: enum__Torappu_PlayerAvatarGroupType,
    pub avatarIdSort: i32,
    pub avatarIdDesc: Option<String>,
    pub avatarItemName: Option<String>,
    pub avatarItemDesc: Option<String>,
    pub avatarItemUsage: Option<String>,
    pub obtainApproach: Option<String>,
    pub dynAvatarId: Option<String>,
}
impl Default for clz_Torappu_PlayerAvatarPerDataT {
    fn default() -> Self {
        Self {
            avatarId: None,
            avatarType: enum__Torappu_PlayerAvatarGroupType::NONE,
            avatarIdSort: 0,
            avatarIdDesc: None,
            avatarItemName: None,
            avatarItemDesc: None,
            avatarItemUsage: None,
            obtainApproach: None,
            dynAvatarId: None,
        }
    }
}
impl clz_Torappu_PlayerAvatarPerDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_PlayerAvatarPerData<'b>> {
        let avatarId = self.avatarId.as_ref().map(|x| _fbb.create_string(x));
        let avatarType = self.avatarType;
        let avatarIdSort = self.avatarIdSort;
        let avatarIdDesc = self.avatarIdDesc.as_ref().map(|x| _fbb.create_string(x));
        let avatarItemName = self.avatarItemName.as_ref().map(|x| _fbb.create_string(x));
        let avatarItemDesc = self.avatarItemDesc.as_ref().map(|x| _fbb.create_string(x));
        let avatarItemUsage = self.avatarItemUsage.as_ref().map(|x| _fbb.create_string(x));
        let obtainApproach = self.obtainApproach.as_ref().map(|x| _fbb.create_string(x));
        let dynAvatarId = self.dynAvatarId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_PlayerAvatarPerData::create(
            _fbb,
            &clz_Torappu_PlayerAvatarPerDataArgs {
                avatarId,
                avatarType,
                avatarIdSort,
                avatarIdDesc,
                avatarItemName,
                avatarItemDesc,
                avatarItemUsage,
                obtainApproach,
                dynAvatarId,
            },
        )
    }
}
pub enum clz_Torappu_PlayerAvatarGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_PlayerAvatarGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_PlayerAvatarGroupData<'a> {
    type Inner = clz_Torappu_PlayerAvatarGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_PlayerAvatarGroupData<'a> {
    pub const VT_AVATARTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_TYPENAME: flatbuffers::VOffsetT = 6;
    pub const VT_SORTID: flatbuffers::VOffsetT = 8;
    pub const VT_AVATARIDLIST: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_PlayerAvatarGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_PlayerAvatarGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_PlayerAvatarGroupData<'bldr>> {
        let mut builder = clz_Torappu_PlayerAvatarGroupDataBuilder::new(_fbb);
        if let Some(x) = args.avatarIdList {
            builder.add_avatarIdList(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.typeName {
            builder.add_typeName(x);
        }
        builder.add_avatarType(args.avatarType);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_PlayerAvatarGroupDataT {
        let avatarType = self.avatarType();
        let typeName = self.typeName().map(|x| x.to_string());
        let sortId = self.sortId();
        let avatarIdList = self
            .avatarIdList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_PlayerAvatarGroupDataT {
            avatarType,
            typeName,
            sortId,
            avatarIdList,
        }
    }

    #[inline]
    pub fn avatarType(&self) -> enum__Torappu_PlayerAvatarGroupType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_PlayerAvatarGroupType>(
                    clz_Torappu_PlayerAvatarGroupData::VT_AVATARTYPE,
                    Some(enum__Torappu_PlayerAvatarGroupType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn typeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_PlayerAvatarGroupData::VT_TYPENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_PlayerAvatarGroupData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn avatarIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_PlayerAvatarGroupData::VT_AVATARIDLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_PlayerAvatarGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_PlayerAvatarGroupType>(
                "avatarType",
                Self::VT_AVATARTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "typeName",
                Self::VT_TYPENAME,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("avatarIdList", Self::VT_AVATARIDLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_PlayerAvatarGroupDataArgs<'a> {
    pub avatarType: enum__Torappu_PlayerAvatarGroupType,
    pub typeName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub avatarIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_PlayerAvatarGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_PlayerAvatarGroupDataArgs {
            avatarType: enum__Torappu_PlayerAvatarGroupType::NONE,
            typeName: None,
            sortId: 0,
            avatarIdList: None,
        }
    }
}

impl Serialize for clz_Torappu_PlayerAvatarGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_PlayerAvatarGroupData", 4)?;
        s.serialize_field("avatarType", &self.avatarType())?;
        if let Some(f) = self.typeName() {
            s.serialize_field("typeName", &f)?;
        } else {
            s.skip_field("typeName")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.avatarIdList() {
            s.serialize_field("avatarIdList", &f)?;
        } else {
            s.skip_field("avatarIdList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_PlayerAvatarGroupDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_PlayerAvatarGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_avatarType(&mut self, avatarType: enum__Torappu_PlayerAvatarGroupType) {
        self.fbb_.push_slot::<enum__Torappu_PlayerAvatarGroupType>(
            clz_Torappu_PlayerAvatarGroupData::VT_AVATARTYPE,
            avatarType,
            enum__Torappu_PlayerAvatarGroupType::NONE,
        );
    }
    #[inline]
    pub fn add_typeName(&mut self, typeName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_PlayerAvatarGroupData::VT_TYPENAME,
            typeName,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_PlayerAvatarGroupData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_avatarIdList(
        &mut self,
        avatarIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_PlayerAvatarGroupData::VT_AVATARIDLIST,
            avatarIdList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_PlayerAvatarGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_PlayerAvatarGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_PlayerAvatarGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_PlayerAvatarGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_PlayerAvatarGroupData");
        ds.field("avatarType", &self.avatarType());
        ds.field("typeName", &self.typeName());
        ds.field("sortId", &self.sortId());
        ds.field("avatarIdList", &self.avatarIdList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_PlayerAvatarGroupDataT {
    pub avatarType: enum__Torappu_PlayerAvatarGroupType,
    pub typeName: Option<String>,
    pub sortId: i32,
    pub avatarIdList: Option<Vec<String>>,
}
impl Default for clz_Torappu_PlayerAvatarGroupDataT {
    fn default() -> Self {
        Self {
            avatarType: enum__Torappu_PlayerAvatarGroupType::NONE,
            typeName: None,
            sortId: 0,
            avatarIdList: None,
        }
    }
}
impl clz_Torappu_PlayerAvatarGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_PlayerAvatarGroupData<'b>> {
        let avatarType = self.avatarType;
        let typeName = self.typeName.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let avatarIdList = self.avatarIdList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_PlayerAvatarGroupData::create(
            _fbb,
            &clz_Torappu_PlayerAvatarGroupDataArgs {
                avatarType,
                typeName,
                sortId,
                avatarIdList,
            },
        )
    }
}
pub enum dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData<'a>
{
    type Inner = dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData<'bldr>,
    > {
        let mut builder = dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(
        &self,
    ) -> dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupDataT {
        let key = self.key();
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_PlayerAvatarGroupType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<enum__Torappu_PlayerAvatarGroupType>(dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData::VT_KEY, Some(enum__Torappu_PlayerAvatarGroupType::NONE)).unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_PlayerAvatarGroupType,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_PlayerAvatarGroupData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_PlayerAvatarGroupData>>(dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable
    for dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_PlayerAvatarGroupType>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_PlayerAvatarGroupData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupDataArgs<'a> {
    pub key: enum__Torappu_PlayerAvatarGroupType,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_PlayerAvatarGroupData<'a>>>,
}
impl<'a> Default
    for dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupDataArgs<'a>
{
    #[inline]
    fn default() -> Self {
        dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupDataArgs {
            key: enum__Torappu_PlayerAvatarGroupType::NONE,
            value: None,
        }
    }
}

impl Serialize
    for dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData<'_>
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: enum__Torappu_PlayerAvatarGroupType) {
        self.fbb_.push_slot::<enum__Torappu_PlayerAvatarGroupType>(
            dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData::VT_KEY,
            key,
            enum__Torappu_PlayerAvatarGroupType::NONE,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_PlayerAvatarGroupData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_PlayerAvatarGroupData>>(
            dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupDataBuilder<
        'a,
        'b,
        A,
    > {
        let start = _fbb.start_table();
        dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct(
            "dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData",
        );
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupDataT {
    pub key: enum__Torappu_PlayerAvatarGroupType,
    pub value: Option<Box<clz_Torappu_PlayerAvatarGroupDataT>>,
}
impl Default for dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupDataT {
    fn default() -> Self {
        Self {
            key: enum__Torappu_PlayerAvatarGroupType::NONE,
            value: None,
        }
    }
}
impl dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData<'b>,
    > {
        let key = self.key;
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData::create(
            _fbb,
            &dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupDataArgs {
                key,
                value,
            },
        )
    }
}
pub enum clz_Torappu_PlayerAvatarDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_PlayerAvatarData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_PlayerAvatarData<'a> {
    type Inner = clz_Torappu_PlayerAvatarData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_PlayerAvatarData<'a> {
    pub const VT_DEFAULTAVATARID: flatbuffers::VOffsetT = 4;
    pub const VT_AVATARLIST: flatbuffers::VOffsetT = 6;
    pub const VT_AVATARTYPEDATA: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_PlayerAvatarData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_PlayerAvatarDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_PlayerAvatarData<'bldr>> {
        let mut builder = clz_Torappu_PlayerAvatarDataBuilder::new(_fbb);
        if let Some(x) = args.avatarTypeData {
            builder.add_avatarTypeData(x);
        }
        if let Some(x) = args.avatarList {
            builder.add_avatarList(x);
        }
        if let Some(x) = args.defaultAvatarId {
            builder.add_defaultAvatarId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_PlayerAvatarDataT {
        let defaultAvatarId = self.defaultAvatarId().map(|x| x.to_string());
        let avatarList = self
            .avatarList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let avatarTypeData = self
            .avatarTypeData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_PlayerAvatarDataT {
            defaultAvatarId,
            avatarList,
            avatarTypeData,
        }
    }

    #[inline]
    pub fn defaultAvatarId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_PlayerAvatarData::VT_DEFAULTAVATARID,
                None,
            )
        }
    }
    #[inline]
    pub fn avatarList(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_PlayerAvatarPerData<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_PlayerAvatarPerData>,
                >,
            >>(clz_Torappu_PlayerAvatarData::VT_AVATARLIST, None)
        }
    }
    #[inline]
    pub fn avatarTypeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData>>>>(clz_Torappu_PlayerAvatarData::VT_AVATARTYPEDATA, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_PlayerAvatarData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("defaultAvatarId", Self::VT_DEFAULTAVATARID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_PlayerAvatarPerData>>>>("avatarList", Self::VT_AVATARLIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData>>>>("avatarTypeData", Self::VT_AVATARTYPEDATA, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_PlayerAvatarDataArgs<'a> {
    pub defaultAvatarId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub avatarList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_PlayerAvatarPerData<'a>>,
            >,
        >,
    >,
    pub avatarTypeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData<
                        'a,
                    >,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_PlayerAvatarDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_PlayerAvatarDataArgs {
            defaultAvatarId: None,
            avatarList: None,
            avatarTypeData: None,
        }
    }
}

impl Serialize for clz_Torappu_PlayerAvatarData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_PlayerAvatarData", 3)?;
        if let Some(f) = self.defaultAvatarId() {
            s.serialize_field("defaultAvatarId", &f)?;
        } else {
            s.skip_field("defaultAvatarId")?;
        }
        if let Some(f) = self.avatarList() {
            s.serialize_field("avatarList", &f)?;
        } else {
            s.skip_field("avatarList")?;
        }
        if let Some(f) = self.avatarTypeData() {
            s.serialize_field("avatarTypeData", &f)?;
        } else {
            s.skip_field("avatarTypeData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_PlayerAvatarDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_PlayerAvatarDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_defaultAvatarId(&mut self, defaultAvatarId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_PlayerAvatarData::VT_DEFAULTAVATARID,
            defaultAvatarId,
        );
    }
    #[inline]
    pub fn add_avatarList(
        &mut self,
        avatarList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_PlayerAvatarPerData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_PlayerAvatarData::VT_AVATARLIST,
            avatarList,
        );
    }
    #[inline]
    pub fn add_avatarTypeData(
        &mut self,
        avatarTypeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupData<
                        'b,
                    >,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_PlayerAvatarData::VT_AVATARTYPEDATA,
            avatarTypeData,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_PlayerAvatarDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_PlayerAvatarDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_PlayerAvatarData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_PlayerAvatarData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_PlayerAvatarData");
        ds.field("defaultAvatarId", &self.defaultAvatarId());
        ds.field("avatarList", &self.avatarList());
        ds.field("avatarTypeData", &self.avatarTypeData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_PlayerAvatarDataT {
    pub defaultAvatarId: Option<String>,
    pub avatarList: Option<Vec<clz_Torappu_PlayerAvatarPerDataT>>,
    pub avatarTypeData:
        Option<Vec<dict__enum__Torappu_PlayerAvatarGroupType__clz_Torappu_PlayerAvatarGroupDataT>>,
}
impl Default for clz_Torappu_PlayerAvatarDataT {
    fn default() -> Self {
        Self {
            defaultAvatarId: None,
            avatarList: None,
            avatarTypeData: None,
        }
    }
}
impl clz_Torappu_PlayerAvatarDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_PlayerAvatarData<'b>> {
        let defaultAvatarId = self.defaultAvatarId.as_ref().map(|x| _fbb.create_string(x));
        let avatarList = self.avatarList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let avatarTypeData = self.avatarTypeData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_PlayerAvatarData::create(
            _fbb,
            &clz_Torappu_PlayerAvatarDataArgs {
                defaultAvatarId,
                avatarList,
                avatarTypeData,
            },
        )
    }
}
pub enum clz_Torappu_HomeBackgroundMultiFormDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_HomeBackgroundMultiFormData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_HomeBackgroundMultiFormData<'a> {
    type Inner = clz_Torappu_HomeBackgroundMultiFormData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_HomeBackgroundMultiFormData<'a> {
    pub const VT_MULTIFORMBGID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_BGMUSICID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_HomeBackgroundMultiFormData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_HomeBackgroundMultiFormDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HomeBackgroundMultiFormData<'bldr>> {
        let mut builder = clz_Torappu_HomeBackgroundMultiFormDataBuilder::new(_fbb);
        if let Some(x) = args.bgMusicId {
            builder.add_bgMusicId(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.multiFormBgId {
            builder.add_multiFormBgId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_HomeBackgroundMultiFormDataT {
        let multiFormBgId = self.multiFormBgId().map(|x| x.to_string());
        let sortId = self.sortId();
        let bgMusicId = self.bgMusicId().map(|x| x.to_string());
        clz_Torappu_HomeBackgroundMultiFormDataT {
            multiFormBgId,
            sortId,
            bgMusicId,
        }
    }

    #[inline]
    pub fn multiFormBgId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeBackgroundMultiFormData::VT_MULTIFORMBGID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_HomeBackgroundMultiFormData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn bgMusicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeBackgroundMultiFormData::VT_BGMUSICID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_HomeBackgroundMultiFormData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "multiFormBgId",
                Self::VT_MULTIFORMBGID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bgMusicId",
                Self::VT_BGMUSICID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_HomeBackgroundMultiFormDataArgs<'a> {
    pub multiFormBgId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub bgMusicId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_HomeBackgroundMultiFormDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_HomeBackgroundMultiFormDataArgs {
            multiFormBgId: None,
            sortId: 0,
            bgMusicId: None,
        }
    }
}

impl Serialize for clz_Torappu_HomeBackgroundMultiFormData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_HomeBackgroundMultiFormData", 3)?;
        if let Some(f) = self.multiFormBgId() {
            s.serialize_field("multiFormBgId", &f)?;
        } else {
            s.skip_field("multiFormBgId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.bgMusicId() {
            s.serialize_field("bgMusicId", &f)?;
        } else {
            s.skip_field("bgMusicId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_HomeBackgroundMultiFormDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_HomeBackgroundMultiFormDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_multiFormBgId(&mut self, multiFormBgId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeBackgroundMultiFormData::VT_MULTIFORMBGID,
            multiFormBgId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_HomeBackgroundMultiFormData::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn add_bgMusicId(&mut self, bgMusicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeBackgroundMultiFormData::VT_BGMUSICID,
            bgMusicId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_HomeBackgroundMultiFormDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_HomeBackgroundMultiFormDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_HomeBackgroundMultiFormData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_HomeBackgroundMultiFormData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_HomeBackgroundMultiFormData");
        ds.field("multiFormBgId", &self.multiFormBgId());
        ds.field("sortId", &self.sortId());
        ds.field("bgMusicId", &self.bgMusicId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_HomeBackgroundMultiFormDataT {
    pub multiFormBgId: Option<String>,
    pub sortId: i32,
    pub bgMusicId: Option<String>,
}
impl Default for clz_Torappu_HomeBackgroundMultiFormDataT {
    fn default() -> Self {
        Self {
            multiFormBgId: None,
            sortId: 0,
            bgMusicId: None,
        }
    }
}
impl clz_Torappu_HomeBackgroundMultiFormDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HomeBackgroundMultiFormData<'b>> {
        let multiFormBgId = self.multiFormBgId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let bgMusicId = self.bgMusicId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_HomeBackgroundMultiFormData::create(
            _fbb,
            &clz_Torappu_HomeBackgroundMultiFormDataArgs {
                multiFormBgId,
                sortId,
                bgMusicId,
            },
        )
    }
}
pub enum clz_Torappu_HomeBackgroundSingleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_HomeBackgroundSingleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_HomeBackgroundSingleData<'a> {
    type Inner = clz_Torappu_HomeBackgroundSingleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_HomeBackgroundSingleData<'a> {
    pub const VT_BGID: flatbuffers::VOffsetT = 4;
    pub const VT_BGSORTID: flatbuffers::VOffsetT = 6;
    pub const VT_BGSTARTTIME: flatbuffers::VOffsetT = 8;
    pub const VT_BGNAME: flatbuffers::VOffsetT = 10;
    pub const VT_BGDES: flatbuffers::VOffsetT = 12;
    pub const VT_BGUSAGE: flatbuffers::VOffsetT = 14;
    pub const VT_ISMULTIFORM: flatbuffers::VOffsetT = 16;
    pub const VT_CHANGERULE: flatbuffers::VOffsetT = 18;
    pub const VT_MULTIFORMLIST: flatbuffers::VOffsetT = 20;
    pub const VT_OBTAINAPPROACH: flatbuffers::VOffsetT = 22;
    pub const VT_UNLOCKDESLIST: flatbuffers::VOffsetT = 24;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_HomeBackgroundSingleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_HomeBackgroundSingleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HomeBackgroundSingleData<'bldr>> {
        let mut builder = clz_Torappu_HomeBackgroundSingleDataBuilder::new(_fbb);
        builder.add_bgStartTime(args.bgStartTime);
        if let Some(x) = args.unlockDesList {
            builder.add_unlockDesList(x);
        }
        if let Some(x) = args.obtainApproach {
            builder.add_obtainApproach(x);
        }
        if let Some(x) = args.multiFormList {
            builder.add_multiFormList(x);
        }
        builder.add_changeRule(args.changeRule);
        if let Some(x) = args.bgUsage {
            builder.add_bgUsage(x);
        }
        if let Some(x) = args.bgDes {
            builder.add_bgDes(x);
        }
        if let Some(x) = args.bgName {
            builder.add_bgName(x);
        }
        builder.add_bgSortId(args.bgSortId);
        if let Some(x) = args.bgId {
            builder.add_bgId(x);
        }
        builder.add_isMultiForm(args.isMultiForm);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_HomeBackgroundSingleDataT {
        let bgId = self.bgId().map(|x| x.to_string());
        let bgSortId = self.bgSortId();
        let bgStartTime = self.bgStartTime();
        let bgName = self.bgName().map(|x| x.to_string());
        let bgDes = self.bgDes().map(|x| x.to_string());
        let bgUsage = self.bgUsage().map(|x| x.to_string());
        let isMultiForm = self.isMultiForm();
        let changeRule = self.changeRule();
        let multiFormList = self
            .multiFormList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let obtainApproach = self.obtainApproach().map(|x| x.to_string());
        let unlockDesList = self
            .unlockDesList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_HomeBackgroundSingleDataT {
            bgId,
            bgSortId,
            bgStartTime,
            bgName,
            bgDes,
            bgUsage,
            isMultiForm,
            changeRule,
            multiFormList,
            obtainApproach,
            unlockDesList,
        }
    }

    #[inline]
    pub fn bgId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeBackgroundSingleData::VT_BGID,
                None,
            )
        }
    }
    #[inline]
    pub fn bgSortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_HomeBackgroundSingleData::VT_BGSORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn bgStartTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_HomeBackgroundSingleData::VT_BGSTARTTIME,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn bgName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeBackgroundSingleData::VT_BGNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn bgDes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeBackgroundSingleData::VT_BGDES,
                None,
            )
        }
    }
    #[inline]
    pub fn bgUsage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeBackgroundSingleData::VT_BGUSAGE,
                None,
            )
        }
    }
    #[inline]
    pub fn isMultiForm(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_HomeBackgroundSingleData::VT_ISMULTIFORM,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn changeRule(&self) -> enum__Torappu_HomeMultiFormChangeRule {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_HomeMultiFormChangeRule>(
                    clz_Torappu_HomeBackgroundSingleData::VT_CHANGERULE,
                    Some(enum__Torappu_HomeMultiFormChangeRule::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn multiFormList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_HomeBackgroundMultiFormData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_HomeBackgroundMultiFormData>,
                >,
            >>(clz_Torappu_HomeBackgroundSingleData::VT_MULTIFORMLIST, None)
        }
    }
    #[inline]
    pub fn obtainApproach(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeBackgroundSingleData::VT_OBTAINAPPROACH,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockDesList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_HomeBackgroundSingleData::VT_UNLOCKDESLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_HomeBackgroundSingleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bgId", Self::VT_BGID, false)?
            .visit_field::<i32>("bgSortId", Self::VT_BGSORTID, false)?
            .visit_field::<i64>("bgStartTime", Self::VT_BGSTARTTIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bgName", Self::VT_BGNAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bgDes", Self::VT_BGDES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bgUsage", Self::VT_BGUSAGE, false)?
            .visit_field::<bool>("isMultiForm", Self::VT_ISMULTIFORM, false)?
            .visit_field::<enum__Torappu_HomeMultiFormChangeRule>(
                "changeRule",
                Self::VT_CHANGERULE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_HomeBackgroundMultiFormData>,
                >,
            >>("multiFormList", Self::VT_MULTIFORMLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "obtainApproach",
                Self::VT_OBTAINAPPROACH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("unlockDesList", Self::VT_UNLOCKDESLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_HomeBackgroundSingleDataArgs<'a> {
    pub bgId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bgSortId: i32,
    pub bgStartTime: i64,
    pub bgName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bgDes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bgUsage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isMultiForm: bool,
    pub changeRule: enum__Torappu_HomeMultiFormChangeRule,
    pub multiFormList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_HomeBackgroundMultiFormData<'a>>,
            >,
        >,
    >,
    pub obtainApproach: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockDesList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_HomeBackgroundSingleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_HomeBackgroundSingleDataArgs {
            bgId: None,
            bgSortId: 0,
            bgStartTime: 0,
            bgName: None,
            bgDes: None,
            bgUsage: None,
            isMultiForm: false,
            changeRule: enum__Torappu_HomeMultiFormChangeRule::NONE,
            multiFormList: None,
            obtainApproach: None,
            unlockDesList: None,
        }
    }
}

impl Serialize for clz_Torappu_HomeBackgroundSingleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_HomeBackgroundSingleData", 11)?;
        if let Some(f) = self.bgId() {
            s.serialize_field("bgId", &f)?;
        } else {
            s.skip_field("bgId")?;
        }
        s.serialize_field("bgSortId", &self.bgSortId())?;
        s.serialize_field("bgStartTime", &self.bgStartTime())?;
        if let Some(f) = self.bgName() {
            s.serialize_field("bgName", &f)?;
        } else {
            s.skip_field("bgName")?;
        }
        if let Some(f) = self.bgDes() {
            s.serialize_field("bgDes", &f)?;
        } else {
            s.skip_field("bgDes")?;
        }
        if let Some(f) = self.bgUsage() {
            s.serialize_field("bgUsage", &f)?;
        } else {
            s.skip_field("bgUsage")?;
        }
        s.serialize_field("isMultiForm", &self.isMultiForm())?;
        s.serialize_field("changeRule", &self.changeRule())?;
        if let Some(f) = self.multiFormList() {
            s.serialize_field("multiFormList", &f)?;
        } else {
            s.skip_field("multiFormList")?;
        }
        if let Some(f) = self.obtainApproach() {
            s.serialize_field("obtainApproach", &f)?;
        } else {
            s.skip_field("obtainApproach")?;
        }
        if let Some(f) = self.unlockDesList() {
            s.serialize_field("unlockDesList", &f)?;
        } else {
            s.skip_field("unlockDesList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_HomeBackgroundSingleDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_HomeBackgroundSingleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_bgId(&mut self, bgId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeBackgroundSingleData::VT_BGID,
            bgId,
        );
    }
    #[inline]
    pub fn add_bgSortId(&mut self, bgSortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_HomeBackgroundSingleData::VT_BGSORTID,
            bgSortId,
            0,
        );
    }
    #[inline]
    pub fn add_bgStartTime(&mut self, bgStartTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_HomeBackgroundSingleData::VT_BGSTARTTIME,
            bgStartTime,
            0,
        );
    }
    #[inline]
    pub fn add_bgName(&mut self, bgName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeBackgroundSingleData::VT_BGNAME,
            bgName,
        );
    }
    #[inline]
    pub fn add_bgDes(&mut self, bgDes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeBackgroundSingleData::VT_BGDES,
            bgDes,
        );
    }
    #[inline]
    pub fn add_bgUsage(&mut self, bgUsage: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeBackgroundSingleData::VT_BGUSAGE,
            bgUsage,
        );
    }
    #[inline]
    pub fn add_isMultiForm(&mut self, isMultiForm: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_HomeBackgroundSingleData::VT_ISMULTIFORM,
            isMultiForm,
            false,
        );
    }
    #[inline]
    pub fn add_changeRule(&mut self, changeRule: enum__Torappu_HomeMultiFormChangeRule) {
        self.fbb_
            .push_slot::<enum__Torappu_HomeMultiFormChangeRule>(
                clz_Torappu_HomeBackgroundSingleData::VT_CHANGERULE,
                changeRule,
                enum__Torappu_HomeMultiFormChangeRule::NONE,
            );
    }
    #[inline]
    pub fn add_multiFormList(
        &mut self,
        multiFormList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_HomeBackgroundMultiFormData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeBackgroundSingleData::VT_MULTIFORMLIST,
            multiFormList,
        );
    }
    #[inline]
    pub fn add_obtainApproach(&mut self, obtainApproach: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeBackgroundSingleData::VT_OBTAINAPPROACH,
            obtainApproach,
        );
    }
    #[inline]
    pub fn add_unlockDesList(
        &mut self,
        unlockDesList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeBackgroundSingleData::VT_UNLOCKDESLIST,
            unlockDesList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_HomeBackgroundSingleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_HomeBackgroundSingleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_HomeBackgroundSingleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_HomeBackgroundSingleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_HomeBackgroundSingleData");
        ds.field("bgId", &self.bgId());
        ds.field("bgSortId", &self.bgSortId());
        ds.field("bgStartTime", &self.bgStartTime());
        ds.field("bgName", &self.bgName());
        ds.field("bgDes", &self.bgDes());
        ds.field("bgUsage", &self.bgUsage());
        ds.field("isMultiForm", &self.isMultiForm());
        ds.field("changeRule", &self.changeRule());
        ds.field("multiFormList", &self.multiFormList());
        ds.field("obtainApproach", &self.obtainApproach());
        ds.field("unlockDesList", &self.unlockDesList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_HomeBackgroundSingleDataT {
    pub bgId: Option<String>,
    pub bgSortId: i32,
    pub bgStartTime: i64,
    pub bgName: Option<String>,
    pub bgDes: Option<String>,
    pub bgUsage: Option<String>,
    pub isMultiForm: bool,
    pub changeRule: enum__Torappu_HomeMultiFormChangeRule,
    pub multiFormList: Option<Vec<clz_Torappu_HomeBackgroundMultiFormDataT>>,
    pub obtainApproach: Option<String>,
    pub unlockDesList: Option<Vec<String>>,
}
impl Default for clz_Torappu_HomeBackgroundSingleDataT {
    fn default() -> Self {
        Self {
            bgId: None,
            bgSortId: 0,
            bgStartTime: 0,
            bgName: None,
            bgDes: None,
            bgUsage: None,
            isMultiForm: false,
            changeRule: enum__Torappu_HomeMultiFormChangeRule::NONE,
            multiFormList: None,
            obtainApproach: None,
            unlockDesList: None,
        }
    }
}
impl clz_Torappu_HomeBackgroundSingleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HomeBackgroundSingleData<'b>> {
        let bgId = self.bgId.as_ref().map(|x| _fbb.create_string(x));
        let bgSortId = self.bgSortId;
        let bgStartTime = self.bgStartTime;
        let bgName = self.bgName.as_ref().map(|x| _fbb.create_string(x));
        let bgDes = self.bgDes.as_ref().map(|x| _fbb.create_string(x));
        let bgUsage = self.bgUsage.as_ref().map(|x| _fbb.create_string(x));
        let isMultiForm = self.isMultiForm;
        let changeRule = self.changeRule;
        let multiFormList = self.multiFormList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let obtainApproach = self.obtainApproach.as_ref().map(|x| _fbb.create_string(x));
        let unlockDesList = self.unlockDesList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_HomeBackgroundSingleData::create(
            _fbb,
            &clz_Torappu_HomeBackgroundSingleDataArgs {
                bgId,
                bgSortId,
                bgStartTime,
                bgName,
                bgDes,
                bgUsage,
                isMultiForm,
                changeRule,
                multiFormList,
                obtainApproach,
                unlockDesList,
            },
        )
    }
}
pub enum clz_Torappu_HomeThemeMultiFormDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_HomeThemeMultiFormData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_HomeThemeMultiFormData<'a> {
    type Inner = clz_Torappu_HomeThemeMultiFormData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_HomeThemeMultiFormData<'a> {
    pub const VT_MULTIFORMTMID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_HomeThemeMultiFormData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_HomeThemeMultiFormDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HomeThemeMultiFormData<'bldr>> {
        let mut builder = clz_Torappu_HomeThemeMultiFormDataBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.multiFormTmId {
            builder.add_multiFormTmId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_HomeThemeMultiFormDataT {
        let multiFormTmId = self.multiFormTmId().map(|x| x.to_string());
        let sortId = self.sortId();
        clz_Torappu_HomeThemeMultiFormDataT {
            multiFormTmId,
            sortId,
        }
    }

    #[inline]
    pub fn multiFormTmId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeThemeMultiFormData::VT_MULTIFORMTMID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_HomeThemeMultiFormData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_HomeThemeMultiFormData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "multiFormTmId",
                Self::VT_MULTIFORMTMID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_HomeThemeMultiFormDataArgs<'a> {
    pub multiFormTmId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_HomeThemeMultiFormDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_HomeThemeMultiFormDataArgs {
            multiFormTmId: None,
            sortId: 0,
        }
    }
}

impl Serialize for clz_Torappu_HomeThemeMultiFormData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_HomeThemeMultiFormData", 2)?;
        if let Some(f) = self.multiFormTmId() {
            s.serialize_field("multiFormTmId", &f)?;
        } else {
            s.skip_field("multiFormTmId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.end()
    }
}

pub struct clz_Torappu_HomeThemeMultiFormDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_HomeThemeMultiFormDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_multiFormTmId(&mut self, multiFormTmId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeThemeMultiFormData::VT_MULTIFORMTMID,
            multiFormTmId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_HomeThemeMultiFormData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_HomeThemeMultiFormDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_HomeThemeMultiFormDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_HomeThemeMultiFormData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_HomeThemeMultiFormData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_HomeThemeMultiFormData");
        ds.field("multiFormTmId", &self.multiFormTmId());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_HomeThemeMultiFormDataT {
    pub multiFormTmId: Option<String>,
    pub sortId: i32,
}
impl Default for clz_Torappu_HomeThemeMultiFormDataT {
    fn default() -> Self {
        Self {
            multiFormTmId: None,
            sortId: 0,
        }
    }
}
impl clz_Torappu_HomeThemeMultiFormDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HomeThemeMultiFormData<'b>> {
        let multiFormTmId = self.multiFormTmId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        clz_Torappu_HomeThemeMultiFormData::create(
            _fbb,
            &clz_Torappu_HomeThemeMultiFormDataArgs {
                multiFormTmId,
                sortId,
            },
        )
    }
}
pub enum clz_Torappu_HomeThemeDisplayDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_HomeThemeDisplayData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_HomeThemeDisplayData<'a> {
    type Inner = clz_Torappu_HomeThemeDisplayData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_HomeThemeDisplayData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_SORTID: flatbuffers::VOffsetT = 8;
    pub const VT_STARTTIME: flatbuffers::VOffsetT = 10;
    pub const VT_TMNAME: flatbuffers::VOffsetT = 12;
    pub const VT_TMDES: flatbuffers::VOffsetT = 14;
    pub const VT_TMUSAGE: flatbuffers::VOffsetT = 16;
    pub const VT_ISMULTIFORM: flatbuffers::VOffsetT = 18;
    pub const VT_CHANGERULE: flatbuffers::VOffsetT = 20;
    pub const VT_MULTIFORMLIST: flatbuffers::VOffsetT = 22;
    pub const VT_OBTAINAPPROACH: flatbuffers::VOffsetT = 24;
    pub const VT_UNLOCKDESLIST: flatbuffers::VOffsetT = 26;
    pub const VT_ISLIMITOBTAIN: flatbuffers::VOffsetT = 28;
    pub const VT_HIDEWHENLIMIT: flatbuffers::VOffsetT = 30;
    pub const VT_RARITY: flatbuffers::VOffsetT = 32;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_HomeThemeDisplayData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_HomeThemeDisplayDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HomeThemeDisplayData<'bldr>> {
        let mut builder = clz_Torappu_HomeThemeDisplayDataBuilder::new(_fbb);
        builder.add_startTime(args.startTime);
        builder.add_rarity(args.rarity);
        if let Some(x) = args.unlockDesList {
            builder.add_unlockDesList(x);
        }
        if let Some(x) = args.obtainApproach {
            builder.add_obtainApproach(x);
        }
        if let Some(x) = args.multiFormList {
            builder.add_multiFormList(x);
        }
        builder.add_changeRule(args.changeRule);
        if let Some(x) = args.tmUsage {
            builder.add_tmUsage(x);
        }
        if let Some(x) = args.tmDes {
            builder.add_tmDes(x);
        }
        if let Some(x) = args.tmName {
            builder.add_tmName(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.type_ {
            builder.add_type_(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_hideWhenLimit(args.hideWhenLimit);
        builder.add_isLimitObtain(args.isLimitObtain);
        builder.add_isMultiForm(args.isMultiForm);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_HomeThemeDisplayDataT {
        let id = self.id().map(|x| x.to_string());
        let type_ = self.type_().map(|x| x.to_string());
        let sortId = self.sortId();
        let startTime = self.startTime();
        let tmName = self.tmName().map(|x| x.to_string());
        let tmDes = self.tmDes().map(|x| x.to_string());
        let tmUsage = self.tmUsage().map(|x| x.to_string());
        let isMultiForm = self.isMultiForm();
        let changeRule = self.changeRule();
        let multiFormList = self
            .multiFormList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let obtainApproach = self.obtainApproach().map(|x| x.to_string());
        let unlockDesList = self
            .unlockDesList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let isLimitObtain = self.isLimitObtain();
        let hideWhenLimit = self.hideWhenLimit();
        let rarity = self.rarity();
        clz_Torappu_HomeThemeDisplayDataT {
            id,
            type_,
            sortId,
            startTime,
            tmName,
            tmDes,
            tmUsage,
            isMultiForm,
            changeRule,
            multiFormList,
            obtainApproach,
            unlockDesList,
            isLimitObtain,
            hideWhenLimit,
            rarity,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeThemeDisplayData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeThemeDisplayData::VT_TYPE_,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_HomeThemeDisplayData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn startTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_HomeThemeDisplayData::VT_STARTTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn tmName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeThemeDisplayData::VT_TMNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn tmDes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeThemeDisplayData::VT_TMDES,
                None,
            )
        }
    }
    #[inline]
    pub fn tmUsage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeThemeDisplayData::VT_TMUSAGE,
                None,
            )
        }
    }
    #[inline]
    pub fn isMultiForm(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_HomeThemeDisplayData::VT_ISMULTIFORM,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn changeRule(&self) -> enum__Torappu_HomeMultiFormChangeRule {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_HomeMultiFormChangeRule>(
                    clz_Torappu_HomeThemeDisplayData::VT_CHANGERULE,
                    Some(enum__Torappu_HomeMultiFormChangeRule::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn multiFormList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_HomeThemeMultiFormData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_HomeThemeMultiFormData>,
                >,
            >>(clz_Torappu_HomeThemeDisplayData::VT_MULTIFORMLIST, None)
        }
    }
    #[inline]
    pub fn obtainApproach(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeThemeDisplayData::VT_OBTAINAPPROACH,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockDesList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_HomeThemeDisplayData::VT_UNLOCKDESLIST, None)
        }
    }
    #[inline]
    pub fn isLimitObtain(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_HomeThemeDisplayData::VT_ISLIMITOBTAIN,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn hideWhenLimit(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_HomeThemeDisplayData::VT_HIDEWHENLIMIT,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rarity(&self) -> enum__Torappu_ItemRarity {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemRarity>(
                    clz_Torappu_HomeThemeDisplayData::VT_RARITY,
                    Some(enum__Torappu_ItemRarity::TIER_1),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_HomeThemeDisplayData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<i64>("startTime", Self::VT_STARTTIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tmName", Self::VT_TMNAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tmDes", Self::VT_TMDES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tmUsage", Self::VT_TMUSAGE, false)?
            .visit_field::<bool>("isMultiForm", Self::VT_ISMULTIFORM, false)?
            .visit_field::<enum__Torappu_HomeMultiFormChangeRule>(
                "changeRule",
                Self::VT_CHANGERULE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_HomeThemeMultiFormData>,
                >,
            >>("multiFormList", Self::VT_MULTIFORMLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "obtainApproach",
                Self::VT_OBTAINAPPROACH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("unlockDesList", Self::VT_UNLOCKDESLIST, false)?
            .visit_field::<bool>("isLimitObtain", Self::VT_ISLIMITOBTAIN, false)?
            .visit_field::<bool>("hideWhenLimit", Self::VT_HIDEWHENLIMIT, false)?
            .visit_field::<enum__Torappu_ItemRarity>("rarity", Self::VT_RARITY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_HomeThemeDisplayDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub startTime: i64,
    pub tmName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tmDes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tmUsage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isMultiForm: bool,
    pub changeRule: enum__Torappu_HomeMultiFormChangeRule,
    pub multiFormList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_HomeThemeMultiFormData<'a>>,
            >,
        >,
    >,
    pub obtainApproach: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockDesList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub isLimitObtain: bool,
    pub hideWhenLimit: bool,
    pub rarity: enum__Torappu_ItemRarity,
}
impl<'a> Default for clz_Torappu_HomeThemeDisplayDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_HomeThemeDisplayDataArgs {
            id: None,
            type_: None,
            sortId: 0,
            startTime: 0,
            tmName: None,
            tmDes: None,
            tmUsage: None,
            isMultiForm: false,
            changeRule: enum__Torappu_HomeMultiFormChangeRule::NONE,
            multiFormList: None,
            obtainApproach: None,
            unlockDesList: None,
            isLimitObtain: false,
            hideWhenLimit: false,
            rarity: enum__Torappu_ItemRarity::TIER_1,
        }
    }
}

impl Serialize for clz_Torappu_HomeThemeDisplayData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_HomeThemeDisplayData", 15)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.type_() {
            s.serialize_field("type_", &f)?;
        } else {
            s.skip_field("type_")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.serialize_field("startTime", &self.startTime())?;
        if let Some(f) = self.tmName() {
            s.serialize_field("tmName", &f)?;
        } else {
            s.skip_field("tmName")?;
        }
        if let Some(f) = self.tmDes() {
            s.serialize_field("tmDes", &f)?;
        } else {
            s.skip_field("tmDes")?;
        }
        if let Some(f) = self.tmUsage() {
            s.serialize_field("tmUsage", &f)?;
        } else {
            s.skip_field("tmUsage")?;
        }
        s.serialize_field("isMultiForm", &self.isMultiForm())?;
        s.serialize_field("changeRule", &self.changeRule())?;
        if let Some(f) = self.multiFormList() {
            s.serialize_field("multiFormList", &f)?;
        } else {
            s.skip_field("multiFormList")?;
        }
        if let Some(f) = self.obtainApproach() {
            s.serialize_field("obtainApproach", &f)?;
        } else {
            s.skip_field("obtainApproach")?;
        }
        if let Some(f) = self.unlockDesList() {
            s.serialize_field("unlockDesList", &f)?;
        } else {
            s.skip_field("unlockDesList")?;
        }
        s.serialize_field("isLimitObtain", &self.isLimitObtain())?;
        s.serialize_field("hideWhenLimit", &self.hideWhenLimit())?;
        s.serialize_field("rarity", &self.rarity())?;
        s.end()
    }
}

pub struct clz_Torappu_HomeThemeDisplayDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_HomeThemeDisplayDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeThemeDisplayData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeThemeDisplayData::VT_TYPE_,
            type_,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_HomeThemeDisplayData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_startTime(&mut self, startTime: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_HomeThemeDisplayData::VT_STARTTIME, startTime, 0);
    }
    #[inline]
    pub fn add_tmName(&mut self, tmName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeThemeDisplayData::VT_TMNAME,
            tmName,
        );
    }
    #[inline]
    pub fn add_tmDes(&mut self, tmDes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeThemeDisplayData::VT_TMDES,
            tmDes,
        );
    }
    #[inline]
    pub fn add_tmUsage(&mut self, tmUsage: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeThemeDisplayData::VT_TMUSAGE,
            tmUsage,
        );
    }
    #[inline]
    pub fn add_isMultiForm(&mut self, isMultiForm: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_HomeThemeDisplayData::VT_ISMULTIFORM,
            isMultiForm,
            false,
        );
    }
    #[inline]
    pub fn add_changeRule(&mut self, changeRule: enum__Torappu_HomeMultiFormChangeRule) {
        self.fbb_
            .push_slot::<enum__Torappu_HomeMultiFormChangeRule>(
                clz_Torappu_HomeThemeDisplayData::VT_CHANGERULE,
                changeRule,
                enum__Torappu_HomeMultiFormChangeRule::NONE,
            );
    }
    #[inline]
    pub fn add_multiFormList(
        &mut self,
        multiFormList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_HomeThemeMultiFormData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeThemeDisplayData::VT_MULTIFORMLIST,
            multiFormList,
        );
    }
    #[inline]
    pub fn add_obtainApproach(&mut self, obtainApproach: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeThemeDisplayData::VT_OBTAINAPPROACH,
            obtainApproach,
        );
    }
    #[inline]
    pub fn add_unlockDesList(
        &mut self,
        unlockDesList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeThemeDisplayData::VT_UNLOCKDESLIST,
            unlockDesList,
        );
    }
    #[inline]
    pub fn add_isLimitObtain(&mut self, isLimitObtain: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_HomeThemeDisplayData::VT_ISLIMITOBTAIN,
            isLimitObtain,
            false,
        );
    }
    #[inline]
    pub fn add_hideWhenLimit(&mut self, hideWhenLimit: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_HomeThemeDisplayData::VT_HIDEWHENLIMIT,
            hideWhenLimit,
            false,
        );
    }
    #[inline]
    pub fn add_rarity(&mut self, rarity: enum__Torappu_ItemRarity) {
        self.fbb_.push_slot::<enum__Torappu_ItemRarity>(
            clz_Torappu_HomeThemeDisplayData::VT_RARITY,
            rarity,
            enum__Torappu_ItemRarity::TIER_1,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_HomeThemeDisplayDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_HomeThemeDisplayDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_HomeThemeDisplayData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_HomeThemeDisplayData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_HomeThemeDisplayData");
        ds.field("id", &self.id());
        ds.field("type_", &self.type_());
        ds.field("sortId", &self.sortId());
        ds.field("startTime", &self.startTime());
        ds.field("tmName", &self.tmName());
        ds.field("tmDes", &self.tmDes());
        ds.field("tmUsage", &self.tmUsage());
        ds.field("isMultiForm", &self.isMultiForm());
        ds.field("changeRule", &self.changeRule());
        ds.field("multiFormList", &self.multiFormList());
        ds.field("obtainApproach", &self.obtainApproach());
        ds.field("unlockDesList", &self.unlockDesList());
        ds.field("isLimitObtain", &self.isLimitObtain());
        ds.field("hideWhenLimit", &self.hideWhenLimit());
        ds.field("rarity", &self.rarity());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_HomeThemeDisplayDataT {
    pub id: Option<String>,
    pub type_: Option<String>,
    pub sortId: i32,
    pub startTime: i64,
    pub tmName: Option<String>,
    pub tmDes: Option<String>,
    pub tmUsage: Option<String>,
    pub isMultiForm: bool,
    pub changeRule: enum__Torappu_HomeMultiFormChangeRule,
    pub multiFormList: Option<Vec<clz_Torappu_HomeThemeMultiFormDataT>>,
    pub obtainApproach: Option<String>,
    pub unlockDesList: Option<Vec<String>>,
    pub isLimitObtain: bool,
    pub hideWhenLimit: bool,
    pub rarity: enum__Torappu_ItemRarity,
}
impl Default for clz_Torappu_HomeThemeDisplayDataT {
    fn default() -> Self {
        Self {
            id: None,
            type_: None,
            sortId: 0,
            startTime: 0,
            tmName: None,
            tmDes: None,
            tmUsage: None,
            isMultiForm: false,
            changeRule: enum__Torappu_HomeMultiFormChangeRule::NONE,
            multiFormList: None,
            obtainApproach: None,
            unlockDesList: None,
            isLimitObtain: false,
            hideWhenLimit: false,
            rarity: enum__Torappu_ItemRarity::TIER_1,
        }
    }
}
impl clz_Torappu_HomeThemeDisplayDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HomeThemeDisplayData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let startTime = self.startTime;
        let tmName = self.tmName.as_ref().map(|x| _fbb.create_string(x));
        let tmDes = self.tmDes.as_ref().map(|x| _fbb.create_string(x));
        let tmUsage = self.tmUsage.as_ref().map(|x| _fbb.create_string(x));
        let isMultiForm = self.isMultiForm;
        let changeRule = self.changeRule;
        let multiFormList = self.multiFormList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let obtainApproach = self.obtainApproach.as_ref().map(|x| _fbb.create_string(x));
        let unlockDesList = self.unlockDesList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let isLimitObtain = self.isLimitObtain;
        let hideWhenLimit = self.hideWhenLimit;
        let rarity = self.rarity;
        clz_Torappu_HomeThemeDisplayData::create(
            _fbb,
            &clz_Torappu_HomeThemeDisplayDataArgs {
                id,
                type_,
                sortId,
                startTime,
                tmName,
                tmDes,
                tmUsage,
                isMultiForm,
                changeRule,
                multiFormList,
                obtainApproach,
                unlockDesList,
                isLimitObtain,
                hideWhenLimit,
                rarity,
            },
        )
    }
}
pub enum clz_Torappu_HomeBackgroundLimitInfoDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_HomeBackgroundLimitInfoData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_HomeBackgroundLimitInfoData<'a> {
    type Inner = clz_Torappu_HomeBackgroundLimitInfoData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_HomeBackgroundLimitInfoData<'a> {
    pub const VT_LIMITINFOID: flatbuffers::VOffsetT = 4;
    pub const VT_STARTTIME: flatbuffers::VOffsetT = 6;
    pub const VT_ENDTIME: flatbuffers::VOffsetT = 8;
    pub const VT_INVALIDOBTAINDESC: flatbuffers::VOffsetT = 10;
    pub const VT_DISPLAYAFTERENDTIME: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_HomeBackgroundLimitInfoData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_HomeBackgroundLimitInfoDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HomeBackgroundLimitInfoData<'bldr>> {
        let mut builder = clz_Torappu_HomeBackgroundLimitInfoDataBuilder::new(_fbb);
        builder.add_endTime(args.endTime);
        builder.add_startTime(args.startTime);
        if let Some(x) = args.invalidObtainDesc {
            builder.add_invalidObtainDesc(x);
        }
        if let Some(x) = args.limitInfoId {
            builder.add_limitInfoId(x);
        }
        builder.add_displayAfterEndTime(args.displayAfterEndTime);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_HomeBackgroundLimitInfoDataT {
        let limitInfoId = self.limitInfoId().map(|x| x.to_string());
        let startTime = self.startTime();
        let endTime = self.endTime();
        let invalidObtainDesc = self.invalidObtainDesc().map(|x| x.to_string());
        let displayAfterEndTime = self.displayAfterEndTime();
        clz_Torappu_HomeBackgroundLimitInfoDataT {
            limitInfoId,
            startTime,
            endTime,
            invalidObtainDesc,
            displayAfterEndTime,
        }
    }

    #[inline]
    pub fn limitInfoId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeBackgroundLimitInfoData::VT_LIMITINFOID,
                None,
            )
        }
    }
    #[inline]
    pub fn startTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_HomeBackgroundLimitInfoData::VT_STARTTIME,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn endTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_HomeBackgroundLimitInfoData::VT_ENDTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn invalidObtainDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeBackgroundLimitInfoData::VT_INVALIDOBTAINDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn displayAfterEndTime(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_HomeBackgroundLimitInfoData::VT_DISPLAYAFTERENDTIME,
                    Some(false),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_HomeBackgroundLimitInfoData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "limitInfoId",
                Self::VT_LIMITINFOID,
                false,
            )?
            .visit_field::<i64>("startTime", Self::VT_STARTTIME, false)?
            .visit_field::<i64>("endTime", Self::VT_ENDTIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "invalidObtainDesc",
                Self::VT_INVALIDOBTAINDESC,
                false,
            )?
            .visit_field::<bool>("displayAfterEndTime", Self::VT_DISPLAYAFTERENDTIME, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_HomeBackgroundLimitInfoDataArgs<'a> {
    pub limitInfoId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub startTime: i64,
    pub endTime: i64,
    pub invalidObtainDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub displayAfterEndTime: bool,
}
impl<'a> Default for clz_Torappu_HomeBackgroundLimitInfoDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_HomeBackgroundLimitInfoDataArgs {
            limitInfoId: None,
            startTime: 0,
            endTime: 0,
            invalidObtainDesc: None,
            displayAfterEndTime: false,
        }
    }
}

impl Serialize for clz_Torappu_HomeBackgroundLimitInfoData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_HomeBackgroundLimitInfoData", 5)?;
        if let Some(f) = self.limitInfoId() {
            s.serialize_field("limitInfoId", &f)?;
        } else {
            s.skip_field("limitInfoId")?;
        }
        s.serialize_field("startTime", &self.startTime())?;
        s.serialize_field("endTime", &self.endTime())?;
        if let Some(f) = self.invalidObtainDesc() {
            s.serialize_field("invalidObtainDesc", &f)?;
        } else {
            s.skip_field("invalidObtainDesc")?;
        }
        s.serialize_field("displayAfterEndTime", &self.displayAfterEndTime())?;
        s.end()
    }
}

pub struct clz_Torappu_HomeBackgroundLimitInfoDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_HomeBackgroundLimitInfoDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_limitInfoId(&mut self, limitInfoId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeBackgroundLimitInfoData::VT_LIMITINFOID,
            limitInfoId,
        );
    }
    #[inline]
    pub fn add_startTime(&mut self, startTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_HomeBackgroundLimitInfoData::VT_STARTTIME,
            startTime,
            0,
        );
    }
    #[inline]
    pub fn add_endTime(&mut self, endTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_HomeBackgroundLimitInfoData::VT_ENDTIME,
            endTime,
            0,
        );
    }
    #[inline]
    pub fn add_invalidObtainDesc(&mut self, invalidObtainDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeBackgroundLimitInfoData::VT_INVALIDOBTAINDESC,
            invalidObtainDesc,
        );
    }
    #[inline]
    pub fn add_displayAfterEndTime(&mut self, displayAfterEndTime: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_HomeBackgroundLimitInfoData::VT_DISPLAYAFTERENDTIME,
            displayAfterEndTime,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_HomeBackgroundLimitInfoDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_HomeBackgroundLimitInfoDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_HomeBackgroundLimitInfoData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_HomeBackgroundLimitInfoData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_HomeBackgroundLimitInfoData");
        ds.field("limitInfoId", &self.limitInfoId());
        ds.field("startTime", &self.startTime());
        ds.field("endTime", &self.endTime());
        ds.field("invalidObtainDesc", &self.invalidObtainDesc());
        ds.field("displayAfterEndTime", &self.displayAfterEndTime());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_HomeBackgroundLimitInfoDataT {
    pub limitInfoId: Option<String>,
    pub startTime: i64,
    pub endTime: i64,
    pub invalidObtainDesc: Option<String>,
    pub displayAfterEndTime: bool,
}
impl Default for clz_Torappu_HomeBackgroundLimitInfoDataT {
    fn default() -> Self {
        Self {
            limitInfoId: None,
            startTime: 0,
            endTime: 0,
            invalidObtainDesc: None,
            displayAfterEndTime: false,
        }
    }
}
impl clz_Torappu_HomeBackgroundLimitInfoDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HomeBackgroundLimitInfoData<'b>> {
        let limitInfoId = self.limitInfoId.as_ref().map(|x| _fbb.create_string(x));
        let startTime = self.startTime;
        let endTime = self.endTime;
        let invalidObtainDesc = self
            .invalidObtainDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let displayAfterEndTime = self.displayAfterEndTime;
        clz_Torappu_HomeBackgroundLimitInfoData::create(
            _fbb,
            &clz_Torappu_HomeBackgroundLimitInfoDataArgs {
                limitInfoId,
                startTime,
                endTime,
                invalidObtainDesc,
                displayAfterEndTime,
            },
        )
    }
}
pub enum clz_Torappu_HomeBackgroundLimitDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_HomeBackgroundLimitData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_HomeBackgroundLimitData<'a> {
    type Inner = clz_Torappu_HomeBackgroundLimitData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_HomeBackgroundLimitData<'a> {
    pub const VT_BGID: flatbuffers::VOffsetT = 4;
    pub const VT_LIMITINFOS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_HomeBackgroundLimitData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_HomeBackgroundLimitDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HomeBackgroundLimitData<'bldr>> {
        let mut builder = clz_Torappu_HomeBackgroundLimitDataBuilder::new(_fbb);
        if let Some(x) = args.limitInfos {
            builder.add_limitInfos(x);
        }
        if let Some(x) = args.bgId {
            builder.add_bgId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_HomeBackgroundLimitDataT {
        let bgId = self.bgId().map(|x| x.to_string());
        let limitInfos = self
            .limitInfos()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_HomeBackgroundLimitDataT { bgId, limitInfos }
    }

    #[inline]
    pub fn bgId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeBackgroundLimitData::VT_BGID,
                None,
            )
        }
    }
    #[inline]
    pub fn limitInfos(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_HomeBackgroundLimitInfoData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_HomeBackgroundLimitInfoData>,
                >,
            >>(clz_Torappu_HomeBackgroundLimitData::VT_LIMITINFOS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_HomeBackgroundLimitData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bgId", Self::VT_BGID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_HomeBackgroundLimitInfoData>,
                >,
            >>("limitInfos", Self::VT_LIMITINFOS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_HomeBackgroundLimitDataArgs<'a> {
    pub bgId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub limitInfos: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_HomeBackgroundLimitInfoData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_HomeBackgroundLimitDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_HomeBackgroundLimitDataArgs {
            bgId: None,
            limitInfos: None,
        }
    }
}

impl Serialize for clz_Torappu_HomeBackgroundLimitData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_HomeBackgroundLimitData", 2)?;
        if let Some(f) = self.bgId() {
            s.serialize_field("bgId", &f)?;
        } else {
            s.skip_field("bgId")?;
        }
        if let Some(f) = self.limitInfos() {
            s.serialize_field("limitInfos", &f)?;
        } else {
            s.skip_field("limitInfos")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_HomeBackgroundLimitDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_HomeBackgroundLimitDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_bgId(&mut self, bgId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeBackgroundLimitData::VT_BGID,
            bgId,
        );
    }
    #[inline]
    pub fn add_limitInfos(
        &mut self,
        limitInfos: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_HomeBackgroundLimitInfoData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeBackgroundLimitData::VT_LIMITINFOS,
            limitInfos,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_HomeBackgroundLimitDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_HomeBackgroundLimitDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_HomeBackgroundLimitData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_HomeBackgroundLimitData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_HomeBackgroundLimitData");
        ds.field("bgId", &self.bgId());
        ds.field("limitInfos", &self.limitInfos());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_HomeBackgroundLimitDataT {
    pub bgId: Option<String>,
    pub limitInfos: Option<Vec<clz_Torappu_HomeBackgroundLimitInfoDataT>>,
}
impl Default for clz_Torappu_HomeBackgroundLimitDataT {
    fn default() -> Self {
        Self {
            bgId: None,
            limitInfos: None,
        }
    }
}
impl clz_Torappu_HomeBackgroundLimitDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HomeBackgroundLimitData<'b>> {
        let bgId = self.bgId.as_ref().map(|x| _fbb.create_string(x));
        let limitInfos = self.limitInfos.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_HomeBackgroundLimitData::create(
            _fbb,
            &clz_Torappu_HomeBackgroundLimitDataArgs { bgId, limitInfos },
        )
    }
}
pub enum dict__string__clz_Torappu_HomeBackgroundLimitDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_HomeBackgroundLimitData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_HomeBackgroundLimitData<'a> {
    type Inner = dict__string__clz_Torappu_HomeBackgroundLimitData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_HomeBackgroundLimitData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_HomeBackgroundLimitData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_HomeBackgroundLimitDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_HomeBackgroundLimitData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_HomeBackgroundLimitDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_HomeBackgroundLimitDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_HomeBackgroundLimitDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_HomeBackgroundLimitData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_HomeBackgroundLimitData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_HomeBackgroundLimitData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_HomeBackgroundLimitData>>(
                    dict__string__clz_Torappu_HomeBackgroundLimitData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_HomeBackgroundLimitData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_HomeBackgroundLimitData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_HomeBackgroundLimitDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_HomeBackgroundLimitData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_HomeBackgroundLimitDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_HomeBackgroundLimitDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_HomeBackgroundLimitData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_HomeBackgroundLimitData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_HomeBackgroundLimitDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_HomeBackgroundLimitDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_HomeBackgroundLimitData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_HomeBackgroundLimitData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_HomeBackgroundLimitData>>(
                dict__string__clz_Torappu_HomeBackgroundLimitData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_HomeBackgroundLimitDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_HomeBackgroundLimitDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_HomeBackgroundLimitData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_HomeBackgroundLimitData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_HomeBackgroundLimitData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_HomeBackgroundLimitData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_HomeBackgroundLimitDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_HomeBackgroundLimitDataT>>,
}
impl Default for dict__string__clz_Torappu_HomeBackgroundLimitDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_HomeBackgroundLimitDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_HomeBackgroundLimitData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_HomeBackgroundLimitData::create(
            _fbb,
            &dict__string__clz_Torappu_HomeBackgroundLimitDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_HomeThemeLimitInfoDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_HomeThemeLimitInfoData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_HomeThemeLimitInfoData<'a> {
    type Inner = clz_Torappu_HomeThemeLimitInfoData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_HomeThemeLimitInfoData<'a> {
    pub const VT_STARTTIME: flatbuffers::VOffsetT = 4;
    pub const VT_ENDTIME: flatbuffers::VOffsetT = 6;
    pub const VT_INVALIDOBTAINDESC: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_HomeThemeLimitInfoData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_HomeThemeLimitInfoDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HomeThemeLimitInfoData<'bldr>> {
        let mut builder = clz_Torappu_HomeThemeLimitInfoDataBuilder::new(_fbb);
        builder.add_endTime(args.endTime);
        builder.add_startTime(args.startTime);
        if let Some(x) = args.invalidObtainDesc {
            builder.add_invalidObtainDesc(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_HomeThemeLimitInfoDataT {
        let startTime = self.startTime();
        let endTime = self.endTime();
        let invalidObtainDesc = self.invalidObtainDesc().map(|x| x.to_string());
        clz_Torappu_HomeThemeLimitInfoDataT {
            startTime,
            endTime,
            invalidObtainDesc,
        }
    }

    #[inline]
    pub fn startTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_HomeThemeLimitInfoData::VT_STARTTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_HomeThemeLimitInfoData::VT_ENDTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn invalidObtainDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeThemeLimitInfoData::VT_INVALIDOBTAINDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_HomeThemeLimitInfoData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("startTime", Self::VT_STARTTIME, false)?
            .visit_field::<i64>("endTime", Self::VT_ENDTIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "invalidObtainDesc",
                Self::VT_INVALIDOBTAINDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_HomeThemeLimitInfoDataArgs<'a> {
    pub startTime: i64,
    pub endTime: i64,
    pub invalidObtainDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_HomeThemeLimitInfoDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_HomeThemeLimitInfoDataArgs {
            startTime: 0,
            endTime: 0,
            invalidObtainDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_HomeThemeLimitInfoData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_HomeThemeLimitInfoData", 3)?;
        s.serialize_field("startTime", &self.startTime())?;
        s.serialize_field("endTime", &self.endTime())?;
        if let Some(f) = self.invalidObtainDesc() {
            s.serialize_field("invalidObtainDesc", &f)?;
        } else {
            s.skip_field("invalidObtainDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_HomeThemeLimitInfoDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_HomeThemeLimitInfoDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_startTime(&mut self, startTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_HomeThemeLimitInfoData::VT_STARTTIME,
            startTime,
            0,
        );
    }
    #[inline]
    pub fn add_endTime(&mut self, endTime: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_HomeThemeLimitInfoData::VT_ENDTIME, endTime, 0);
    }
    #[inline]
    pub fn add_invalidObtainDesc(&mut self, invalidObtainDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeThemeLimitInfoData::VT_INVALIDOBTAINDESC,
            invalidObtainDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_HomeThemeLimitInfoDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_HomeThemeLimitInfoDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_HomeThemeLimitInfoData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_HomeThemeLimitInfoData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_HomeThemeLimitInfoData");
        ds.field("startTime", &self.startTime());
        ds.field("endTime", &self.endTime());
        ds.field("invalidObtainDesc", &self.invalidObtainDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_HomeThemeLimitInfoDataT {
    pub startTime: i64,
    pub endTime: i64,
    pub invalidObtainDesc: Option<String>,
}
impl Default for clz_Torappu_HomeThemeLimitInfoDataT {
    fn default() -> Self {
        Self {
            startTime: 0,
            endTime: 0,
            invalidObtainDesc: None,
        }
    }
}
impl clz_Torappu_HomeThemeLimitInfoDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HomeThemeLimitInfoData<'b>> {
        let startTime = self.startTime;
        let endTime = self.endTime;
        let invalidObtainDesc = self
            .invalidObtainDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_HomeThemeLimitInfoData::create(
            _fbb,
            &clz_Torappu_HomeThemeLimitInfoDataArgs {
                startTime,
                endTime,
                invalidObtainDesc,
            },
        )
    }
}
pub enum clz_Torappu_HomeThemeLimitDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_HomeThemeLimitData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_HomeThemeLimitData<'a> {
    type Inner = clz_Torappu_HomeThemeLimitData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_HomeThemeLimitData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_LIMITINFOS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_HomeThemeLimitData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_HomeThemeLimitDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HomeThemeLimitData<'bldr>> {
        let mut builder = clz_Torappu_HomeThemeLimitDataBuilder::new(_fbb);
        if let Some(x) = args.limitInfos {
            builder.add_limitInfos(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_HomeThemeLimitDataT {
        let id = self.id().map(|x| x.to_string());
        let limitInfos = self
            .limitInfos()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_HomeThemeLimitDataT { id, limitInfos }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeThemeLimitData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn limitInfos(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_HomeThemeLimitInfoData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_HomeThemeLimitInfoData>,
                >,
            >>(clz_Torappu_HomeThemeLimitData::VT_LIMITINFOS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_HomeThemeLimitData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_HomeThemeLimitInfoData>,
                >,
            >>("limitInfos", Self::VT_LIMITINFOS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_HomeThemeLimitDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub limitInfos: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_HomeThemeLimitInfoData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_HomeThemeLimitDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_HomeThemeLimitDataArgs {
            id: None,
            limitInfos: None,
        }
    }
}

impl Serialize for clz_Torappu_HomeThemeLimitData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_HomeThemeLimitData", 2)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.limitInfos() {
            s.serialize_field("limitInfos", &f)?;
        } else {
            s.skip_field("limitInfos")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_HomeThemeLimitDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_HomeThemeLimitDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeThemeLimitData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_limitInfos(
        &mut self,
        limitInfos: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_HomeThemeLimitInfoData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeThemeLimitData::VT_LIMITINFOS,
            limitInfos,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_HomeThemeLimitDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_HomeThemeLimitDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_HomeThemeLimitData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_HomeThemeLimitData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_HomeThemeLimitData");
        ds.field("id", &self.id());
        ds.field("limitInfos", &self.limitInfos());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_HomeThemeLimitDataT {
    pub id: Option<String>,
    pub limitInfos: Option<Vec<clz_Torappu_HomeThemeLimitInfoDataT>>,
}
impl Default for clz_Torappu_HomeThemeLimitDataT {
    fn default() -> Self {
        Self {
            id: None,
            limitInfos: None,
        }
    }
}
impl clz_Torappu_HomeThemeLimitDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HomeThemeLimitData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let limitInfos = self.limitInfos.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_HomeThemeLimitData::create(
            _fbb,
            &clz_Torappu_HomeThemeLimitDataArgs { id, limitInfos },
        )
    }
}
pub enum dict__string__clz_Torappu_HomeThemeLimitDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_HomeThemeLimitData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_HomeThemeLimitData<'a> {
    type Inner = dict__string__clz_Torappu_HomeThemeLimitData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_HomeThemeLimitData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_HomeThemeLimitData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_HomeThemeLimitDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_HomeThemeLimitData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_HomeThemeLimitDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_HomeThemeLimitDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_HomeThemeLimitDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_HomeThemeLimitData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_HomeThemeLimitData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_HomeThemeLimitData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_HomeThemeLimitData>>(
                    dict__string__clz_Torappu_HomeThemeLimitData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_HomeThemeLimitData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_HomeThemeLimitData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_HomeThemeLimitDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_HomeThemeLimitData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_HomeThemeLimitDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_HomeThemeLimitDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_HomeThemeLimitData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_HomeThemeLimitData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_HomeThemeLimitDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_HomeThemeLimitDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_HomeThemeLimitData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_HomeThemeLimitData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_HomeThemeLimitData>>(
                dict__string__clz_Torappu_HomeThemeLimitData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_HomeThemeLimitDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_HomeThemeLimitDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_HomeThemeLimitData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_HomeThemeLimitData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_HomeThemeLimitData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_HomeThemeLimitData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_HomeThemeLimitDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_HomeThemeLimitDataT>>,
}
impl Default for dict__string__clz_Torappu_HomeThemeLimitDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_HomeThemeLimitDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_HomeThemeLimitData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_HomeThemeLimitData::create(
            _fbb,
            &dict__string__clz_Torappu_HomeThemeLimitDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_HomeMultiFormInfoDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_HomeMultiFormInfoData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_HomeMultiFormInfoData<'a> {
    type Inner = clz_Torappu_HomeMultiFormInfoData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_HomeMultiFormInfoData<'a> {
    pub const VT_CHANGERULE: flatbuffers::VOffsetT = 4;
    pub const VT_BGDESC: flatbuffers::VOffsetT = 6;
    pub const VT_TMDESC: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_HomeMultiFormInfoData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_HomeMultiFormInfoDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HomeMultiFormInfoData<'bldr>> {
        let mut builder = clz_Torappu_HomeMultiFormInfoDataBuilder::new(_fbb);
        if let Some(x) = args.tmDesc {
            builder.add_tmDesc(x);
        }
        if let Some(x) = args.bgDesc {
            builder.add_bgDesc(x);
        }
        builder.add_changeRule(args.changeRule);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_HomeMultiFormInfoDataT {
        let changeRule = self.changeRule();
        let bgDesc = self.bgDesc().map(|x| x.to_string());
        let tmDesc = self.tmDesc().map(|x| x.to_string());
        clz_Torappu_HomeMultiFormInfoDataT {
            changeRule,
            bgDesc,
            tmDesc,
        }
    }

    #[inline]
    pub fn changeRule(&self) -> enum__Torappu_HomeMultiFormChangeRule {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_HomeMultiFormChangeRule>(
                    clz_Torappu_HomeMultiFormInfoData::VT_CHANGERULE,
                    Some(enum__Torappu_HomeMultiFormChangeRule::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn bgDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeMultiFormInfoData::VT_BGDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn tmDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeMultiFormInfoData::VT_TMDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_HomeMultiFormInfoData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_HomeMultiFormChangeRule>(
                "changeRule",
                Self::VT_CHANGERULE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bgDesc", Self::VT_BGDESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tmDesc", Self::VT_TMDESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_HomeMultiFormInfoDataArgs<'a> {
    pub changeRule: enum__Torappu_HomeMultiFormChangeRule,
    pub bgDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tmDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_HomeMultiFormInfoDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_HomeMultiFormInfoDataArgs {
            changeRule: enum__Torappu_HomeMultiFormChangeRule::NONE,
            bgDesc: None,
            tmDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_HomeMultiFormInfoData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_HomeMultiFormInfoData", 3)?;
        s.serialize_field("changeRule", &self.changeRule())?;
        if let Some(f) = self.bgDesc() {
            s.serialize_field("bgDesc", &f)?;
        } else {
            s.skip_field("bgDesc")?;
        }
        if let Some(f) = self.tmDesc() {
            s.serialize_field("tmDesc", &f)?;
        } else {
            s.skip_field("tmDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_HomeMultiFormInfoDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_HomeMultiFormInfoDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_changeRule(&mut self, changeRule: enum__Torappu_HomeMultiFormChangeRule) {
        self.fbb_
            .push_slot::<enum__Torappu_HomeMultiFormChangeRule>(
                clz_Torappu_HomeMultiFormInfoData::VT_CHANGERULE,
                changeRule,
                enum__Torappu_HomeMultiFormChangeRule::NONE,
            );
    }
    #[inline]
    pub fn add_bgDesc(&mut self, bgDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeMultiFormInfoData::VT_BGDESC,
            bgDesc,
        );
    }
    #[inline]
    pub fn add_tmDesc(&mut self, tmDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeMultiFormInfoData::VT_TMDESC,
            tmDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_HomeMultiFormInfoDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_HomeMultiFormInfoDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_HomeMultiFormInfoData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_HomeMultiFormInfoData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_HomeMultiFormInfoData");
        ds.field("changeRule", &self.changeRule());
        ds.field("bgDesc", &self.bgDesc());
        ds.field("tmDesc", &self.tmDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_HomeMultiFormInfoDataT {
    pub changeRule: enum__Torappu_HomeMultiFormChangeRule,
    pub bgDesc: Option<String>,
    pub tmDesc: Option<String>,
}
impl Default for clz_Torappu_HomeMultiFormInfoDataT {
    fn default() -> Self {
        Self {
            changeRule: enum__Torappu_HomeMultiFormChangeRule::NONE,
            bgDesc: None,
            tmDesc: None,
        }
    }
}
impl clz_Torappu_HomeMultiFormInfoDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HomeMultiFormInfoData<'b>> {
        let changeRule = self.changeRule;
        let bgDesc = self.bgDesc.as_ref().map(|x| _fbb.create_string(x));
        let tmDesc = self.tmDesc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_HomeMultiFormInfoData::create(
            _fbb,
            &clz_Torappu_HomeMultiFormInfoDataArgs {
                changeRule,
                bgDesc,
                tmDesc,
            },
        )
    }
}
pub enum clz_Torappu_HomeMultiFormTimeRuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_HomeMultiFormTimeRuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_HomeMultiFormTimeRuleData<'a> {
    type Inner = clz_Torappu_HomeMultiFormTimeRuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_HomeMultiFormTimeRuleData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_STARTHOUR: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_HomeMultiFormTimeRuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_HomeMultiFormTimeRuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HomeMultiFormTimeRuleData<'bldr>> {
        let mut builder = clz_Torappu_HomeMultiFormTimeRuleDataBuilder::new(_fbb);
        builder.add_startHour(args.startHour);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_HomeMultiFormTimeRuleDataT {
        let id = self.id().map(|x| x.to_string());
        let startHour = self.startHour();
        clz_Torappu_HomeMultiFormTimeRuleDataT { id, startHour }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeMultiFormTimeRuleData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn startHour(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_HomeMultiFormTimeRuleData::VT_STARTHOUR, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_HomeMultiFormTimeRuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("startHour", Self::VT_STARTHOUR, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_HomeMultiFormTimeRuleDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub startHour: i32,
}
impl<'a> Default for clz_Torappu_HomeMultiFormTimeRuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_HomeMultiFormTimeRuleDataArgs {
            id: None,
            startHour: 0,
        }
    }
}

impl Serialize for clz_Torappu_HomeMultiFormTimeRuleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_HomeMultiFormTimeRuleData", 2)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("startHour", &self.startHour())?;
        s.end()
    }
}

pub struct clz_Torappu_HomeMultiFormTimeRuleDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_HomeMultiFormTimeRuleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeMultiFormTimeRuleData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_startHour(&mut self, startHour: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_HomeMultiFormTimeRuleData::VT_STARTHOUR,
            startHour,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_HomeMultiFormTimeRuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_HomeMultiFormTimeRuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_HomeMultiFormTimeRuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_HomeMultiFormTimeRuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_HomeMultiFormTimeRuleData");
        ds.field("id", &self.id());
        ds.field("startHour", &self.startHour());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_HomeMultiFormTimeRuleDataT {
    pub id: Option<String>,
    pub startHour: i32,
}
impl Default for clz_Torappu_HomeMultiFormTimeRuleDataT {
    fn default() -> Self {
        Self {
            id: None,
            startHour: 0,
        }
    }
}
impl clz_Torappu_HomeMultiFormTimeRuleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HomeMultiFormTimeRuleData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let startHour = self.startHour;
        clz_Torappu_HomeMultiFormTimeRuleData::create(
            _fbb,
            &clz_Torappu_HomeMultiFormTimeRuleDataArgs { id, startHour },
        )
    }
}
pub enum dict__string__list_clz_Torappu_HomeMultiFormTimeRuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData<'a> {
    type Inner = dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_clz_Torappu_HomeMultiFormTimeRuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData<'bldr>>
    {
        let mut builder =
            dict__string__list_clz_Torappu_HomeMultiFormTimeRuleDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__list_clz_Torappu_HomeMultiFormTimeRuleDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| x.iter().map(|t| t.unpack()).collect());
        dict__string__list_clz_Torappu_HomeMultiFormTimeRuleDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_HomeMultiFormTimeRuleData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_HomeMultiFormTimeRuleData>,
                >,
            >>(
                dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_HomeMultiFormTimeRuleData>,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_clz_Torappu_HomeMultiFormTimeRuleDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_HomeMultiFormTimeRuleData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for dict__string__list_clz_Torappu_HomeMultiFormTimeRuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__list_clz_Torappu_HomeMultiFormTimeRuleDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__list_clz_Torappu_HomeMultiFormTimeRuleDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__list_clz_Torappu_HomeMultiFormTimeRuleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_HomeMultiFormTimeRuleData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__list_clz_Torappu_HomeMultiFormTimeRuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__list_clz_Torappu_HomeMultiFormTimeRuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__list_clz_Torappu_HomeMultiFormTimeRuleDataT {
    pub key: String,
    pub value: Option<Vec<clz_Torappu_HomeMultiFormTimeRuleDataT>>,
}
impl Default for dict__string__list_clz_Torappu_HomeMultiFormTimeRuleDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__list_clz_Torappu_HomeMultiFormTimeRuleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData::create(
            _fbb,
            &dict__string__list_clz_Torappu_HomeMultiFormTimeRuleDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_HomeBackgroundDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_HomeBackgroundData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_HomeBackgroundData<'a> {
    type Inner = clz_Torappu_HomeBackgroundData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_HomeBackgroundData<'a> {
    pub const VT_DEFAULTBACKGROUNDID: flatbuffers::VOffsetT = 4;
    pub const VT_DEFAULTTHEMEID: flatbuffers::VOffsetT = 6;
    pub const VT_HOMEBGDATALIST: flatbuffers::VOffsetT = 8;
    pub const VT_THEMELIST: flatbuffers::VOffsetT = 10;
    pub const VT_BACKGROUNDLIMITDATA: flatbuffers::VOffsetT = 12;
    pub const VT_THEMELIMITDATA: flatbuffers::VOffsetT = 14;
    pub const VT_MULTIFORMINFODATA: flatbuffers::VOffsetT = 16;
    pub const VT_TIMERULEDATA: flatbuffers::VOffsetT = 18;
    pub const VT_DEFAULTBGMUSICID: flatbuffers::VOffsetT = 20;
    pub const VT_THEMESTARTTIME: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_HomeBackgroundData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_HomeBackgroundDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HomeBackgroundData<'bldr>> {
        let mut builder = clz_Torappu_HomeBackgroundDataBuilder::new(_fbb);
        builder.add_themeStartTime(args.themeStartTime);
        if let Some(x) = args.defaultBgMusicId {
            builder.add_defaultBgMusicId(x);
        }
        if let Some(x) = args.timeRuleData {
            builder.add_timeRuleData(x);
        }
        if let Some(x) = args.multiFormInfoData {
            builder.add_multiFormInfoData(x);
        }
        if let Some(x) = args.themeLimitData {
            builder.add_themeLimitData(x);
        }
        if let Some(x) = args.backgroundLimitData {
            builder.add_backgroundLimitData(x);
        }
        if let Some(x) = args.themeList {
            builder.add_themeList(x);
        }
        if let Some(x) = args.homeBgDataList {
            builder.add_homeBgDataList(x);
        }
        if let Some(x) = args.defaultThemeId {
            builder.add_defaultThemeId(x);
        }
        if let Some(x) = args.defaultBackgroundId {
            builder.add_defaultBackgroundId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_HomeBackgroundDataT {
        let defaultBackgroundId = self.defaultBackgroundId().map(|x| x.to_string());
        let defaultThemeId = self.defaultThemeId().map(|x| x.to_string());
        let homeBgDataList = self
            .homeBgDataList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let themeList = self
            .themeList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let backgroundLimitData = self
            .backgroundLimitData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let themeLimitData = self
            .themeLimitData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let multiFormInfoData = self
            .multiFormInfoData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let timeRuleData = self
            .timeRuleData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let defaultBgMusicId = self.defaultBgMusicId().map(|x| x.to_string());
        let themeStartTime = self.themeStartTime();
        clz_Torappu_HomeBackgroundDataT {
            defaultBackgroundId,
            defaultThemeId,
            homeBgDataList,
            themeList,
            backgroundLimitData,
            themeLimitData,
            multiFormInfoData,
            timeRuleData,
            defaultBgMusicId,
            themeStartTime,
        }
    }

    #[inline]
    pub fn defaultBackgroundId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeBackgroundData::VT_DEFAULTBACKGROUNDID,
                None,
            )
        }
    }
    #[inline]
    pub fn defaultThemeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeBackgroundData::VT_DEFAULTTHEMEID,
                None,
            )
        }
    }
    #[inline]
    pub fn homeBgDataList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_HomeBackgroundSingleData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_HomeBackgroundSingleData>,
                >,
            >>(clz_Torappu_HomeBackgroundData::VT_HOMEBGDATALIST, None)
        }
    }
    #[inline]
    pub fn themeList(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_HomeThemeDisplayData<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_HomeThemeDisplayData>,
                >,
            >>(clz_Torappu_HomeBackgroundData::VT_THEMELIST, None)
        }
    }
    #[inline]
    pub fn backgroundLimitData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_HomeBackgroundLimitData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_HomeBackgroundLimitData>,
                >,
            >>(clz_Torappu_HomeBackgroundData::VT_BACKGROUNDLIMITDATA, None)
        }
    }
    #[inline]
    pub fn themeLimitData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_HomeThemeLimitData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_HomeThemeLimitData>,
                >,
            >>(clz_Torappu_HomeBackgroundData::VT_THEMELIMITDATA, None)
        }
    }
    #[inline]
    pub fn multiFormInfoData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_HomeMultiFormInfoData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_HomeMultiFormInfoData>,
                >,
            >>(clz_Torappu_HomeBackgroundData::VT_MULTIFORMINFODATA, None)
        }
    }
    #[inline]
    pub fn timeRuleData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData,
                    >,
                >,
            >>(clz_Torappu_HomeBackgroundData::VT_TIMERULEDATA, None)
        }
    }
    #[inline]
    pub fn defaultBgMusicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HomeBackgroundData::VT_DEFAULTBGMUSICID,
                None,
            )
        }
    }
    #[inline]
    pub fn themeStartTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_HomeBackgroundData::VT_THEMESTARTTIME, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_HomeBackgroundData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "defaultBackgroundId",
                Self::VT_DEFAULTBACKGROUNDID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "defaultThemeId",
                Self::VT_DEFAULTTHEMEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_HomeBackgroundSingleData>,
                >,
            >>("homeBgDataList", Self::VT_HOMEBGDATALIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_HomeThemeDisplayData>,
                >,
            >>("themeList", Self::VT_THEMELIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_HomeBackgroundLimitData>,
                >,
            >>("backgroundLimitData", Self::VT_BACKGROUNDLIMITDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_HomeThemeLimitData>,
                >,
            >>("themeLimitData", Self::VT_THEMELIMITDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_HomeMultiFormInfoData>,
                >,
            >>("multiFormInfoData", Self::VT_MULTIFORMINFODATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData,
                    >,
                >,
            >>("timeRuleData", Self::VT_TIMERULEDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "defaultBgMusicId",
                Self::VT_DEFAULTBGMUSICID,
                false,
            )?
            .visit_field::<i64>("themeStartTime", Self::VT_THEMESTARTTIME, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_HomeBackgroundDataArgs<'a> {
    pub defaultBackgroundId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub defaultThemeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub homeBgDataList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_HomeBackgroundSingleData<'a>>,
            >,
        >,
    >,
    pub themeList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_HomeThemeDisplayData<'a>>,
            >,
        >,
    >,
    pub backgroundLimitData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_HomeBackgroundLimitData<'a>>,
            >,
        >,
    >,
    pub themeLimitData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_HomeThemeLimitData<'a>>,
            >,
        >,
    >,
    pub multiFormInfoData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_HomeMultiFormInfoData<'a>>,
            >,
        >,
    >,
    pub timeRuleData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData<'a>,
                >,
            >,
        >,
    >,
    pub defaultBgMusicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub themeStartTime: i64,
}
impl<'a> Default for clz_Torappu_HomeBackgroundDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_HomeBackgroundDataArgs {
            defaultBackgroundId: None,
            defaultThemeId: None,
            homeBgDataList: None,
            themeList: None,
            backgroundLimitData: None,
            themeLimitData: None,
            multiFormInfoData: None,
            timeRuleData: None,
            defaultBgMusicId: None,
            themeStartTime: 0,
        }
    }
}

impl Serialize for clz_Torappu_HomeBackgroundData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_HomeBackgroundData", 10)?;
        if let Some(f) = self.defaultBackgroundId() {
            s.serialize_field("defaultBackgroundId", &f)?;
        } else {
            s.skip_field("defaultBackgroundId")?;
        }
        if let Some(f) = self.defaultThemeId() {
            s.serialize_field("defaultThemeId", &f)?;
        } else {
            s.skip_field("defaultThemeId")?;
        }
        if let Some(f) = self.homeBgDataList() {
            s.serialize_field("homeBgDataList", &f)?;
        } else {
            s.skip_field("homeBgDataList")?;
        }
        if let Some(f) = self.themeList() {
            s.serialize_field("themeList", &f)?;
        } else {
            s.skip_field("themeList")?;
        }
        if let Some(f) = self.backgroundLimitData() {
            s.serialize_field("backgroundLimitData", &f)?;
        } else {
            s.skip_field("backgroundLimitData")?;
        }
        if let Some(f) = self.themeLimitData() {
            s.serialize_field("themeLimitData", &f)?;
        } else {
            s.skip_field("themeLimitData")?;
        }
        if let Some(f) = self.multiFormInfoData() {
            s.serialize_field("multiFormInfoData", &f)?;
        } else {
            s.skip_field("multiFormInfoData")?;
        }
        if let Some(f) = self.timeRuleData() {
            s.serialize_field("timeRuleData", &f)?;
        } else {
            s.skip_field("timeRuleData")?;
        }
        if let Some(f) = self.defaultBgMusicId() {
            s.serialize_field("defaultBgMusicId", &f)?;
        } else {
            s.skip_field("defaultBgMusicId")?;
        }
        s.serialize_field("themeStartTime", &self.themeStartTime())?;
        s.end()
    }
}

pub struct clz_Torappu_HomeBackgroundDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_HomeBackgroundDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_defaultBackgroundId(
        &mut self,
        defaultBackgroundId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeBackgroundData::VT_DEFAULTBACKGROUNDID,
            defaultBackgroundId,
        );
    }
    #[inline]
    pub fn add_defaultThemeId(&mut self, defaultThemeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeBackgroundData::VT_DEFAULTTHEMEID,
            defaultThemeId,
        );
    }
    #[inline]
    pub fn add_homeBgDataList(
        &mut self,
        homeBgDataList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_HomeBackgroundSingleData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeBackgroundData::VT_HOMEBGDATALIST,
            homeBgDataList,
        );
    }
    #[inline]
    pub fn add_themeList(
        &mut self,
        themeList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_HomeThemeDisplayData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeBackgroundData::VT_THEMELIST,
            themeList,
        );
    }
    #[inline]
    pub fn add_backgroundLimitData(
        &mut self,
        backgroundLimitData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_HomeBackgroundLimitData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeBackgroundData::VT_BACKGROUNDLIMITDATA,
            backgroundLimitData,
        );
    }
    #[inline]
    pub fn add_themeLimitData(
        &mut self,
        themeLimitData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_HomeThemeLimitData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeBackgroundData::VT_THEMELIMITDATA,
            themeLimitData,
        );
    }
    #[inline]
    pub fn add_multiFormInfoData(
        &mut self,
        multiFormInfoData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_HomeMultiFormInfoData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeBackgroundData::VT_MULTIFORMINFODATA,
            multiFormInfoData,
        );
    }
    #[inline]
    pub fn add_timeRuleData(
        &mut self,
        timeRuleData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_clz_Torappu_HomeMultiFormTimeRuleData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeBackgroundData::VT_TIMERULEDATA,
            timeRuleData,
        );
    }
    #[inline]
    pub fn add_defaultBgMusicId(&mut self, defaultBgMusicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HomeBackgroundData::VT_DEFAULTBGMUSICID,
            defaultBgMusicId,
        );
    }
    #[inline]
    pub fn add_themeStartTime(&mut self, themeStartTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_HomeBackgroundData::VT_THEMESTARTTIME,
            themeStartTime,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_HomeBackgroundDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_HomeBackgroundDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_HomeBackgroundData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_HomeBackgroundData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_HomeBackgroundData");
        ds.field("defaultBackgroundId", &self.defaultBackgroundId());
        ds.field("defaultThemeId", &self.defaultThemeId());
        ds.field("homeBgDataList", &self.homeBgDataList());
        ds.field("themeList", &self.themeList());
        ds.field("backgroundLimitData", &self.backgroundLimitData());
        ds.field("themeLimitData", &self.themeLimitData());
        ds.field("multiFormInfoData", &self.multiFormInfoData());
        ds.field("timeRuleData", &self.timeRuleData());
        ds.field("defaultBgMusicId", &self.defaultBgMusicId());
        ds.field("themeStartTime", &self.themeStartTime());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_HomeBackgroundDataT {
    pub defaultBackgroundId: Option<String>,
    pub defaultThemeId: Option<String>,
    pub homeBgDataList: Option<Vec<clz_Torappu_HomeBackgroundSingleDataT>>,
    pub themeList: Option<Vec<clz_Torappu_HomeThemeDisplayDataT>>,
    pub backgroundLimitData: Option<Vec<dict__string__clz_Torappu_HomeBackgroundLimitDataT>>,
    pub themeLimitData: Option<Vec<dict__string__clz_Torappu_HomeThemeLimitDataT>>,
    pub multiFormInfoData: Option<Vec<clz_Torappu_HomeMultiFormInfoDataT>>,
    pub timeRuleData: Option<Vec<dict__string__list_clz_Torappu_HomeMultiFormTimeRuleDataT>>,
    pub defaultBgMusicId: Option<String>,
    pub themeStartTime: i64,
}
impl Default for clz_Torappu_HomeBackgroundDataT {
    fn default() -> Self {
        Self {
            defaultBackgroundId: None,
            defaultThemeId: None,
            homeBgDataList: None,
            themeList: None,
            backgroundLimitData: None,
            themeLimitData: None,
            multiFormInfoData: None,
            timeRuleData: None,
            defaultBgMusicId: None,
            themeStartTime: 0,
        }
    }
}
impl clz_Torappu_HomeBackgroundDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HomeBackgroundData<'b>> {
        let defaultBackgroundId = self
            .defaultBackgroundId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let defaultThemeId = self.defaultThemeId.as_ref().map(|x| _fbb.create_string(x));
        let homeBgDataList = self.homeBgDataList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let themeList = self.themeList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let backgroundLimitData = self.backgroundLimitData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let themeLimitData = self.themeLimitData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let multiFormInfoData = self.multiFormInfoData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let timeRuleData = self.timeRuleData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let defaultBgMusicId = self
            .defaultBgMusicId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let themeStartTime = self.themeStartTime;
        clz_Torappu_HomeBackgroundData::create(
            _fbb,
            &clz_Torappu_HomeBackgroundDataArgs {
                defaultBackgroundId,
                defaultThemeId,
                homeBgDataList,
                themeList,
                backgroundLimitData,
                themeLimitData,
                multiFormInfoData,
                timeRuleData,
                defaultBgMusicId,
                themeStartTime,
            },
        )
    }
}
pub enum clz_Torappu_NameCardV2ModuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_NameCardV2ModuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_NameCardV2ModuleData<'a> {
    type Inner = clz_Torappu_NameCardV2ModuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_NameCardV2ModuleData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_NameCardV2ModuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_NameCardV2ModuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_NameCardV2ModuleData<'bldr>> {
        let mut builder = clz_Torappu_NameCardV2ModuleDataBuilder::new(_fbb);
        builder.add_type_(args.type_);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_NameCardV2ModuleDataT {
        let id = self.id().map(|x| x.to_string());
        let type_ = self.type_();
        clz_Torappu_NameCardV2ModuleDataT { id, type_ }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_NameCardV2ModuleData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_NameCardV2ModuleType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_NameCardV2ModuleType>(
                    clz_Torappu_NameCardV2ModuleData::VT_TYPE_,
                    Some(enum__Torappu_NameCardV2ModuleType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_NameCardV2ModuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_NameCardV2ModuleType>("type_", Self::VT_TYPE_, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_NameCardV2ModuleDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_NameCardV2ModuleType,
}
impl<'a> Default for clz_Torappu_NameCardV2ModuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_NameCardV2ModuleDataArgs {
            id: None,
            type_: enum__Torappu_NameCardV2ModuleType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_NameCardV2ModuleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_NameCardV2ModuleData", 2)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("type_", &self.type_())?;
        s.end()
    }
}

pub struct clz_Torappu_NameCardV2ModuleDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_NameCardV2ModuleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_NameCardV2ModuleData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_NameCardV2ModuleType) {
        self.fbb_.push_slot::<enum__Torappu_NameCardV2ModuleType>(
            clz_Torappu_NameCardV2ModuleData::VT_TYPE_,
            type_,
            enum__Torappu_NameCardV2ModuleType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_NameCardV2ModuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_NameCardV2ModuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_NameCardV2ModuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_NameCardV2ModuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_NameCardV2ModuleData");
        ds.field("id", &self.id());
        ds.field("type_", &self.type_());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_NameCardV2ModuleDataT {
    pub id: Option<String>,
    pub type_: enum__Torappu_NameCardV2ModuleType,
}
impl Default for clz_Torappu_NameCardV2ModuleDataT {
    fn default() -> Self {
        Self {
            id: None,
            type_: enum__Torappu_NameCardV2ModuleType::NONE,
        }
    }
}
impl clz_Torappu_NameCardV2ModuleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_NameCardV2ModuleData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        clz_Torappu_NameCardV2ModuleData::create(
            _fbb,
            &clz_Torappu_NameCardV2ModuleDataArgs { id, type_ },
        )
    }
}
pub enum dict__string__clz_Torappu_NameCardV2ModuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_NameCardV2ModuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_NameCardV2ModuleData<'a> {
    type Inner = dict__string__clz_Torappu_NameCardV2ModuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_NameCardV2ModuleData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_NameCardV2ModuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_NameCardV2ModuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_NameCardV2ModuleData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_NameCardV2ModuleDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_NameCardV2ModuleDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_NameCardV2ModuleDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_NameCardV2ModuleData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_NameCardV2ModuleData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_NameCardV2ModuleData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_NameCardV2ModuleData>>(
                    dict__string__clz_Torappu_NameCardV2ModuleData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_NameCardV2ModuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_NameCardV2ModuleData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_NameCardV2ModuleDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_NameCardV2ModuleData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_NameCardV2ModuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_NameCardV2ModuleDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_NameCardV2ModuleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_NameCardV2ModuleData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_NameCardV2ModuleDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_NameCardV2ModuleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_NameCardV2ModuleData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_NameCardV2ModuleData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_NameCardV2ModuleData>>(
                dict__string__clz_Torappu_NameCardV2ModuleData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_NameCardV2ModuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_NameCardV2ModuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_NameCardV2ModuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_NameCardV2ModuleData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_NameCardV2ModuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_NameCardV2ModuleData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_NameCardV2ModuleDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_NameCardV2ModuleDataT>>,
}
impl Default for dict__string__clz_Torappu_NameCardV2ModuleDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_NameCardV2ModuleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_NameCardV2ModuleData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_NameCardV2ModuleData::create(
            _fbb,
            &dict__string__clz_Torappu_NameCardV2ModuleDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_NameCardV2RemovableModuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_NameCardV2RemovableModuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_NameCardV2RemovableModuleData<'a> {
    type Inner = clz_Torappu_NameCardV2RemovableModuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_NameCardV2RemovableModuleData<'a> {
    pub const VT_SORTID: flatbuffers::VOffsetT = 4;
    pub const VT_SUBTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_NAME: flatbuffers::VOffsetT = 8;
    pub const VT_ID: flatbuffers::VOffsetT = 10;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_NameCardV2RemovableModuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_NameCardV2RemovableModuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_NameCardV2RemovableModuleData<'bldr>> {
        let mut builder = clz_Torappu_NameCardV2RemovableModuleDataBuilder::new(_fbb);
        builder.add_type_(args.type_);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_subType(args.subType);
        builder.add_sortId(args.sortId);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_NameCardV2RemovableModuleDataT {
        let sortId = self.sortId();
        let subType = self.subType();
        let name = self.name().map(|x| x.to_string());
        let id = self.id().map(|x| x.to_string());
        let type_ = self.type_();
        clz_Torappu_NameCardV2RemovableModuleDataT {
            sortId,
            subType,
            name,
            id,
            type_,
        }
    }

    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_NameCardV2RemovableModuleData::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn subType(&self) -> enum__Torappu_NameCardV2ModuleSubType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_NameCardV2ModuleSubType>(
                    clz_Torappu_NameCardV2RemovableModuleData::VT_SUBTYPE,
                    Some(enum__Torappu_NameCardV2ModuleSubType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_NameCardV2RemovableModuleData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_NameCardV2RemovableModuleData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_NameCardV2ModuleType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_NameCardV2ModuleType>(
                    clz_Torappu_NameCardV2RemovableModuleData::VT_TYPE_,
                    Some(enum__Torappu_NameCardV2ModuleType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_NameCardV2RemovableModuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<enum__Torappu_NameCardV2ModuleSubType>(
                "subType",
                Self::VT_SUBTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_NameCardV2ModuleType>("type_", Self::VT_TYPE_, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_NameCardV2RemovableModuleDataArgs<'a> {
    pub sortId: i32,
    pub subType: enum__Torappu_NameCardV2ModuleSubType,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_NameCardV2ModuleType,
}
impl<'a> Default for clz_Torappu_NameCardV2RemovableModuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_NameCardV2RemovableModuleDataArgs {
            sortId: 0,
            subType: enum__Torappu_NameCardV2ModuleSubType::NONE,
            name: None,
            id: None,
            type_: enum__Torappu_NameCardV2ModuleType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_NameCardV2RemovableModuleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_NameCardV2RemovableModuleData", 5)?;
        s.serialize_field("sortId", &self.sortId())?;
        s.serialize_field("subType", &self.subType())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("type_", &self.type_())?;
        s.end()
    }
}

pub struct clz_Torappu_NameCardV2RemovableModuleDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_NameCardV2RemovableModuleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_NameCardV2RemovableModuleData::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn add_subType(&mut self, subType: enum__Torappu_NameCardV2ModuleSubType) {
        self.fbb_
            .push_slot::<enum__Torappu_NameCardV2ModuleSubType>(
                clz_Torappu_NameCardV2RemovableModuleData::VT_SUBTYPE,
                subType,
                enum__Torappu_NameCardV2ModuleSubType::NONE,
            );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_NameCardV2RemovableModuleData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_NameCardV2RemovableModuleData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_NameCardV2ModuleType) {
        self.fbb_.push_slot::<enum__Torappu_NameCardV2ModuleType>(
            clz_Torappu_NameCardV2RemovableModuleData::VT_TYPE_,
            type_,
            enum__Torappu_NameCardV2ModuleType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_NameCardV2RemovableModuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_NameCardV2RemovableModuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_NameCardV2RemovableModuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_NameCardV2RemovableModuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_NameCardV2RemovableModuleData");
        ds.field("sortId", &self.sortId());
        ds.field("subType", &self.subType());
        ds.field("name", &self.name());
        ds.field("id", &self.id());
        ds.field("type_", &self.type_());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_NameCardV2RemovableModuleDataT {
    pub sortId: i32,
    pub subType: enum__Torappu_NameCardV2ModuleSubType,
    pub name: Option<String>,
    pub id: Option<String>,
    pub type_: enum__Torappu_NameCardV2ModuleType,
}
impl Default for clz_Torappu_NameCardV2RemovableModuleDataT {
    fn default() -> Self {
        Self {
            sortId: 0,
            subType: enum__Torappu_NameCardV2ModuleSubType::NONE,
            name: None,
            id: None,
            type_: enum__Torappu_NameCardV2ModuleType::NONE,
        }
    }
}
impl clz_Torappu_NameCardV2RemovableModuleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_NameCardV2RemovableModuleData<'b>> {
        let sortId = self.sortId;
        let subType = self.subType;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        clz_Torappu_NameCardV2RemovableModuleData::create(
            _fbb,
            &clz_Torappu_NameCardV2RemovableModuleDataArgs {
                sortId,
                subType,
                name,
                id,
                type_,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_NameCardV2RemovableModuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_NameCardV2RemovableModuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_NameCardV2RemovableModuleData<'a> {
    type Inner = dict__string__clz_Torappu_NameCardV2RemovableModuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_NameCardV2RemovableModuleData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_NameCardV2RemovableModuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_NameCardV2RemovableModuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_NameCardV2RemovableModuleData<'bldr>>
    {
        let mut builder = dict__string__clz_Torappu_NameCardV2RemovableModuleDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_NameCardV2RemovableModuleDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_NameCardV2RemovableModuleDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_NameCardV2RemovableModuleData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_NameCardV2RemovableModuleData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_NameCardV2RemovableModuleData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_NameCardV2RemovableModuleData>>(
                    dict__string__clz_Torappu_NameCardV2RemovableModuleData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_NameCardV2RemovableModuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_NameCardV2RemovableModuleData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_NameCardV2RemovableModuleDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_NameCardV2RemovableModuleData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_NameCardV2RemovableModuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_NameCardV2RemovableModuleDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_NameCardV2RemovableModuleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_NameCardV2RemovableModuleData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_NameCardV2RemovableModuleDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_NameCardV2RemovableModuleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_NameCardV2RemovableModuleData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_NameCardV2RemovableModuleData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_NameCardV2RemovableModuleData>>(
                dict__string__clz_Torappu_NameCardV2RemovableModuleData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_NameCardV2RemovableModuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_NameCardV2RemovableModuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_NameCardV2RemovableModuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_NameCardV2RemovableModuleData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_NameCardV2RemovableModuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_NameCardV2RemovableModuleData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_NameCardV2RemovableModuleDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_NameCardV2RemovableModuleDataT>>,
}
impl Default for dict__string__clz_Torappu_NameCardV2RemovableModuleDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_NameCardV2RemovableModuleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_NameCardV2RemovableModuleData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_NameCardV2RemovableModuleData::create(
            _fbb,
            &dict__string__clz_Torappu_NameCardV2RemovableModuleDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_NameCardV2TimeLimitInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_NameCardV2TimeLimitInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_NameCardV2TimeLimitInfo<'a> {
    type Inner = clz_Torappu_NameCardV2TimeLimitInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_NameCardV2TimeLimitInfo<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_AVAILSTARTTIME: flatbuffers::VOffsetT = 6;
    pub const VT_AVAILENDTIME: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_NameCardV2TimeLimitInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_NameCardV2TimeLimitInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_NameCardV2TimeLimitInfo<'bldr>> {
        let mut builder = clz_Torappu_NameCardV2TimeLimitInfoBuilder::new(_fbb);
        builder.add_availEndTime(args.availEndTime);
        builder.add_availStartTime(args.availStartTime);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_NameCardV2TimeLimitInfoT {
        let id = self.id().map(|x| x.to_string());
        let availStartTime = self.availStartTime();
        let availEndTime = self.availEndTime();
        clz_Torappu_NameCardV2TimeLimitInfoT {
            id,
            availStartTime,
            availEndTime,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_NameCardV2TimeLimitInfo::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn availStartTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_NameCardV2TimeLimitInfo::VT_AVAILSTARTTIME,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn availEndTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_NameCardV2TimeLimitInfo::VT_AVAILENDTIME,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_NameCardV2TimeLimitInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i64>("availStartTime", Self::VT_AVAILSTARTTIME, false)?
            .visit_field::<i64>("availEndTime", Self::VT_AVAILENDTIME, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_NameCardV2TimeLimitInfoArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub availStartTime: i64,
    pub availEndTime: i64,
}
impl<'a> Default for clz_Torappu_NameCardV2TimeLimitInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_NameCardV2TimeLimitInfoArgs {
            id: None,
            availStartTime: 0,
            availEndTime: 0,
        }
    }
}

impl Serialize for clz_Torappu_NameCardV2TimeLimitInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_NameCardV2TimeLimitInfo", 3)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("availStartTime", &self.availStartTime())?;
        s.serialize_field("availEndTime", &self.availEndTime())?;
        s.end()
    }
}

pub struct clz_Torappu_NameCardV2TimeLimitInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_NameCardV2TimeLimitInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_NameCardV2TimeLimitInfo::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_availStartTime(&mut self, availStartTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_NameCardV2TimeLimitInfo::VT_AVAILSTARTTIME,
            availStartTime,
            0,
        );
    }
    #[inline]
    pub fn add_availEndTime(&mut self, availEndTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_NameCardV2TimeLimitInfo::VT_AVAILENDTIME,
            availEndTime,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_NameCardV2TimeLimitInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_NameCardV2TimeLimitInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_NameCardV2TimeLimitInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_NameCardV2TimeLimitInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_NameCardV2TimeLimitInfo");
        ds.field("id", &self.id());
        ds.field("availStartTime", &self.availStartTime());
        ds.field("availEndTime", &self.availEndTime());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_NameCardV2TimeLimitInfoT {
    pub id: Option<String>,
    pub availStartTime: i64,
    pub availEndTime: i64,
}
impl Default for clz_Torappu_NameCardV2TimeLimitInfoT {
    fn default() -> Self {
        Self {
            id: None,
            availStartTime: 0,
            availEndTime: 0,
        }
    }
}
impl clz_Torappu_NameCardV2TimeLimitInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_NameCardV2TimeLimitInfo<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let availStartTime = self.availStartTime;
        let availEndTime = self.availEndTime;
        clz_Torappu_NameCardV2TimeLimitInfo::create(
            _fbb,
            &clz_Torappu_NameCardV2TimeLimitInfoArgs {
                id,
                availStartTime,
                availEndTime,
            },
        )
    }
}
pub enum clz_Torappu_NameCardV2SkinDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_NameCardV2SkinData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_NameCardV2SkinData<'a> {
    type Inner = clz_Torappu_NameCardV2SkinData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_NameCardV2SkinData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;
    pub const VT_SORTID: flatbuffers::VOffsetT = 10;
    pub const VT_ISSPTHEME: flatbuffers::VOffsetT = 12;
    pub const VT_DEFAULTSHOWDETAIL: flatbuffers::VOffsetT = 14;
    pub const VT_THEMENAME: flatbuffers::VOffsetT = 16;
    pub const VT_THEMEENNAME: flatbuffers::VOffsetT = 18;
    pub const VT_SKINSTARTTIME: flatbuffers::VOffsetT = 20;
    pub const VT_SKINDESC: flatbuffers::VOffsetT = 22;
    pub const VT_USAGEDESC: flatbuffers::VOffsetT = 24;
    pub const VT_SKINAPPROACH: flatbuffers::VOffsetT = 26;
    pub const VT_UNLOCKCONDITIONCNT: flatbuffers::VOffsetT = 28;
    pub const VT_UNLOCKDESCLIST: flatbuffers::VOffsetT = 30;
    pub const VT_FIXEDMODULELIST: flatbuffers::VOffsetT = 32;
    pub const VT_RARITY: flatbuffers::VOffsetT = 34;
    pub const VT_SKINTMPLCNT: flatbuffers::VOffsetT = 36;
    pub const VT_CANCHANGETMPL: flatbuffers::VOffsetT = 38;
    pub const VT_ISTIMELIMIT: flatbuffers::VOffsetT = 40;
    pub const VT_TIMELIMITINFOLIST: flatbuffers::VOffsetT = 42;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_NameCardV2SkinData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_NameCardV2SkinDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_NameCardV2SkinData<'bldr>> {
        let mut builder = clz_Torappu_NameCardV2SkinDataBuilder::new(_fbb);
        builder.add_skinStartTime(args.skinStartTime);
        if let Some(x) = args.timeLimitInfoList {
            builder.add_timeLimitInfoList(x);
        }
        builder.add_skinTmplCnt(args.skinTmplCnt);
        builder.add_rarity(args.rarity);
        if let Some(x) = args.fixedModuleList {
            builder.add_fixedModuleList(x);
        }
        if let Some(x) = args.unlockDescList {
            builder.add_unlockDescList(x);
        }
        builder.add_unlockConditionCnt(args.unlockConditionCnt);
        if let Some(x) = args.skinApproach {
            builder.add_skinApproach(x);
        }
        if let Some(x) = args.usageDesc {
            builder.add_usageDesc(x);
        }
        if let Some(x) = args.skinDesc {
            builder.add_skinDesc(x);
        }
        if let Some(x) = args.themeEnName {
            builder.add_themeEnName(x);
        }
        if let Some(x) = args.themeName {
            builder.add_themeName(x);
        }
        builder.add_sortId(args.sortId);
        builder.add_type_(args.type_);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_isTimeLimit(args.isTimeLimit);
        builder.add_canChangeTmpl(args.canChangeTmpl);
        builder.add_defaultShowDetail(args.defaultShowDetail);
        builder.add_isSpTheme(args.isSpTheme);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_NameCardV2SkinDataT {
        let id = self.id().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let type_ = self.type_();
        let sortId = self.sortId();
        let isSpTheme = self.isSpTheme();
        let defaultShowDetail = self.defaultShowDetail();
        let themeName = self.themeName().map(|x| x.to_string());
        let themeEnName = self.themeEnName().map(|x| x.to_string());
        let skinStartTime = self.skinStartTime();
        let skinDesc = self.skinDesc().map(|x| x.to_string());
        let usageDesc = self.usageDesc().map(|x| x.to_string());
        let skinApproach = self.skinApproach().map(|x| x.to_string());
        let unlockConditionCnt = self.unlockConditionCnt();
        let unlockDescList = self
            .unlockDescList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let fixedModuleList = self
            .fixedModuleList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let rarity = self.rarity();
        let skinTmplCnt = self.skinTmplCnt();
        let canChangeTmpl = self.canChangeTmpl();
        let isTimeLimit = self.isTimeLimit();
        let timeLimitInfoList = self
            .timeLimitInfoList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_NameCardV2SkinDataT {
            id,
            name,
            type_,
            sortId,
            isSpTheme,
            defaultShowDetail,
            themeName,
            themeEnName,
            skinStartTime,
            skinDesc,
            usageDesc,
            skinApproach,
            unlockConditionCnt,
            unlockDescList,
            fixedModuleList,
            rarity,
            skinTmplCnt,
            canChangeTmpl,
            isTimeLimit,
            timeLimitInfoList,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_NameCardV2SkinData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_NameCardV2SkinData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_NameCardV2SkinType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_NameCardV2SkinType>(
                    clz_Torappu_NameCardV2SkinData::VT_TYPE_,
                    Some(enum__Torappu_NameCardV2SkinType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_NameCardV2SkinData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn isSpTheme(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_NameCardV2SkinData::VT_ISSPTHEME, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn defaultShowDetail(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_NameCardV2SkinData::VT_DEFAULTSHOWDETAIL,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn themeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_NameCardV2SkinData::VT_THEMENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn themeEnName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_NameCardV2SkinData::VT_THEMEENNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn skinStartTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_NameCardV2SkinData::VT_SKINSTARTTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn skinDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_NameCardV2SkinData::VT_SKINDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn usageDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_NameCardV2SkinData::VT_USAGEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn skinApproach(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_NameCardV2SkinData::VT_SKINAPPROACH,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockConditionCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_NameCardV2SkinData::VT_UNLOCKCONDITIONCNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockDescList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_NameCardV2SkinData::VT_UNLOCKDESCLIST, None)
        }
    }
    #[inline]
    pub fn fixedModuleList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_NameCardV2SkinData::VT_FIXEDMODULELIST, None)
        }
    }
    #[inline]
    pub fn rarity(&self) -> enum__Torappu_ItemRarity {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemRarity>(
                    clz_Torappu_NameCardV2SkinData::VT_RARITY,
                    Some(enum__Torappu_ItemRarity::TIER_1),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn skinTmplCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_NameCardV2SkinData::VT_SKINTMPLCNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn canChangeTmpl(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_NameCardV2SkinData::VT_CANCHANGETMPL,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn isTimeLimit(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_NameCardV2SkinData::VT_ISTIMELIMIT, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn timeLimitInfoList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_NameCardV2TimeLimitInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_NameCardV2TimeLimitInfo>,
                >,
            >>(clz_Torappu_NameCardV2SkinData::VT_TIMELIMITINFOLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_NameCardV2SkinData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<enum__Torappu_NameCardV2SkinType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<bool>("isSpTheme", Self::VT_ISSPTHEME, false)?
            .visit_field::<bool>("defaultShowDetail", Self::VT_DEFAULTSHOWDETAIL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "themeName",
                Self::VT_THEMENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "themeEnName",
                Self::VT_THEMEENNAME,
                false,
            )?
            .visit_field::<i64>("skinStartTime", Self::VT_SKINSTARTTIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "skinDesc",
                Self::VT_SKINDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "usageDesc",
                Self::VT_USAGEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "skinApproach",
                Self::VT_SKINAPPROACH,
                false,
            )?
            .visit_field::<i32>("unlockConditionCnt", Self::VT_UNLOCKCONDITIONCNT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("unlockDescList", Self::VT_UNLOCKDESCLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("fixedModuleList", Self::VT_FIXEDMODULELIST, false)?
            .visit_field::<enum__Torappu_ItemRarity>("rarity", Self::VT_RARITY, false)?
            .visit_field::<i32>("skinTmplCnt", Self::VT_SKINTMPLCNT, false)?
            .visit_field::<bool>("canChangeTmpl", Self::VT_CANCHANGETMPL, false)?
            .visit_field::<bool>("isTimeLimit", Self::VT_ISTIMELIMIT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_NameCardV2TimeLimitInfo>,
                >,
            >>("timeLimitInfoList", Self::VT_TIMELIMITINFOLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_NameCardV2SkinDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_NameCardV2SkinType,
    pub sortId: i32,
    pub isSpTheme: bool,
    pub defaultShowDetail: bool,
    pub themeName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub themeEnName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub skinStartTime: i64,
    pub skinDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub usageDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub skinApproach: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockConditionCnt: i32,
    pub unlockDescList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub fixedModuleList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub rarity: enum__Torappu_ItemRarity,
    pub skinTmplCnt: i32,
    pub canChangeTmpl: bool,
    pub isTimeLimit: bool,
    pub timeLimitInfoList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_NameCardV2TimeLimitInfo<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_NameCardV2SkinDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_NameCardV2SkinDataArgs {
            id: None,
            name: None,
            type_: enum__Torappu_NameCardV2SkinType::NONE,
            sortId: 0,
            isSpTheme: false,
            defaultShowDetail: false,
            themeName: None,
            themeEnName: None,
            skinStartTime: 0,
            skinDesc: None,
            usageDesc: None,
            skinApproach: None,
            unlockConditionCnt: 0,
            unlockDescList: None,
            fixedModuleList: None,
            rarity: enum__Torappu_ItemRarity::TIER_1,
            skinTmplCnt: 0,
            canChangeTmpl: false,
            isTimeLimit: false,
            timeLimitInfoList: None,
        }
    }
}

impl Serialize for clz_Torappu_NameCardV2SkinData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_NameCardV2SkinData", 20)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        s.serialize_field("type_", &self.type_())?;
        s.serialize_field("sortId", &self.sortId())?;
        s.serialize_field("isSpTheme", &self.isSpTheme())?;
        s.serialize_field("defaultShowDetail", &self.defaultShowDetail())?;
        if let Some(f) = self.themeName() {
            s.serialize_field("themeName", &f)?;
        } else {
            s.skip_field("themeName")?;
        }
        if let Some(f) = self.themeEnName() {
            s.serialize_field("themeEnName", &f)?;
        } else {
            s.skip_field("themeEnName")?;
        }
        s.serialize_field("skinStartTime", &self.skinStartTime())?;
        if let Some(f) = self.skinDesc() {
            s.serialize_field("skinDesc", &f)?;
        } else {
            s.skip_field("skinDesc")?;
        }
        if let Some(f) = self.usageDesc() {
            s.serialize_field("usageDesc", &f)?;
        } else {
            s.skip_field("usageDesc")?;
        }
        if let Some(f) = self.skinApproach() {
            s.serialize_field("skinApproach", &f)?;
        } else {
            s.skip_field("skinApproach")?;
        }
        s.serialize_field("unlockConditionCnt", &self.unlockConditionCnt())?;
        if let Some(f) = self.unlockDescList() {
            s.serialize_field("unlockDescList", &f)?;
        } else {
            s.skip_field("unlockDescList")?;
        }
        if let Some(f) = self.fixedModuleList() {
            s.serialize_field("fixedModuleList", &f)?;
        } else {
            s.skip_field("fixedModuleList")?;
        }
        s.serialize_field("rarity", &self.rarity())?;
        s.serialize_field("skinTmplCnt", &self.skinTmplCnt())?;
        s.serialize_field("canChangeTmpl", &self.canChangeTmpl())?;
        s.serialize_field("isTimeLimit", &self.isTimeLimit())?;
        if let Some(f) = self.timeLimitInfoList() {
            s.serialize_field("timeLimitInfoList", &f)?;
        } else {
            s.skip_field("timeLimitInfoList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_NameCardV2SkinDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_NameCardV2SkinDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_NameCardV2SkinData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_NameCardV2SkinData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_NameCardV2SkinType) {
        self.fbb_.push_slot::<enum__Torappu_NameCardV2SkinType>(
            clz_Torappu_NameCardV2SkinData::VT_TYPE_,
            type_,
            enum__Torappu_NameCardV2SkinType::NONE,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_NameCardV2SkinData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_isSpTheme(&mut self, isSpTheme: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_NameCardV2SkinData::VT_ISSPTHEME,
            isSpTheme,
            false,
        );
    }
    #[inline]
    pub fn add_defaultShowDetail(&mut self, defaultShowDetail: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_NameCardV2SkinData::VT_DEFAULTSHOWDETAIL,
            defaultShowDetail,
            false,
        );
    }
    #[inline]
    pub fn add_themeName(&mut self, themeName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_NameCardV2SkinData::VT_THEMENAME,
            themeName,
        );
    }
    #[inline]
    pub fn add_themeEnName(&mut self, themeEnName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_NameCardV2SkinData::VT_THEMEENNAME,
            themeEnName,
        );
    }
    #[inline]
    pub fn add_skinStartTime(&mut self, skinStartTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_NameCardV2SkinData::VT_SKINSTARTTIME,
            skinStartTime,
            0,
        );
    }
    #[inline]
    pub fn add_skinDesc(&mut self, skinDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_NameCardV2SkinData::VT_SKINDESC,
            skinDesc,
        );
    }
    #[inline]
    pub fn add_usageDesc(&mut self, usageDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_NameCardV2SkinData::VT_USAGEDESC,
            usageDesc,
        );
    }
    #[inline]
    pub fn add_skinApproach(&mut self, skinApproach: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_NameCardV2SkinData::VT_SKINAPPROACH,
            skinApproach,
        );
    }
    #[inline]
    pub fn add_unlockConditionCnt(&mut self, unlockConditionCnt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_NameCardV2SkinData::VT_UNLOCKCONDITIONCNT,
            unlockConditionCnt,
            0,
        );
    }
    #[inline]
    pub fn add_unlockDescList(
        &mut self,
        unlockDescList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_NameCardV2SkinData::VT_UNLOCKDESCLIST,
            unlockDescList,
        );
    }
    #[inline]
    pub fn add_fixedModuleList(
        &mut self,
        fixedModuleList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_NameCardV2SkinData::VT_FIXEDMODULELIST,
            fixedModuleList,
        );
    }
    #[inline]
    pub fn add_rarity(&mut self, rarity: enum__Torappu_ItemRarity) {
        self.fbb_.push_slot::<enum__Torappu_ItemRarity>(
            clz_Torappu_NameCardV2SkinData::VT_RARITY,
            rarity,
            enum__Torappu_ItemRarity::TIER_1,
        );
    }
    #[inline]
    pub fn add_skinTmplCnt(&mut self, skinTmplCnt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_NameCardV2SkinData::VT_SKINTMPLCNT,
            skinTmplCnt,
            0,
        );
    }
    #[inline]
    pub fn add_canChangeTmpl(&mut self, canChangeTmpl: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_NameCardV2SkinData::VT_CANCHANGETMPL,
            canChangeTmpl,
            false,
        );
    }
    #[inline]
    pub fn add_isTimeLimit(&mut self, isTimeLimit: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_NameCardV2SkinData::VT_ISTIMELIMIT,
            isTimeLimit,
            false,
        );
    }
    #[inline]
    pub fn add_timeLimitInfoList(
        &mut self,
        timeLimitInfoList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_NameCardV2TimeLimitInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_NameCardV2SkinData::VT_TIMELIMITINFOLIST,
            timeLimitInfoList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_NameCardV2SkinDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_NameCardV2SkinDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_NameCardV2SkinData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_NameCardV2SkinData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_NameCardV2SkinData");
        ds.field("id", &self.id());
        ds.field("name", &self.name());
        ds.field("type_", &self.type_());
        ds.field("sortId", &self.sortId());
        ds.field("isSpTheme", &self.isSpTheme());
        ds.field("defaultShowDetail", &self.defaultShowDetail());
        ds.field("themeName", &self.themeName());
        ds.field("themeEnName", &self.themeEnName());
        ds.field("skinStartTime", &self.skinStartTime());
        ds.field("skinDesc", &self.skinDesc());
        ds.field("usageDesc", &self.usageDesc());
        ds.field("skinApproach", &self.skinApproach());
        ds.field("unlockConditionCnt", &self.unlockConditionCnt());
        ds.field("unlockDescList", &self.unlockDescList());
        ds.field("fixedModuleList", &self.fixedModuleList());
        ds.field("rarity", &self.rarity());
        ds.field("skinTmplCnt", &self.skinTmplCnt());
        ds.field("canChangeTmpl", &self.canChangeTmpl());
        ds.field("isTimeLimit", &self.isTimeLimit());
        ds.field("timeLimitInfoList", &self.timeLimitInfoList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_NameCardV2SkinDataT {
    pub id: Option<String>,
    pub name: Option<String>,
    pub type_: enum__Torappu_NameCardV2SkinType,
    pub sortId: i32,
    pub isSpTheme: bool,
    pub defaultShowDetail: bool,
    pub themeName: Option<String>,
    pub themeEnName: Option<String>,
    pub skinStartTime: i64,
    pub skinDesc: Option<String>,
    pub usageDesc: Option<String>,
    pub skinApproach: Option<String>,
    pub unlockConditionCnt: i32,
    pub unlockDescList: Option<Vec<String>>,
    pub fixedModuleList: Option<Vec<String>>,
    pub rarity: enum__Torappu_ItemRarity,
    pub skinTmplCnt: i32,
    pub canChangeTmpl: bool,
    pub isTimeLimit: bool,
    pub timeLimitInfoList: Option<Vec<clz_Torappu_NameCardV2TimeLimitInfoT>>,
}
impl Default for clz_Torappu_NameCardV2SkinDataT {
    fn default() -> Self {
        Self {
            id: None,
            name: None,
            type_: enum__Torappu_NameCardV2SkinType::NONE,
            sortId: 0,
            isSpTheme: false,
            defaultShowDetail: false,
            themeName: None,
            themeEnName: None,
            skinStartTime: 0,
            skinDesc: None,
            usageDesc: None,
            skinApproach: None,
            unlockConditionCnt: 0,
            unlockDescList: None,
            fixedModuleList: None,
            rarity: enum__Torappu_ItemRarity::TIER_1,
            skinTmplCnt: 0,
            canChangeTmpl: false,
            isTimeLimit: false,
            timeLimitInfoList: None,
        }
    }
}
impl clz_Torappu_NameCardV2SkinDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_NameCardV2SkinData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let sortId = self.sortId;
        let isSpTheme = self.isSpTheme;
        let defaultShowDetail = self.defaultShowDetail;
        let themeName = self.themeName.as_ref().map(|x| _fbb.create_string(x));
        let themeEnName = self.themeEnName.as_ref().map(|x| _fbb.create_string(x));
        let skinStartTime = self.skinStartTime;
        let skinDesc = self.skinDesc.as_ref().map(|x| _fbb.create_string(x));
        let usageDesc = self.usageDesc.as_ref().map(|x| _fbb.create_string(x));
        let skinApproach = self.skinApproach.as_ref().map(|x| _fbb.create_string(x));
        let unlockConditionCnt = self.unlockConditionCnt;
        let unlockDescList = self.unlockDescList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let fixedModuleList = self.fixedModuleList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let rarity = self.rarity;
        let skinTmplCnt = self.skinTmplCnt;
        let canChangeTmpl = self.canChangeTmpl;
        let isTimeLimit = self.isTimeLimit;
        let timeLimitInfoList = self.timeLimitInfoList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_NameCardV2SkinData::create(
            _fbb,
            &clz_Torappu_NameCardV2SkinDataArgs {
                id,
                name,
                type_,
                sortId,
                isSpTheme,
                defaultShowDetail,
                themeName,
                themeEnName,
                skinStartTime,
                skinDesc,
                usageDesc,
                skinApproach,
                unlockConditionCnt,
                unlockDescList,
                fixedModuleList,
                rarity,
                skinTmplCnt,
                canChangeTmpl,
                isTimeLimit,
                timeLimitInfoList,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_NameCardV2SkinDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_NameCardV2SkinData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_NameCardV2SkinData<'a> {
    type Inner = dict__string__clz_Torappu_NameCardV2SkinData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_NameCardV2SkinData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_NameCardV2SkinData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_NameCardV2SkinDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_NameCardV2SkinData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_NameCardV2SkinDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_NameCardV2SkinDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_NameCardV2SkinDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_NameCardV2SkinData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_NameCardV2SkinData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_NameCardV2SkinData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_NameCardV2SkinData>>(
                    dict__string__clz_Torappu_NameCardV2SkinData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_NameCardV2SkinData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_NameCardV2SkinData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_NameCardV2SkinDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_NameCardV2SkinData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_NameCardV2SkinDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_NameCardV2SkinDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_NameCardV2SkinData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_NameCardV2SkinData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_NameCardV2SkinDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_NameCardV2SkinDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_NameCardV2SkinData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_NameCardV2SkinData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_NameCardV2SkinData>>(
                dict__string__clz_Torappu_NameCardV2SkinData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_NameCardV2SkinDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_NameCardV2SkinDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_NameCardV2SkinData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_NameCardV2SkinData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_NameCardV2SkinData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_NameCardV2SkinData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_NameCardV2SkinDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_NameCardV2SkinDataT>>,
}
impl Default for dict__string__clz_Torappu_NameCardV2SkinDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_NameCardV2SkinDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_NameCardV2SkinData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_NameCardV2SkinData::create(
            _fbb,
            &dict__string__clz_Torappu_NameCardV2SkinDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_NameCardV2ConstsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_NameCardV2Consts<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_NameCardV2Consts<'a> {
    type Inner = clz_Torappu_NameCardV2Consts<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_NameCardV2Consts<'a> {
    pub const VT_DEFAULTNAMECARDSKINID: flatbuffers::VOffsetT = 4;
    pub const VT_CANUIDHIDE: flatbuffers::VOffsetT = 6;
    pub const VT_REMOVABLEMODULEMAXCOUNT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_NameCardV2Consts { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_NameCardV2ConstsArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_NameCardV2Consts<'bldr>> {
        let mut builder = clz_Torappu_NameCardV2ConstsBuilder::new(_fbb);
        builder.add_removableModuleMaxCount(args.removableModuleMaxCount);
        if let Some(x) = args.defaultNameCardSkinId {
            builder.add_defaultNameCardSkinId(x);
        }
        builder.add_canUidHide(args.canUidHide);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_NameCardV2ConstsT {
        let defaultNameCardSkinId = self.defaultNameCardSkinId().map(|x| x.to_string());
        let canUidHide = self.canUidHide();
        let removableModuleMaxCount = self.removableModuleMaxCount();
        clz_Torappu_NameCardV2ConstsT {
            defaultNameCardSkinId,
            canUidHide,
            removableModuleMaxCount,
        }
    }

    #[inline]
    pub fn defaultNameCardSkinId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_NameCardV2Consts::VT_DEFAULTNAMECARDSKINID,
                None,
            )
        }
    }
    #[inline]
    pub fn canUidHide(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_NameCardV2Consts::VT_CANUIDHIDE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn removableModuleMaxCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_NameCardV2Consts::VT_REMOVABLEMODULEMAXCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_NameCardV2Consts<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "defaultNameCardSkinId",
                Self::VT_DEFAULTNAMECARDSKINID,
                false,
            )?
            .visit_field::<bool>("canUidHide", Self::VT_CANUIDHIDE, false)?
            .visit_field::<i32>(
                "removableModuleMaxCount",
                Self::VT_REMOVABLEMODULEMAXCOUNT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_NameCardV2ConstsArgs<'a> {
    pub defaultNameCardSkinId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub canUidHide: bool,
    pub removableModuleMaxCount: i32,
}
impl<'a> Default for clz_Torappu_NameCardV2ConstsArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_NameCardV2ConstsArgs {
            defaultNameCardSkinId: None,
            canUidHide: false,
            removableModuleMaxCount: 0,
        }
    }
}

impl Serialize for clz_Torappu_NameCardV2Consts<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_NameCardV2Consts", 3)?;
        if let Some(f) = self.defaultNameCardSkinId() {
            s.serialize_field("defaultNameCardSkinId", &f)?;
        } else {
            s.skip_field("defaultNameCardSkinId")?;
        }
        s.serialize_field("canUidHide", &self.canUidHide())?;
        s.serialize_field("removableModuleMaxCount", &self.removableModuleMaxCount())?;
        s.end()
    }
}

pub struct clz_Torappu_NameCardV2ConstsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_NameCardV2ConstsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_defaultNameCardSkinId(
        &mut self,
        defaultNameCardSkinId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_NameCardV2Consts::VT_DEFAULTNAMECARDSKINID,
            defaultNameCardSkinId,
        );
    }
    #[inline]
    pub fn add_canUidHide(&mut self, canUidHide: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_NameCardV2Consts::VT_CANUIDHIDE,
            canUidHide,
            false,
        );
    }
    #[inline]
    pub fn add_removableModuleMaxCount(&mut self, removableModuleMaxCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_NameCardV2Consts::VT_REMOVABLEMODULEMAXCOUNT,
            removableModuleMaxCount,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_NameCardV2ConstsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_NameCardV2ConstsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_NameCardV2Consts<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_NameCardV2Consts<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_NameCardV2Consts");
        ds.field("defaultNameCardSkinId", &self.defaultNameCardSkinId());
        ds.field("canUidHide", &self.canUidHide());
        ds.field("removableModuleMaxCount", &self.removableModuleMaxCount());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_NameCardV2ConstsT {
    pub defaultNameCardSkinId: Option<String>,
    pub canUidHide: bool,
    pub removableModuleMaxCount: i32,
}
impl Default for clz_Torappu_NameCardV2ConstsT {
    fn default() -> Self {
        Self {
            defaultNameCardSkinId: None,
            canUidHide: false,
            removableModuleMaxCount: 0,
        }
    }
}
impl clz_Torappu_NameCardV2ConstsT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_NameCardV2Consts<'b>> {
        let defaultNameCardSkinId = self
            .defaultNameCardSkinId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let canUidHide = self.canUidHide;
        let removableModuleMaxCount = self.removableModuleMaxCount;
        clz_Torappu_NameCardV2Consts::create(
            _fbb,
            &clz_Torappu_NameCardV2ConstsArgs {
                defaultNameCardSkinId,
                canUidHide,
                removableModuleMaxCount,
            },
        )
    }
}
pub enum clz_Torappu_NameCardV2DataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_NameCardV2Data<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_NameCardV2Data<'a> {
    type Inner = clz_Torappu_NameCardV2Data<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_NameCardV2Data<'a> {
    pub const VT_FIXEDMODULEDATA: flatbuffers::VOffsetT = 4;
    pub const VT_REMOVABLEMODULEDATA: flatbuffers::VOffsetT = 6;
    pub const VT_SKINDATA: flatbuffers::VOffsetT = 8;
    pub const VT_CONSTS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_NameCardV2Data { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_NameCardV2DataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_NameCardV2Data<'bldr>> {
        let mut builder = clz_Torappu_NameCardV2DataBuilder::new(_fbb);
        if let Some(x) = args.consts {
            builder.add_consts(x);
        }
        if let Some(x) = args.skinData {
            builder.add_skinData(x);
        }
        if let Some(x) = args.removableModuleData {
            builder.add_removableModuleData(x);
        }
        if let Some(x) = args.fixedModuleData {
            builder.add_fixedModuleData(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_NameCardV2DataT {
        let fixedModuleData = self
            .fixedModuleData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let removableModuleData = self
            .removableModuleData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let skinData = self
            .skinData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let consts = self.consts().map(|x| Box::new(x.unpack()));
        clz_Torappu_NameCardV2DataT {
            fixedModuleData,
            removableModuleData,
            skinData,
            consts,
        }
    }

    #[inline]
    pub fn fixedModuleData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_NameCardV2ModuleData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_NameCardV2ModuleData>,
                >,
            >>(clz_Torappu_NameCardV2Data::VT_FIXEDMODULEDATA, None)
        }
    }
    #[inline]
    pub fn removableModuleData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_NameCardV2RemovableModuleData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_NameCardV2RemovableModuleData,
                    >,
                >,
            >>(clz_Torappu_NameCardV2Data::VT_REMOVABLEMODULEDATA, None)
        }
    }
    #[inline]
    pub fn skinData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_NameCardV2SkinData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_NameCardV2SkinData>,
                >,
            >>(clz_Torappu_NameCardV2Data::VT_SKINDATA, None)
        }
    }
    #[inline]
    pub fn consts(&self) -> Option<clz_Torappu_NameCardV2Consts<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_NameCardV2Consts>>(
                    clz_Torappu_NameCardV2Data::VT_CONSTS,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_NameCardV2Data<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_NameCardV2ModuleData>,
                >,
            >>("fixedModuleData", Self::VT_FIXEDMODULEDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_NameCardV2RemovableModuleData,
                    >,
                >,
            >>("removableModuleData", Self::VT_REMOVABLEMODULEDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_NameCardV2SkinData>,
                >,
            >>("skinData", Self::VT_SKINDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_NameCardV2Consts>>(
                "consts",
                Self::VT_CONSTS,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_NameCardV2DataArgs<'a> {
    pub fixedModuleData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_NameCardV2ModuleData<'a>>,
            >,
        >,
    >,
    pub removableModuleData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_NameCardV2RemovableModuleData<'a>,
                >,
            >,
        >,
    >,
    pub skinData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_NameCardV2SkinData<'a>>,
            >,
        >,
    >,
    pub consts: Option<flatbuffers::WIPOffset<clz_Torappu_NameCardV2Consts<'a>>>,
}
impl<'a> Default for clz_Torappu_NameCardV2DataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_NameCardV2DataArgs {
            fixedModuleData: None,
            removableModuleData: None,
            skinData: None,
            consts: None,
        }
    }
}

impl Serialize for clz_Torappu_NameCardV2Data<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_NameCardV2Data", 4)?;
        if let Some(f) = self.fixedModuleData() {
            s.serialize_field("fixedModuleData", &f)?;
        } else {
            s.skip_field("fixedModuleData")?;
        }
        if let Some(f) = self.removableModuleData() {
            s.serialize_field("removableModuleData", &f)?;
        } else {
            s.skip_field("removableModuleData")?;
        }
        if let Some(f) = self.skinData() {
            s.serialize_field("skinData", &f)?;
        } else {
            s.skip_field("skinData")?;
        }
        if let Some(f) = self.consts() {
            s.serialize_field("consts", &f)?;
        } else {
            s.skip_field("consts")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_NameCardV2DataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_NameCardV2DataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_fixedModuleData(
        &mut self,
        fixedModuleData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_NameCardV2ModuleData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_NameCardV2Data::VT_FIXEDMODULEDATA,
            fixedModuleData,
        );
    }
    #[inline]
    pub fn add_removableModuleData(
        &mut self,
        removableModuleData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_NameCardV2RemovableModuleData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_NameCardV2Data::VT_REMOVABLEMODULEDATA,
            removableModuleData,
        );
    }
    #[inline]
    pub fn add_skinData(
        &mut self,
        skinData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_NameCardV2SkinData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_NameCardV2Data::VT_SKINDATA,
            skinData,
        );
    }
    #[inline]
    pub fn add_consts(&mut self, consts: flatbuffers::WIPOffset<clz_Torappu_NameCardV2Consts<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_NameCardV2Consts>>(
                clz_Torappu_NameCardV2Data::VT_CONSTS,
                consts,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_NameCardV2DataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_NameCardV2DataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_NameCardV2Data<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_NameCardV2Data<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_NameCardV2Data");
        ds.field("fixedModuleData", &self.fixedModuleData());
        ds.field("removableModuleData", &self.removableModuleData());
        ds.field("skinData", &self.skinData());
        ds.field("consts", &self.consts());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_NameCardV2DataT {
    pub fixedModuleData: Option<Vec<dict__string__clz_Torappu_NameCardV2ModuleDataT>>,
    pub removableModuleData: Option<Vec<dict__string__clz_Torappu_NameCardV2RemovableModuleDataT>>,
    pub skinData: Option<Vec<dict__string__clz_Torappu_NameCardV2SkinDataT>>,
    pub consts: Option<Box<clz_Torappu_NameCardV2ConstsT>>,
}
impl Default for clz_Torappu_NameCardV2DataT {
    fn default() -> Self {
        Self {
            fixedModuleData: None,
            removableModuleData: None,
            skinData: None,
            consts: None,
        }
    }
}
impl clz_Torappu_NameCardV2DataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_NameCardV2Data<'b>> {
        let fixedModuleData = self.fixedModuleData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let removableModuleData = self.removableModuleData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let skinData = self.skinData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let consts = self.consts.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_NameCardV2Data::create(
            _fbb,
            &clz_Torappu_NameCardV2DataArgs {
                fixedModuleData,
                removableModuleData,
                skinData,
                consts,
            },
        )
    }
}
pub enum clz_Torappu_ItemBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ItemBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ItemBundle<'a> {
    type Inner = clz_Torappu_ItemBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ItemBundle<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_COUNT: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ItemBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ItemBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'bldr>> {
        let mut builder = clz_Torappu_ItemBundleBuilder::new(_fbb);
        builder.add_type_(args.type_);
        builder.add_count(args.count);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ItemBundleT {
        let id = self.id().map(|x| x.to_string());
        let count = self.count();
        let type_ = self.type_();
        clz_Torappu_ItemBundleT { id, count, type_ }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_ItemBundle::VT_ID, None)
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ItemBundle::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_ItemBundle::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ItemBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ItemBundleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl<'a> Default for clz_Torappu_ItemBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ItemBundleArgs {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_ItemBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ItemBundle", 3)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("count", &self.count())?;
        s.serialize_field("type_", &self.type_())?;
        s.end()
    }
}

pub struct clz_Torappu_ItemBundleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ItemBundle::VT_ID, id);
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ItemBundle::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_ItemBundle::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ItemBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ItemBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ItemBundle");
        ds.field("id", &self.id());
        ds.field("count", &self.count());
        ds.field("type_", &self.type_());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ItemBundleT {
    pub id: Option<String>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl Default for clz_Torappu_ItemBundleT {
    fn default() -> Self {
        Self {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}
impl clz_Torappu_ItemBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let count = self.count;
        let type_ = self.type_;
        clz_Torappu_ItemBundle::create(_fbb, &clz_Torappu_ItemBundleArgs { id, count, type_ })
    }
}
pub enum clz_Torappu_MailArchiveItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_MailArchiveItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_MailArchiveItemData<'a> {
    type Inner = clz_Torappu_MailArchiveItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_MailArchiveItemData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_SORTID: flatbuffers::VOffsetT = 8;
    pub const VT_DISPLAYRECEIVETS: flatbuffers::VOffsetT = 10;
    pub const VT_YEAR: flatbuffers::VOffsetT = 12;
    pub const VT_DATEDELTA: flatbuffers::VOffsetT = 14;
    pub const VT_SENDERID: flatbuffers::VOffsetT = 16;
    pub const VT_TITLE: flatbuffers::VOffsetT = 18;
    pub const VT_CONTENT: flatbuffers::VOffsetT = 20;
    pub const VT_REWARDLIST: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_MailArchiveItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_MailArchiveItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MailArchiveItemData<'bldr>> {
        let mut builder = clz_Torappu_MailArchiveItemDataBuilder::new(_fbb);
        builder.add_displayReceiveTs(args.displayReceiveTs);
        if let Some(x) = args.rewardList {
            builder.add_rewardList(x);
        }
        if let Some(x) = args.content {
            builder.add_content(x);
        }
        if let Some(x) = args.title {
            builder.add_title(x);
        }
        if let Some(x) = args.senderId {
            builder.add_senderId(x);
        }
        builder.add_dateDelta(args.dateDelta);
        builder.add_year(args.year);
        builder.add_sortId(args.sortId);
        builder.add_type_(args.type_);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_MailArchiveItemDataT {
        let id = self.id().map(|x| x.to_string());
        let type_ = self.type_();
        let sortId = self.sortId();
        let displayReceiveTs = self.displayReceiveTs();
        let year = self.year();
        let dateDelta = self.dateDelta();
        let senderId = self.senderId().map(|x| x.to_string());
        let title = self.title().map(|x| x.to_string());
        let content = self.content().map(|x| x.to_string());
        let rewardList = self
            .rewardList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_MailArchiveItemDataT {
            id,
            type_,
            sortId,
            displayReceiveTs,
            year,
            dateDelta,
            senderId,
            title,
            content,
            rewardList,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MailArchiveItemData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_MailArchiveItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_MailArchiveItemType>(
                    clz_Torappu_MailArchiveItemData::VT_TYPE_,
                    Some(enum__Torappu_MailArchiveItemType::NORMAL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_MailArchiveItemData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn displayReceiveTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_MailArchiveItemData::VT_DISPLAYRECEIVETS,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn year(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_MailArchiveItemData::VT_YEAR, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn dateDelta(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_MailArchiveItemData::VT_DATEDELTA, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn senderId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MailArchiveItemData::VT_SENDERID,
                None,
            )
        }
    }
    #[inline]
    pub fn title(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MailArchiveItemData::VT_TITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn content(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MailArchiveItemData::VT_CONTENT,
                None,
            )
        }
    }
    #[inline]
    pub fn rewardList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(clz_Torappu_MailArchiveItemData::VT_REWARDLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_MailArchiveItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_MailArchiveItemType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<i64>("displayReceiveTs", Self::VT_DISPLAYRECEIVETS, false)?
            .visit_field::<i32>("year", Self::VT_YEAR, false)?
            .visit_field::<i32>("dateDelta", Self::VT_DATEDELTA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "senderId",
                Self::VT_SENDERID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("content", Self::VT_CONTENT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("rewardList", Self::VT_REWARDLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_MailArchiveItemDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_MailArchiveItemType,
    pub sortId: i32,
    pub displayReceiveTs: i64,
    pub year: i32,
    pub dateDelta: i32,
    pub senderId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub content: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewardList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_MailArchiveItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_MailArchiveItemDataArgs {
            id: None,
            type_: enum__Torappu_MailArchiveItemType::NORMAL,
            sortId: 0,
            displayReceiveTs: 0,
            year: 0,
            dateDelta: 0,
            senderId: None,
            title: None,
            content: None,
            rewardList: None,
        }
    }
}

impl Serialize for clz_Torappu_MailArchiveItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_MailArchiveItemData", 10)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("type_", &self.type_())?;
        s.serialize_field("sortId", &self.sortId())?;
        s.serialize_field("displayReceiveTs", &self.displayReceiveTs())?;
        s.serialize_field("year", &self.year())?;
        s.serialize_field("dateDelta", &self.dateDelta())?;
        if let Some(f) = self.senderId() {
            s.serialize_field("senderId", &f)?;
        } else {
            s.skip_field("senderId")?;
        }
        if let Some(f) = self.title() {
            s.serialize_field("title", &f)?;
        } else {
            s.skip_field("title")?;
        }
        if let Some(f) = self.content() {
            s.serialize_field("content", &f)?;
        } else {
            s.skip_field("content")?;
        }
        if let Some(f) = self.rewardList() {
            s.serialize_field("rewardList", &f)?;
        } else {
            s.skip_field("rewardList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_MailArchiveItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_MailArchiveItemDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MailArchiveItemData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_MailArchiveItemType) {
        self.fbb_.push_slot::<enum__Torappu_MailArchiveItemType>(
            clz_Torappu_MailArchiveItemData::VT_TYPE_,
            type_,
            enum__Torappu_MailArchiveItemType::NORMAL,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_MailArchiveItemData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_displayReceiveTs(&mut self, displayReceiveTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_MailArchiveItemData::VT_DISPLAYRECEIVETS,
            displayReceiveTs,
            0,
        );
    }
    #[inline]
    pub fn add_year(&mut self, year: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_MailArchiveItemData::VT_YEAR, year, 0);
    }
    #[inline]
    pub fn add_dateDelta(&mut self, dateDelta: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_MailArchiveItemData::VT_DATEDELTA, dateDelta, 0);
    }
    #[inline]
    pub fn add_senderId(&mut self, senderId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MailArchiveItemData::VT_SENDERID,
            senderId,
        );
    }
    #[inline]
    pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MailArchiveItemData::VT_TITLE,
            title,
        );
    }
    #[inline]
    pub fn add_content(&mut self, content: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MailArchiveItemData::VT_CONTENT,
            content,
        );
    }
    #[inline]
    pub fn add_rewardList(
        &mut self,
        rewardList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MailArchiveItemData::VT_REWARDLIST,
            rewardList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_MailArchiveItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_MailArchiveItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_MailArchiveItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_MailArchiveItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_MailArchiveItemData");
        ds.field("id", &self.id());
        ds.field("type_", &self.type_());
        ds.field("sortId", &self.sortId());
        ds.field("displayReceiveTs", &self.displayReceiveTs());
        ds.field("year", &self.year());
        ds.field("dateDelta", &self.dateDelta());
        ds.field("senderId", &self.senderId());
        ds.field("title", &self.title());
        ds.field("content", &self.content());
        ds.field("rewardList", &self.rewardList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_MailArchiveItemDataT {
    pub id: Option<String>,
    pub type_: enum__Torappu_MailArchiveItemType,
    pub sortId: i32,
    pub displayReceiveTs: i64,
    pub year: i32,
    pub dateDelta: i32,
    pub senderId: Option<String>,
    pub title: Option<String>,
    pub content: Option<String>,
    pub rewardList: Option<Vec<clz_Torappu_ItemBundleT>>,
}
impl Default for clz_Torappu_MailArchiveItemDataT {
    fn default() -> Self {
        Self {
            id: None,
            type_: enum__Torappu_MailArchiveItemType::NORMAL,
            sortId: 0,
            displayReceiveTs: 0,
            year: 0,
            dateDelta: 0,
            senderId: None,
            title: None,
            content: None,
            rewardList: None,
        }
    }
}
impl clz_Torappu_MailArchiveItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MailArchiveItemData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let sortId = self.sortId;
        let displayReceiveTs = self.displayReceiveTs;
        let year = self.year;
        let dateDelta = self.dateDelta;
        let senderId = self.senderId.as_ref().map(|x| _fbb.create_string(x));
        let title = self.title.as_ref().map(|x| _fbb.create_string(x));
        let content = self.content.as_ref().map(|x| _fbb.create_string(x));
        let rewardList = self.rewardList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_MailArchiveItemData::create(
            _fbb,
            &clz_Torappu_MailArchiveItemDataArgs {
                id,
                type_,
                sortId,
                displayReceiveTs,
                year,
                dateDelta,
                senderId,
                title,
                content,
                rewardList,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_MailArchiveItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_MailArchiveItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_MailArchiveItemData<'a> {
    type Inner = dict__string__clz_Torappu_MailArchiveItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_MailArchiveItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_MailArchiveItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_MailArchiveItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_MailArchiveItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_MailArchiveItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_MailArchiveItemDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_MailArchiveItemDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_MailArchiveItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_MailArchiveItemData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_MailArchiveItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_MailArchiveItemData>>(
                    dict__string__clz_Torappu_MailArchiveItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_MailArchiveItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_MailArchiveItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_MailArchiveItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_MailArchiveItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_MailArchiveItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_MailArchiveItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_MailArchiveItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_MailArchiveItemData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_MailArchiveItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_MailArchiveItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_MailArchiveItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_MailArchiveItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_MailArchiveItemData>>(
                dict__string__clz_Torappu_MailArchiveItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_MailArchiveItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_MailArchiveItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_MailArchiveItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_MailArchiveItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_MailArchiveItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_MailArchiveItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_MailArchiveItemDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_MailArchiveItemDataT>>,
}
impl Default for dict__string__clz_Torappu_MailArchiveItemDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_MailArchiveItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_MailArchiveItemData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_MailArchiveItemData::create(
            _fbb,
            &dict__string__clz_Torappu_MailArchiveItemDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_MailArchiveConstDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_MailArchiveConstData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_MailArchiveConstData<'a> {
    type Inner = clz_Torappu_MailArchiveConstData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_MailArchiveConstData<'a> {
    pub const VT_FUNCOPENTS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_MailArchiveConstData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_MailArchiveConstDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MailArchiveConstData<'bldr>> {
        let mut builder = clz_Torappu_MailArchiveConstDataBuilder::new(_fbb);
        builder.add_funcOpenTs(args.funcOpenTs);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_MailArchiveConstDataT {
        let funcOpenTs = self.funcOpenTs();
        clz_Torappu_MailArchiveConstDataT { funcOpenTs }
    }

    #[inline]
    pub fn funcOpenTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_MailArchiveConstData::VT_FUNCOPENTS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_MailArchiveConstData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("funcOpenTs", Self::VT_FUNCOPENTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_MailArchiveConstDataArgs {
    pub funcOpenTs: i64,
}
impl<'a> Default for clz_Torappu_MailArchiveConstDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_MailArchiveConstDataArgs { funcOpenTs: 0 }
    }
}

impl Serialize for clz_Torappu_MailArchiveConstData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_MailArchiveConstData", 1)?;
        s.serialize_field("funcOpenTs", &self.funcOpenTs())?;
        s.end()
    }
}

pub struct clz_Torappu_MailArchiveConstDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_MailArchiveConstDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_funcOpenTs(&mut self, funcOpenTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_MailArchiveConstData::VT_FUNCOPENTS,
            funcOpenTs,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_MailArchiveConstDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_MailArchiveConstDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_MailArchiveConstData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_MailArchiveConstData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_MailArchiveConstData");
        ds.field("funcOpenTs", &self.funcOpenTs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_MailArchiveConstDataT {
    pub funcOpenTs: i64,
}
impl Default for clz_Torappu_MailArchiveConstDataT {
    fn default() -> Self {
        Self { funcOpenTs: 0 }
    }
}
impl clz_Torappu_MailArchiveConstDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MailArchiveConstData<'b>> {
        let funcOpenTs = self.funcOpenTs;
        clz_Torappu_MailArchiveConstData::create(
            _fbb,
            &clz_Torappu_MailArchiveConstDataArgs { funcOpenTs },
        )
    }
}
pub enum clz_Torappu_MailArchiveDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_MailArchiveData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_MailArchiveData<'a> {
    type Inner = clz_Torappu_MailArchiveData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_MailArchiveData<'a> {
    pub const VT_MAILARCHIVEINFODICT: flatbuffers::VOffsetT = 4;
    pub const VT_CONSTDATA: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_MailArchiveData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_MailArchiveDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MailArchiveData<'bldr>> {
        let mut builder = clz_Torappu_MailArchiveDataBuilder::new(_fbb);
        if let Some(x) = args.constData {
            builder.add_constData(x);
        }
        if let Some(x) = args.mailArchiveInfoDict {
            builder.add_mailArchiveInfoDict(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_MailArchiveDataT {
        let mailArchiveInfoDict = self
            .mailArchiveInfoDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let constData = self.constData().map(|x| Box::new(x.unpack()));
        clz_Torappu_MailArchiveDataT {
            mailArchiveInfoDict,
            constData,
        }
    }

    #[inline]
    pub fn mailArchiveInfoDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MailArchiveItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MailArchiveItemData>,
                >,
            >>(clz_Torappu_MailArchiveData::VT_MAILARCHIVEINFODICT, None)
        }
    }
    #[inline]
    pub fn constData(&self) -> Option<clz_Torappu_MailArchiveConstData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_MailArchiveConstData>>(
                    clz_Torappu_MailArchiveData::VT_CONSTDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_MailArchiveData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MailArchiveItemData>,
                >,
            >>("mailArchiveInfoDict", Self::VT_MAILARCHIVEINFODICT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_MailArchiveConstData>>(
                "constData",
                Self::VT_CONSTDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_MailArchiveDataArgs<'a> {
    pub mailArchiveInfoDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MailArchiveItemData<'a>>,
            >,
        >,
    >,
    pub constData: Option<flatbuffers::WIPOffset<clz_Torappu_MailArchiveConstData<'a>>>,
}
impl<'a> Default for clz_Torappu_MailArchiveDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_MailArchiveDataArgs {
            mailArchiveInfoDict: None,
            constData: None,
        }
    }
}

impl Serialize for clz_Torappu_MailArchiveData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_MailArchiveData", 2)?;
        if let Some(f) = self.mailArchiveInfoDict() {
            s.serialize_field("mailArchiveInfoDict", &f)?;
        } else {
            s.skip_field("mailArchiveInfoDict")?;
        }
        if let Some(f) = self.constData() {
            s.serialize_field("constData", &f)?;
        } else {
            s.skip_field("constData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_MailArchiveDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_MailArchiveDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_mailArchiveInfoDict(
        &mut self,
        mailArchiveInfoDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MailArchiveItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MailArchiveData::VT_MAILARCHIVEINFODICT,
            mailArchiveInfoDict,
        );
    }
    #[inline]
    pub fn add_constData(
        &mut self,
        constData: flatbuffers::WIPOffset<clz_Torappu_MailArchiveConstData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_MailArchiveConstData>>(
                clz_Torappu_MailArchiveData::VT_CONSTDATA,
                constData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_MailArchiveDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_MailArchiveDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_MailArchiveData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_MailArchiveData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_MailArchiveData");
        ds.field("mailArchiveInfoDict", &self.mailArchiveInfoDict());
        ds.field("constData", &self.constData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_MailArchiveDataT {
    pub mailArchiveInfoDict: Option<Vec<dict__string__clz_Torappu_MailArchiveItemDataT>>,
    pub constData: Option<Box<clz_Torappu_MailArchiveConstDataT>>,
}
impl Default for clz_Torappu_MailArchiveDataT {
    fn default() -> Self {
        Self {
            mailArchiveInfoDict: None,
            constData: None,
        }
    }
}
impl clz_Torappu_MailArchiveDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MailArchiveData<'b>> {
        let mailArchiveInfoDict = self.mailArchiveInfoDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let constData = self.constData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_MailArchiveData::create(
            _fbb,
            &clz_Torappu_MailArchiveDataArgs {
                mailArchiveInfoDict,
                constData,
            },
        )
    }
}
pub enum clz_Torappu_MailSenderSingleInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_MailSenderSingleInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_MailSenderSingleInfo<'a> {
    type Inner = clz_Torappu_MailSenderSingleInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_MailSenderSingleInfo<'a> {
    pub const VT_SENDERID: flatbuffers::VOffsetT = 4;
    pub const VT_SENDERNAME: flatbuffers::VOffsetT = 6;
    pub const VT_AVATARID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_MailSenderSingleInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_MailSenderSingleInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MailSenderSingleInfo<'bldr>> {
        let mut builder = clz_Torappu_MailSenderSingleInfoBuilder::new(_fbb);
        if let Some(x) = args.avatarId {
            builder.add_avatarId(x);
        }
        if let Some(x) = args.senderName {
            builder.add_senderName(x);
        }
        if let Some(x) = args.senderId {
            builder.add_senderId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_MailSenderSingleInfoT {
        let senderId = self.senderId().map(|x| x.to_string());
        let senderName = self.senderName().map(|x| x.to_string());
        let avatarId = self.avatarId().map(|x| x.to_string());
        clz_Torappu_MailSenderSingleInfoT {
            senderId,
            senderName,
            avatarId,
        }
    }

    #[inline]
    pub fn senderId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MailSenderSingleInfo::VT_SENDERID,
                None,
            )
        }
    }
    #[inline]
    pub fn senderName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MailSenderSingleInfo::VT_SENDERNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn avatarId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MailSenderSingleInfo::VT_AVATARID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_MailSenderSingleInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "senderId",
                Self::VT_SENDERID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "senderName",
                Self::VT_SENDERNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "avatarId",
                Self::VT_AVATARID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_MailSenderSingleInfoArgs<'a> {
    pub senderId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub senderName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub avatarId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_MailSenderSingleInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_MailSenderSingleInfoArgs {
            senderId: None,
            senderName: None,
            avatarId: None,
        }
    }
}

impl Serialize for clz_Torappu_MailSenderSingleInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_MailSenderSingleInfo", 3)?;
        if let Some(f) = self.senderId() {
            s.serialize_field("senderId", &f)?;
        } else {
            s.skip_field("senderId")?;
        }
        if let Some(f) = self.senderName() {
            s.serialize_field("senderName", &f)?;
        } else {
            s.skip_field("senderName")?;
        }
        if let Some(f) = self.avatarId() {
            s.serialize_field("avatarId", &f)?;
        } else {
            s.skip_field("avatarId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_MailSenderSingleInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_MailSenderSingleInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_senderId(&mut self, senderId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MailSenderSingleInfo::VT_SENDERID,
            senderId,
        );
    }
    #[inline]
    pub fn add_senderName(&mut self, senderName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MailSenderSingleInfo::VT_SENDERNAME,
            senderName,
        );
    }
    #[inline]
    pub fn add_avatarId(&mut self, avatarId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MailSenderSingleInfo::VT_AVATARID,
            avatarId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_MailSenderSingleInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_MailSenderSingleInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_MailSenderSingleInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_MailSenderSingleInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_MailSenderSingleInfo");
        ds.field("senderId", &self.senderId());
        ds.field("senderName", &self.senderName());
        ds.field("avatarId", &self.avatarId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_MailSenderSingleInfoT {
    pub senderId: Option<String>,
    pub senderName: Option<String>,
    pub avatarId: Option<String>,
}
impl Default for clz_Torappu_MailSenderSingleInfoT {
    fn default() -> Self {
        Self {
            senderId: None,
            senderName: None,
            avatarId: None,
        }
    }
}
impl clz_Torappu_MailSenderSingleInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MailSenderSingleInfo<'b>> {
        let senderId = self.senderId.as_ref().map(|x| _fbb.create_string(x));
        let senderName = self.senderName.as_ref().map(|x| _fbb.create_string(x));
        let avatarId = self.avatarId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_MailSenderSingleInfo::create(
            _fbb,
            &clz_Torappu_MailSenderSingleInfoArgs {
                senderId,
                senderName,
                avatarId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_MailSenderSingleInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_MailSenderSingleInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_MailSenderSingleInfo<'a> {
    type Inner = dict__string__clz_Torappu_MailSenderSingleInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_MailSenderSingleInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_MailSenderSingleInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_MailSenderSingleInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_MailSenderSingleInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_MailSenderSingleInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_MailSenderSingleInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_MailSenderSingleInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_MailSenderSingleInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_MailSenderSingleInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_MailSenderSingleInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_MailSenderSingleInfo>>(
                    dict__string__clz_Torappu_MailSenderSingleInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_MailSenderSingleInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_MailSenderSingleInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_MailSenderSingleInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_MailSenderSingleInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_MailSenderSingleInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_MailSenderSingleInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_MailSenderSingleInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_MailSenderSingleInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_MailSenderSingleInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_MailSenderSingleInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_MailSenderSingleInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_MailSenderSingleInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_MailSenderSingleInfo>>(
                dict__string__clz_Torappu_MailSenderSingleInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_MailSenderSingleInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_MailSenderSingleInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_MailSenderSingleInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_MailSenderSingleInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_MailSenderSingleInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_MailSenderSingleInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_MailSenderSingleInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_MailSenderSingleInfoT>>,
}
impl Default for dict__string__clz_Torappu_MailSenderSingleInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_MailSenderSingleInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_MailSenderSingleInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_MailSenderSingleInfo::create(
            _fbb,
            &dict__string__clz_Torappu_MailSenderSingleInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_MailSenderDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_MailSenderData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_MailSenderData<'a> {
    type Inner = clz_Torappu_MailSenderData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_MailSenderData<'a> {
    pub const VT_SENDERDICT: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_MailSenderData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_MailSenderDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MailSenderData<'bldr>> {
        let mut builder = clz_Torappu_MailSenderDataBuilder::new(_fbb);
        if let Some(x) = args.senderDict {
            builder.add_senderDict(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_MailSenderDataT {
        let senderDict = self
            .senderDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_MailSenderDataT { senderDict }
    }

    #[inline]
    pub fn senderDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MailSenderSingleInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MailSenderSingleInfo>,
                >,
            >>(clz_Torappu_MailSenderData::VT_SENDERDICT, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_MailSenderData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MailSenderSingleInfo>,
                >,
            >>("senderDict", Self::VT_SENDERDICT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_MailSenderDataArgs<'a> {
    pub senderDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MailSenderSingleInfo<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_MailSenderDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_MailSenderDataArgs { senderDict: None }
    }
}

impl Serialize for clz_Torappu_MailSenderData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_MailSenderData", 1)?;
        if let Some(f) = self.senderDict() {
            s.serialize_field("senderDict", &f)?;
        } else {
            s.skip_field("senderDict")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_MailSenderDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_MailSenderDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_senderDict(
        &mut self,
        senderDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MailSenderSingleInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MailSenderData::VT_SENDERDICT,
            senderDict,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_MailSenderDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_MailSenderDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_MailSenderData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_MailSenderData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_MailSenderData");
        ds.field("senderDict", &self.senderDict());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_MailSenderDataT {
    pub senderDict: Option<Vec<dict__string__clz_Torappu_MailSenderSingleInfoT>>,
}
impl Default for clz_Torappu_MailSenderDataT {
    fn default() -> Self {
        Self { senderDict: None }
    }
}
impl clz_Torappu_MailSenderDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MailSenderData<'b>> {
        let senderDict = self.senderDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_MailSenderData::create(_fbb, &clz_Torappu_MailSenderDataArgs { senderDict })
    }
}
pub enum clz_Torappu_EmoticonData_EmojiDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_EmoticonData_EmojiData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_EmoticonData_EmojiData<'a> {
    type Inner = clz_Torappu_EmoticonData_EmojiData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_EmoticonData_EmojiData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_SORTID: flatbuffers::VOffsetT = 8;
    pub const VT_PICID: flatbuffers::VOffsetT = 10;
    pub const VT_DESC: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_EmoticonData_EmojiData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_EmoticonData_EmojiDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EmoticonData_EmojiData<'bldr>> {
        let mut builder = clz_Torappu_EmoticonData_EmojiDataBuilder::new(_fbb);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.picId {
            builder.add_picId(x);
        }
        builder.add_sortId(args.sortId);
        builder.add_type_(args.type_);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_EmoticonData_EmojiDataT {
        let id = self.id().map(|x| x.to_string());
        let type_ = self.type_();
        let sortId = self.sortId();
        let picId = self.picId().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        clz_Torappu_EmoticonData_EmojiDataT {
            id,
            type_,
            sortId,
            picId,
            desc,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_EmoticonData_EmojiData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_EmojiSceneType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_EmojiSceneType>(
                    clz_Torappu_EmoticonData_EmojiData::VT_TYPE_,
                    Some(enum__Torappu_EmojiSceneType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_EmoticonData_EmojiData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn picId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_EmoticonData_EmojiData::VT_PICID,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_EmoticonData_EmojiData::VT_DESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_EmoticonData_EmojiData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_EmojiSceneType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("picId", Self::VT_PICID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_EmoticonData_EmojiDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_EmojiSceneType,
    pub sortId: i32,
    pub picId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_EmoticonData_EmojiDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_EmoticonData_EmojiDataArgs {
            id: None,
            type_: enum__Torappu_EmojiSceneType::NONE,
            sortId: 0,
            picId: None,
            desc: None,
        }
    }
}

impl Serialize for clz_Torappu_EmoticonData_EmojiData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_EmoticonData_EmojiData", 5)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("type_", &self.type_())?;
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.picId() {
            s.serialize_field("picId", &f)?;
        } else {
            s.skip_field("picId")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_EmoticonData_EmojiDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_EmoticonData_EmojiDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EmoticonData_EmojiData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_EmojiSceneType) {
        self.fbb_.push_slot::<enum__Torappu_EmojiSceneType>(
            clz_Torappu_EmoticonData_EmojiData::VT_TYPE_,
            type_,
            enum__Torappu_EmojiSceneType::NONE,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_EmoticonData_EmojiData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_picId(&mut self, picId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EmoticonData_EmojiData::VT_PICID,
            picId,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EmoticonData_EmojiData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_EmoticonData_EmojiDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_EmoticonData_EmojiDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_EmoticonData_EmojiData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_EmoticonData_EmojiData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_EmoticonData_EmojiData");
        ds.field("id", &self.id());
        ds.field("type_", &self.type_());
        ds.field("sortId", &self.sortId());
        ds.field("picId", &self.picId());
        ds.field("desc", &self.desc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_EmoticonData_EmojiDataT {
    pub id: Option<String>,
    pub type_: enum__Torappu_EmojiSceneType,
    pub sortId: i32,
    pub picId: Option<String>,
    pub desc: Option<String>,
}
impl Default for clz_Torappu_EmoticonData_EmojiDataT {
    fn default() -> Self {
        Self {
            id: None,
            type_: enum__Torappu_EmojiSceneType::NONE,
            sortId: 0,
            picId: None,
            desc: None,
        }
    }
}
impl clz_Torappu_EmoticonData_EmojiDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EmoticonData_EmojiData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let sortId = self.sortId;
        let picId = self.picId.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_EmoticonData_EmojiData::create(
            _fbb,
            &clz_Torappu_EmoticonData_EmojiDataArgs {
                id,
                type_,
                sortId,
                picId,
                desc,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_EmoticonData_EmojiDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_EmoticonData_EmojiData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_EmoticonData_EmojiData<'a> {
    type Inner = dict__string__clz_Torappu_EmoticonData_EmojiData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_EmoticonData_EmojiData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_EmoticonData_EmojiData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_EmoticonData_EmojiDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_EmoticonData_EmojiData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_EmoticonData_EmojiDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_EmoticonData_EmojiDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_EmoticonData_EmojiDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_EmoticonData_EmojiData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_EmoticonData_EmojiData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_EmoticonData_EmojiData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_EmoticonData_EmojiData>>(
                    dict__string__clz_Torappu_EmoticonData_EmojiData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_EmoticonData_EmojiData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_EmoticonData_EmojiData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_EmoticonData_EmojiDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_EmoticonData_EmojiData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_EmoticonData_EmojiDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_EmoticonData_EmojiDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_EmoticonData_EmojiData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_EmoticonData_EmojiData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_EmoticonData_EmojiDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_EmoticonData_EmojiDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_EmoticonData_EmojiData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_EmoticonData_EmojiData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_EmoticonData_EmojiData>>(
                dict__string__clz_Torappu_EmoticonData_EmojiData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_EmoticonData_EmojiDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_EmoticonData_EmojiDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_EmoticonData_EmojiData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_EmoticonData_EmojiData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_EmoticonData_EmojiData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_EmoticonData_EmojiData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_EmoticonData_EmojiDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_EmoticonData_EmojiDataT>>,
}
impl Default for dict__string__clz_Torappu_EmoticonData_EmojiDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_EmoticonData_EmojiDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_EmoticonData_EmojiData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_EmoticonData_EmojiData::create(
            _fbb,
            &dict__string__clz_Torappu_EmoticonData_EmojiDataArgs { key, value },
        )
    }
}
pub enum dict__string__list_stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__list_string<'a> {
    type Inner = dict__string__list_string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__list_string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__list_string<'bldr>> {
        let mut builder = dict__string__list_stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__list_stringT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self
            .value()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        dict__string__list_stringT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__list_string::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__list_string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(dict__string__list_string::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__list_string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_stringArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for dict__string__list_stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__list_stringArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__list_string<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__list_string", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__list_stringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__list_stringBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__list_string::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_string::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__list_stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__list_stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__list_string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__list_string::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__list_string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__list_string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__list_stringT {
    pub key: String,
    pub value: Option<Vec<String>>,
}
impl Default for dict__string__list_stringT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__list_stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__list_string<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        dict__string__list_string::create(_fbb, &dict__string__list_stringArgs { key, value })
    }
}
pub enum clz_Torappu_EmoticonDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_EmoticonData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_EmoticonData<'a> {
    type Inner = clz_Torappu_EmoticonData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_EmoticonData<'a> {
    pub const VT_EMOJIDATADICT: flatbuffers::VOffsetT = 4;
    pub const VT_EMOTICONTHEMEDATADICT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_EmoticonData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_EmoticonDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EmoticonData<'bldr>> {
        let mut builder = clz_Torappu_EmoticonDataBuilder::new(_fbb);
        if let Some(x) = args.emoticonThemeDataDict {
            builder.add_emoticonThemeDataDict(x);
        }
        if let Some(x) = args.emojiDataDict {
            builder.add_emojiDataDict(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_EmoticonDataT {
        let emojiDataDict = self
            .emojiDataDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let emoticonThemeDataDict = self
            .emoticonThemeDataDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_EmoticonDataT {
            emojiDataDict,
            emoticonThemeDataDict,
        }
    }

    #[inline]
    pub fn emojiDataDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_EmoticonData_EmojiData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_EmoticonData_EmojiData>,
                >,
            >>(clz_Torappu_EmoticonData::VT_EMOJIDATADICT, None)
        }
    }
    #[inline]
    pub fn emoticonThemeDataDict(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string>>,
            >>(clz_Torappu_EmoticonData::VT_EMOTICONTHEMEDATADICT, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_EmoticonData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_EmoticonData_EmojiData>,
                >,
            >>("emojiDataDict", Self::VT_EMOJIDATADICT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__list_string>>,
            >>(
                "emoticonThemeDataDict",
                Self::VT_EMOTICONTHEMEDATADICT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_EmoticonDataArgs<'a> {
    pub emojiDataDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_EmoticonData_EmojiData<'a>>,
            >,
        >,
    >,
    pub emoticonThemeDataDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_EmoticonDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_EmoticonDataArgs {
            emojiDataDict: None,
            emoticonThemeDataDict: None,
        }
    }
}

impl Serialize for clz_Torappu_EmoticonData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_EmoticonData", 2)?;
        if let Some(f) = self.emojiDataDict() {
            s.serialize_field("emojiDataDict", &f)?;
        } else {
            s.skip_field("emojiDataDict")?;
        }
        if let Some(f) = self.emoticonThemeDataDict() {
            s.serialize_field("emoticonThemeDataDict", &f)?;
        } else {
            s.skip_field("emoticonThemeDataDict")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_EmoticonDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_EmoticonDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_emojiDataDict(
        &mut self,
        emojiDataDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_EmoticonData_EmojiData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EmoticonData::VT_EMOJIDATADICT,
            emojiDataDict,
        );
    }
    #[inline]
    pub fn add_emoticonThemeDataDict(
        &mut self,
        emoticonThemeDataDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__list_string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EmoticonData::VT_EMOTICONTHEMEDATADICT,
            emoticonThemeDataDict,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_EmoticonDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_EmoticonDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_EmoticonData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_EmoticonData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_EmoticonData");
        ds.field("emojiDataDict", &self.emojiDataDict());
        ds.field("emoticonThemeDataDict", &self.emoticonThemeDataDict());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_EmoticonDataT {
    pub emojiDataDict: Option<Vec<dict__string__clz_Torappu_EmoticonData_EmojiDataT>>,
    pub emoticonThemeDataDict: Option<Vec<dict__string__list_stringT>>,
}
impl Default for clz_Torappu_EmoticonDataT {
    fn default() -> Self {
        Self {
            emojiDataDict: None,
            emoticonThemeDataDict: None,
        }
    }
}
impl clz_Torappu_EmoticonDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EmoticonData<'b>> {
        let emojiDataDict = self.emojiDataDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let emoticonThemeDataDict = self.emoticonThemeDataDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_EmoticonData::create(
            _fbb,
            &clz_Torappu_EmoticonDataArgs {
                emojiDataDict,
                emoticonThemeDataDict,
            },
        )
    }
}
pub enum clz_Torappu_StoryVariantDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StoryVariantData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StoryVariantData<'a> {
    type Inner = clz_Torappu_StoryVariantData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StoryVariantData<'a> {
    pub const VT_PLOTTASKID: flatbuffers::VOffsetT = 4;
    pub const VT_SPSTORYID: flatbuffers::VOffsetT = 6;
    pub const VT_STORYID: flatbuffers::VOffsetT = 8;
    pub const VT_PRIORITY: flatbuffers::VOffsetT = 10;
    pub const VT_STARTTIME: flatbuffers::VOffsetT = 12;
    pub const VT_ENDTIME: flatbuffers::VOffsetT = 14;
    pub const VT_TEMPLATE: flatbuffers::VOffsetT = 16;
    pub const VT_PARAM: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StoryVariantData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StoryVariantDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StoryVariantData<'bldr>> {
        let mut builder = clz_Torappu_StoryVariantDataBuilder::new(_fbb);
        builder.add_endTime(args.endTime);
        builder.add_startTime(args.startTime);
        if let Some(x) = args.param {
            builder.add_param(x);
        }
        if let Some(x) = args.template {
            builder.add_template(x);
        }
        builder.add_priority(args.priority);
        if let Some(x) = args.storyId {
            builder.add_storyId(x);
        }
        if let Some(x) = args.spStoryId {
            builder.add_spStoryId(x);
        }
        if let Some(x) = args.plotTaskId {
            builder.add_plotTaskId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StoryVariantDataT {
        let plotTaskId = self.plotTaskId().map(|x| x.to_string());
        let spStoryId = self.spStoryId().map(|x| x.to_string());
        let storyId = self.storyId().map(|x| x.to_string());
        let priority = self.priority();
        let startTime = self.startTime();
        let endTime = self.endTime();
        let template = self.template().map(|x| x.to_string());
        let param = self
            .param()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_StoryVariantDataT {
            plotTaskId,
            spStoryId,
            storyId,
            priority,
            startTime,
            endTime,
            template,
            param,
        }
    }

    #[inline]
    pub fn plotTaskId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StoryVariantData::VT_PLOTTASKID,
                None,
            )
        }
    }
    #[inline]
    pub fn spStoryId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StoryVariantData::VT_SPSTORYID,
                None,
            )
        }
    }
    #[inline]
    pub fn storyId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StoryVariantData::VT_STORYID,
                None,
            )
        }
    }
    #[inline]
    pub fn priority(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StoryVariantData::VT_PRIORITY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn startTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_StoryVariantData::VT_STARTTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_StoryVariantData::VT_ENDTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn template(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StoryVariantData::VT_TEMPLATE,
                None,
            )
        }
    }
    #[inline]
    pub fn param(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_StoryVariantData::VT_PARAM, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StoryVariantData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "plotTaskId",
                Self::VT_PLOTTASKID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "spStoryId",
                Self::VT_SPSTORYID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("storyId", Self::VT_STORYID, false)?
            .visit_field::<i32>("priority", Self::VT_PRIORITY, false)?
            .visit_field::<i64>("startTime", Self::VT_STARTTIME, false)?
            .visit_field::<i64>("endTime", Self::VT_ENDTIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "template",
                Self::VT_TEMPLATE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("param", Self::VT_PARAM, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StoryVariantDataArgs<'a> {
    pub plotTaskId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub spStoryId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub storyId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub priority: i32,
    pub startTime: i64,
    pub endTime: i64,
    pub template: Option<flatbuffers::WIPOffset<&'a str>>,
    pub param: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_StoryVariantDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StoryVariantDataArgs {
            plotTaskId: None,
            spStoryId: None,
            storyId: None,
            priority: 0,
            startTime: 0,
            endTime: 0,
            template: None,
            param: None,
        }
    }
}

impl Serialize for clz_Torappu_StoryVariantData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StoryVariantData", 8)?;
        if let Some(f) = self.plotTaskId() {
            s.serialize_field("plotTaskId", &f)?;
        } else {
            s.skip_field("plotTaskId")?;
        }
        if let Some(f) = self.spStoryId() {
            s.serialize_field("spStoryId", &f)?;
        } else {
            s.skip_field("spStoryId")?;
        }
        if let Some(f) = self.storyId() {
            s.serialize_field("storyId", &f)?;
        } else {
            s.skip_field("storyId")?;
        }
        s.serialize_field("priority", &self.priority())?;
        s.serialize_field("startTime", &self.startTime())?;
        s.serialize_field("endTime", &self.endTime())?;
        if let Some(f) = self.template() {
            s.serialize_field("template", &f)?;
        } else {
            s.skip_field("template")?;
        }
        if let Some(f) = self.param() {
            s.serialize_field("param", &f)?;
        } else {
            s.skip_field("param")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_StoryVariantDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_StoryVariantDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_plotTaskId(&mut self, plotTaskId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StoryVariantData::VT_PLOTTASKID,
            plotTaskId,
        );
    }
    #[inline]
    pub fn add_spStoryId(&mut self, spStoryId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StoryVariantData::VT_SPSTORYID,
            spStoryId,
        );
    }
    #[inline]
    pub fn add_storyId(&mut self, storyId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StoryVariantData::VT_STORYID,
            storyId,
        );
    }
    #[inline]
    pub fn add_priority(&mut self, priority: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StoryVariantData::VT_PRIORITY, priority, 0);
    }
    #[inline]
    pub fn add_startTime(&mut self, startTime: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_StoryVariantData::VT_STARTTIME, startTime, 0);
    }
    #[inline]
    pub fn add_endTime(&mut self, endTime: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_StoryVariantData::VT_ENDTIME, endTime, 0);
    }
    #[inline]
    pub fn add_template(&mut self, template: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StoryVariantData::VT_TEMPLATE,
            template,
        );
    }
    #[inline]
    pub fn add_param(
        &mut self,
        param: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StoryVariantData::VT_PARAM,
            param,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StoryVariantDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StoryVariantDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StoryVariantData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StoryVariantData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StoryVariantData");
        ds.field("plotTaskId", &self.plotTaskId());
        ds.field("spStoryId", &self.spStoryId());
        ds.field("storyId", &self.storyId());
        ds.field("priority", &self.priority());
        ds.field("startTime", &self.startTime());
        ds.field("endTime", &self.endTime());
        ds.field("template", &self.template());
        ds.field("param", &self.param());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StoryVariantDataT {
    pub plotTaskId: Option<String>,
    pub spStoryId: Option<String>,
    pub storyId: Option<String>,
    pub priority: i32,
    pub startTime: i64,
    pub endTime: i64,
    pub template: Option<String>,
    pub param: Option<Vec<String>>,
}
impl Default for clz_Torappu_StoryVariantDataT {
    fn default() -> Self {
        Self {
            plotTaskId: None,
            spStoryId: None,
            storyId: None,
            priority: 0,
            startTime: 0,
            endTime: 0,
            template: None,
            param: None,
        }
    }
}
impl clz_Torappu_StoryVariantDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StoryVariantData<'b>> {
        let plotTaskId = self.plotTaskId.as_ref().map(|x| _fbb.create_string(x));
        let spStoryId = self.spStoryId.as_ref().map(|x| _fbb.create_string(x));
        let storyId = self.storyId.as_ref().map(|x| _fbb.create_string(x));
        let priority = self.priority;
        let startTime = self.startTime;
        let endTime = self.endTime;
        let template = self.template.as_ref().map(|x| _fbb.create_string(x));
        let param = self.param.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_StoryVariantData::create(
            _fbb,
            &clz_Torappu_StoryVariantDataArgs {
                plotTaskId,
                spStoryId,
                storyId,
                priority,
                startTime,
                endTime,
                template,
                param,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_StoryVariantDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_StoryVariantData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_StoryVariantData<'a> {
    type Inner = dict__string__clz_Torappu_StoryVariantData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_StoryVariantData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_StoryVariantData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_StoryVariantDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StoryVariantData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_StoryVariantDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_StoryVariantDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_StoryVariantDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_StoryVariantData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_StoryVariantData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_StoryVariantData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StoryVariantData>>(
                    dict__string__clz_Torappu_StoryVariantData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_StoryVariantData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StoryVariantData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_StoryVariantDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_StoryVariantData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_StoryVariantDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_StoryVariantDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_StoryVariantData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_StoryVariantData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_StoryVariantDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_StoryVariantDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_StoryVariantData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_StoryVariantData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StoryVariantData>>(
                dict__string__clz_Torappu_StoryVariantData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_StoryVariantDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_StoryVariantDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StoryVariantData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_StoryVariantData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_StoryVariantData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_StoryVariantData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_StoryVariantDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_StoryVariantDataT>>,
}
impl Default for dict__string__clz_Torappu_StoryVariantDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_StoryVariantDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StoryVariantData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_StoryVariantData::create(
            _fbb,
            &dict__string__clz_Torappu_StoryVariantDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_GuidebookConfigDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_GuidebookConfigData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_GuidebookConfigData<'a> {
    type Inner = clz_Torappu_GuidebookConfigData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_GuidebookConfigData<'a> {
    pub const VT_CONFIGID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_PAGEIDLIST: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_GuidebookConfigData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_GuidebookConfigDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_GuidebookConfigData<'bldr>> {
        let mut builder = clz_Torappu_GuidebookConfigDataBuilder::new(_fbb);
        if let Some(x) = args.pageIdList {
            builder.add_pageIdList(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.configId {
            builder.add_configId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_GuidebookConfigDataT {
        let configId = self.configId().map(|x| x.to_string());
        let sortId = self.sortId();
        let pageIdList = self
            .pageIdList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_GuidebookConfigDataT {
            configId,
            sortId,
            pageIdList,
        }
    }

    #[inline]
    pub fn configId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_GuidebookConfigData::VT_CONFIGID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_GuidebookConfigData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn pageIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_GuidebookConfigData::VT_PAGEIDLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_GuidebookConfigData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "configId",
                Self::VT_CONFIGID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("pageIdList", Self::VT_PAGEIDLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_GuidebookConfigDataArgs<'a> {
    pub configId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub pageIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_GuidebookConfigDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_GuidebookConfigDataArgs {
            configId: None,
            sortId: 0,
            pageIdList: None,
        }
    }
}

impl Serialize for clz_Torappu_GuidebookConfigData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_GuidebookConfigData", 3)?;
        if let Some(f) = self.configId() {
            s.serialize_field("configId", &f)?;
        } else {
            s.skip_field("configId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.pageIdList() {
            s.serialize_field("pageIdList", &f)?;
        } else {
            s.skip_field("pageIdList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_GuidebookConfigDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_GuidebookConfigDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_configId(&mut self, configId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_GuidebookConfigData::VT_CONFIGID,
            configId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_GuidebookConfigData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_pageIdList(
        &mut self,
        pageIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_GuidebookConfigData::VT_PAGEIDLIST,
            pageIdList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_GuidebookConfigDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_GuidebookConfigDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_GuidebookConfigData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_GuidebookConfigData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_GuidebookConfigData");
        ds.field("configId", &self.configId());
        ds.field("sortId", &self.sortId());
        ds.field("pageIdList", &self.pageIdList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_GuidebookConfigDataT {
    pub configId: Option<String>,
    pub sortId: i32,
    pub pageIdList: Option<Vec<String>>,
}
impl Default for clz_Torappu_GuidebookConfigDataT {
    fn default() -> Self {
        Self {
            configId: None,
            sortId: 0,
            pageIdList: None,
        }
    }
}
impl clz_Torappu_GuidebookConfigDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_GuidebookConfigData<'b>> {
        let configId = self.configId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let pageIdList = self.pageIdList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_GuidebookConfigData::create(
            _fbb,
            &clz_Torappu_GuidebookConfigDataArgs {
                configId,
                sortId,
                pageIdList,
            },
        )
    }
}
pub enum clz_Torappu_GuidebookGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_GuidebookGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_GuidebookGroupData<'a> {
    type Inner = clz_Torappu_GuidebookGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_GuidebookGroupData<'a> {
    pub const VT_GROUPID: flatbuffers::VOffsetT = 4;
    pub const VT_GUIDETARGET: flatbuffers::VOffsetT = 6;
    pub const VT_SUBSIGNAL: flatbuffers::VOffsetT = 8;
    pub const VT_CONFIGLIST: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_GuidebookGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_GuidebookGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_GuidebookGroupData<'bldr>> {
        let mut builder = clz_Torappu_GuidebookGroupDataBuilder::new(_fbb);
        if let Some(x) = args.configList {
            builder.add_configList(x);
        }
        if let Some(x) = args.subSignal {
            builder.add_subSignal(x);
        }
        builder.add_guideTarget(args.guideTarget);
        if let Some(x) = args.groupId {
            builder.add_groupId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_GuidebookGroupDataT {
        let groupId = self.groupId().map(|x| x.to_string());
        let guideTarget = self.guideTarget();
        let subSignal = self.subSignal().map(|x| x.to_string());
        let configList = self
            .configList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_GuidebookGroupDataT {
            groupId,
            guideTarget,
            subSignal,
            configList,
        }
    }

    #[inline]
    pub fn groupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_GuidebookGroupData::VT_GROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn guideTarget(&self) -> enum__Torappu_UIGuideTarget {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_UIGuideTarget>(
                    clz_Torappu_GuidebookGroupData::VT_GUIDETARGET,
                    Some(enum__Torappu_UIGuideTarget::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn subSignal(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_GuidebookGroupData::VT_SUBSIGNAL,
                None,
            )
        }
    }
    #[inline]
    pub fn configList(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_GuidebookConfigData<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_GuidebookConfigData>,
                >,
            >>(clz_Torappu_GuidebookGroupData::VT_CONFIGLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_GuidebookGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("groupId", Self::VT_GROUPID, false)?
            .visit_field::<enum__Torappu_UIGuideTarget>("guideTarget", Self::VT_GUIDETARGET, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "subSignal",
                Self::VT_SUBSIGNAL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_GuidebookConfigData>,
                >,
            >>("configList", Self::VT_CONFIGLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_GuidebookGroupDataArgs<'a> {
    pub groupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub guideTarget: enum__Torappu_UIGuideTarget,
    pub subSignal: Option<flatbuffers::WIPOffset<&'a str>>,
    pub configList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_GuidebookConfigData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_GuidebookGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_GuidebookGroupDataArgs {
            groupId: None,
            guideTarget: enum__Torappu_UIGuideTarget::NONE,
            subSignal: None,
            configList: None,
        }
    }
}

impl Serialize for clz_Torappu_GuidebookGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_GuidebookGroupData", 4)?;
        if let Some(f) = self.groupId() {
            s.serialize_field("groupId", &f)?;
        } else {
            s.skip_field("groupId")?;
        }
        s.serialize_field("guideTarget", &self.guideTarget())?;
        if let Some(f) = self.subSignal() {
            s.serialize_field("subSignal", &f)?;
        } else {
            s.skip_field("subSignal")?;
        }
        if let Some(f) = self.configList() {
            s.serialize_field("configList", &f)?;
        } else {
            s.skip_field("configList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_GuidebookGroupDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_GuidebookGroupDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_groupId(&mut self, groupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_GuidebookGroupData::VT_GROUPID,
            groupId,
        );
    }
    #[inline]
    pub fn add_guideTarget(&mut self, guideTarget: enum__Torappu_UIGuideTarget) {
        self.fbb_.push_slot::<enum__Torappu_UIGuideTarget>(
            clz_Torappu_GuidebookGroupData::VT_GUIDETARGET,
            guideTarget,
            enum__Torappu_UIGuideTarget::NONE,
        );
    }
    #[inline]
    pub fn add_subSignal(&mut self, subSignal: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_GuidebookGroupData::VT_SUBSIGNAL,
            subSignal,
        );
    }
    #[inline]
    pub fn add_configList(
        &mut self,
        configList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_GuidebookConfigData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_GuidebookGroupData::VT_CONFIGLIST,
            configList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_GuidebookGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_GuidebookGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_GuidebookGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_GuidebookGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_GuidebookGroupData");
        ds.field("groupId", &self.groupId());
        ds.field("guideTarget", &self.guideTarget());
        ds.field("subSignal", &self.subSignal());
        ds.field("configList", &self.configList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_GuidebookGroupDataT {
    pub groupId: Option<String>,
    pub guideTarget: enum__Torappu_UIGuideTarget,
    pub subSignal: Option<String>,
    pub configList: Option<Vec<clz_Torappu_GuidebookConfigDataT>>,
}
impl Default for clz_Torappu_GuidebookGroupDataT {
    fn default() -> Self {
        Self {
            groupId: None,
            guideTarget: enum__Torappu_UIGuideTarget::NONE,
            subSignal: None,
            configList: None,
        }
    }
}
impl clz_Torappu_GuidebookGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_GuidebookGroupData<'b>> {
        let groupId = self.groupId.as_ref().map(|x| _fbb.create_string(x));
        let guideTarget = self.guideTarget;
        let subSignal = self.subSignal.as_ref().map(|x| _fbb.create_string(x));
        let configList = self.configList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_GuidebookGroupData::create(
            _fbb,
            &clz_Torappu_GuidebookGroupDataArgs {
                groupId,
                guideTarget,
                subSignal,
                configList,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_GuidebookGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_GuidebookGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_GuidebookGroupData<'a> {
    type Inner = dict__string__clz_Torappu_GuidebookGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_GuidebookGroupData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_GuidebookGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_GuidebookGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_GuidebookGroupData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_GuidebookGroupDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_GuidebookGroupDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_GuidebookGroupDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_GuidebookGroupData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_GuidebookGroupData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_GuidebookGroupData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_GuidebookGroupData>>(
                    dict__string__clz_Torappu_GuidebookGroupData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_GuidebookGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_GuidebookGroupData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_GuidebookGroupDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_GuidebookGroupData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_GuidebookGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_GuidebookGroupDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_GuidebookGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_GuidebookGroupData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_GuidebookGroupDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_GuidebookGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_GuidebookGroupData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_GuidebookGroupData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_GuidebookGroupData>>(
                dict__string__clz_Torappu_GuidebookGroupData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_GuidebookGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_GuidebookGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_GuidebookGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_GuidebookGroupData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_GuidebookGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_GuidebookGroupData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_GuidebookGroupDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_GuidebookGroupDataT>>,
}
impl Default for dict__string__clz_Torappu_GuidebookGroupDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_GuidebookGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_GuidebookGroupData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_GuidebookGroupData::create(
            _fbb,
            &dict__string__clz_Torappu_GuidebookGroupDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_DisplayMetaDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_DisplayMetaData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_DisplayMetaData<'a> {
    type Inner = clz_Torappu_DisplayMetaData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_DisplayMetaData<'a> {
    pub const VT_PLAYERAVATARDATA: flatbuffers::VOffsetT = 4;
    pub const VT_HOMEBACKGROUNDDATA: flatbuffers::VOffsetT = 6;
    pub const VT_NAMECARDV2DATA: flatbuffers::VOffsetT = 8;
    pub const VT_MAILARCHIVEDATA: flatbuffers::VOffsetT = 10;
    pub const VT_MAILSENDERDATA: flatbuffers::VOffsetT = 12;
    pub const VT_EMOTICONDATA: flatbuffers::VOffsetT = 14;
    pub const VT_STORYVARIANTDATA: flatbuffers::VOffsetT = 16;
    pub const VT_GUIDEBOOKGROUPDATAS: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_DisplayMetaData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_DisplayMetaDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_DisplayMetaData<'bldr>> {
        let mut builder = clz_Torappu_DisplayMetaDataBuilder::new(_fbb);
        if let Some(x) = args.guidebookGroupDatas {
            builder.add_guidebookGroupDatas(x);
        }
        if let Some(x) = args.storyVariantData {
            builder.add_storyVariantData(x);
        }
        if let Some(x) = args.emoticonData {
            builder.add_emoticonData(x);
        }
        if let Some(x) = args.mailSenderData {
            builder.add_mailSenderData(x);
        }
        if let Some(x) = args.mailArchiveData {
            builder.add_mailArchiveData(x);
        }
        if let Some(x) = args.nameCardV2Data {
            builder.add_nameCardV2Data(x);
        }
        if let Some(x) = args.homeBackgroundData {
            builder.add_homeBackgroundData(x);
        }
        if let Some(x) = args.playerAvatarData {
            builder.add_playerAvatarData(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_DisplayMetaDataT {
        let playerAvatarData = self.playerAvatarData().map(|x| Box::new(x.unpack()));
        let homeBackgroundData = self.homeBackgroundData().map(|x| Box::new(x.unpack()));
        let nameCardV2Data = self.nameCardV2Data().map(|x| Box::new(x.unpack()));
        let mailArchiveData = self.mailArchiveData().map(|x| Box::new(x.unpack()));
        let mailSenderData = self.mailSenderData().map(|x| Box::new(x.unpack()));
        let emoticonData = self.emoticonData().map(|x| Box::new(x.unpack()));
        let storyVariantData = self
            .storyVariantData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let guidebookGroupDatas = self
            .guidebookGroupDatas()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_DisplayMetaDataT {
            playerAvatarData,
            homeBackgroundData,
            nameCardV2Data,
            mailArchiveData,
            mailSenderData,
            emoticonData,
            storyVariantData,
            guidebookGroupDatas,
        }
    }

    #[inline]
    pub fn playerAvatarData(&self) -> Option<clz_Torappu_PlayerAvatarData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_PlayerAvatarData>>(
                    clz_Torappu_DisplayMetaData::VT_PLAYERAVATARDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn homeBackgroundData(&self) -> Option<clz_Torappu_HomeBackgroundData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_HomeBackgroundData>>(
                    clz_Torappu_DisplayMetaData::VT_HOMEBACKGROUNDDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn nameCardV2Data(&self) -> Option<clz_Torappu_NameCardV2Data<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_NameCardV2Data>>(
                    clz_Torappu_DisplayMetaData::VT_NAMECARDV2DATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn mailArchiveData(&self) -> Option<clz_Torappu_MailArchiveData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_MailArchiveData>>(
                    clz_Torappu_DisplayMetaData::VT_MAILARCHIVEDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn mailSenderData(&self) -> Option<clz_Torappu_MailSenderData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_MailSenderData>>(
                    clz_Torappu_DisplayMetaData::VT_MAILSENDERDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn emoticonData(&self) -> Option<clz_Torappu_EmoticonData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_EmoticonData>>(
                    clz_Torappu_DisplayMetaData::VT_EMOTICONDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn storyVariantData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StoryVariantData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StoryVariantData>,
                >,
            >>(clz_Torappu_DisplayMetaData::VT_STORYVARIANTDATA, None)
        }
    }
    #[inline]
    pub fn guidebookGroupDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_GuidebookGroupData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_GuidebookGroupData>,
                >,
            >>(clz_Torappu_DisplayMetaData::VT_GUIDEBOOKGROUPDATAS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_DisplayMetaData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_PlayerAvatarData>>(
                "playerAvatarData",
                Self::VT_PLAYERAVATARDATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_HomeBackgroundData>>(
                "homeBackgroundData",
                Self::VT_HOMEBACKGROUNDDATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_NameCardV2Data>>(
                "nameCardV2Data",
                Self::VT_NAMECARDV2DATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_MailArchiveData>>(
                "mailArchiveData",
                Self::VT_MAILARCHIVEDATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_MailSenderData>>(
                "mailSenderData",
                Self::VT_MAILSENDERDATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_EmoticonData>>(
                "emoticonData",
                Self::VT_EMOTICONDATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StoryVariantData>,
                >,
            >>("storyVariantData", Self::VT_STORYVARIANTDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_GuidebookGroupData>,
                >,
            >>("guidebookGroupDatas", Self::VT_GUIDEBOOKGROUPDATAS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_DisplayMetaDataArgs<'a> {
    pub playerAvatarData: Option<flatbuffers::WIPOffset<clz_Torappu_PlayerAvatarData<'a>>>,
    pub homeBackgroundData: Option<flatbuffers::WIPOffset<clz_Torappu_HomeBackgroundData<'a>>>,
    pub nameCardV2Data: Option<flatbuffers::WIPOffset<clz_Torappu_NameCardV2Data<'a>>>,
    pub mailArchiveData: Option<flatbuffers::WIPOffset<clz_Torappu_MailArchiveData<'a>>>,
    pub mailSenderData: Option<flatbuffers::WIPOffset<clz_Torappu_MailSenderData<'a>>>,
    pub emoticonData: Option<flatbuffers::WIPOffset<clz_Torappu_EmoticonData<'a>>>,
    pub storyVariantData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StoryVariantData<'a>>,
            >,
        >,
    >,
    pub guidebookGroupDatas: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_GuidebookGroupData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_DisplayMetaDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_DisplayMetaDataArgs {
            playerAvatarData: None,
            homeBackgroundData: None,
            nameCardV2Data: None,
            mailArchiveData: None,
            mailSenderData: None,
            emoticonData: None,
            storyVariantData: None,
            guidebookGroupDatas: None,
        }
    }
}

impl Serialize for clz_Torappu_DisplayMetaData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_DisplayMetaData", 8)?;
        if let Some(f) = self.playerAvatarData() {
            s.serialize_field("playerAvatarData", &f)?;
        } else {
            s.skip_field("playerAvatarData")?;
        }
        if let Some(f) = self.homeBackgroundData() {
            s.serialize_field("homeBackgroundData", &f)?;
        } else {
            s.skip_field("homeBackgroundData")?;
        }
        if let Some(f) = self.nameCardV2Data() {
            s.serialize_field("nameCardV2Data", &f)?;
        } else {
            s.skip_field("nameCardV2Data")?;
        }
        if let Some(f) = self.mailArchiveData() {
            s.serialize_field("mailArchiveData", &f)?;
        } else {
            s.skip_field("mailArchiveData")?;
        }
        if let Some(f) = self.mailSenderData() {
            s.serialize_field("mailSenderData", &f)?;
        } else {
            s.skip_field("mailSenderData")?;
        }
        if let Some(f) = self.emoticonData() {
            s.serialize_field("emoticonData", &f)?;
        } else {
            s.skip_field("emoticonData")?;
        }
        if let Some(f) = self.storyVariantData() {
            s.serialize_field("storyVariantData", &f)?;
        } else {
            s.skip_field("storyVariantData")?;
        }
        if let Some(f) = self.guidebookGroupDatas() {
            s.serialize_field("guidebookGroupDatas", &f)?;
        } else {
            s.skip_field("guidebookGroupDatas")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_DisplayMetaDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_DisplayMetaDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_playerAvatarData(
        &mut self,
        playerAvatarData: flatbuffers::WIPOffset<clz_Torappu_PlayerAvatarData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_PlayerAvatarData>>(
                clz_Torappu_DisplayMetaData::VT_PLAYERAVATARDATA,
                playerAvatarData,
            );
    }
    #[inline]
    pub fn add_homeBackgroundData(
        &mut self,
        homeBackgroundData: flatbuffers::WIPOffset<clz_Torappu_HomeBackgroundData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_HomeBackgroundData>>(
                clz_Torappu_DisplayMetaData::VT_HOMEBACKGROUNDDATA,
                homeBackgroundData,
            );
    }
    #[inline]
    pub fn add_nameCardV2Data(
        &mut self,
        nameCardV2Data: flatbuffers::WIPOffset<clz_Torappu_NameCardV2Data<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_NameCardV2Data>>(
                clz_Torappu_DisplayMetaData::VT_NAMECARDV2DATA,
                nameCardV2Data,
            );
    }
    #[inline]
    pub fn add_mailArchiveData(
        &mut self,
        mailArchiveData: flatbuffers::WIPOffset<clz_Torappu_MailArchiveData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_MailArchiveData>>(
                clz_Torappu_DisplayMetaData::VT_MAILARCHIVEDATA,
                mailArchiveData,
            );
    }
    #[inline]
    pub fn add_mailSenderData(
        &mut self,
        mailSenderData: flatbuffers::WIPOffset<clz_Torappu_MailSenderData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_MailSenderData>>(
                clz_Torappu_DisplayMetaData::VT_MAILSENDERDATA,
                mailSenderData,
            );
    }
    #[inline]
    pub fn add_emoticonData(
        &mut self,
        emoticonData: flatbuffers::WIPOffset<clz_Torappu_EmoticonData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_EmoticonData>>(
                clz_Torappu_DisplayMetaData::VT_EMOTICONDATA,
                emoticonData,
            );
    }
    #[inline]
    pub fn add_storyVariantData(
        &mut self,
        storyVariantData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StoryVariantData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_DisplayMetaData::VT_STORYVARIANTDATA,
            storyVariantData,
        );
    }
    #[inline]
    pub fn add_guidebookGroupDatas(
        &mut self,
        guidebookGroupDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_GuidebookGroupData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_DisplayMetaData::VT_GUIDEBOOKGROUPDATAS,
            guidebookGroupDatas,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_DisplayMetaDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_DisplayMetaDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_DisplayMetaData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_DisplayMetaData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_DisplayMetaData");
        ds.field("playerAvatarData", &self.playerAvatarData());
        ds.field("homeBackgroundData", &self.homeBackgroundData());
        ds.field("nameCardV2Data", &self.nameCardV2Data());
        ds.field("mailArchiveData", &self.mailArchiveData());
        ds.field("mailSenderData", &self.mailSenderData());
        ds.field("emoticonData", &self.emoticonData());
        ds.field("storyVariantData", &self.storyVariantData());
        ds.field("guidebookGroupDatas", &self.guidebookGroupDatas());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_DisplayMetaDataT {
    pub playerAvatarData: Option<Box<clz_Torappu_PlayerAvatarDataT>>,
    pub homeBackgroundData: Option<Box<clz_Torappu_HomeBackgroundDataT>>,
    pub nameCardV2Data: Option<Box<clz_Torappu_NameCardV2DataT>>,
    pub mailArchiveData: Option<Box<clz_Torappu_MailArchiveDataT>>,
    pub mailSenderData: Option<Box<clz_Torappu_MailSenderDataT>>,
    pub emoticonData: Option<Box<clz_Torappu_EmoticonDataT>>,
    pub storyVariantData: Option<Vec<dict__string__clz_Torappu_StoryVariantDataT>>,
    pub guidebookGroupDatas: Option<Vec<dict__string__clz_Torappu_GuidebookGroupDataT>>,
}
impl Default for clz_Torappu_DisplayMetaDataT {
    fn default() -> Self {
        Self {
            playerAvatarData: None,
            homeBackgroundData: None,
            nameCardV2Data: None,
            mailArchiveData: None,
            mailSenderData: None,
            emoticonData: None,
            storyVariantData: None,
            guidebookGroupDatas: None,
        }
    }
}
impl clz_Torappu_DisplayMetaDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_DisplayMetaData<'b>> {
        let playerAvatarData = self.playerAvatarData.as_ref().map(|x| x.pack(_fbb));
        let homeBackgroundData = self.homeBackgroundData.as_ref().map(|x| x.pack(_fbb));
        let nameCardV2Data = self.nameCardV2Data.as_ref().map(|x| x.pack(_fbb));
        let mailArchiveData = self.mailArchiveData.as_ref().map(|x| x.pack(_fbb));
        let mailSenderData = self.mailSenderData.as_ref().map(|x| x.pack(_fbb));
        let emoticonData = self.emoticonData.as_ref().map(|x| x.pack(_fbb));
        let storyVariantData = self.storyVariantData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let guidebookGroupDatas = self.guidebookGroupDatas.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_DisplayMetaData::create(
            _fbb,
            &clz_Torappu_DisplayMetaDataArgs {
                playerAvatarData,
                homeBackgroundData,
                nameCardV2Data,
                mailArchiveData,
                mailSenderData,
                emoticonData,
                storyVariantData,
                guidebookGroupDatas,
            },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_DisplayMetaData`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_display_meta_data_unchecked`.
pub fn root_as_clz_torappu_display_meta_data(
    buf: &[u8],
) -> Result<clz_Torappu_DisplayMetaData<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_DisplayMetaData>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_DisplayMetaData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_display_meta_data_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_display_meta_data(
    buf: &[u8],
) -> Result<clz_Torappu_DisplayMetaData<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_DisplayMetaData>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_DisplayMetaData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_display_meta_data_unchecked`.
pub fn root_as_clz_torappu_display_meta_data_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_DisplayMetaData<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_DisplayMetaData<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_DisplayMetaData` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_display_meta_data_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_display_meta_data_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_DisplayMetaData<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_DisplayMetaData<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_DisplayMetaData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_DisplayMetaData`.
pub unsafe fn root_as_clz_torappu_display_meta_data_unchecked(
    buf: &[u8],
) -> clz_Torappu_DisplayMetaData<'_> {
    unsafe { flatbuffers::root_unchecked::<clz_Torappu_DisplayMetaData>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_DisplayMetaData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_DisplayMetaData`.
pub unsafe fn size_prefixed_root_as_clz_torappu_display_meta_data_unchecked(
    buf: &[u8],
) -> clz_Torappu_DisplayMetaData<'_> {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_DisplayMetaData>(buf) }
}
#[inline]
pub fn finish_clz_torappu_display_meta_data_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_DisplayMetaData<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_display_meta_data_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_DisplayMetaData<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
