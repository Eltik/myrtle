// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ZONE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ZONE_TYPE: i32 = 12;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ZONE_TYPE: [enum__Torappu_ZoneType; 13] = [
    enum__Torappu_ZoneType::NONE,
    enum__Torappu_ZoneType::MAINLINE,
    enum__Torappu_ZoneType::WEEKLY,
    enum__Torappu_ZoneType::ACTIVITY,
    enum__Torappu_ZoneType::GUIDE,
    enum__Torappu_ZoneType::TRAINING,
    enum__Torappu_ZoneType::CAMPAIGN,
    enum__Torappu_ZoneType::SIDESTORY,
    enum__Torappu_ZoneType::BRANCHLINE,
    enum__Torappu_ZoneType::ROGUELIKE,
    enum__Torappu_ZoneType::CLIMB_TOWER,
    enum__Torappu_ZoneType::MAINLINE_ACTIVITY,
    enum__Torappu_ZoneType::MAINLINE_RETRO,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ZoneType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ZoneType {
    pub const NONE: Self = Self(0);
    pub const MAINLINE: Self = Self(1);
    pub const WEEKLY: Self = Self(2);
    pub const ACTIVITY: Self = Self(3);
    pub const GUIDE: Self = Self(4);
    pub const TRAINING: Self = Self(5);
    pub const CAMPAIGN: Self = Self(6);
    pub const SIDESTORY: Self = Self(7);
    pub const BRANCHLINE: Self = Self(8);
    pub const ROGUELIKE: Self = Self(9);
    pub const CLIMB_TOWER: Self = Self(10);
    pub const MAINLINE_ACTIVITY: Self = Self(11);
    pub const MAINLINE_RETRO: Self = Self(12);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 12;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::MAINLINE,
        Self::WEEKLY,
        Self::ACTIVITY,
        Self::GUIDE,
        Self::TRAINING,
        Self::CAMPAIGN,
        Self::SIDESTORY,
        Self::BRANCHLINE,
        Self::ROGUELIKE,
        Self::CLIMB_TOWER,
        Self::MAINLINE_ACTIVITY,
        Self::MAINLINE_RETRO,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MAINLINE => Some("MAINLINE"),
            Self::WEEKLY => Some("WEEKLY"),
            Self::ACTIVITY => Some("ACTIVITY"),
            Self::GUIDE => Some("GUIDE"),
            Self::TRAINING => Some("TRAINING"),
            Self::CAMPAIGN => Some("CAMPAIGN"),
            Self::SIDESTORY => Some("SIDESTORY"),
            Self::BRANCHLINE => Some("BRANCHLINE"),
            Self::ROGUELIKE => Some("ROGUELIKE"),
            Self::CLIMB_TOWER => Some("CLIMB_TOWER"),
            Self::MAINLINE_ACTIVITY => Some("MAINLINE_ACTIVITY"),
            Self::MAINLINE_RETRO => Some("MAINLINE_RETRO"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ZoneType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ZoneType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ZoneType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ZoneType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ZoneType {
    type Output = enum__Torappu_ZoneType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ZoneType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ZoneType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ZoneType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_WEEKLY_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_WEEKLY_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_WEEKLY_TYPE: [enum__Torappu_WeeklyType; 4] = [
    enum__Torappu_WeeklyType::NONE,
    enum__Torappu_WeeklyType::MATERIAL,
    enum__Torappu_WeeklyType::SPECIAL,
    enum__Torappu_WeeklyType::EVOLVE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_WeeklyType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_WeeklyType {
    pub const NONE: Self = Self(0);
    pub const MATERIAL: Self = Self(1);
    pub const SPECIAL: Self = Self(2);
    pub const EVOLVE: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::MATERIAL, Self::SPECIAL, Self::EVOLVE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MATERIAL => Some("MATERIAL"),
            Self::SPECIAL => Some("SPECIAL"),
            Self::EVOLVE => Some("EVOLVE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_WeeklyType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_WeeklyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_WeeklyType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_WeeklyType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_WeeklyType {
    type Output = enum__Torappu_WeeklyType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_WeeklyType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_WeeklyType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_WeeklyType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_MAINLINE_ZONE_DATA_ZONE_REPLAY_BTN_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_MAINLINE_ZONE_DATA_ZONE_REPLAY_BTN_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_MAINLINE_ZONE_DATA_ZONE_REPLAY_BTN_TYPE:
    [enum__Torappu_MainlineZoneData_ZoneReplayBtnType; 3] = [
    enum__Torappu_MainlineZoneData_ZoneReplayBtnType::NONE,
    enum__Torappu_MainlineZoneData_ZoneReplayBtnType::RECAP,
    enum__Torappu_MainlineZoneData_ZoneReplayBtnType::REPLAY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_MainlineZoneData_ZoneReplayBtnType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_MainlineZoneData_ZoneReplayBtnType {
    pub const NONE: Self = Self(0);
    pub const RECAP: Self = Self(1);
    pub const REPLAY: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::RECAP, Self::REPLAY];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::RECAP => Some("RECAP"),
            Self::REPLAY => Some("REPLAY"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_MainlineZoneData_ZoneReplayBtnType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_MainlineZoneData_ZoneReplayBtnType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_MainlineZoneData_ZoneReplayBtnType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_MainlineZoneData_ZoneReplayBtnType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_MainlineZoneData_ZoneReplayBtnType {
    type Output = enum__Torappu_MainlineZoneData_ZoneReplayBtnType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_MainlineZoneData_ZoneReplayBtnType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_MainlineZoneData_ZoneReplayBtnType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_MainlineZoneData_ZoneReplayBtnType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_STAGE_DIFF_GROUP: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_STAGE_DIFF_GROUP: i32 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_STAGE_DIFF_GROUP: [enum__Torappu_StageDiffGroup; 5] = [
    enum__Torappu_StageDiffGroup::NONE,
    enum__Torappu_StageDiffGroup::EASY,
    enum__Torappu_StageDiffGroup::NORMAL,
    enum__Torappu_StageDiffGroup::TOUGH,
    enum__Torappu_StageDiffGroup::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_StageDiffGroup(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_StageDiffGroup {
    pub const NONE: Self = Self(0);
    pub const EASY: Self = Self(1);
    pub const NORMAL: Self = Self(2);
    pub const TOUGH: Self = Self(4);
    pub const ALL: Self = Self(7);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 7;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::EASY, Self::NORMAL, Self::TOUGH, Self::ALL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::EASY => Some("EASY"),
            Self::NORMAL => Some("NORMAL"),
            Self::TOUGH => Some("TOUGH"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_StageDiffGroup {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_StageDiffGroup {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_StageDiffGroup",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_StageDiffGroup {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_StageDiffGroup {
    type Output = enum__Torappu_StageDiffGroup;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_StageDiffGroup {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_StageDiffGroup {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_StageDiffGroup {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_RECORD_REWARD_STAGE_DIFF: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_RECORD_REWARD_STAGE_DIFF: i32 = 5;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_RECORD_REWARD_STAGE_DIFF:
    [enum__Torappu_RecordRewardStageDiff; 6] = [
    enum__Torappu_RecordRewardStageDiff::NONE,
    enum__Torappu_RecordRewardStageDiff::EASY,
    enum__Torappu_RecordRewardStageDiff::NORMAL,
    enum__Torappu_RecordRewardStageDiff::TOUGH,
    enum__Torappu_RecordRewardStageDiff::PREDEFINED,
    enum__Torappu_RecordRewardStageDiff::HARD,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RecordRewardStageDiff(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RecordRewardStageDiff {
    pub const NONE: Self = Self(0);
    pub const EASY: Self = Self(1);
    pub const NORMAL: Self = Self(2);
    pub const TOUGH: Self = Self(3);
    pub const PREDEFINED: Self = Self(4);
    pub const HARD: Self = Self(5);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 5;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::EASY,
        Self::NORMAL,
        Self::TOUGH,
        Self::PREDEFINED,
        Self::HARD,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::EASY => Some("EASY"),
            Self::NORMAL => Some("NORMAL"),
            Self::TOUGH => Some("TOUGH"),
            Self::PREDEFINED => Some("PREDEFINED"),
            Self::HARD => Some("HARD"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RecordRewardStageDiff {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RecordRewardStageDiff {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RecordRewardStageDiff",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RecordRewardStageDiff {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RecordRewardStageDiff {
    type Output = enum__Torappu_RecordRewardStageDiff;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RecordRewardStageDiff {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RecordRewardStageDiff {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RecordRewardStageDiff {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ITEM_TYPE: i32 = 90;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ITEM_TYPE: [enum__Torappu_ItemType; 91] = [
    enum__Torappu_ItemType::NONE,
    enum__Torappu_ItemType::CHAR,
    enum__Torappu_ItemType::CARD_EXP,
    enum__Torappu_ItemType::MATERIAL,
    enum__Torappu_ItemType::GOLD,
    enum__Torappu_ItemType::EXP_PLAYER,
    enum__Torappu_ItemType::TKT_TRY,
    enum__Torappu_ItemType::TKT_RECRUIT,
    enum__Torappu_ItemType::TKT_INST_FIN,
    enum__Torappu_ItemType::TKT_GACHA,
    enum__Torappu_ItemType::ACTIVITY_COIN,
    enum__Torappu_ItemType::DIAMOND,
    enum__Torappu_ItemType::DIAMOND_SHD,
    enum__Torappu_ItemType::HGG_SHD,
    enum__Torappu_ItemType::LGG_SHD,
    enum__Torappu_ItemType::FURN,
    enum__Torappu_ItemType::AP_GAMEPLAY,
    enum__Torappu_ItemType::AP_BASE,
    enum__Torappu_ItemType::SOCIAL_PT,
    enum__Torappu_ItemType::CHAR_SKIN,
    enum__Torappu_ItemType::TKT_GACHA_10,
    enum__Torappu_ItemType::TKT_GACHA_PRSV,
    enum__Torappu_ItemType::AP_ITEM,
    enum__Torappu_ItemType::AP_SUPPLY,
    enum__Torappu_ItemType::RENAMING_CARD,
    enum__Torappu_ItemType::RENAMING_CARD_2,
    enum__Torappu_ItemType::ET_STAGE,
    enum__Torappu_ItemType::ACTIVITY_ITEM,
    enum__Torappu_ItemType::VOUCHER_PICK,
    enum__Torappu_ItemType::VOUCHER_CGACHA,
    enum__Torappu_ItemType::VOUCHER_MGACHA,
    enum__Torappu_ItemType::CRS_SHOP_COIN,
    enum__Torappu_ItemType::CRS_RUNE_COIN,
    enum__Torappu_ItemType::LMTGS_COIN,
    enum__Torappu_ItemType::EPGS_COIN,
    enum__Torappu_ItemType::LIMITED_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_FREE_GACHA,
    enum__Torappu_ItemType::REP_COIN,
    enum__Torappu_ItemType::ROGUELIKE,
    enum__Torappu_ItemType::LINKAGE_TKT_GACHA_10,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_4,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_5,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_6,
    enum__Torappu_ItemType::VOUCHER_SKIN,
    enum__Torappu_ItemType::RETRO_COIN,
    enum__Torappu_ItemType::PLAYER_AVATAR,
    enum__Torappu_ItemType::UNI_COLLECTION,
    enum__Torappu_ItemType::VOUCHER_FULL_POTENTIAL,
    enum__Torappu_ItemType::RL_COIN,
    enum__Torappu_ItemType::RETURN_CREDIT,
    enum__Torappu_ItemType::MEDAL,
    enum__Torappu_ItemType::CHARM,
    enum__Torappu_ItemType::HOME_BACKGROUND,
    enum__Torappu_ItemType::EXTERMINATION_AGENT,
    enum__Torappu_ItemType::OPTIONAL_VOUCHER_PICK,
    enum__Torappu_ItemType::ACT_CART_COMPONENT,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_4,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_4,
    enum__Torappu_ItemType::ACTIVITY_POTENTIAL,
    enum__Torappu_ItemType::ITEM_PACK,
    enum__Torappu_ItemType::SANDBOX,
    enum__Torappu_ItemType::FAVOR_ADD_ITEM,
    enum__Torappu_ItemType::CLASSIC_SHD,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_BUFF,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_5,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_6,
    enum__Torappu_ItemType::RETURN_PROGRESS,
    enum__Torappu_ItemType::NEW_PROGRESS,
    enum__Torappu_ItemType::MCARD_VOUCHER,
    enum__Torappu_ItemType::MATERIAL_ISSUE_VOUCHER,
    enum__Torappu_ItemType::CRS_SHOP_COIN_V2,
    enum__Torappu_ItemType::HOME_THEME,
    enum__Torappu_ItemType::SANDBOX_PERM,
    enum__Torappu_ItemType::SANDBOX_TOKEN,
    enum__Torappu_ItemType::TEMPLATE_TRAP,
    enum__Torappu_ItemType::NAME_CARD_SKIN,
    enum__Torappu_ItemType::EMOTICON_SET,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA_10,
    enum__Torappu_ItemType::SO_CHAR_EXP,
    enum__Torappu_ItemType::GIFTPACKAGE_TKT,
    enum__Torappu_ItemType::VOUCHER_SKIN_V2,
    enum__Torappu_ItemType::RANDOM_VOUCHER_SKIN,
    enum__Torappu_ItemType::ACT1VHALFIDLE_ITEM,
    enum__Torappu_ItemType::PLOT_ITEM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ItemType {
    pub const NONE: Self = Self(0);
    pub const CHAR: Self = Self(1);
    pub const CARD_EXP: Self = Self(2);
    pub const MATERIAL: Self = Self(3);
    pub const GOLD: Self = Self(4);
    pub const EXP_PLAYER: Self = Self(5);
    pub const TKT_TRY: Self = Self(6);
    pub const TKT_RECRUIT: Self = Self(7);
    pub const TKT_INST_FIN: Self = Self(8);
    pub const TKT_GACHA: Self = Self(9);
    pub const ACTIVITY_COIN: Self = Self(10);
    pub const DIAMOND: Self = Self(11);
    pub const DIAMOND_SHD: Self = Self(12);
    pub const HGG_SHD: Self = Self(13);
    pub const LGG_SHD: Self = Self(14);
    pub const FURN: Self = Self(15);
    pub const AP_GAMEPLAY: Self = Self(16);
    pub const AP_BASE: Self = Self(17);
    pub const SOCIAL_PT: Self = Self(18);
    pub const CHAR_SKIN: Self = Self(19);
    pub const TKT_GACHA_10: Self = Self(20);
    pub const TKT_GACHA_PRSV: Self = Self(21);
    pub const AP_ITEM: Self = Self(22);
    pub const AP_SUPPLY: Self = Self(23);
    pub const RENAMING_CARD: Self = Self(24);
    pub const RENAMING_CARD_2: Self = Self(25);
    pub const ET_STAGE: Self = Self(26);
    pub const ACTIVITY_ITEM: Self = Self(27);
    pub const VOUCHER_PICK: Self = Self(28);
    pub const VOUCHER_CGACHA: Self = Self(29);
    pub const VOUCHER_MGACHA: Self = Self(30);
    pub const CRS_SHOP_COIN: Self = Self(31);
    pub const CRS_RUNE_COIN: Self = Self(32);
    pub const LMTGS_COIN: Self = Self(33);
    pub const EPGS_COIN: Self = Self(34);
    pub const LIMITED_TKT_GACHA_10: Self = Self(35);
    pub const LIMITED_FREE_GACHA: Self = Self(36);
    pub const REP_COIN: Self = Self(37);
    pub const ROGUELIKE: Self = Self(38);
    pub const LINKAGE_TKT_GACHA_10: Self = Self(39);
    pub const VOUCHER_ELITE_II_4: Self = Self(40);
    pub const VOUCHER_ELITE_II_5: Self = Self(41);
    pub const VOUCHER_ELITE_II_6: Self = Self(42);
    pub const VOUCHER_SKIN: Self = Self(43);
    pub const RETRO_COIN: Self = Self(44);
    pub const PLAYER_AVATAR: Self = Self(45);
    pub const UNI_COLLECTION: Self = Self(46);
    pub const VOUCHER_FULL_POTENTIAL: Self = Self(47);
    pub const RL_COIN: Self = Self(48);
    pub const RETURN_CREDIT: Self = Self(49);
    pub const MEDAL: Self = Self(50);
    pub const CHARM: Self = Self(51);
    pub const HOME_BACKGROUND: Self = Self(52);
    pub const EXTERMINATION_AGENT: Self = Self(53);
    pub const OPTIONAL_VOUCHER_PICK: Self = Self(54);
    pub const ACT_CART_COMPONENT: Self = Self(55);
    pub const VOUCHER_LEVELMAX_6: Self = Self(56);
    pub const VOUCHER_LEVELMAX_5: Self = Self(57);
    pub const VOUCHER_LEVELMAX_4: Self = Self(58);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_6: Self = Self(59);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_5: Self = Self(60);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_4: Self = Self(61);
    pub const ACTIVITY_POTENTIAL: Self = Self(62);
    pub const ITEM_PACK: Self = Self(63);
    pub const SANDBOX: Self = Self(64);
    pub const FAVOR_ADD_ITEM: Self = Self(65);
    pub const CLASSIC_SHD: Self = Self(66);
    pub const CLASSIC_TKT_GACHA: Self = Self(67);
    pub const CLASSIC_TKT_GACHA_10: Self = Self(68);
    pub const LIMITED_BUFF: Self = Self(69);
    pub const CLASSIC_FES_PICK_TIER_5: Self = Self(70);
    pub const CLASSIC_FES_PICK_TIER_6: Self = Self(71);
    pub const RETURN_PROGRESS: Self = Self(72);
    pub const NEW_PROGRESS: Self = Self(73);
    pub const MCARD_VOUCHER: Self = Self(74);
    pub const MATERIAL_ISSUE_VOUCHER: Self = Self(75);
    pub const CRS_SHOP_COIN_V2: Self = Self(76);
    pub const HOME_THEME: Self = Self(77);
    pub const SANDBOX_PERM: Self = Self(78);
    pub const SANDBOX_TOKEN: Self = Self(79);
    pub const TEMPLATE_TRAP: Self = Self(80);
    pub const NAME_CARD_SKIN: Self = Self(81);
    pub const EMOTICON_SET: Self = Self(82);
    pub const EXCLUSIVE_TKT_GACHA: Self = Self(83);
    pub const EXCLUSIVE_TKT_GACHA_10: Self = Self(84);
    pub const SO_CHAR_EXP: Self = Self(85);
    pub const GIFTPACKAGE_TKT: Self = Self(86);
    pub const VOUCHER_SKIN_V2: Self = Self(87);
    pub const RANDOM_VOUCHER_SKIN: Self = Self(88);
    pub const ACT1VHALFIDLE_ITEM: Self = Self(89);
    pub const PLOT_ITEM: Self = Self(90);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 90;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::CHAR,
        Self::CARD_EXP,
        Self::MATERIAL,
        Self::GOLD,
        Self::EXP_PLAYER,
        Self::TKT_TRY,
        Self::TKT_RECRUIT,
        Self::TKT_INST_FIN,
        Self::TKT_GACHA,
        Self::ACTIVITY_COIN,
        Self::DIAMOND,
        Self::DIAMOND_SHD,
        Self::HGG_SHD,
        Self::LGG_SHD,
        Self::FURN,
        Self::AP_GAMEPLAY,
        Self::AP_BASE,
        Self::SOCIAL_PT,
        Self::CHAR_SKIN,
        Self::TKT_GACHA_10,
        Self::TKT_GACHA_PRSV,
        Self::AP_ITEM,
        Self::AP_SUPPLY,
        Self::RENAMING_CARD,
        Self::RENAMING_CARD_2,
        Self::ET_STAGE,
        Self::ACTIVITY_ITEM,
        Self::VOUCHER_PICK,
        Self::VOUCHER_CGACHA,
        Self::VOUCHER_MGACHA,
        Self::CRS_SHOP_COIN,
        Self::CRS_RUNE_COIN,
        Self::LMTGS_COIN,
        Self::EPGS_COIN,
        Self::LIMITED_TKT_GACHA_10,
        Self::LIMITED_FREE_GACHA,
        Self::REP_COIN,
        Self::ROGUELIKE,
        Self::LINKAGE_TKT_GACHA_10,
        Self::VOUCHER_ELITE_II_4,
        Self::VOUCHER_ELITE_II_5,
        Self::VOUCHER_ELITE_II_6,
        Self::VOUCHER_SKIN,
        Self::RETRO_COIN,
        Self::PLAYER_AVATAR,
        Self::UNI_COLLECTION,
        Self::VOUCHER_FULL_POTENTIAL,
        Self::RL_COIN,
        Self::RETURN_CREDIT,
        Self::MEDAL,
        Self::CHARM,
        Self::HOME_BACKGROUND,
        Self::EXTERMINATION_AGENT,
        Self::OPTIONAL_VOUCHER_PICK,
        Self::ACT_CART_COMPONENT,
        Self::VOUCHER_LEVELMAX_6,
        Self::VOUCHER_LEVELMAX_5,
        Self::VOUCHER_LEVELMAX_4,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_6,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_5,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_4,
        Self::ACTIVITY_POTENTIAL,
        Self::ITEM_PACK,
        Self::SANDBOX,
        Self::FAVOR_ADD_ITEM,
        Self::CLASSIC_SHD,
        Self::CLASSIC_TKT_GACHA,
        Self::CLASSIC_TKT_GACHA_10,
        Self::LIMITED_BUFF,
        Self::CLASSIC_FES_PICK_TIER_5,
        Self::CLASSIC_FES_PICK_TIER_6,
        Self::RETURN_PROGRESS,
        Self::NEW_PROGRESS,
        Self::MCARD_VOUCHER,
        Self::MATERIAL_ISSUE_VOUCHER,
        Self::CRS_SHOP_COIN_V2,
        Self::HOME_THEME,
        Self::SANDBOX_PERM,
        Self::SANDBOX_TOKEN,
        Self::TEMPLATE_TRAP,
        Self::NAME_CARD_SKIN,
        Self::EMOTICON_SET,
        Self::EXCLUSIVE_TKT_GACHA,
        Self::EXCLUSIVE_TKT_GACHA_10,
        Self::SO_CHAR_EXP,
        Self::GIFTPACKAGE_TKT,
        Self::VOUCHER_SKIN_V2,
        Self::RANDOM_VOUCHER_SKIN,
        Self::ACT1VHALFIDLE_ITEM,
        Self::PLOT_ITEM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::CHAR => Some("CHAR"),
            Self::CARD_EXP => Some("CARD_EXP"),
            Self::MATERIAL => Some("MATERIAL"),
            Self::GOLD => Some("GOLD"),
            Self::EXP_PLAYER => Some("EXP_PLAYER"),
            Self::TKT_TRY => Some("TKT_TRY"),
            Self::TKT_RECRUIT => Some("TKT_RECRUIT"),
            Self::TKT_INST_FIN => Some("TKT_INST_FIN"),
            Self::TKT_GACHA => Some("TKT_GACHA"),
            Self::ACTIVITY_COIN => Some("ACTIVITY_COIN"),
            Self::DIAMOND => Some("DIAMOND"),
            Self::DIAMOND_SHD => Some("DIAMOND_SHD"),
            Self::HGG_SHD => Some("HGG_SHD"),
            Self::LGG_SHD => Some("LGG_SHD"),
            Self::FURN => Some("FURN"),
            Self::AP_GAMEPLAY => Some("AP_GAMEPLAY"),
            Self::AP_BASE => Some("AP_BASE"),
            Self::SOCIAL_PT => Some("SOCIAL_PT"),
            Self::CHAR_SKIN => Some("CHAR_SKIN"),
            Self::TKT_GACHA_10 => Some("TKT_GACHA_10"),
            Self::TKT_GACHA_PRSV => Some("TKT_GACHA_PRSV"),
            Self::AP_ITEM => Some("AP_ITEM"),
            Self::AP_SUPPLY => Some("AP_SUPPLY"),
            Self::RENAMING_CARD => Some("RENAMING_CARD"),
            Self::RENAMING_CARD_2 => Some("RENAMING_CARD_2"),
            Self::ET_STAGE => Some("ET_STAGE"),
            Self::ACTIVITY_ITEM => Some("ACTIVITY_ITEM"),
            Self::VOUCHER_PICK => Some("VOUCHER_PICK"),
            Self::VOUCHER_CGACHA => Some("VOUCHER_CGACHA"),
            Self::VOUCHER_MGACHA => Some("VOUCHER_MGACHA"),
            Self::CRS_SHOP_COIN => Some("CRS_SHOP_COIN"),
            Self::CRS_RUNE_COIN => Some("CRS_RUNE_COIN"),
            Self::LMTGS_COIN => Some("LMTGS_COIN"),
            Self::EPGS_COIN => Some("EPGS_COIN"),
            Self::LIMITED_TKT_GACHA_10 => Some("LIMITED_TKT_GACHA_10"),
            Self::LIMITED_FREE_GACHA => Some("LIMITED_FREE_GACHA"),
            Self::REP_COIN => Some("REP_COIN"),
            Self::ROGUELIKE => Some("ROGUELIKE"),
            Self::LINKAGE_TKT_GACHA_10 => Some("LINKAGE_TKT_GACHA_10"),
            Self::VOUCHER_ELITE_II_4 => Some("VOUCHER_ELITE_II_4"),
            Self::VOUCHER_ELITE_II_5 => Some("VOUCHER_ELITE_II_5"),
            Self::VOUCHER_ELITE_II_6 => Some("VOUCHER_ELITE_II_6"),
            Self::VOUCHER_SKIN => Some("VOUCHER_SKIN"),
            Self::RETRO_COIN => Some("RETRO_COIN"),
            Self::PLAYER_AVATAR => Some("PLAYER_AVATAR"),
            Self::UNI_COLLECTION => Some("UNI_COLLECTION"),
            Self::VOUCHER_FULL_POTENTIAL => Some("VOUCHER_FULL_POTENTIAL"),
            Self::RL_COIN => Some("RL_COIN"),
            Self::RETURN_CREDIT => Some("RETURN_CREDIT"),
            Self::MEDAL => Some("MEDAL"),
            Self::CHARM => Some("CHARM"),
            Self::HOME_BACKGROUND => Some("HOME_BACKGROUND"),
            Self::EXTERMINATION_AGENT => Some("EXTERMINATION_AGENT"),
            Self::OPTIONAL_VOUCHER_PICK => Some("OPTIONAL_VOUCHER_PICK"),
            Self::ACT_CART_COMPONENT => Some("ACT_CART_COMPONENT"),
            Self::VOUCHER_LEVELMAX_6 => Some("VOUCHER_LEVELMAX_6"),
            Self::VOUCHER_LEVELMAX_5 => Some("VOUCHER_LEVELMAX_5"),
            Self::VOUCHER_LEVELMAX_4 => Some("VOUCHER_LEVELMAX_4"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_6 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_6"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_5 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_5"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_4 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_4"),
            Self::ACTIVITY_POTENTIAL => Some("ACTIVITY_POTENTIAL"),
            Self::ITEM_PACK => Some("ITEM_PACK"),
            Self::SANDBOX => Some("SANDBOX"),
            Self::FAVOR_ADD_ITEM => Some("FAVOR_ADD_ITEM"),
            Self::CLASSIC_SHD => Some("CLASSIC_SHD"),
            Self::CLASSIC_TKT_GACHA => Some("CLASSIC_TKT_GACHA"),
            Self::CLASSIC_TKT_GACHA_10 => Some("CLASSIC_TKT_GACHA_10"),
            Self::LIMITED_BUFF => Some("LIMITED_BUFF"),
            Self::CLASSIC_FES_PICK_TIER_5 => Some("CLASSIC_FES_PICK_TIER_5"),
            Self::CLASSIC_FES_PICK_TIER_6 => Some("CLASSIC_FES_PICK_TIER_6"),
            Self::RETURN_PROGRESS => Some("RETURN_PROGRESS"),
            Self::NEW_PROGRESS => Some("NEW_PROGRESS"),
            Self::MCARD_VOUCHER => Some("MCARD_VOUCHER"),
            Self::MATERIAL_ISSUE_VOUCHER => Some("MATERIAL_ISSUE_VOUCHER"),
            Self::CRS_SHOP_COIN_V2 => Some("CRS_SHOP_COIN_V2"),
            Self::HOME_THEME => Some("HOME_THEME"),
            Self::SANDBOX_PERM => Some("SANDBOX_PERM"),
            Self::SANDBOX_TOKEN => Some("SANDBOX_TOKEN"),
            Self::TEMPLATE_TRAP => Some("TEMPLATE_TRAP"),
            Self::NAME_CARD_SKIN => Some("NAME_CARD_SKIN"),
            Self::EMOTICON_SET => Some("EMOTICON_SET"),
            Self::EXCLUSIVE_TKT_GACHA => Some("EXCLUSIVE_TKT_GACHA"),
            Self::EXCLUSIVE_TKT_GACHA_10 => Some("EXCLUSIVE_TKT_GACHA_10"),
            Self::SO_CHAR_EXP => Some("SO_CHAR_EXP"),
            Self::GIFTPACKAGE_TKT => Some("GIFTPACKAGE_TKT"),
            Self::VOUCHER_SKIN_V2 => Some("VOUCHER_SKIN_V2"),
            Self::RANDOM_VOUCHER_SKIN => Some("RANDOM_VOUCHER_SKIN"),
            Self::ACT1VHALFIDLE_ITEM => Some("ACT1VHALFIDLE_ITEM"),
            Self::PLOT_ITEM => Some("PLOT_ITEM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ItemType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ItemType {
    type Output = enum__Torappu_ItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ItemType {}
pub enum clz_Torappu_ZoneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ZoneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ZoneData<'a> {
    type Inner = clz_Torappu_ZoneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ZoneData<'a> {
    pub const VT_ZONEID: flatbuffers::VOffsetT = 4;
    pub const VT_ZONEINDEX: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;
    pub const VT_ZONENAMEFIRST: flatbuffers::VOffsetT = 10;
    pub const VT_ZONENAMESECOND: flatbuffers::VOffsetT = 12;
    pub const VT_ZONENAMETITLECURRENT: flatbuffers::VOffsetT = 14;
    pub const VT_ZONENAMETITLEUNCURRENT: flatbuffers::VOffsetT = 16;
    pub const VT_ZONENAMETITLEEX: flatbuffers::VOffsetT = 18;
    pub const VT_ZONENAMETHIRD: flatbuffers::VOffsetT = 20;
    pub const VT_LOCKEDTEXT: flatbuffers::VOffsetT = 22;
    pub const VT_ANTISPOILERID: flatbuffers::VOffsetT = 24;
    pub const VT_CANPREVIEW: flatbuffers::VOffsetT = 26;
    pub const VT_HASADDITIONALPANEL: flatbuffers::VOffsetT = 28;
    pub const VT_SIXSTARMILESTONEGROUPID: flatbuffers::VOffsetT = 30;
    pub const VT_BINDMAINLINEZONEID: flatbuffers::VOffsetT = 32;
    pub const VT_BINDMAINLINERETROZONEID: flatbuffers::VOffsetT = 34;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ZoneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ZoneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ZoneData<'bldr>> {
        let mut builder = clz_Torappu_ZoneDataBuilder::new(_fbb);
        if let Some(x) = args.bindMainlineRetroZoneId {
            builder.add_bindMainlineRetroZoneId(x);
        }
        if let Some(x) = args.bindMainlineZoneId {
            builder.add_bindMainlineZoneId(x);
        }
        if let Some(x) = args.sixStarMilestoneGroupId {
            builder.add_sixStarMilestoneGroupId(x);
        }
        if let Some(x) = args.antiSpoilerId {
            builder.add_antiSpoilerId(x);
        }
        if let Some(x) = args.lockedText {
            builder.add_lockedText(x);
        }
        if let Some(x) = args.zoneNameThird {
            builder.add_zoneNameThird(x);
        }
        if let Some(x) = args.zoneNameTitleEx {
            builder.add_zoneNameTitleEx(x);
        }
        if let Some(x) = args.zoneNameTitleUnCurrent {
            builder.add_zoneNameTitleUnCurrent(x);
        }
        if let Some(x) = args.zoneNameTitleCurrent {
            builder.add_zoneNameTitleCurrent(x);
        }
        if let Some(x) = args.zoneNameSecond {
            builder.add_zoneNameSecond(x);
        }
        if let Some(x) = args.zoneNameFirst {
            builder.add_zoneNameFirst(x);
        }
        builder.add_type_(args.type_);
        builder.add_zoneIndex(args.zoneIndex);
        if let Some(x) = args.zoneID {
            builder.add_zoneID(x);
        }
        builder.add_hasAdditionalPanel(args.hasAdditionalPanel);
        builder.add_canPreview(args.canPreview);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ZoneDataT {
        let zoneID = self.zoneID().map(|x| x.to_string());
        let zoneIndex = self.zoneIndex();
        let type_ = self.type_();
        let zoneNameFirst = self.zoneNameFirst().map(|x| x.to_string());
        let zoneNameSecond = self.zoneNameSecond().map(|x| x.to_string());
        let zoneNameTitleCurrent = self.zoneNameTitleCurrent().map(|x| x.to_string());
        let zoneNameTitleUnCurrent = self.zoneNameTitleUnCurrent().map(|x| x.to_string());
        let zoneNameTitleEx = self.zoneNameTitleEx().map(|x| x.to_string());
        let zoneNameThird = self.zoneNameThird().map(|x| x.to_string());
        let lockedText = self.lockedText().map(|x| x.to_string());
        let antiSpoilerId = self.antiSpoilerId().map(|x| x.to_string());
        let canPreview = self.canPreview();
        let hasAdditionalPanel = self.hasAdditionalPanel();
        let sixStarMilestoneGroupId = self.sixStarMilestoneGroupId().map(|x| x.to_string());
        let bindMainlineZoneId = self.bindMainlineZoneId().map(|x| x.to_string());
        let bindMainlineRetroZoneId = self.bindMainlineRetroZoneId().map(|x| x.to_string());
        clz_Torappu_ZoneDataT {
            zoneID,
            zoneIndex,
            type_,
            zoneNameFirst,
            zoneNameSecond,
            zoneNameTitleCurrent,
            zoneNameTitleUnCurrent,
            zoneNameTitleEx,
            zoneNameThird,
            lockedText,
            antiSpoilerId,
            canPreview,
            hasAdditionalPanel,
            sixStarMilestoneGroupId,
            bindMainlineZoneId,
            bindMainlineRetroZoneId,
        }
    }

    #[inline]
    pub fn zoneID(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_ZoneData::VT_ZONEID, None)
        }
    }
    #[inline]
    pub fn zoneIndex(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ZoneData::VT_ZONEINDEX, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ZoneType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ZoneType>(
                    clz_Torappu_ZoneData::VT_TYPE_,
                    Some(enum__Torappu_ZoneType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn zoneNameFirst(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneData::VT_ZONENAMEFIRST,
                None,
            )
        }
    }
    #[inline]
    pub fn zoneNameSecond(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneData::VT_ZONENAMESECOND,
                None,
            )
        }
    }
    #[inline]
    pub fn zoneNameTitleCurrent(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneData::VT_ZONENAMETITLECURRENT,
                None,
            )
        }
    }
    #[inline]
    pub fn zoneNameTitleUnCurrent(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneData::VT_ZONENAMETITLEUNCURRENT,
                None,
            )
        }
    }
    #[inline]
    pub fn zoneNameTitleEx(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneData::VT_ZONENAMETITLEEX,
                None,
            )
        }
    }
    #[inline]
    pub fn zoneNameThird(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneData::VT_ZONENAMETHIRD,
                None,
            )
        }
    }
    #[inline]
    pub fn lockedText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneData::VT_LOCKEDTEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn antiSpoilerId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneData::VT_ANTISPOILERID,
                None,
            )
        }
    }
    #[inline]
    pub fn canPreview(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_ZoneData::VT_CANPREVIEW, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn hasAdditionalPanel(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_ZoneData::VT_HASADDITIONALPANEL, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn sixStarMilestoneGroupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneData::VT_SIXSTARMILESTONEGROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn bindMainlineZoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneData::VT_BINDMAINLINEZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn bindMainlineRetroZoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneData::VT_BINDMAINLINERETROZONEID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ZoneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zoneID", Self::VT_ZONEID, false)?
            .visit_field::<i32>("zoneIndex", Self::VT_ZONEINDEX, false)?
            .visit_field::<enum__Torappu_ZoneType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "zoneNameFirst",
                Self::VT_ZONENAMEFIRST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "zoneNameSecond",
                Self::VT_ZONENAMESECOND,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "zoneNameTitleCurrent",
                Self::VT_ZONENAMETITLECURRENT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "zoneNameTitleUnCurrent",
                Self::VT_ZONENAMETITLEUNCURRENT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "zoneNameTitleEx",
                Self::VT_ZONENAMETITLEEX,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "zoneNameThird",
                Self::VT_ZONENAMETHIRD,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "lockedText",
                Self::VT_LOCKEDTEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "antiSpoilerId",
                Self::VT_ANTISPOILERID,
                false,
            )?
            .visit_field::<bool>("canPreview", Self::VT_CANPREVIEW, false)?
            .visit_field::<bool>("hasAdditionalPanel", Self::VT_HASADDITIONALPANEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "sixStarMilestoneGroupId",
                Self::VT_SIXSTARMILESTONEGROUPID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bindMainlineZoneId",
                Self::VT_BINDMAINLINEZONEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bindMainlineRetroZoneId",
                Self::VT_BINDMAINLINERETROZONEID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ZoneDataArgs<'a> {
    pub zoneID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneIndex: i32,
    pub type_: enum__Torappu_ZoneType,
    pub zoneNameFirst: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneNameSecond: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneNameTitleCurrent: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneNameTitleUnCurrent: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneNameTitleEx: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneNameThird: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lockedText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub antiSpoilerId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub canPreview: bool,
    pub hasAdditionalPanel: bool,
    pub sixStarMilestoneGroupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bindMainlineZoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bindMainlineRetroZoneId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ZoneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ZoneDataArgs {
            zoneID: None,
            zoneIndex: 0,
            type_: enum__Torappu_ZoneType::NONE,
            zoneNameFirst: None,
            zoneNameSecond: None,
            zoneNameTitleCurrent: None,
            zoneNameTitleUnCurrent: None,
            zoneNameTitleEx: None,
            zoneNameThird: None,
            lockedText: None,
            antiSpoilerId: None,
            canPreview: false,
            hasAdditionalPanel: false,
            sixStarMilestoneGroupId: None,
            bindMainlineZoneId: None,
            bindMainlineRetroZoneId: None,
        }
    }
}

impl Serialize for clz_Torappu_ZoneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ZoneData", 16)?;
        if let Some(f) = self.zoneID() {
            s.serialize_field("zoneID", &f)?;
        } else {
            s.skip_field("zoneID")?;
        }
        s.serialize_field("zoneIndex", &self.zoneIndex())?;
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.zoneNameFirst() {
            s.serialize_field("zoneNameFirst", &f)?;
        } else {
            s.skip_field("zoneNameFirst")?;
        }
        if let Some(f) = self.zoneNameSecond() {
            s.serialize_field("zoneNameSecond", &f)?;
        } else {
            s.skip_field("zoneNameSecond")?;
        }
        if let Some(f) = self.zoneNameTitleCurrent() {
            s.serialize_field("zoneNameTitleCurrent", &f)?;
        } else {
            s.skip_field("zoneNameTitleCurrent")?;
        }
        if let Some(f) = self.zoneNameTitleUnCurrent() {
            s.serialize_field("zoneNameTitleUnCurrent", &f)?;
        } else {
            s.skip_field("zoneNameTitleUnCurrent")?;
        }
        if let Some(f) = self.zoneNameTitleEx() {
            s.serialize_field("zoneNameTitleEx", &f)?;
        } else {
            s.skip_field("zoneNameTitleEx")?;
        }
        if let Some(f) = self.zoneNameThird() {
            s.serialize_field("zoneNameThird", &f)?;
        } else {
            s.skip_field("zoneNameThird")?;
        }
        if let Some(f) = self.lockedText() {
            s.serialize_field("lockedText", &f)?;
        } else {
            s.skip_field("lockedText")?;
        }
        if let Some(f) = self.antiSpoilerId() {
            s.serialize_field("antiSpoilerId", &f)?;
        } else {
            s.skip_field("antiSpoilerId")?;
        }
        s.serialize_field("canPreview", &self.canPreview())?;
        s.serialize_field("hasAdditionalPanel", &self.hasAdditionalPanel())?;
        if let Some(f) = self.sixStarMilestoneGroupId() {
            s.serialize_field("sixStarMilestoneGroupId", &f)?;
        } else {
            s.skip_field("sixStarMilestoneGroupId")?;
        }
        if let Some(f) = self.bindMainlineZoneId() {
            s.serialize_field("bindMainlineZoneId", &f)?;
        } else {
            s.skip_field("bindMainlineZoneId")?;
        }
        if let Some(f) = self.bindMainlineRetroZoneId() {
            s.serialize_field("bindMainlineRetroZoneId", &f)?;
        } else {
            s.skip_field("bindMainlineRetroZoneId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ZoneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ZoneDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_zoneID(&mut self, zoneID: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ZoneData::VT_ZONEID, zoneID);
    }
    #[inline]
    pub fn add_zoneIndex(&mut self, zoneIndex: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ZoneData::VT_ZONEINDEX, zoneIndex, 0);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ZoneType) {
        self.fbb_.push_slot::<enum__Torappu_ZoneType>(
            clz_Torappu_ZoneData::VT_TYPE_,
            type_,
            enum__Torappu_ZoneType::NONE,
        );
    }
    #[inline]
    pub fn add_zoneNameFirst(&mut self, zoneNameFirst: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneData::VT_ZONENAMEFIRST,
            zoneNameFirst,
        );
    }
    #[inline]
    pub fn add_zoneNameSecond(&mut self, zoneNameSecond: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneData::VT_ZONENAMESECOND,
            zoneNameSecond,
        );
    }
    #[inline]
    pub fn add_zoneNameTitleCurrent(
        &mut self,
        zoneNameTitleCurrent: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneData::VT_ZONENAMETITLECURRENT,
            zoneNameTitleCurrent,
        );
    }
    #[inline]
    pub fn add_zoneNameTitleUnCurrent(
        &mut self,
        zoneNameTitleUnCurrent: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneData::VT_ZONENAMETITLEUNCURRENT,
            zoneNameTitleUnCurrent,
        );
    }
    #[inline]
    pub fn add_zoneNameTitleEx(&mut self, zoneNameTitleEx: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneData::VT_ZONENAMETITLEEX,
            zoneNameTitleEx,
        );
    }
    #[inline]
    pub fn add_zoneNameThird(&mut self, zoneNameThird: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneData::VT_ZONENAMETHIRD,
            zoneNameThird,
        );
    }
    #[inline]
    pub fn add_lockedText(&mut self, lockedText: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneData::VT_LOCKEDTEXT,
            lockedText,
        );
    }
    #[inline]
    pub fn add_antiSpoilerId(&mut self, antiSpoilerId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneData::VT_ANTISPOILERID,
            antiSpoilerId,
        );
    }
    #[inline]
    pub fn add_canPreview(&mut self, canPreview: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_ZoneData::VT_CANPREVIEW, canPreview, false);
    }
    #[inline]
    pub fn add_hasAdditionalPanel(&mut self, hasAdditionalPanel: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_ZoneData::VT_HASADDITIONALPANEL,
            hasAdditionalPanel,
            false,
        );
    }
    #[inline]
    pub fn add_sixStarMilestoneGroupId(
        &mut self,
        sixStarMilestoneGroupId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneData::VT_SIXSTARMILESTONEGROUPID,
            sixStarMilestoneGroupId,
        );
    }
    #[inline]
    pub fn add_bindMainlineZoneId(&mut self, bindMainlineZoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneData::VT_BINDMAINLINEZONEID,
            bindMainlineZoneId,
        );
    }
    #[inline]
    pub fn add_bindMainlineRetroZoneId(
        &mut self,
        bindMainlineRetroZoneId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneData::VT_BINDMAINLINERETROZONEID,
            bindMainlineRetroZoneId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ZoneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ZoneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ZoneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ZoneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ZoneData");
        ds.field("zoneID", &self.zoneID());
        ds.field("zoneIndex", &self.zoneIndex());
        ds.field("type_", &self.type_());
        ds.field("zoneNameFirst", &self.zoneNameFirst());
        ds.field("zoneNameSecond", &self.zoneNameSecond());
        ds.field("zoneNameTitleCurrent", &self.zoneNameTitleCurrent());
        ds.field("zoneNameTitleUnCurrent", &self.zoneNameTitleUnCurrent());
        ds.field("zoneNameTitleEx", &self.zoneNameTitleEx());
        ds.field("zoneNameThird", &self.zoneNameThird());
        ds.field("lockedText", &self.lockedText());
        ds.field("antiSpoilerId", &self.antiSpoilerId());
        ds.field("canPreview", &self.canPreview());
        ds.field("hasAdditionalPanel", &self.hasAdditionalPanel());
        ds.field("sixStarMilestoneGroupId", &self.sixStarMilestoneGroupId());
        ds.field("bindMainlineZoneId", &self.bindMainlineZoneId());
        ds.field("bindMainlineRetroZoneId", &self.bindMainlineRetroZoneId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ZoneDataT {
    pub zoneID: Option<String>,
    pub zoneIndex: i32,
    pub type_: enum__Torappu_ZoneType,
    pub zoneNameFirst: Option<String>,
    pub zoneNameSecond: Option<String>,
    pub zoneNameTitleCurrent: Option<String>,
    pub zoneNameTitleUnCurrent: Option<String>,
    pub zoneNameTitleEx: Option<String>,
    pub zoneNameThird: Option<String>,
    pub lockedText: Option<String>,
    pub antiSpoilerId: Option<String>,
    pub canPreview: bool,
    pub hasAdditionalPanel: bool,
    pub sixStarMilestoneGroupId: Option<String>,
    pub bindMainlineZoneId: Option<String>,
    pub bindMainlineRetroZoneId: Option<String>,
}
impl Default for clz_Torappu_ZoneDataT {
    fn default() -> Self {
        Self {
            zoneID: None,
            zoneIndex: 0,
            type_: enum__Torappu_ZoneType::NONE,
            zoneNameFirst: None,
            zoneNameSecond: None,
            zoneNameTitleCurrent: None,
            zoneNameTitleUnCurrent: None,
            zoneNameTitleEx: None,
            zoneNameThird: None,
            lockedText: None,
            antiSpoilerId: None,
            canPreview: false,
            hasAdditionalPanel: false,
            sixStarMilestoneGroupId: None,
            bindMainlineZoneId: None,
            bindMainlineRetroZoneId: None,
        }
    }
}
impl clz_Torappu_ZoneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ZoneData<'b>> {
        let zoneID = self.zoneID.as_ref().map(|x| _fbb.create_string(x));
        let zoneIndex = self.zoneIndex;
        let type_ = self.type_;
        let zoneNameFirst = self.zoneNameFirst.as_ref().map(|x| _fbb.create_string(x));
        let zoneNameSecond = self.zoneNameSecond.as_ref().map(|x| _fbb.create_string(x));
        let zoneNameTitleCurrent = self
            .zoneNameTitleCurrent
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let zoneNameTitleUnCurrent = self
            .zoneNameTitleUnCurrent
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let zoneNameTitleEx = self.zoneNameTitleEx.as_ref().map(|x| _fbb.create_string(x));
        let zoneNameThird = self.zoneNameThird.as_ref().map(|x| _fbb.create_string(x));
        let lockedText = self.lockedText.as_ref().map(|x| _fbb.create_string(x));
        let antiSpoilerId = self.antiSpoilerId.as_ref().map(|x| _fbb.create_string(x));
        let canPreview = self.canPreview;
        let hasAdditionalPanel = self.hasAdditionalPanel;
        let sixStarMilestoneGroupId = self
            .sixStarMilestoneGroupId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let bindMainlineZoneId = self
            .bindMainlineZoneId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let bindMainlineRetroZoneId = self
            .bindMainlineRetroZoneId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_ZoneData::create(
            _fbb,
            &clz_Torappu_ZoneDataArgs {
                zoneID,
                zoneIndex,
                type_,
                zoneNameFirst,
                zoneNameSecond,
                zoneNameTitleCurrent,
                zoneNameTitleUnCurrent,
                zoneNameTitleEx,
                zoneNameThird,
                lockedText,
                antiSpoilerId,
                canPreview,
                hasAdditionalPanel,
                sixStarMilestoneGroupId,
                bindMainlineZoneId,
                bindMainlineRetroZoneId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ZoneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ZoneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ZoneData<'a> {
    type Inner = dict__string__clz_Torappu_ZoneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ZoneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ZoneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ZoneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ZoneData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ZoneDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ZoneDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ZoneDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ZoneData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_ZoneData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ZoneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ZoneData>>(
                    dict__string__clz_Torappu_ZoneData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ZoneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ZoneData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ZoneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ZoneData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ZoneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ZoneDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ZoneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_ZoneData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ZoneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ZoneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ZoneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_ZoneData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ZoneData>>(
                dict__string__clz_Torappu_ZoneData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ZoneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ZoneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ZoneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_ZoneData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ZoneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ZoneData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ZoneDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ZoneDataT>>,
}
impl Default for dict__string__clz_Torappu_ZoneDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ZoneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ZoneData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ZoneData::create(
            _fbb,
            &dict__string__clz_Torappu_ZoneDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_WeeklyZoneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_WeeklyZoneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_WeeklyZoneData<'a> {
    type Inner = clz_Torappu_WeeklyZoneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_WeeklyZoneData<'a> {
    pub const VT_DAYSOFWEEK: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_WeeklyZoneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_WeeklyZoneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_WeeklyZoneData<'bldr>> {
        let mut builder = clz_Torappu_WeeklyZoneDataBuilder::new(_fbb);
        builder.add_type_(args.type_);
        if let Some(x) = args.daysOfWeek {
            builder.add_daysOfWeek(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_WeeklyZoneDataT {
        let daysOfWeek = self.daysOfWeek().map(|x| x.into_iter().collect());
        let type_ = self.type_();
        clz_Torappu_WeeklyZoneDataT { daysOfWeek, type_ }
    }

    #[inline]
    pub fn daysOfWeek(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    clz_Torappu_WeeklyZoneData::VT_DAYSOFWEEK,
                    None,
                )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_WeeklyType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_WeeklyType>(
                    clz_Torappu_WeeklyZoneData::VT_TYPE_,
                    Some(enum__Torappu_WeeklyType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_WeeklyZoneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "daysOfWeek",
                Self::VT_DAYSOFWEEK,
                false,
            )?
            .visit_field::<enum__Torappu_WeeklyType>("type_", Self::VT_TYPE_, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_WeeklyZoneDataArgs<'a> {
    pub daysOfWeek: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub type_: enum__Torappu_WeeklyType,
}
impl<'a> Default for clz_Torappu_WeeklyZoneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_WeeklyZoneDataArgs {
            daysOfWeek: None,
            type_: enum__Torappu_WeeklyType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_WeeklyZoneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_WeeklyZoneData", 2)?;
        if let Some(f) = self.daysOfWeek() {
            s.serialize_field("daysOfWeek", &f)?;
        } else {
            s.skip_field("daysOfWeek")?;
        }
        s.serialize_field("type_", &self.type_())?;
        s.end()
    }
}

pub struct clz_Torappu_WeeklyZoneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_WeeklyZoneDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_daysOfWeek(
        &mut self,
        daysOfWeek: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_WeeklyZoneData::VT_DAYSOFWEEK,
            daysOfWeek,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_WeeklyType) {
        self.fbb_.push_slot::<enum__Torappu_WeeklyType>(
            clz_Torappu_WeeklyZoneData::VT_TYPE_,
            type_,
            enum__Torappu_WeeklyType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_WeeklyZoneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_WeeklyZoneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_WeeklyZoneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_WeeklyZoneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_WeeklyZoneData");
        ds.field("daysOfWeek", &self.daysOfWeek());
        ds.field("type_", &self.type_());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_WeeklyZoneDataT {
    pub daysOfWeek: Option<Vec<i32>>,
    pub type_: enum__Torappu_WeeklyType,
}
impl Default for clz_Torappu_WeeklyZoneDataT {
    fn default() -> Self {
        Self {
            daysOfWeek: None,
            type_: enum__Torappu_WeeklyType::NONE,
        }
    }
}
impl clz_Torappu_WeeklyZoneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_WeeklyZoneData<'b>> {
        let daysOfWeek = self.daysOfWeek.as_ref().map(|x| _fbb.create_vector(x));
        let type_ = self.type_;
        clz_Torappu_WeeklyZoneData::create(
            _fbb,
            &clz_Torappu_WeeklyZoneDataArgs { daysOfWeek, type_ },
        )
    }
}
pub enum dict__string__clz_Torappu_WeeklyZoneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_WeeklyZoneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_WeeklyZoneData<'a> {
    type Inner = dict__string__clz_Torappu_WeeklyZoneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_WeeklyZoneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_WeeklyZoneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_WeeklyZoneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_WeeklyZoneData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_WeeklyZoneDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_WeeklyZoneDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_WeeklyZoneDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_WeeklyZoneData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_WeeklyZoneData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_WeeklyZoneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_WeeklyZoneData>>(
                    dict__string__clz_Torappu_WeeklyZoneData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_WeeklyZoneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_WeeklyZoneData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_WeeklyZoneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_WeeklyZoneData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_WeeklyZoneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_WeeklyZoneDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_WeeklyZoneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_WeeklyZoneData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_WeeklyZoneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_WeeklyZoneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_WeeklyZoneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_WeeklyZoneData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_WeeklyZoneData>>(
                dict__string__clz_Torappu_WeeklyZoneData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_WeeklyZoneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_WeeklyZoneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_WeeklyZoneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_WeeklyZoneData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_WeeklyZoneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_WeeklyZoneData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_WeeklyZoneDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_WeeklyZoneDataT>>,
}
impl Default for dict__string__clz_Torappu_WeeklyZoneDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_WeeklyZoneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_WeeklyZoneData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_WeeklyZoneData::create(
            _fbb,
            &dict__string__clz_Torappu_WeeklyZoneDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ZoneValidInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ZoneValidInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ZoneValidInfo<'a> {
    type Inner = clz_Torappu_ZoneValidInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ZoneValidInfo<'a> {
    pub const VT_STARTTS: flatbuffers::VOffsetT = 4;
    pub const VT_ENDTS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ZoneValidInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ZoneValidInfoArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ZoneValidInfo<'bldr>> {
        let mut builder = clz_Torappu_ZoneValidInfoBuilder::new(_fbb);
        builder.add_endTs(args.endTs);
        builder.add_startTs(args.startTs);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ZoneValidInfoT {
        let startTs = self.startTs();
        let endTs = self.endTs();
        clz_Torappu_ZoneValidInfoT { startTs, endTs }
    }

    #[inline]
    pub fn startTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_ZoneValidInfo::VT_STARTTS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_ZoneValidInfo::VT_ENDTS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ZoneValidInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("startTs", Self::VT_STARTTS, false)?
            .visit_field::<i64>("endTs", Self::VT_ENDTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ZoneValidInfoArgs {
    pub startTs: i64,
    pub endTs: i64,
}
impl<'a> Default for clz_Torappu_ZoneValidInfoArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ZoneValidInfoArgs {
            startTs: 0,
            endTs: 0,
        }
    }
}

impl Serialize for clz_Torappu_ZoneValidInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ZoneValidInfo", 2)?;
        s.serialize_field("startTs", &self.startTs())?;
        s.serialize_field("endTs", &self.endTs())?;
        s.end()
    }
}

pub struct clz_Torappu_ZoneValidInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ZoneValidInfoBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_startTs(&mut self, startTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_ZoneValidInfo::VT_STARTTS, startTs, 0);
    }
    #[inline]
    pub fn add_endTs(&mut self, endTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_ZoneValidInfo::VT_ENDTS, endTs, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ZoneValidInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ZoneValidInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ZoneValidInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ZoneValidInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ZoneValidInfo");
        ds.field("startTs", &self.startTs());
        ds.field("endTs", &self.endTs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ZoneValidInfoT {
    pub startTs: i64,
    pub endTs: i64,
}
impl Default for clz_Torappu_ZoneValidInfoT {
    fn default() -> Self {
        Self {
            startTs: 0,
            endTs: 0,
        }
    }
}
impl clz_Torappu_ZoneValidInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ZoneValidInfo<'b>> {
        let startTs = self.startTs;
        let endTs = self.endTs;
        clz_Torappu_ZoneValidInfo::create(_fbb, &clz_Torappu_ZoneValidInfoArgs { startTs, endTs })
    }
}
pub enum dict__string__clz_Torappu_ZoneValidInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ZoneValidInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ZoneValidInfo<'a> {
    type Inner = dict__string__clz_Torappu_ZoneValidInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ZoneValidInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ZoneValidInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ZoneValidInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ZoneValidInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ZoneValidInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ZoneValidInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ZoneValidInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ZoneValidInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_ZoneValidInfo) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ZoneValidInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ZoneValidInfo>>(
                    dict__string__clz_Torappu_ZoneValidInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ZoneValidInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ZoneValidInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ZoneValidInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ZoneValidInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ZoneValidInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ZoneValidInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ZoneValidInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_ZoneValidInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ZoneValidInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ZoneValidInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ZoneValidInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_ZoneValidInfo<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ZoneValidInfo>>(
                dict__string__clz_Torappu_ZoneValidInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ZoneValidInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ZoneValidInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ZoneValidInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_ZoneValidInfo::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ZoneValidInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ZoneValidInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ZoneValidInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ZoneValidInfoT>>,
}
impl Default for dict__string__clz_Torappu_ZoneValidInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ZoneValidInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ZoneValidInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ZoneValidInfo::create(
            _fbb,
            &dict__string__clz_Torappu_ZoneValidInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_MainlineZoneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_MainlineZoneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_MainlineZoneData<'a> {
    type Inner = clz_Torappu_MainlineZoneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_MainlineZoneData<'a> {
    pub const VT_ZONEID: flatbuffers::VOffsetT = 4;
    pub const VT_CHAPTERID: flatbuffers::VOffsetT = 6;
    pub const VT_PREPOSEDZONEID: flatbuffers::VOffsetT = 8;
    pub const VT_ZONEINDEX: flatbuffers::VOffsetT = 10;
    pub const VT_STARTSTAGEID: flatbuffers::VOffsetT = 12;
    pub const VT_ENDSTAGEID: flatbuffers::VOffsetT = 14;
    pub const VT_GAMEMUSICID: flatbuffers::VOffsetT = 16;
    pub const VT_RECAPID: flatbuffers::VOffsetT = 18;
    pub const VT_RECAPPRESTAGEID: flatbuffers::VOffsetT = 20;
    pub const VT_BUTTONNAME: flatbuffers::VOffsetT = 22;
    pub const VT_BUTTONSTYLE: flatbuffers::VOffsetT = 24;
    pub const VT_SPOILALERT: flatbuffers::VOffsetT = 26;
    pub const VT_ZONEOPENTIME: flatbuffers::VOffsetT = 28;
    pub const VT_DIFFGROUP: flatbuffers::VOffsetT = 30;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_MainlineZoneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_MainlineZoneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MainlineZoneData<'bldr>> {
        let mut builder = clz_Torappu_MainlineZoneDataBuilder::new(_fbb);
        builder.add_zoneOpenTime(args.zoneOpenTime);
        if let Some(x) = args.diffGroup {
            builder.add_diffGroup(x);
        }
        builder.add_buttonStyle(args.buttonStyle);
        if let Some(x) = args.buttonName {
            builder.add_buttonName(x);
        }
        if let Some(x) = args.recapPreStageId {
            builder.add_recapPreStageId(x);
        }
        if let Some(x) = args.recapId {
            builder.add_recapId(x);
        }
        if let Some(x) = args.gameMusicId {
            builder.add_gameMusicId(x);
        }
        if let Some(x) = args.endStageId {
            builder.add_endStageId(x);
        }
        if let Some(x) = args.startStageId {
            builder.add_startStageId(x);
        }
        builder.add_zoneIndex(args.zoneIndex);
        if let Some(x) = args.preposedZoneId {
            builder.add_preposedZoneId(x);
        }
        if let Some(x) = args.chapterId {
            builder.add_chapterId(x);
        }
        if let Some(x) = args.zoneId {
            builder.add_zoneId(x);
        }
        builder.add_spoilAlert(args.spoilAlert);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_MainlineZoneDataT {
        let zoneId = self.zoneId().map(|x| x.to_string());
        let chapterId = self.chapterId().map(|x| x.to_string());
        let preposedZoneId = self.preposedZoneId().map(|x| x.to_string());
        let zoneIndex = self.zoneIndex();
        let startStageId = self.startStageId().map(|x| x.to_string());
        let endStageId = self.endStageId().map(|x| x.to_string());
        let gameMusicId = self.gameMusicId().map(|x| x.to_string());
        let recapId = self.recapId().map(|x| x.to_string());
        let recapPreStageId = self.recapPreStageId().map(|x| x.to_string());
        let buttonName = self.buttonName().map(|x| x.to_string());
        let buttonStyle = self.buttonStyle();
        let spoilAlert = self.spoilAlert();
        let zoneOpenTime = self.zoneOpenTime();
        let diffGroup = self.diffGroup().map(|x| x.into_iter().collect());
        clz_Torappu_MainlineZoneDataT {
            zoneId,
            chapterId,
            preposedZoneId,
            zoneIndex,
            startStageId,
            endStageId,
            gameMusicId,
            recapId,
            recapPreStageId,
            buttonName,
            buttonStyle,
            spoilAlert,
            zoneOpenTime,
            diffGroup,
        }
    }

    #[inline]
    pub fn zoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MainlineZoneData::VT_ZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn chapterId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MainlineZoneData::VT_CHAPTERID,
                None,
            )
        }
    }
    #[inline]
    pub fn preposedZoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MainlineZoneData::VT_PREPOSEDZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn zoneIndex(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_MainlineZoneData::VT_ZONEINDEX, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn startStageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MainlineZoneData::VT_STARTSTAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn endStageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MainlineZoneData::VT_ENDSTAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn gameMusicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MainlineZoneData::VT_GAMEMUSICID,
                None,
            )
        }
    }
    #[inline]
    pub fn recapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MainlineZoneData::VT_RECAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn recapPreStageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MainlineZoneData::VT_RECAPPRESTAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn buttonName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MainlineZoneData::VT_BUTTONNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn buttonStyle(&self) -> enum__Torappu_MainlineZoneData_ZoneReplayBtnType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_MainlineZoneData_ZoneReplayBtnType>(
                    clz_Torappu_MainlineZoneData::VT_BUTTONSTYLE,
                    Some(enum__Torappu_MainlineZoneData_ZoneReplayBtnType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn spoilAlert(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_MainlineZoneData::VT_SPOILALERT, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn zoneOpenTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_MainlineZoneData::VT_ZONEOPENTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn diffGroup(&self) -> Option<flatbuffers::Vector<'a, enum__Torappu_StageDiffGroup>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_StageDiffGroup>,
            >>(clz_Torappu_MainlineZoneData::VT_DIFFGROUP, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_MainlineZoneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zoneId", Self::VT_ZONEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("chapterId", Self::VT_CHAPTERID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("preposedZoneId", Self::VT_PREPOSEDZONEID, false)?
     .visit_field::<i32>("zoneIndex", Self::VT_ZONEINDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("startStageId", Self::VT_STARTSTAGEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("endStageId", Self::VT_ENDSTAGEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("gameMusicId", Self::VT_GAMEMUSICID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("recapId", Self::VT_RECAPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("recapPreStageId", Self::VT_RECAPPRESTAGEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buttonName", Self::VT_BUTTONNAME, false)?
     .visit_field::<enum__Torappu_MainlineZoneData_ZoneReplayBtnType>("buttonStyle", Self::VT_BUTTONSTYLE, false)?
     .visit_field::<bool>("spoilAlert", Self::VT_SPOILALERT, false)?
     .visit_field::<i64>("zoneOpenTime", Self::VT_ZONEOPENTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_StageDiffGroup>>>("diffGroup", Self::VT_DIFFGROUP, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_MainlineZoneDataArgs<'a> {
    pub zoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub chapterId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub preposedZoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneIndex: i32,
    pub startStageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub endStageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gameMusicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub recapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub recapPreStageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buttonName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buttonStyle: enum__Torappu_MainlineZoneData_ZoneReplayBtnType,
    pub spoilAlert: bool,
    pub zoneOpenTime: i64,
    pub diffGroup:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_StageDiffGroup>>>,
}
impl<'a> Default for clz_Torappu_MainlineZoneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_MainlineZoneDataArgs {
            zoneId: None,
            chapterId: None,
            preposedZoneId: None,
            zoneIndex: 0,
            startStageId: None,
            endStageId: None,
            gameMusicId: None,
            recapId: None,
            recapPreStageId: None,
            buttonName: None,
            buttonStyle: enum__Torappu_MainlineZoneData_ZoneReplayBtnType::NONE,
            spoilAlert: false,
            zoneOpenTime: 0,
            diffGroup: None,
        }
    }
}

impl Serialize for clz_Torappu_MainlineZoneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_MainlineZoneData", 14)?;
        if let Some(f) = self.zoneId() {
            s.serialize_field("zoneId", &f)?;
        } else {
            s.skip_field("zoneId")?;
        }
        if let Some(f) = self.chapterId() {
            s.serialize_field("chapterId", &f)?;
        } else {
            s.skip_field("chapterId")?;
        }
        if let Some(f) = self.preposedZoneId() {
            s.serialize_field("preposedZoneId", &f)?;
        } else {
            s.skip_field("preposedZoneId")?;
        }
        s.serialize_field("zoneIndex", &self.zoneIndex())?;
        if let Some(f) = self.startStageId() {
            s.serialize_field("startStageId", &f)?;
        } else {
            s.skip_field("startStageId")?;
        }
        if let Some(f) = self.endStageId() {
            s.serialize_field("endStageId", &f)?;
        } else {
            s.skip_field("endStageId")?;
        }
        if let Some(f) = self.gameMusicId() {
            s.serialize_field("gameMusicId", &f)?;
        } else {
            s.skip_field("gameMusicId")?;
        }
        if let Some(f) = self.recapId() {
            s.serialize_field("recapId", &f)?;
        } else {
            s.skip_field("recapId")?;
        }
        if let Some(f) = self.recapPreStageId() {
            s.serialize_field("recapPreStageId", &f)?;
        } else {
            s.skip_field("recapPreStageId")?;
        }
        if let Some(f) = self.buttonName() {
            s.serialize_field("buttonName", &f)?;
        } else {
            s.skip_field("buttonName")?;
        }
        s.serialize_field("buttonStyle", &self.buttonStyle())?;
        s.serialize_field("spoilAlert", &self.spoilAlert())?;
        s.serialize_field("zoneOpenTime", &self.zoneOpenTime())?;
        if let Some(f) = self.diffGroup() {
            s.serialize_field("diffGroup", &f)?;
        } else {
            s.skip_field("diffGroup")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_MainlineZoneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_MainlineZoneDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_zoneId(&mut self, zoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MainlineZoneData::VT_ZONEID,
            zoneId,
        );
    }
    #[inline]
    pub fn add_chapterId(&mut self, chapterId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MainlineZoneData::VT_CHAPTERID,
            chapterId,
        );
    }
    #[inline]
    pub fn add_preposedZoneId(&mut self, preposedZoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MainlineZoneData::VT_PREPOSEDZONEID,
            preposedZoneId,
        );
    }
    #[inline]
    pub fn add_zoneIndex(&mut self, zoneIndex: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_MainlineZoneData::VT_ZONEINDEX, zoneIndex, 0);
    }
    #[inline]
    pub fn add_startStageId(&mut self, startStageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MainlineZoneData::VT_STARTSTAGEID,
            startStageId,
        );
    }
    #[inline]
    pub fn add_endStageId(&mut self, endStageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MainlineZoneData::VT_ENDSTAGEID,
            endStageId,
        );
    }
    #[inline]
    pub fn add_gameMusicId(&mut self, gameMusicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MainlineZoneData::VT_GAMEMUSICID,
            gameMusicId,
        );
    }
    #[inline]
    pub fn add_recapId(&mut self, recapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MainlineZoneData::VT_RECAPID,
            recapId,
        );
    }
    #[inline]
    pub fn add_recapPreStageId(&mut self, recapPreStageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MainlineZoneData::VT_RECAPPRESTAGEID,
            recapPreStageId,
        );
    }
    #[inline]
    pub fn add_buttonName(&mut self, buttonName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MainlineZoneData::VT_BUTTONNAME,
            buttonName,
        );
    }
    #[inline]
    pub fn add_buttonStyle(
        &mut self,
        buttonStyle: enum__Torappu_MainlineZoneData_ZoneReplayBtnType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_MainlineZoneData_ZoneReplayBtnType>(
                clz_Torappu_MainlineZoneData::VT_BUTTONSTYLE,
                buttonStyle,
                enum__Torappu_MainlineZoneData_ZoneReplayBtnType::NONE,
            );
    }
    #[inline]
    pub fn add_spoilAlert(&mut self, spoilAlert: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_MainlineZoneData::VT_SPOILALERT,
            spoilAlert,
            false,
        );
    }
    #[inline]
    pub fn add_zoneOpenTime(&mut self, zoneOpenTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_MainlineZoneData::VT_ZONEOPENTIME,
            zoneOpenTime,
            0,
        );
    }
    #[inline]
    pub fn add_diffGroup(
        &mut self,
        diffGroup: flatbuffers::WIPOffset<flatbuffers::Vector<'b, enum__Torappu_StageDiffGroup>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MainlineZoneData::VT_DIFFGROUP,
            diffGroup,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_MainlineZoneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_MainlineZoneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_MainlineZoneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_MainlineZoneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_MainlineZoneData");
        ds.field("zoneId", &self.zoneId());
        ds.field("chapterId", &self.chapterId());
        ds.field("preposedZoneId", &self.preposedZoneId());
        ds.field("zoneIndex", &self.zoneIndex());
        ds.field("startStageId", &self.startStageId());
        ds.field("endStageId", &self.endStageId());
        ds.field("gameMusicId", &self.gameMusicId());
        ds.field("recapId", &self.recapId());
        ds.field("recapPreStageId", &self.recapPreStageId());
        ds.field("buttonName", &self.buttonName());
        ds.field("buttonStyle", &self.buttonStyle());
        ds.field("spoilAlert", &self.spoilAlert());
        ds.field("zoneOpenTime", &self.zoneOpenTime());
        ds.field("diffGroup", &self.diffGroup());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_MainlineZoneDataT {
    pub zoneId: Option<String>,
    pub chapterId: Option<String>,
    pub preposedZoneId: Option<String>,
    pub zoneIndex: i32,
    pub startStageId: Option<String>,
    pub endStageId: Option<String>,
    pub gameMusicId: Option<String>,
    pub recapId: Option<String>,
    pub recapPreStageId: Option<String>,
    pub buttonName: Option<String>,
    pub buttonStyle: enum__Torappu_MainlineZoneData_ZoneReplayBtnType,
    pub spoilAlert: bool,
    pub zoneOpenTime: i64,
    pub diffGroup: Option<Vec<enum__Torappu_StageDiffGroup>>,
}
impl Default for clz_Torappu_MainlineZoneDataT {
    fn default() -> Self {
        Self {
            zoneId: None,
            chapterId: None,
            preposedZoneId: None,
            zoneIndex: 0,
            startStageId: None,
            endStageId: None,
            gameMusicId: None,
            recapId: None,
            recapPreStageId: None,
            buttonName: None,
            buttonStyle: enum__Torappu_MainlineZoneData_ZoneReplayBtnType::NONE,
            spoilAlert: false,
            zoneOpenTime: 0,
            diffGroup: None,
        }
    }
}
impl clz_Torappu_MainlineZoneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MainlineZoneData<'b>> {
        let zoneId = self.zoneId.as_ref().map(|x| _fbb.create_string(x));
        let chapterId = self.chapterId.as_ref().map(|x| _fbb.create_string(x));
        let preposedZoneId = self.preposedZoneId.as_ref().map(|x| _fbb.create_string(x));
        let zoneIndex = self.zoneIndex;
        let startStageId = self.startStageId.as_ref().map(|x| _fbb.create_string(x));
        let endStageId = self.endStageId.as_ref().map(|x| _fbb.create_string(x));
        let gameMusicId = self.gameMusicId.as_ref().map(|x| _fbb.create_string(x));
        let recapId = self.recapId.as_ref().map(|x| _fbb.create_string(x));
        let recapPreStageId = self.recapPreStageId.as_ref().map(|x| _fbb.create_string(x));
        let buttonName = self.buttonName.as_ref().map(|x| _fbb.create_string(x));
        let buttonStyle = self.buttonStyle;
        let spoilAlert = self.spoilAlert;
        let zoneOpenTime = self.zoneOpenTime;
        let diffGroup = self.diffGroup.as_ref().map(|x| _fbb.create_vector(x));
        clz_Torappu_MainlineZoneData::create(
            _fbb,
            &clz_Torappu_MainlineZoneDataArgs {
                zoneId,
                chapterId,
                preposedZoneId,
                zoneIndex,
                startStageId,
                endStageId,
                gameMusicId,
                recapId,
                recapPreStageId,
                buttonName,
                buttonStyle,
                spoilAlert,
                zoneOpenTime,
                diffGroup,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_MainlineZoneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_MainlineZoneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_MainlineZoneData<'a> {
    type Inner = dict__string__clz_Torappu_MainlineZoneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_MainlineZoneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_MainlineZoneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_MainlineZoneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_MainlineZoneData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_MainlineZoneDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_MainlineZoneDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_MainlineZoneDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_MainlineZoneData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_MainlineZoneData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_MainlineZoneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_MainlineZoneData>>(
                    dict__string__clz_Torappu_MainlineZoneData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_MainlineZoneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_MainlineZoneData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_MainlineZoneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_MainlineZoneData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_MainlineZoneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_MainlineZoneDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_MainlineZoneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_MainlineZoneData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_MainlineZoneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_MainlineZoneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_MainlineZoneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_MainlineZoneData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_MainlineZoneData>>(
                dict__string__clz_Torappu_MainlineZoneData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_MainlineZoneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_MainlineZoneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_MainlineZoneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_MainlineZoneData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_MainlineZoneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_MainlineZoneData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_MainlineZoneDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_MainlineZoneDataT>>,
}
impl Default for dict__string__clz_Torappu_MainlineZoneDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_MainlineZoneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_MainlineZoneData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_MainlineZoneData::create(
            _fbb,
            &dict__string__clz_Torappu_MainlineZoneDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ItemBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ItemBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ItemBundle<'a> {
    type Inner = clz_Torappu_ItemBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ItemBundle<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_COUNT: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ItemBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ItemBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'bldr>> {
        let mut builder = clz_Torappu_ItemBundleBuilder::new(_fbb);
        builder.add_type_(args.type_);
        builder.add_count(args.count);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ItemBundleT {
        let id = self.id().map(|x| x.to_string());
        let count = self.count();
        let type_ = self.type_();
        clz_Torappu_ItemBundleT { id, count, type_ }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_ItemBundle::VT_ID, None)
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ItemBundle::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_ItemBundle::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ItemBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ItemBundleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl<'a> Default for clz_Torappu_ItemBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ItemBundleArgs {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_ItemBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ItemBundle", 3)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("count", &self.count())?;
        s.serialize_field("type_", &self.type_())?;
        s.end()
    }
}

pub struct clz_Torappu_ItemBundleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ItemBundle::VT_ID, id);
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ItemBundle::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_ItemBundle::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ItemBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ItemBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ItemBundle");
        ds.field("id", &self.id());
        ds.field("count", &self.count());
        ds.field("type_", &self.type_());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ItemBundleT {
    pub id: Option<String>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl Default for clz_Torappu_ItemBundleT {
    fn default() -> Self {
        Self {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}
impl clz_Torappu_ItemBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let count = self.count;
        let type_ = self.type_;
        clz_Torappu_ItemBundle::create(_fbb, &clz_Torappu_ItemBundleArgs { id, count, type_ })
    }
}
pub enum clz_Torappu_RecordRewardInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RecordRewardInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RecordRewardInfo<'a> {
    type Inner = clz_Torappu_RecordRewardInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RecordRewardInfo<'a> {
    pub const VT_BINDSTAGEID: flatbuffers::VOffsetT = 4;
    pub const VT_STAGEDIFF1: flatbuffers::VOffsetT = 6;
    pub const VT_STAGEDIFF: flatbuffers::VOffsetT = 8;
    pub const VT_PICRES: flatbuffers::VOffsetT = 10;
    pub const VT_TEXTPATH: flatbuffers::VOffsetT = 12;
    pub const VT_TEXTDESC: flatbuffers::VOffsetT = 14;
    pub const VT_RECORDREWARD: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RecordRewardInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RecordRewardInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RecordRewardInfo<'bldr>> {
        let mut builder = clz_Torappu_RecordRewardInfoBuilder::new(_fbb);
        if let Some(x) = args.recordReward {
            builder.add_recordReward(x);
        }
        if let Some(x) = args.textDesc {
            builder.add_textDesc(x);
        }
        if let Some(x) = args.textPath {
            builder.add_textPath(x);
        }
        if let Some(x) = args.picRes {
            builder.add_picRes(x);
        }
        builder.add_stageDiff(args.stageDiff);
        builder.add_stageDiff1(args.stageDiff1);
        if let Some(x) = args.bindStageId {
            builder.add_bindStageId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RecordRewardInfoT {
        let bindStageId = self.bindStageId().map(|x| x.to_string());
        let stageDiff1 = self.stageDiff1();
        let stageDiff = self.stageDiff();
        let picRes = self.picRes().map(|x| x.to_string());
        let textPath = self.textPath().map(|x| x.to_string());
        let textDesc = self.textDesc().map(|x| x.to_string());
        let recordReward = self
            .recordReward()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RecordRewardInfoT {
            bindStageId,
            stageDiff1,
            stageDiff,
            picRes,
            textPath,
            textDesc,
            recordReward,
        }
    }

    #[inline]
    pub fn bindStageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RecordRewardInfo::VT_BINDSTAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn stageDiff1(&self) -> enum__Torappu_RecordRewardStageDiff {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RecordRewardStageDiff>(
                    clz_Torappu_RecordRewardInfo::VT_STAGEDIFF1,
                    Some(enum__Torappu_RecordRewardStageDiff::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn stageDiff(&self) -> enum__Torappu_StageDiffGroup {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageDiffGroup>(
                    clz_Torappu_RecordRewardInfo::VT_STAGEDIFF,
                    Some(enum__Torappu_StageDiffGroup::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn picRes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RecordRewardInfo::VT_PICRES,
                None,
            )
        }
    }
    #[inline]
    pub fn textPath(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RecordRewardInfo::VT_TEXTPATH,
                None,
            )
        }
    }
    #[inline]
    pub fn textDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RecordRewardInfo::VT_TEXTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn recordReward(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(clz_Torappu_RecordRewardInfo::VT_RECORDREWARD, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RecordRewardInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bindStageId",
                Self::VT_BINDSTAGEID,
                false,
            )?
            .visit_field::<enum__Torappu_RecordRewardStageDiff>(
                "stageDiff1",
                Self::VT_STAGEDIFF1,
                false,
            )?
            .visit_field::<enum__Torappu_StageDiffGroup>("stageDiff", Self::VT_STAGEDIFF, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("picRes", Self::VT_PICRES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "textPath",
                Self::VT_TEXTPATH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "textDesc",
                Self::VT_TEXTDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("recordReward", Self::VT_RECORDREWARD, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RecordRewardInfoArgs<'a> {
    pub bindStageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stageDiff1: enum__Torappu_RecordRewardStageDiff,
    pub stageDiff: enum__Torappu_StageDiffGroup,
    pub picRes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub textPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub textDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub recordReward: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RecordRewardInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RecordRewardInfoArgs {
            bindStageId: None,
            stageDiff1: enum__Torappu_RecordRewardStageDiff::NONE,
            stageDiff: enum__Torappu_StageDiffGroup::NONE,
            picRes: None,
            textPath: None,
            textDesc: None,
            recordReward: None,
        }
    }
}

impl Serialize for clz_Torappu_RecordRewardInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RecordRewardInfo", 7)?;
        if let Some(f) = self.bindStageId() {
            s.serialize_field("bindStageId", &f)?;
        } else {
            s.skip_field("bindStageId")?;
        }
        s.serialize_field("stageDiff1", &self.stageDiff1())?;
        s.serialize_field("stageDiff", &self.stageDiff())?;
        if let Some(f) = self.picRes() {
            s.serialize_field("picRes", &f)?;
        } else {
            s.skip_field("picRes")?;
        }
        if let Some(f) = self.textPath() {
            s.serialize_field("textPath", &f)?;
        } else {
            s.skip_field("textPath")?;
        }
        if let Some(f) = self.textDesc() {
            s.serialize_field("textDesc", &f)?;
        } else {
            s.skip_field("textDesc")?;
        }
        if let Some(f) = self.recordReward() {
            s.serialize_field("recordReward", &f)?;
        } else {
            s.skip_field("recordReward")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RecordRewardInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RecordRewardInfoBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_bindStageId(&mut self, bindStageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RecordRewardInfo::VT_BINDSTAGEID,
            bindStageId,
        );
    }
    #[inline]
    pub fn add_stageDiff1(&mut self, stageDiff1: enum__Torappu_RecordRewardStageDiff) {
        self.fbb_.push_slot::<enum__Torappu_RecordRewardStageDiff>(
            clz_Torappu_RecordRewardInfo::VT_STAGEDIFF1,
            stageDiff1,
            enum__Torappu_RecordRewardStageDiff::NONE,
        );
    }
    #[inline]
    pub fn add_stageDiff(&mut self, stageDiff: enum__Torappu_StageDiffGroup) {
        self.fbb_.push_slot::<enum__Torappu_StageDiffGroup>(
            clz_Torappu_RecordRewardInfo::VT_STAGEDIFF,
            stageDiff,
            enum__Torappu_StageDiffGroup::NONE,
        );
    }
    #[inline]
    pub fn add_picRes(&mut self, picRes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RecordRewardInfo::VT_PICRES,
            picRes,
        );
    }
    #[inline]
    pub fn add_textPath(&mut self, textPath: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RecordRewardInfo::VT_TEXTPATH,
            textPath,
        );
    }
    #[inline]
    pub fn add_textDesc(&mut self, textDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RecordRewardInfo::VT_TEXTDESC,
            textDesc,
        );
    }
    #[inline]
    pub fn add_recordReward(
        &mut self,
        recordReward: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RecordRewardInfo::VT_RECORDREWARD,
            recordReward,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RecordRewardInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RecordRewardInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RecordRewardInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RecordRewardInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RecordRewardInfo");
        ds.field("bindStageId", &self.bindStageId());
        ds.field("stageDiff1", &self.stageDiff1());
        ds.field("stageDiff", &self.stageDiff());
        ds.field("picRes", &self.picRes());
        ds.field("textPath", &self.textPath());
        ds.field("textDesc", &self.textDesc());
        ds.field("recordReward", &self.recordReward());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RecordRewardInfoT {
    pub bindStageId: Option<String>,
    pub stageDiff1: enum__Torappu_RecordRewardStageDiff,
    pub stageDiff: enum__Torappu_StageDiffGroup,
    pub picRes: Option<String>,
    pub textPath: Option<String>,
    pub textDesc: Option<String>,
    pub recordReward: Option<Vec<clz_Torappu_ItemBundleT>>,
}
impl Default for clz_Torappu_RecordRewardInfoT {
    fn default() -> Self {
        Self {
            bindStageId: None,
            stageDiff1: enum__Torappu_RecordRewardStageDiff::NONE,
            stageDiff: enum__Torappu_StageDiffGroup::NONE,
            picRes: None,
            textPath: None,
            textDesc: None,
            recordReward: None,
        }
    }
}
impl clz_Torappu_RecordRewardInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RecordRewardInfo<'b>> {
        let bindStageId = self.bindStageId.as_ref().map(|x| _fbb.create_string(x));
        let stageDiff1 = self.stageDiff1;
        let stageDiff = self.stageDiff;
        let picRes = self.picRes.as_ref().map(|x| _fbb.create_string(x));
        let textPath = self.textPath.as_ref().map(|x| _fbb.create_string(x));
        let textDesc = self.textDesc.as_ref().map(|x| _fbb.create_string(x));
        let recordReward = self.recordReward.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RecordRewardInfo::create(
            _fbb,
            &clz_Torappu_RecordRewardInfoArgs {
                bindStageId,
                stageDiff1,
                stageDiff,
                picRes,
                textPath,
                textDesc,
                recordReward,
            },
        )
    }
}
pub enum clz_Torappu_ZoneRecordDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ZoneRecordData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ZoneRecordData<'a> {
    type Inner = clz_Torappu_ZoneRecordData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ZoneRecordData<'a> {
    pub const VT_RECORDID: flatbuffers::VOffsetT = 4;
    pub const VT_ZONEID: flatbuffers::VOffsetT = 6;
    pub const VT_RECORDTITLENAME: flatbuffers::VOffsetT = 8;
    pub const VT_PRERECORDID: flatbuffers::VOffsetT = 10;
    pub const VT_NODETITLE1: flatbuffers::VOffsetT = 12;
    pub const VT_NODETITLE2: flatbuffers::VOffsetT = 14;
    pub const VT_REWARDS: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ZoneRecordData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ZoneRecordDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ZoneRecordData<'bldr>> {
        let mut builder = clz_Torappu_ZoneRecordDataBuilder::new(_fbb);
        if let Some(x) = args.rewards {
            builder.add_rewards(x);
        }
        if let Some(x) = args.nodeTitle2 {
            builder.add_nodeTitle2(x);
        }
        if let Some(x) = args.nodeTitle1 {
            builder.add_nodeTitle1(x);
        }
        if let Some(x) = args.preRecordId {
            builder.add_preRecordId(x);
        }
        if let Some(x) = args.recordTitleName {
            builder.add_recordTitleName(x);
        }
        if let Some(x) = args.zoneId {
            builder.add_zoneId(x);
        }
        if let Some(x) = args.recordId {
            builder.add_recordId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ZoneRecordDataT {
        let recordId = self.recordId().map(|x| x.to_string());
        let zoneId = self.zoneId().map(|x| x.to_string());
        let recordTitleName = self.recordTitleName().map(|x| x.to_string());
        let preRecordId = self.preRecordId().map(|x| x.to_string());
        let nodeTitle1 = self.nodeTitle1().map(|x| x.to_string());
        let nodeTitle2 = self.nodeTitle2().map(|x| x.to_string());
        let rewards = self
            .rewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ZoneRecordDataT {
            recordId,
            zoneId,
            recordTitleName,
            preRecordId,
            nodeTitle1,
            nodeTitle2,
            rewards,
        }
    }

    #[inline]
    pub fn recordId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneRecordData::VT_RECORDID,
                None,
            )
        }
    }
    #[inline]
    pub fn zoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneRecordData::VT_ZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn recordTitleName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneRecordData::VT_RECORDTITLENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn preRecordId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneRecordData::VT_PRERECORDID,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeTitle1(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneRecordData::VT_NODETITLE1,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeTitle2(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneRecordData::VT_NODETITLE2,
                None,
            )
        }
    }
    #[inline]
    pub fn rewards(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RecordRewardInfo<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RecordRewardInfo>>,
            >>(clz_Torappu_ZoneRecordData::VT_REWARDS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ZoneRecordData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "recordId",
                Self::VT_RECORDID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zoneId", Self::VT_ZONEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "recordTitleName",
                Self::VT_RECORDTITLENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "preRecordId",
                Self::VT_PRERECORDID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nodeTitle1",
                Self::VT_NODETITLE1,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nodeTitle2",
                Self::VT_NODETITLE2,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RecordRewardInfo>>,
            >>("rewards", Self::VT_REWARDS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ZoneRecordDataArgs<'a> {
    pub recordId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub recordTitleName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub preRecordId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nodeTitle1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nodeTitle2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RecordRewardInfo<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ZoneRecordDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ZoneRecordDataArgs {
            recordId: None,
            zoneId: None,
            recordTitleName: None,
            preRecordId: None,
            nodeTitle1: None,
            nodeTitle2: None,
            rewards: None,
        }
    }
}

impl Serialize for clz_Torappu_ZoneRecordData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ZoneRecordData", 7)?;
        if let Some(f) = self.recordId() {
            s.serialize_field("recordId", &f)?;
        } else {
            s.skip_field("recordId")?;
        }
        if let Some(f) = self.zoneId() {
            s.serialize_field("zoneId", &f)?;
        } else {
            s.skip_field("zoneId")?;
        }
        if let Some(f) = self.recordTitleName() {
            s.serialize_field("recordTitleName", &f)?;
        } else {
            s.skip_field("recordTitleName")?;
        }
        if let Some(f) = self.preRecordId() {
            s.serialize_field("preRecordId", &f)?;
        } else {
            s.skip_field("preRecordId")?;
        }
        if let Some(f) = self.nodeTitle1() {
            s.serialize_field("nodeTitle1", &f)?;
        } else {
            s.skip_field("nodeTitle1")?;
        }
        if let Some(f) = self.nodeTitle2() {
            s.serialize_field("nodeTitle2", &f)?;
        } else {
            s.skip_field("nodeTitle2")?;
        }
        if let Some(f) = self.rewards() {
            s.serialize_field("rewards", &f)?;
        } else {
            s.skip_field("rewards")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ZoneRecordDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ZoneRecordDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_recordId(&mut self, recordId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneRecordData::VT_RECORDID,
            recordId,
        );
    }
    #[inline]
    pub fn add_zoneId(&mut self, zoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneRecordData::VT_ZONEID,
            zoneId,
        );
    }
    #[inline]
    pub fn add_recordTitleName(&mut self, recordTitleName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneRecordData::VT_RECORDTITLENAME,
            recordTitleName,
        );
    }
    #[inline]
    pub fn add_preRecordId(&mut self, preRecordId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneRecordData::VT_PRERECORDID,
            preRecordId,
        );
    }
    #[inline]
    pub fn add_nodeTitle1(&mut self, nodeTitle1: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneRecordData::VT_NODETITLE1,
            nodeTitle1,
        );
    }
    #[inline]
    pub fn add_nodeTitle2(&mut self, nodeTitle2: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneRecordData::VT_NODETITLE2,
            nodeTitle2,
        );
    }
    #[inline]
    pub fn add_rewards(
        &mut self,
        rewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_RecordRewardInfo<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneRecordData::VT_REWARDS,
            rewards,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ZoneRecordDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ZoneRecordDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ZoneRecordData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ZoneRecordData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ZoneRecordData");
        ds.field("recordId", &self.recordId());
        ds.field("zoneId", &self.zoneId());
        ds.field("recordTitleName", &self.recordTitleName());
        ds.field("preRecordId", &self.preRecordId());
        ds.field("nodeTitle1", &self.nodeTitle1());
        ds.field("nodeTitle2", &self.nodeTitle2());
        ds.field("rewards", &self.rewards());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ZoneRecordDataT {
    pub recordId: Option<String>,
    pub zoneId: Option<String>,
    pub recordTitleName: Option<String>,
    pub preRecordId: Option<String>,
    pub nodeTitle1: Option<String>,
    pub nodeTitle2: Option<String>,
    pub rewards: Option<Vec<clz_Torappu_RecordRewardInfoT>>,
}
impl Default for clz_Torappu_ZoneRecordDataT {
    fn default() -> Self {
        Self {
            recordId: None,
            zoneId: None,
            recordTitleName: None,
            preRecordId: None,
            nodeTitle1: None,
            nodeTitle2: None,
            rewards: None,
        }
    }
}
impl clz_Torappu_ZoneRecordDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ZoneRecordData<'b>> {
        let recordId = self.recordId.as_ref().map(|x| _fbb.create_string(x));
        let zoneId = self.zoneId.as_ref().map(|x| _fbb.create_string(x));
        let recordTitleName = self.recordTitleName.as_ref().map(|x| _fbb.create_string(x));
        let preRecordId = self.preRecordId.as_ref().map(|x| _fbb.create_string(x));
        let nodeTitle1 = self.nodeTitle1.as_ref().map(|x| _fbb.create_string(x));
        let nodeTitle2 = self.nodeTitle2.as_ref().map(|x| _fbb.create_string(x));
        let rewards = self.rewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ZoneRecordData::create(
            _fbb,
            &clz_Torappu_ZoneRecordDataArgs {
                recordId,
                zoneId,
                recordTitleName,
                preRecordId,
                nodeTitle1,
                nodeTitle2,
                rewards,
            },
        )
    }
}
pub enum clz_Torappu_ZoneRecordUnlockDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ZoneRecordUnlockData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ZoneRecordUnlockData<'a> {
    type Inner = clz_Torappu_ZoneRecordUnlockData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ZoneRecordUnlockData<'a> {
    pub const VT_NOTEID: flatbuffers::VOffsetT = 4;
    pub const VT_ZONEID: flatbuffers::VOffsetT = 6;
    pub const VT_INITIALNAME: flatbuffers::VOffsetT = 8;
    pub const VT_FINALNAME: flatbuffers::VOffsetT = 10;
    pub const VT_ACCORDINGEXPOSEID: flatbuffers::VOffsetT = 12;
    pub const VT_INITIALDES: flatbuffers::VOffsetT = 14;
    pub const VT_FINALDES: flatbuffers::VOffsetT = 16;
    pub const VT_REMINDDES: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ZoneRecordUnlockData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ZoneRecordUnlockDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ZoneRecordUnlockData<'bldr>> {
        let mut builder = clz_Torappu_ZoneRecordUnlockDataBuilder::new(_fbb);
        if let Some(x) = args.remindDes {
            builder.add_remindDes(x);
        }
        if let Some(x) = args.finalDes {
            builder.add_finalDes(x);
        }
        if let Some(x) = args.initialDes {
            builder.add_initialDes(x);
        }
        if let Some(x) = args.accordingExposeId {
            builder.add_accordingExposeId(x);
        }
        if let Some(x) = args.finalName {
            builder.add_finalName(x);
        }
        if let Some(x) = args.initialName {
            builder.add_initialName(x);
        }
        if let Some(x) = args.zoneId {
            builder.add_zoneId(x);
        }
        if let Some(x) = args.noteId {
            builder.add_noteId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ZoneRecordUnlockDataT {
        let noteId = self.noteId().map(|x| x.to_string());
        let zoneId = self.zoneId().map(|x| x.to_string());
        let initialName = self.initialName().map(|x| x.to_string());
        let finalName = self.finalName().map(|x| x.to_string());
        let accordingExposeId = self.accordingExposeId().map(|x| x.to_string());
        let initialDes = self.initialDes().map(|x| x.to_string());
        let finalDes = self.finalDes().map(|x| x.to_string());
        let remindDes = self.remindDes().map(|x| x.to_string());
        clz_Torappu_ZoneRecordUnlockDataT {
            noteId,
            zoneId,
            initialName,
            finalName,
            accordingExposeId,
            initialDes,
            finalDes,
            remindDes,
        }
    }

    #[inline]
    pub fn noteId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneRecordUnlockData::VT_NOTEID,
                None,
            )
        }
    }
    #[inline]
    pub fn zoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneRecordUnlockData::VT_ZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn initialName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneRecordUnlockData::VT_INITIALNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn finalName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneRecordUnlockData::VT_FINALNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn accordingExposeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneRecordUnlockData::VT_ACCORDINGEXPOSEID,
                None,
            )
        }
    }
    #[inline]
    pub fn initialDes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneRecordUnlockData::VT_INITIALDES,
                None,
            )
        }
    }
    #[inline]
    pub fn finalDes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneRecordUnlockData::VT_FINALDES,
                None,
            )
        }
    }
    #[inline]
    pub fn remindDes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneRecordUnlockData::VT_REMINDDES,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ZoneRecordUnlockData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("noteId", Self::VT_NOTEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zoneId", Self::VT_ZONEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "initialName",
                Self::VT_INITIALNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "finalName",
                Self::VT_FINALNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "accordingExposeId",
                Self::VT_ACCORDINGEXPOSEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "initialDes",
                Self::VT_INITIALDES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "finalDes",
                Self::VT_FINALDES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "remindDes",
                Self::VT_REMINDDES,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ZoneRecordUnlockDataArgs<'a> {
    pub noteId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub initialName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub finalName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub accordingExposeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub initialDes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub finalDes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub remindDes: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ZoneRecordUnlockDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ZoneRecordUnlockDataArgs {
            noteId: None,
            zoneId: None,
            initialName: None,
            finalName: None,
            accordingExposeId: None,
            initialDes: None,
            finalDes: None,
            remindDes: None,
        }
    }
}

impl Serialize for clz_Torappu_ZoneRecordUnlockData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ZoneRecordUnlockData", 8)?;
        if let Some(f) = self.noteId() {
            s.serialize_field("noteId", &f)?;
        } else {
            s.skip_field("noteId")?;
        }
        if let Some(f) = self.zoneId() {
            s.serialize_field("zoneId", &f)?;
        } else {
            s.skip_field("zoneId")?;
        }
        if let Some(f) = self.initialName() {
            s.serialize_field("initialName", &f)?;
        } else {
            s.skip_field("initialName")?;
        }
        if let Some(f) = self.finalName() {
            s.serialize_field("finalName", &f)?;
        } else {
            s.skip_field("finalName")?;
        }
        if let Some(f) = self.accordingExposeId() {
            s.serialize_field("accordingExposeId", &f)?;
        } else {
            s.skip_field("accordingExposeId")?;
        }
        if let Some(f) = self.initialDes() {
            s.serialize_field("initialDes", &f)?;
        } else {
            s.skip_field("initialDes")?;
        }
        if let Some(f) = self.finalDes() {
            s.serialize_field("finalDes", &f)?;
        } else {
            s.skip_field("finalDes")?;
        }
        if let Some(f) = self.remindDes() {
            s.serialize_field("remindDes", &f)?;
        } else {
            s.skip_field("remindDes")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ZoneRecordUnlockDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ZoneRecordUnlockDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_noteId(&mut self, noteId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneRecordUnlockData::VT_NOTEID,
            noteId,
        );
    }
    #[inline]
    pub fn add_zoneId(&mut self, zoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneRecordUnlockData::VT_ZONEID,
            zoneId,
        );
    }
    #[inline]
    pub fn add_initialName(&mut self, initialName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneRecordUnlockData::VT_INITIALNAME,
            initialName,
        );
    }
    #[inline]
    pub fn add_finalName(&mut self, finalName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneRecordUnlockData::VT_FINALNAME,
            finalName,
        );
    }
    #[inline]
    pub fn add_accordingExposeId(&mut self, accordingExposeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneRecordUnlockData::VT_ACCORDINGEXPOSEID,
            accordingExposeId,
        );
    }
    #[inline]
    pub fn add_initialDes(&mut self, initialDes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneRecordUnlockData::VT_INITIALDES,
            initialDes,
        );
    }
    #[inline]
    pub fn add_finalDes(&mut self, finalDes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneRecordUnlockData::VT_FINALDES,
            finalDes,
        );
    }
    #[inline]
    pub fn add_remindDes(&mut self, remindDes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneRecordUnlockData::VT_REMINDDES,
            remindDes,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ZoneRecordUnlockDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ZoneRecordUnlockDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ZoneRecordUnlockData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ZoneRecordUnlockData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ZoneRecordUnlockData");
        ds.field("noteId", &self.noteId());
        ds.field("zoneId", &self.zoneId());
        ds.field("initialName", &self.initialName());
        ds.field("finalName", &self.finalName());
        ds.field("accordingExposeId", &self.accordingExposeId());
        ds.field("initialDes", &self.initialDes());
        ds.field("finalDes", &self.finalDes());
        ds.field("remindDes", &self.remindDes());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ZoneRecordUnlockDataT {
    pub noteId: Option<String>,
    pub zoneId: Option<String>,
    pub initialName: Option<String>,
    pub finalName: Option<String>,
    pub accordingExposeId: Option<String>,
    pub initialDes: Option<String>,
    pub finalDes: Option<String>,
    pub remindDes: Option<String>,
}
impl Default for clz_Torappu_ZoneRecordUnlockDataT {
    fn default() -> Self {
        Self {
            noteId: None,
            zoneId: None,
            initialName: None,
            finalName: None,
            accordingExposeId: None,
            initialDes: None,
            finalDes: None,
            remindDes: None,
        }
    }
}
impl clz_Torappu_ZoneRecordUnlockDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ZoneRecordUnlockData<'b>> {
        let noteId = self.noteId.as_ref().map(|x| _fbb.create_string(x));
        let zoneId = self.zoneId.as_ref().map(|x| _fbb.create_string(x));
        let initialName = self.initialName.as_ref().map(|x| _fbb.create_string(x));
        let finalName = self.finalName.as_ref().map(|x| _fbb.create_string(x));
        let accordingExposeId = self
            .accordingExposeId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let initialDes = self.initialDes.as_ref().map(|x| _fbb.create_string(x));
        let finalDes = self.finalDes.as_ref().map(|x| _fbb.create_string(x));
        let remindDes = self.remindDes.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_ZoneRecordUnlockData::create(
            _fbb,
            &clz_Torappu_ZoneRecordUnlockDataArgs {
                noteId,
                zoneId,
                initialName,
                finalName,
                accordingExposeId,
                initialDes,
                finalDes,
                remindDes,
            },
        )
    }
}
pub enum clz_Torappu_ZoneRecordGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ZoneRecordGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ZoneRecordGroupData<'a> {
    type Inner = clz_Torappu_ZoneRecordGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ZoneRecordGroupData<'a> {
    pub const VT_ZONEID: flatbuffers::VOffsetT = 4;
    pub const VT_RECORDS: flatbuffers::VOffsetT = 6;
    pub const VT_UNLOCKDATA: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ZoneRecordGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ZoneRecordGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ZoneRecordGroupData<'bldr>> {
        let mut builder = clz_Torappu_ZoneRecordGroupDataBuilder::new(_fbb);
        if let Some(x) = args.unlockData {
            builder.add_unlockData(x);
        }
        if let Some(x) = args.records {
            builder.add_records(x);
        }
        if let Some(x) = args.zoneId {
            builder.add_zoneId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ZoneRecordGroupDataT {
        let zoneId = self.zoneId().map(|x| x.to_string());
        let records = self
            .records()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let unlockData = self.unlockData().map(|x| Box::new(x.unpack()));
        clz_Torappu_ZoneRecordGroupDataT {
            zoneId,
            records,
            unlockData,
        }
    }

    #[inline]
    pub fn zoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneRecordGroupData::VT_ZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn records(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ZoneRecordData<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ZoneRecordData>>,
            >>(clz_Torappu_ZoneRecordGroupData::VT_RECORDS, None)
        }
    }
    #[inline]
    pub fn unlockData(&self) -> Option<clz_Torappu_ZoneRecordUnlockData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ZoneRecordUnlockData>>(
                    clz_Torappu_ZoneRecordGroupData::VT_UNLOCKDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ZoneRecordGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zoneId", Self::VT_ZONEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ZoneRecordData>>,
            >>("records", Self::VT_RECORDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ZoneRecordUnlockData>>(
                "unlockData",
                Self::VT_UNLOCKDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ZoneRecordGroupDataArgs<'a> {
    pub zoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub records: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ZoneRecordData<'a>>>,
        >,
    >,
    pub unlockData: Option<flatbuffers::WIPOffset<clz_Torappu_ZoneRecordUnlockData<'a>>>,
}
impl<'a> Default for clz_Torappu_ZoneRecordGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ZoneRecordGroupDataArgs {
            zoneId: None,
            records: None,
            unlockData: None,
        }
    }
}

impl Serialize for clz_Torappu_ZoneRecordGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ZoneRecordGroupData", 3)?;
        if let Some(f) = self.zoneId() {
            s.serialize_field("zoneId", &f)?;
        } else {
            s.skip_field("zoneId")?;
        }
        if let Some(f) = self.records() {
            s.serialize_field("records", &f)?;
        } else {
            s.skip_field("records")?;
        }
        if let Some(f) = self.unlockData() {
            s.serialize_field("unlockData", &f)?;
        } else {
            s.skip_field("unlockData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ZoneRecordGroupDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ZoneRecordGroupDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_zoneId(&mut self, zoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneRecordGroupData::VT_ZONEID,
            zoneId,
        );
    }
    #[inline]
    pub fn add_records(
        &mut self,
        records: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ZoneRecordData<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneRecordGroupData::VT_RECORDS,
            records,
        );
    }
    #[inline]
    pub fn add_unlockData(
        &mut self,
        unlockData: flatbuffers::WIPOffset<clz_Torappu_ZoneRecordUnlockData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ZoneRecordUnlockData>>(
                clz_Torappu_ZoneRecordGroupData::VT_UNLOCKDATA,
                unlockData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ZoneRecordGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ZoneRecordGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ZoneRecordGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ZoneRecordGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ZoneRecordGroupData");
        ds.field("zoneId", &self.zoneId());
        ds.field("records", &self.records());
        ds.field("unlockData", &self.unlockData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ZoneRecordGroupDataT {
    pub zoneId: Option<String>,
    pub records: Option<Vec<clz_Torappu_ZoneRecordDataT>>,
    pub unlockData: Option<Box<clz_Torappu_ZoneRecordUnlockDataT>>,
}
impl Default for clz_Torappu_ZoneRecordGroupDataT {
    fn default() -> Self {
        Self {
            zoneId: None,
            records: None,
            unlockData: None,
        }
    }
}
impl clz_Torappu_ZoneRecordGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ZoneRecordGroupData<'b>> {
        let zoneId = self.zoneId.as_ref().map(|x| _fbb.create_string(x));
        let records = self.records.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let unlockData = self.unlockData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_ZoneRecordGroupData::create(
            _fbb,
            &clz_Torappu_ZoneRecordGroupDataArgs {
                zoneId,
                records,
                unlockData,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ZoneRecordGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ZoneRecordGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ZoneRecordGroupData<'a> {
    type Inner = dict__string__clz_Torappu_ZoneRecordGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ZoneRecordGroupData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ZoneRecordGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ZoneRecordGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ZoneRecordGroupData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ZoneRecordGroupDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ZoneRecordGroupDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ZoneRecordGroupDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ZoneRecordGroupData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_ZoneRecordGroupData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ZoneRecordGroupData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ZoneRecordGroupData>>(
                    dict__string__clz_Torappu_ZoneRecordGroupData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ZoneRecordGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ZoneRecordGroupData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ZoneRecordGroupDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ZoneRecordGroupData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ZoneRecordGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ZoneRecordGroupDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ZoneRecordGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ZoneRecordGroupData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ZoneRecordGroupDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ZoneRecordGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ZoneRecordGroupData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ZoneRecordGroupData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ZoneRecordGroupData>>(
                dict__string__clz_Torappu_ZoneRecordGroupData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ZoneRecordGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ZoneRecordGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ZoneRecordGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ZoneRecordGroupData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ZoneRecordGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ZoneRecordGroupData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ZoneRecordGroupDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ZoneRecordGroupDataT>>,
}
impl Default for dict__string__clz_Torappu_ZoneRecordGroupDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ZoneRecordGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ZoneRecordGroupData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ZoneRecordGroupData::create(
            _fbb,
            &dict__string__clz_Torappu_ZoneRecordGroupDataArgs { key, value },
        )
    }
}
pub enum dict__string__list_stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__list_string<'a> {
    type Inner = dict__string__list_string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__list_string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__list_string<'bldr>> {
        let mut builder = dict__string__list_stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__list_stringT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self
            .value()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        dict__string__list_stringT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__list_string::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__list_string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(dict__string__list_string::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__list_string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_stringArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for dict__string__list_stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__list_stringArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__list_string<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__list_string", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__list_stringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__list_stringBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__list_string::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_string::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__list_stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__list_stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__list_string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__list_string::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__list_string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__list_string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__list_stringT {
    pub key: String,
    pub value: Option<Vec<String>>,
}
impl Default for dict__string__list_stringT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__list_stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__list_string<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        dict__string__list_string::create(_fbb, &dict__string__list_stringArgs { key, value })
    }
}
pub enum clz_Torappu_ZoneRecordMissionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ZoneRecordMissionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ZoneRecordMissionData<'a> {
    type Inner = clz_Torappu_ZoneRecordMissionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ZoneRecordMissionData<'a> {
    pub const VT_MISSIONID: flatbuffers::VOffsetT = 4;
    pub const VT_RECORDSTAGEID: flatbuffers::VOffsetT = 6;
    pub const VT_TEMPLATEDESC: flatbuffers::VOffsetT = 8;
    pub const VT_DESC: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ZoneRecordMissionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ZoneRecordMissionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ZoneRecordMissionData<'bldr>> {
        let mut builder = clz_Torappu_ZoneRecordMissionDataBuilder::new(_fbb);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.templateDesc {
            builder.add_templateDesc(x);
        }
        if let Some(x) = args.recordStageId {
            builder.add_recordStageId(x);
        }
        if let Some(x) = args.missionId {
            builder.add_missionId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ZoneRecordMissionDataT {
        let missionId = self.missionId().map(|x| x.to_string());
        let recordStageId = self.recordStageId().map(|x| x.to_string());
        let templateDesc = self.templateDesc().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        clz_Torappu_ZoneRecordMissionDataT {
            missionId,
            recordStageId,
            templateDesc,
            desc,
        }
    }

    #[inline]
    pub fn missionId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneRecordMissionData::VT_MISSIONID,
                None,
            )
        }
    }
    #[inline]
    pub fn recordStageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneRecordMissionData::VT_RECORDSTAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn templateDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneRecordMissionData::VT_TEMPLATEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ZoneRecordMissionData::VT_DESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ZoneRecordMissionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "missionId",
                Self::VT_MISSIONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "recordStageId",
                Self::VT_RECORDSTAGEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "templateDesc",
                Self::VT_TEMPLATEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ZoneRecordMissionDataArgs<'a> {
    pub missionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub recordStageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub templateDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ZoneRecordMissionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ZoneRecordMissionDataArgs {
            missionId: None,
            recordStageId: None,
            templateDesc: None,
            desc: None,
        }
    }
}

impl Serialize for clz_Torappu_ZoneRecordMissionData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ZoneRecordMissionData", 4)?;
        if let Some(f) = self.missionId() {
            s.serialize_field("missionId", &f)?;
        } else {
            s.skip_field("missionId")?;
        }
        if let Some(f) = self.recordStageId() {
            s.serialize_field("recordStageId", &f)?;
        } else {
            s.skip_field("recordStageId")?;
        }
        if let Some(f) = self.templateDesc() {
            s.serialize_field("templateDesc", &f)?;
        } else {
            s.skip_field("templateDesc")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ZoneRecordMissionDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ZoneRecordMissionDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_missionId(&mut self, missionId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneRecordMissionData::VT_MISSIONID,
            missionId,
        );
    }
    #[inline]
    pub fn add_recordStageId(&mut self, recordStageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneRecordMissionData::VT_RECORDSTAGEID,
            recordStageId,
        );
    }
    #[inline]
    pub fn add_templateDesc(&mut self, templateDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneRecordMissionData::VT_TEMPLATEDESC,
            templateDesc,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneRecordMissionData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ZoneRecordMissionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ZoneRecordMissionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ZoneRecordMissionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ZoneRecordMissionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ZoneRecordMissionData");
        ds.field("missionId", &self.missionId());
        ds.field("recordStageId", &self.recordStageId());
        ds.field("templateDesc", &self.templateDesc());
        ds.field("desc", &self.desc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ZoneRecordMissionDataT {
    pub missionId: Option<String>,
    pub recordStageId: Option<String>,
    pub templateDesc: Option<String>,
    pub desc: Option<String>,
}
impl Default for clz_Torappu_ZoneRecordMissionDataT {
    fn default() -> Self {
        Self {
            missionId: None,
            recordStageId: None,
            templateDesc: None,
            desc: None,
        }
    }
}
impl clz_Torappu_ZoneRecordMissionDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ZoneRecordMissionData<'b>> {
        let missionId = self.missionId.as_ref().map(|x| _fbb.create_string(x));
        let recordStageId = self.recordStageId.as_ref().map(|x| _fbb.create_string(x));
        let templateDesc = self.templateDesc.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_ZoneRecordMissionData::create(
            _fbb,
            &clz_Torappu_ZoneRecordMissionDataArgs {
                missionId,
                recordStageId,
                templateDesc,
                desc,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ZoneRecordMissionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ZoneRecordMissionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ZoneRecordMissionData<'a> {
    type Inner = dict__string__clz_Torappu_ZoneRecordMissionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ZoneRecordMissionData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ZoneRecordMissionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ZoneRecordMissionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ZoneRecordMissionData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ZoneRecordMissionDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ZoneRecordMissionDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ZoneRecordMissionDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ZoneRecordMissionData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ZoneRecordMissionData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ZoneRecordMissionData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ZoneRecordMissionData>>(
                    dict__string__clz_Torappu_ZoneRecordMissionData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ZoneRecordMissionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ZoneRecordMissionData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ZoneRecordMissionDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ZoneRecordMissionData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ZoneRecordMissionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ZoneRecordMissionDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ZoneRecordMissionData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ZoneRecordMissionData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ZoneRecordMissionDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ZoneRecordMissionDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ZoneRecordMissionData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ZoneRecordMissionData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ZoneRecordMissionData>>(
                dict__string__clz_Torappu_ZoneRecordMissionData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ZoneRecordMissionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ZoneRecordMissionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ZoneRecordMissionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ZoneRecordMissionData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ZoneRecordMissionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ZoneRecordMissionData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ZoneRecordMissionDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ZoneRecordMissionDataT>>,
}
impl Default for dict__string__clz_Torappu_ZoneRecordMissionDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ZoneRecordMissionDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ZoneRecordMissionData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ZoneRecordMissionData::create(
            _fbb,
            &dict__string__clz_Torappu_ZoneRecordMissionDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ZoneMetaDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ZoneMetaData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ZoneMetaData<'a> {
    type Inner = clz_Torappu_ZoneMetaData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ZoneMetaData<'a> {
    pub const VT_ZONERECORDMISSIONDATA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ZoneMetaData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ZoneMetaDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ZoneMetaData<'bldr>> {
        let mut builder = clz_Torappu_ZoneMetaDataBuilder::new(_fbb);
        if let Some(x) = args.ZoneRecordMissionData {
            builder.add_ZoneRecordMissionData(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ZoneMetaDataT {
        let ZoneRecordMissionData = self
            .ZoneRecordMissionData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ZoneMetaDataT {
            ZoneRecordMissionData,
        }
    }

    #[inline]
    pub fn ZoneRecordMissionData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ZoneRecordMissionData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ZoneRecordMissionData>,
                >,
            >>(clz_Torappu_ZoneMetaData::VT_ZONERECORDMISSIONDATA, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ZoneMetaData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ZoneRecordMissionData>,
                >,
            >>(
                "ZoneRecordMissionData",
                Self::VT_ZONERECORDMISSIONDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ZoneMetaDataArgs<'a> {
    pub ZoneRecordMissionData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ZoneRecordMissionData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ZoneMetaDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ZoneMetaDataArgs {
            ZoneRecordMissionData: None,
        }
    }
}

impl Serialize for clz_Torappu_ZoneMetaData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ZoneMetaData", 1)?;
        if let Some(f) = self.ZoneRecordMissionData() {
            s.serialize_field("ZoneRecordMissionData", &f)?;
        } else {
            s.skip_field("ZoneRecordMissionData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ZoneMetaDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ZoneMetaDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_ZoneRecordMissionData(
        &mut self,
        ZoneRecordMissionData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ZoneRecordMissionData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneMetaData::VT_ZONERECORDMISSIONDATA,
            ZoneRecordMissionData,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ZoneMetaDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ZoneMetaDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ZoneMetaData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ZoneMetaData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ZoneMetaData");
        ds.field("ZoneRecordMissionData", &self.ZoneRecordMissionData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ZoneMetaDataT {
    pub ZoneRecordMissionData: Option<Vec<dict__string__clz_Torappu_ZoneRecordMissionDataT>>,
}
impl Default for clz_Torappu_ZoneMetaDataT {
    fn default() -> Self {
        Self {
            ZoneRecordMissionData: None,
        }
    }
}
impl clz_Torappu_ZoneMetaDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ZoneMetaData<'b>> {
        let ZoneRecordMissionData = self.ZoneRecordMissionData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ZoneMetaData::create(
            _fbb,
            &clz_Torappu_ZoneMetaDataArgs {
                ZoneRecordMissionData,
            },
        )
    }
}
pub enum clz_Torappu_ZoneTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ZoneTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ZoneTable<'a> {
    type Inner = clz_Torappu_ZoneTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ZoneTable<'a> {
    pub const VT_ZONES: flatbuffers::VOffsetT = 4;
    pub const VT_WEEKLYADDITIONINFO: flatbuffers::VOffsetT = 6;
    pub const VT_ZONEVALIDINFO: flatbuffers::VOffsetT = 8;
    pub const VT_MAINLINEADDITIONINFO: flatbuffers::VOffsetT = 10;
    pub const VT_ZONERECORDGROUPEDDATA: flatbuffers::VOffsetT = 12;
    pub const VT_ZONERECORDREWARDDATA: flatbuffers::VOffsetT = 14;
    pub const VT_MAINLINEZONEIDLIST: flatbuffers::VOffsetT = 16;
    pub const VT_ZONEMETADATA: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ZoneTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ZoneTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ZoneTable<'bldr>> {
        let mut builder = clz_Torappu_ZoneTableBuilder::new(_fbb);
        if let Some(x) = args.zoneMetaData {
            builder.add_zoneMetaData(x);
        }
        if let Some(x) = args.mainlineZoneIdList {
            builder.add_mainlineZoneIdList(x);
        }
        if let Some(x) = args.zoneRecordRewardData {
            builder.add_zoneRecordRewardData(x);
        }
        if let Some(x) = args.zoneRecordGroupedData {
            builder.add_zoneRecordGroupedData(x);
        }
        if let Some(x) = args.mainlineAdditionInfo {
            builder.add_mainlineAdditionInfo(x);
        }
        if let Some(x) = args.zoneValidInfo {
            builder.add_zoneValidInfo(x);
        }
        if let Some(x) = args.weeklyAdditionInfo {
            builder.add_weeklyAdditionInfo(x);
        }
        if let Some(x) = args.zones {
            builder.add_zones(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ZoneTableT {
        let zones = self.zones().map(|x| x.iter().map(|t| t.unpack()).collect());
        let weeklyAdditionInfo = self
            .weeklyAdditionInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let zoneValidInfo = self
            .zoneValidInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let mainlineAdditionInfo = self
            .mainlineAdditionInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let zoneRecordGroupedData = self
            .zoneRecordGroupedData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let zoneRecordRewardData = self
            .zoneRecordRewardData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let mainlineZoneIdList = self
            .mainlineZoneIdList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let zoneMetaData = self.zoneMetaData().map(|x| Box::new(x.unpack()));
        clz_Torappu_ZoneTableT {
            zones,
            weeklyAdditionInfo,
            zoneValidInfo,
            mainlineAdditionInfo,
            zoneRecordGroupedData,
            zoneRecordRewardData,
            mainlineZoneIdList,
            zoneMetaData,
        }
    }

    #[inline]
    pub fn zones(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ZoneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ZoneData>,
                >,
            >>(clz_Torappu_ZoneTable::VT_ZONES, None)
        }
    }
    #[inline]
    pub fn weeklyAdditionInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_WeeklyZoneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_WeeklyZoneData>,
                >,
            >>(clz_Torappu_ZoneTable::VT_WEEKLYADDITIONINFO, None)
        }
    }
    #[inline]
    pub fn zoneValidInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ZoneValidInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ZoneValidInfo>,
                >,
            >>(clz_Torappu_ZoneTable::VT_ZONEVALIDINFO, None)
        }
    }
    #[inline]
    pub fn mainlineAdditionInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MainlineZoneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MainlineZoneData>,
                >,
            >>(clz_Torappu_ZoneTable::VT_MAINLINEADDITIONINFO, None)
        }
    }
    #[inline]
    pub fn zoneRecordGroupedData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ZoneRecordGroupData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ZoneRecordGroupData>,
                >,
            >>(clz_Torappu_ZoneTable::VT_ZONERECORDGROUPEDDATA, None)
        }
    }
    #[inline]
    pub fn zoneRecordRewardData(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string>>,
            >>(clz_Torappu_ZoneTable::VT_ZONERECORDREWARDDATA, None)
        }
    }
    #[inline]
    pub fn mainlineZoneIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ZoneTable::VT_MAINLINEZONEIDLIST, None)
        }
    }
    #[inline]
    pub fn zoneMetaData(&self) -> Option<clz_Torappu_ZoneMetaData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ZoneMetaData>>(
                    clz_Torappu_ZoneTable::VT_ZONEMETADATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ZoneTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ZoneData>,
                >,
            >>("zones", Self::VT_ZONES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_WeeklyZoneData>,
                >,
            >>("weeklyAdditionInfo", Self::VT_WEEKLYADDITIONINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ZoneValidInfo>,
                >,
            >>("zoneValidInfo", Self::VT_ZONEVALIDINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MainlineZoneData>,
                >,
            >>("mainlineAdditionInfo", Self::VT_MAINLINEADDITIONINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ZoneRecordGroupData>,
                >,
            >>(
                "zoneRecordGroupedData",
                Self::VT_ZONERECORDGROUPEDDATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__list_string>>,
            >>("zoneRecordRewardData", Self::VT_ZONERECORDREWARDDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("mainlineZoneIdList", Self::VT_MAINLINEZONEIDLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ZoneMetaData>>(
                "zoneMetaData",
                Self::VT_ZONEMETADATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ZoneTableArgs<'a> {
    pub zones: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ZoneData<'a>>,
            >,
        >,
    >,
    pub weeklyAdditionInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_WeeklyZoneData<'a>>,
            >,
        >,
    >,
    pub zoneValidInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ZoneValidInfo<'a>>,
            >,
        >,
    >,
    pub mainlineAdditionInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MainlineZoneData<'a>>,
            >,
        >,
    >,
    pub zoneRecordGroupedData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ZoneRecordGroupData<'a>>,
            >,
        >,
    >,
    pub zoneRecordRewardData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string<'a>>>,
        >,
    >,
    pub mainlineZoneIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub zoneMetaData: Option<flatbuffers::WIPOffset<clz_Torappu_ZoneMetaData<'a>>>,
}
impl<'a> Default for clz_Torappu_ZoneTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ZoneTableArgs {
            zones: None,
            weeklyAdditionInfo: None,
            zoneValidInfo: None,
            mainlineAdditionInfo: None,
            zoneRecordGroupedData: None,
            zoneRecordRewardData: None,
            mainlineZoneIdList: None,
            zoneMetaData: None,
        }
    }
}

impl Serialize for clz_Torappu_ZoneTable<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ZoneTable", 8)?;
        if let Some(f) = self.zones() {
            s.serialize_field("zones", &f)?;
        } else {
            s.skip_field("zones")?;
        }
        if let Some(f) = self.weeklyAdditionInfo() {
            s.serialize_field("weeklyAdditionInfo", &f)?;
        } else {
            s.skip_field("weeklyAdditionInfo")?;
        }
        if let Some(f) = self.zoneValidInfo() {
            s.serialize_field("zoneValidInfo", &f)?;
        } else {
            s.skip_field("zoneValidInfo")?;
        }
        if let Some(f) = self.mainlineAdditionInfo() {
            s.serialize_field("mainlineAdditionInfo", &f)?;
        } else {
            s.skip_field("mainlineAdditionInfo")?;
        }
        if let Some(f) = self.zoneRecordGroupedData() {
            s.serialize_field("zoneRecordGroupedData", &f)?;
        } else {
            s.skip_field("zoneRecordGroupedData")?;
        }
        if let Some(f) = self.zoneRecordRewardData() {
            s.serialize_field("zoneRecordRewardData", &f)?;
        } else {
            s.skip_field("zoneRecordRewardData")?;
        }
        if let Some(f) = self.mainlineZoneIdList() {
            s.serialize_field("mainlineZoneIdList", &f)?;
        } else {
            s.skip_field("mainlineZoneIdList")?;
        }
        if let Some(f) = self.zoneMetaData() {
            s.serialize_field("zoneMetaData", &f)?;
        } else {
            s.skip_field("zoneMetaData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ZoneTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ZoneTableBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_zones(
        &mut self,
        zones: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ZoneData<'b>>,
            >,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ZoneTable::VT_ZONES, zones);
    }
    #[inline]
    pub fn add_weeklyAdditionInfo(
        &mut self,
        weeklyAdditionInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_WeeklyZoneData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneTable::VT_WEEKLYADDITIONINFO,
            weeklyAdditionInfo,
        );
    }
    #[inline]
    pub fn add_zoneValidInfo(
        &mut self,
        zoneValidInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ZoneValidInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneTable::VT_ZONEVALIDINFO,
            zoneValidInfo,
        );
    }
    #[inline]
    pub fn add_mainlineAdditionInfo(
        &mut self,
        mainlineAdditionInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MainlineZoneData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneTable::VT_MAINLINEADDITIONINFO,
            mainlineAdditionInfo,
        );
    }
    #[inline]
    pub fn add_zoneRecordGroupedData(
        &mut self,
        zoneRecordGroupedData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ZoneRecordGroupData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneTable::VT_ZONERECORDGROUPEDDATA,
            zoneRecordGroupedData,
        );
    }
    #[inline]
    pub fn add_zoneRecordRewardData(
        &mut self,
        zoneRecordRewardData: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__list_string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneTable::VT_ZONERECORDREWARDDATA,
            zoneRecordRewardData,
        );
    }
    #[inline]
    pub fn add_mainlineZoneIdList(
        &mut self,
        mainlineZoneIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ZoneTable::VT_MAINLINEZONEIDLIST,
            mainlineZoneIdList,
        );
    }
    #[inline]
    pub fn add_zoneMetaData(
        &mut self,
        zoneMetaData: flatbuffers::WIPOffset<clz_Torappu_ZoneMetaData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ZoneMetaData>>(
                clz_Torappu_ZoneTable::VT_ZONEMETADATA,
                zoneMetaData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ZoneTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ZoneTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ZoneTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ZoneTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ZoneTable");
        ds.field("zones", &self.zones());
        ds.field("weeklyAdditionInfo", &self.weeklyAdditionInfo());
        ds.field("zoneValidInfo", &self.zoneValidInfo());
        ds.field("mainlineAdditionInfo", &self.mainlineAdditionInfo());
        ds.field("zoneRecordGroupedData", &self.zoneRecordGroupedData());
        ds.field("zoneRecordRewardData", &self.zoneRecordRewardData());
        ds.field("mainlineZoneIdList", &self.mainlineZoneIdList());
        ds.field("zoneMetaData", &self.zoneMetaData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ZoneTableT {
    pub zones: Option<Vec<dict__string__clz_Torappu_ZoneDataT>>,
    pub weeklyAdditionInfo: Option<Vec<dict__string__clz_Torappu_WeeklyZoneDataT>>,
    pub zoneValidInfo: Option<Vec<dict__string__clz_Torappu_ZoneValidInfoT>>,
    pub mainlineAdditionInfo: Option<Vec<dict__string__clz_Torappu_MainlineZoneDataT>>,
    pub zoneRecordGroupedData: Option<Vec<dict__string__clz_Torappu_ZoneRecordGroupDataT>>,
    pub zoneRecordRewardData: Option<Vec<dict__string__list_stringT>>,
    pub mainlineZoneIdList: Option<Vec<String>>,
    pub zoneMetaData: Option<Box<clz_Torappu_ZoneMetaDataT>>,
}
impl Default for clz_Torappu_ZoneTableT {
    fn default() -> Self {
        Self {
            zones: None,
            weeklyAdditionInfo: None,
            zoneValidInfo: None,
            mainlineAdditionInfo: None,
            zoneRecordGroupedData: None,
            zoneRecordRewardData: None,
            mainlineZoneIdList: None,
            zoneMetaData: None,
        }
    }
}
impl clz_Torappu_ZoneTableT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ZoneTable<'b>> {
        let zones = self.zones.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let weeklyAdditionInfo = self.weeklyAdditionInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let zoneValidInfo = self.zoneValidInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let mainlineAdditionInfo = self.mainlineAdditionInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let zoneRecordGroupedData = self.zoneRecordGroupedData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let zoneRecordRewardData = self.zoneRecordRewardData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let mainlineZoneIdList = self.mainlineZoneIdList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let zoneMetaData = self.zoneMetaData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_ZoneTable::create(
            _fbb,
            &clz_Torappu_ZoneTableArgs {
                zones,
                weeklyAdditionInfo,
                zoneValidInfo,
                mainlineAdditionInfo,
                zoneRecordGroupedData,
                zoneRecordRewardData,
                mainlineZoneIdList,
                zoneMetaData,
            },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_ZoneTable`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_zone_table_unchecked`.
pub fn root_as_clz_torappu_zone_table(
    buf: &[u8],
) -> Result<clz_Torappu_ZoneTable, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_ZoneTable>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_ZoneTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_zone_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_zone_table(
    buf: &[u8],
) -> Result<clz_Torappu_ZoneTable, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_ZoneTable>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_ZoneTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_zone_table_unchecked`.
pub fn root_as_clz_torappu_zone_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_ZoneTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_ZoneTable<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_ZoneTable` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_zone_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_zone_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_ZoneTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_ZoneTable<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_ZoneTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_ZoneTable`.
pub unsafe fn root_as_clz_torappu_zone_table_unchecked(buf: &[u8]) -> clz_Torappu_ZoneTable {
    unsafe { flatbuffers::root_unchecked::<clz_Torappu_ZoneTable>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_ZoneTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_ZoneTable`.
pub unsafe fn size_prefixed_root_as_clz_torappu_zone_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_ZoneTable {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_ZoneTable>(buf) }
}
#[inline]
pub fn finish_clz_torappu_zone_table_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_ZoneTable<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_zone_table_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_ZoneTable<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
