// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_EVOLVE_PHASE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_EVOLVE_PHASE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_EVOLVE_PHASE: [enum__Torappu_EvolvePhase; 5] = [
    enum__Torappu_EvolvePhase::PHASE_0,
    enum__Torappu_EvolvePhase::PHASE_1,
    enum__Torappu_EvolvePhase::PHASE_2,
    enum__Torappu_EvolvePhase::PHASE_3,
    enum__Torappu_EvolvePhase::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_EvolvePhase(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_EvolvePhase {
    pub const PHASE_0: Self = Self(0);
    pub const PHASE_1: Self = Self(1);
    pub const PHASE_2: Self = Self(2);
    pub const PHASE_3: Self = Self(3);
    pub const E_NUM: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::PHASE_0,
        Self::PHASE_1,
        Self::PHASE_2,
        Self::PHASE_3,
        Self::E_NUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::PHASE_0 => Some("PHASE_0"),
            Self::PHASE_1 => Some("PHASE_1"),
            Self::PHASE_2 => Some("PHASE_2"),
            Self::PHASE_3 => Some("PHASE_3"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_EvolvePhase {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_EvolvePhase {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_EvolvePhase",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_EvolvePhase {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_EvolvePhase {
    type Output = enum__Torappu_EvolvePhase;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_EvolvePhase {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_EvolvePhase {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_EvolvePhase {}
pub enum clz_Torappu_CharacterData_UnlockConditionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharacterData_UnlockCondition<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharacterData_UnlockCondition<'a> {
    type Inner = clz_Torappu_CharacterData_UnlockCondition<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharacterData_UnlockCondition<'a> {
    pub const VT_PHASE: flatbuffers::VOffsetT = 4;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharacterData_UnlockCondition { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharacterData_UnlockConditionArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'bldr>> {
        let mut builder = clz_Torappu_CharacterData_UnlockConditionBuilder::new(_fbb);
        builder.add_level(args.level);
        builder.add_phase(args.phase);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharacterData_UnlockConditionT {
        let phase = self.phase();
        let level = self.level();
        clz_Torappu_CharacterData_UnlockConditionT { phase, level }
    }

    #[inline]
    pub fn phase(&self) -> enum__Torappu_EvolvePhase {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_EvolvePhase>(
                    clz_Torappu_CharacterData_UnlockCondition::VT_PHASE,
                    Some(enum__Torappu_EvolvePhase::PHASE_0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CharacterData_UnlockCondition::VT_LEVEL, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharacterData_UnlockCondition<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_EvolvePhase>("phase", Self::VT_PHASE, false)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharacterData_UnlockConditionArgs {
    pub phase: enum__Torappu_EvolvePhase,
    pub level: i32,
}
impl<'a> Default for clz_Torappu_CharacterData_UnlockConditionArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharacterData_UnlockConditionArgs {
            phase: enum__Torappu_EvolvePhase::PHASE_0,
            level: 0,
        }
    }
}

impl Serialize for clz_Torappu_CharacterData_UnlockCondition<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharacterData_UnlockCondition", 2)?;
        s.serialize_field("phase", &self.phase())?;
        s.serialize_field("level", &self.level())?;
        s.end()
    }
}

pub struct clz_Torappu_CharacterData_UnlockConditionBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharacterData_UnlockConditionBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_phase(&mut self, phase: enum__Torappu_EvolvePhase) {
        self.fbb_.push_slot::<enum__Torappu_EvolvePhase>(
            clz_Torappu_CharacterData_UnlockCondition::VT_PHASE,
            phase,
            enum__Torappu_EvolvePhase::PHASE_0,
        );
    }
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_CharacterData_UnlockCondition::VT_LEVEL,
            level,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharacterData_UnlockConditionBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharacterData_UnlockConditionBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharacterData_UnlockCondition<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharacterData_UnlockCondition");
        ds.field("phase", &self.phase());
        ds.field("level", &self.level());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharacterData_UnlockConditionT {
    pub phase: enum__Torappu_EvolvePhase,
    pub level: i32,
}
impl Default for clz_Torappu_CharacterData_UnlockConditionT {
    fn default() -> Self {
        Self {
            phase: enum__Torappu_EvolvePhase::PHASE_0,
            level: 0,
        }
    }
}
impl clz_Torappu_CharacterData_UnlockConditionT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'b>> {
        let phase = self.phase;
        let level = self.level;
        clz_Torappu_CharacterData_UnlockCondition::create(
            _fbb,
            &clz_Torappu_CharacterData_UnlockConditionArgs { phase, level },
        )
    }
}
pub enum clz_Torappu_Blackboard_DataPairOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Blackboard_DataPair<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Blackboard_DataPair<'a> {
    type Inner = clz_Torappu_Blackboard_DataPair<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Blackboard_DataPair<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;
    pub const VT_VALUESTR: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Blackboard_DataPair { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Blackboard_DataPairArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'bldr>> {
        let mut builder = clz_Torappu_Blackboard_DataPairBuilder::new(_fbb);
        if let Some(x) = args.valueStr {
            builder.add_valueStr(x);
        }
        builder.add_value(args.value);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Blackboard_DataPairT {
        let key = self.key().map(|x| x.to_string());
        let value = self.value();
        let valueStr = self.valueStr().map(|x| x.to_string());
        clz_Torappu_Blackboard_DataPairT {
            key,
            value,
            valueStr,
        }
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_KEY,
                None,
            )
        }
    }
    #[inline]
    pub fn value(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn valueStr(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Blackboard_DataPair<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<f32>("value", Self::VT_VALUE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "valueStr",
                Self::VT_VALUESTR,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Blackboard_DataPairArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: f32,
    pub valueStr: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Blackboard_DataPairArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Blackboard_DataPairArgs {
            key: None,
            value: 0.0,
            valueStr: None,
        }
    }
}

impl Serialize for clz_Torappu_Blackboard_DataPair<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Blackboard_DataPair", 3)?;
        if let Some(f) = self.key() {
            s.serialize_field("key", &f)?;
        } else {
            s.skip_field("key")?;
        }
        s.serialize_field("value", &self.value())?;
        if let Some(f) = self.valueStr() {
            s.serialize_field("valueStr", &f)?;
        } else {
            s.skip_field("valueStr")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Blackboard_DataPairBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, value, 0.0);
    }
    #[inline]
    pub fn add_valueStr(&mut self, valueStr: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
            valueStr,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Blackboard_DataPairBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Blackboard_DataPair<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Blackboard_DataPair");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.field("valueStr", &self.valueStr());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Blackboard_DataPairT {
    pub key: Option<String>,
    pub value: f32,
    pub valueStr: Option<String>,
}
impl Default for clz_Torappu_Blackboard_DataPairT {
    fn default() -> Self {
        Self {
            key: None,
            value: 0.0,
            valueStr: None,
        }
    }
}
impl clz_Torappu_Blackboard_DataPairT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'b>> {
        let key = self.key.as_ref().map(|x| _fbb.create_string(x));
        let value = self.value;
        let valueStr = self.valueStr.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Blackboard_DataPair::create(
            _fbb,
            &clz_Torappu_Blackboard_DataPairArgs {
                key,
                value,
                valueStr,
            },
        )
    }
}
pub enum clz_Torappu_TalentDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_TalentData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_TalentData<'a> {
    type Inner = clz_Torappu_TalentData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_TalentData<'a> {
    pub const VT_UNLOCKCONDITION: flatbuffers::VOffsetT = 4;
    pub const VT_REQUIREDPOTENTIALRANK: flatbuffers::VOffsetT = 6;
    pub const VT_PREFABKEY: flatbuffers::VOffsetT = 8;
    pub const VT_NAME: flatbuffers::VOffsetT = 10;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 12;
    pub const VT_RANGEID: flatbuffers::VOffsetT = 14;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 16;
    pub const VT_TOKENKEY: flatbuffers::VOffsetT = 18;
    pub const VT_ISHIDETALENT: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_TalentData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_TalentDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TalentData<'bldr>> {
        let mut builder = clz_Torappu_TalentDataBuilder::new(_fbb);
        if let Some(x) = args.tokenKey {
            builder.add_tokenKey(x);
        }
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        if let Some(x) = args.rangeId {
            builder.add_rangeId(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.prefabKey {
            builder.add_prefabKey(x);
        }
        builder.add_requiredPotentialRank(args.requiredPotentialRank);
        if let Some(x) = args.unlockCondition {
            builder.add_unlockCondition(x);
        }
        builder.add_isHideTalent(args.isHideTalent);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_TalentDataT {
        let unlockCondition = self.unlockCondition().map(|x| Box::new(x.unpack()));
        let requiredPotentialRank = self.requiredPotentialRank();
        let prefabKey = self.prefabKey().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let rangeId = self.rangeId().map(|x| x.to_string());
        let blackboard = self
            .blackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let tokenKey = self.tokenKey().map(|x| x.to_string());
        let isHideTalent = self.isHideTalent();
        clz_Torappu_TalentDataT {
            unlockCondition,
            requiredPotentialRank,
            prefabKey,
            name,
            description,
            rangeId,
            blackboard,
            tokenKey,
            isHideTalent,
        }
    }

    #[inline]
    pub fn unlockCondition(&self) -> Option<clz_Torappu_CharacterData_UnlockCondition<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                    clz_Torappu_TalentData::VT_UNLOCKCONDITION,
                    None,
                )
        }
    }
    #[inline]
    pub fn requiredPotentialRank(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_TalentData::VT_REQUIREDPOTENTIALRANK, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn prefabKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TalentData::VT_PREFABKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_TalentData::VT_NAME, None)
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TalentData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn rangeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_TalentData::VT_RANGEID, None)
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(clz_Torappu_TalentData::VT_BLACKBOARD, None)
        }
    }
    #[inline]
    pub fn tokenKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TalentData::VT_TOKENKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn isHideTalent(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_TalentData::VT_ISHIDETALENT, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_TalentData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                "unlockCondition",
                Self::VT_UNLOCKCONDITION,
                false,
            )?
            .visit_field::<i32>(
                "requiredPotentialRank",
                Self::VT_REQUIREDPOTENTIALRANK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "prefabKey",
                Self::VT_PREFABKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rangeId", Self::VT_RANGEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "tokenKey",
                Self::VT_TOKENKEY,
                false,
            )?
            .visit_field::<bool>("isHideTalent", Self::VT_ISHIDETALENT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_TalentDataArgs<'a> {
    pub unlockCondition:
        Option<flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'a>>>,
    pub requiredPotentialRank: i32,
    pub prefabKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rangeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
    pub tokenKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isHideTalent: bool,
}
impl<'a> Default for clz_Torappu_TalentDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_TalentDataArgs {
            unlockCondition: None,
            requiredPotentialRank: 0,
            prefabKey: None,
            name: None,
            description: None,
            rangeId: None,
            blackboard: None,
            tokenKey: None,
            isHideTalent: false,
        }
    }
}

impl Serialize for clz_Torappu_TalentData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_TalentData", 9)?;
        if let Some(f) = self.unlockCondition() {
            s.serialize_field("unlockCondition", &f)?;
        } else {
            s.skip_field("unlockCondition")?;
        }
        s.serialize_field("requiredPotentialRank", &self.requiredPotentialRank())?;
        if let Some(f) = self.prefabKey() {
            s.serialize_field("prefabKey", &f)?;
        } else {
            s.skip_field("prefabKey")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        if let Some(f) = self.rangeId() {
            s.serialize_field("rangeId", &f)?;
        } else {
            s.skip_field("rangeId")?;
        }
        if let Some(f) = self.blackboard() {
            s.serialize_field("blackboard", &f)?;
        } else {
            s.skip_field("blackboard")?;
        }
        if let Some(f) = self.tokenKey() {
            s.serialize_field("tokenKey", &f)?;
        } else {
            s.skip_field("tokenKey")?;
        }
        s.serialize_field("isHideTalent", &self.isHideTalent())?;
        s.end()
    }
}

pub struct clz_Torappu_TalentDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_TalentDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_unlockCondition(
        &mut self,
        unlockCondition: flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                clz_Torappu_TalentData::VT_UNLOCKCONDITION,
                unlockCondition,
            );
    }
    #[inline]
    pub fn add_requiredPotentialRank(&mut self, requiredPotentialRank: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_TalentData::VT_REQUIREDPOTENTIALRANK,
            requiredPotentialRank,
            0,
        );
    }
    #[inline]
    pub fn add_prefabKey(&mut self, prefabKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TalentData::VT_PREFABKEY,
            prefabKey,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_TalentData::VT_NAME, name);
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TalentData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_rangeId(&mut self, rangeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TalentData::VT_RANGEID,
            rangeId,
        );
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TalentData::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn add_tokenKey(&mut self, tokenKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TalentData::VT_TOKENKEY,
            tokenKey,
        );
    }
    #[inline]
    pub fn add_isHideTalent(&mut self, isHideTalent: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_TalentData::VT_ISHIDETALENT, isHideTalent, false);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_TalentDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_TalentDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_TalentData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_TalentData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_TalentData");
        ds.field("unlockCondition", &self.unlockCondition());
        ds.field("requiredPotentialRank", &self.requiredPotentialRank());
        ds.field("prefabKey", &self.prefabKey());
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.field("rangeId", &self.rangeId());
        ds.field("blackboard", &self.blackboard());
        ds.field("tokenKey", &self.tokenKey());
        ds.field("isHideTalent", &self.isHideTalent());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_TalentDataT {
    pub unlockCondition: Option<Box<clz_Torappu_CharacterData_UnlockConditionT>>,
    pub requiredPotentialRank: i32,
    pub prefabKey: Option<String>,
    pub name: Option<String>,
    pub description: Option<String>,
    pub rangeId: Option<String>,
    pub blackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
    pub tokenKey: Option<String>,
    pub isHideTalent: bool,
}
impl Default for clz_Torappu_TalentDataT {
    fn default() -> Self {
        Self {
            unlockCondition: None,
            requiredPotentialRank: 0,
            prefabKey: None,
            name: None,
            description: None,
            rangeId: None,
            blackboard: None,
            tokenKey: None,
            isHideTalent: false,
        }
    }
}
impl clz_Torappu_TalentDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TalentData<'b>> {
        let unlockCondition = self.unlockCondition.as_ref().map(|x| x.pack(_fbb));
        let requiredPotentialRank = self.requiredPotentialRank;
        let prefabKey = self.prefabKey.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let rangeId = self.rangeId.as_ref().map(|x| _fbb.create_string(x));
        let blackboard = self.blackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let tokenKey = self.tokenKey.as_ref().map(|x| _fbb.create_string(x));
        let isHideTalent = self.isHideTalent;
        clz_Torappu_TalentData::create(
            _fbb,
            &clz_Torappu_TalentDataArgs {
                unlockCondition,
                requiredPotentialRank,
                prefabKey,
                name,
                description,
                rangeId,
                blackboard,
                tokenKey,
                isHideTalent,
            },
        )
    }
}
pub enum clz_Torappu_CharacterData_MasterDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharacterData_MasterData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharacterData_MasterData<'a> {
    type Inner = clz_Torappu_CharacterData_MasterData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharacterData_MasterData<'a> {
    pub const VT_LEVEL: flatbuffers::VOffsetT = 4;
    pub const VT_MASTERID: flatbuffers::VOffsetT = 6;
    pub const VT_TALENTDATA: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharacterData_MasterData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharacterData_MasterDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_MasterData<'bldr>> {
        let mut builder = clz_Torappu_CharacterData_MasterDataBuilder::new(_fbb);
        if let Some(x) = args.talentData {
            builder.add_talentData(x);
        }
        if let Some(x) = args.masterId {
            builder.add_masterId(x);
        }
        builder.add_level(args.level);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharacterData_MasterDataT {
        let level = self.level();
        let masterId = self.masterId().map(|x| x.to_string());
        let talentData = self.talentData().map(|x| Box::new(x.unpack()));
        clz_Torappu_CharacterData_MasterDataT {
            level,
            masterId,
            talentData,
        }
    }

    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CharacterData_MasterData::VT_LEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn masterId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData_MasterData::VT_MASTERID,
                None,
            )
        }
    }
    #[inline]
    pub fn talentData(&self) -> Option<clz_Torappu_TalentData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_TalentData>>(
                    clz_Torappu_CharacterData_MasterData::VT_TALENTDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharacterData_MasterData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "masterId",
                Self::VT_MASTERID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_TalentData>>(
                "talentData",
                Self::VT_TALENTDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharacterData_MasterDataArgs<'a> {
    pub level: i32,
    pub masterId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub talentData: Option<flatbuffers::WIPOffset<clz_Torappu_TalentData<'a>>>,
}
impl<'a> Default for clz_Torappu_CharacterData_MasterDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharacterData_MasterDataArgs {
            level: 0,
            masterId: None,
            talentData: None,
        }
    }
}

impl Serialize for clz_Torappu_CharacterData_MasterData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharacterData_MasterData", 3)?;
        s.serialize_field("level", &self.level())?;
        if let Some(f) = self.masterId() {
            s.serialize_field("masterId", &f)?;
        } else {
            s.skip_field("masterId")?;
        }
        if let Some(f) = self.talentData() {
            s.serialize_field("talentData", &f)?;
        } else {
            s.skip_field("talentData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CharacterData_MasterDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharacterData_MasterDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_CharacterData_MasterData::VT_LEVEL, level, 0);
    }
    #[inline]
    pub fn add_masterId(&mut self, masterId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_MasterData::VT_MASTERID,
            masterId,
        );
    }
    #[inline]
    pub fn add_talentData(
        &mut self,
        talentData: flatbuffers::WIPOffset<clz_Torappu_TalentData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_TalentData>>(
                clz_Torappu_CharacterData_MasterData::VT_TALENTDATA,
                talentData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharacterData_MasterDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharacterData_MasterDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_MasterData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharacterData_MasterData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharacterData_MasterData");
        ds.field("level", &self.level());
        ds.field("masterId", &self.masterId());
        ds.field("talentData", &self.talentData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharacterData_MasterDataT {
    pub level: i32,
    pub masterId: Option<String>,
    pub talentData: Option<Box<clz_Torappu_TalentDataT>>,
}
impl Default for clz_Torappu_CharacterData_MasterDataT {
    fn default() -> Self {
        Self {
            level: 0,
            masterId: None,
            talentData: None,
        }
    }
}
impl clz_Torappu_CharacterData_MasterDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_MasterData<'b>> {
        let level = self.level;
        let masterId = self.masterId.as_ref().map(|x| _fbb.create_string(x));
        let talentData = self.talentData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_CharacterData_MasterData::create(
            _fbb,
            &clz_Torappu_CharacterData_MasterDataArgs {
                level,
                masterId,
                talentData,
            },
        )
    }
}
pub enum clz_Torappu_CharacterData_MasterDataBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharacterData_MasterDataBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharacterData_MasterDataBundle<'a> {
    type Inner = clz_Torappu_CharacterData_MasterDataBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharacterData_MasterDataBundle<'a> {
    pub const VT_CANDIDATES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharacterData_MasterDataBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharacterData_MasterDataBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_MasterDataBundle<'bldr>> {
        let mut builder = clz_Torappu_CharacterData_MasterDataBundleBuilder::new(_fbb);
        if let Some(x) = args.candidates {
            builder.add_candidates(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharacterData_MasterDataBundleT {
        let candidates = self
            .candidates()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_CharacterData_MasterDataBundleT { candidates }
    }

    #[inline]
    pub fn candidates(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MasterData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MasterData>,
                >,
            >>(
                clz_Torappu_CharacterData_MasterDataBundle::VT_CANDIDATES,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharacterData_MasterDataBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MasterData>,
                >,
            >>("candidates", Self::VT_CANDIDATES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharacterData_MasterDataBundleArgs<'a> {
    pub candidates: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MasterData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_CharacterData_MasterDataBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharacterData_MasterDataBundleArgs { candidates: None }
    }
}

impl Serialize for clz_Torappu_CharacterData_MasterDataBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharacterData_MasterDataBundle", 1)?;
        if let Some(f) = self.candidates() {
            s.serialize_field("candidates", &f)?;
        } else {
            s.skip_field("candidates")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CharacterData_MasterDataBundleBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharacterData_MasterDataBundleBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_candidates(
        &mut self,
        candidates: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MasterData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_MasterDataBundle::VT_CANDIDATES,
            candidates,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharacterData_MasterDataBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharacterData_MasterDataBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_MasterDataBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharacterData_MasterDataBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharacterData_MasterDataBundle");
        ds.field("candidates", &self.candidates());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharacterData_MasterDataBundleT {
    pub candidates: Option<Vec<clz_Torappu_CharacterData_MasterDataT>>,
}
impl Default for clz_Torappu_CharacterData_MasterDataBundleT {
    fn default() -> Self {
        Self { candidates: None }
    }
}
impl clz_Torappu_CharacterData_MasterDataBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_MasterDataBundle<'b>> {
        let candidates = self.candidates.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_CharacterData_MasterDataBundle::create(
            _fbb,
            &clz_Torappu_CharacterData_MasterDataBundleArgs { candidates },
        )
    }
}
pub enum dict__string__clz_Torappu_CharacterData_MasterDataBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_CharacterData_MasterDataBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_CharacterData_MasterDataBundle<'a> {
    type Inner = dict__string__clz_Torappu_CharacterData_MasterDataBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_CharacterData_MasterDataBundle<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_CharacterData_MasterDataBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_CharacterData_MasterDataBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharacterData_MasterDataBundle<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_CharacterData_MasterDataBundleBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_CharacterData_MasterDataBundleT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_CharacterData_MasterDataBundleT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_CharacterData_MasterDataBundle::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_CharacterData_MasterDataBundle,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_CharacterData_MasterDataBundle<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MasterDataBundle>>(
                    dict__string__clz_Torappu_CharacterData_MasterDataBundle::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_CharacterData_MasterDataBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MasterDataBundle>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_CharacterData_MasterDataBundleArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_CharacterData_MasterDataBundle<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_CharacterData_MasterDataBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_CharacterData_MasterDataBundleArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_CharacterData_MasterDataBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_CharacterData_MasterDataBundle",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_CharacterData_MasterDataBundleBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_CharacterData_MasterDataBundleBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_CharacterData_MasterDataBundle::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_CharacterData_MasterDataBundle<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharacterData_MasterDataBundle>>(
                dict__string__clz_Torappu_CharacterData_MasterDataBundle::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_CharacterData_MasterDataBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_CharacterData_MasterDataBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharacterData_MasterDataBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_CharacterData_MasterDataBundle::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_CharacterData_MasterDataBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_CharacterData_MasterDataBundle");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_CharacterData_MasterDataBundleT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_CharacterData_MasterDataBundleT>>,
}
impl Default for dict__string__clz_Torappu_CharacterData_MasterDataBundleT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_CharacterData_MasterDataBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharacterData_MasterDataBundle<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_CharacterData_MasterDataBundle::create(
            _fbb,
            &dict__string__clz_Torappu_CharacterData_MasterDataBundleArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle<'a>
{
    type Inner = clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle<'a> {
    pub const VT_MASTER_DATA_BUNDLES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundleArgs<
            'args,
        >,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle<'bldr>,
    > {
        let mut builder =
            clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundleBuilder::new(_fbb);
        if let Some(x) = args.master_data_bundles {
            builder.add_master_data_bundles(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundleT {
        let master_data_bundles = self
            .master_data_bundles()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundleT {
            master_data_bundles,
        }
    }

    #[inline]
    pub fn master_data_bundles(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_CharacterData_MasterDataBundle<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharacterData_MasterDataBundle>>>>(clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle::VT_MASTER_DATA_BUNDLES, None)
        }
    }
}

impl flatbuffers::Verifiable
    for clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_CharacterData_MasterDataBundle,
                    >,
                >,
            >>("master_data_bundles", Self::VT_MASTER_DATA_BUNDLES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundleArgs<'a> {
    pub master_data_bundles: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_CharacterData_MasterDataBundle<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundleArgs {
            master_data_bundles: None,
        }
    }
}

impl Serialize for clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle",
            1,
        )?;
        if let Some(f) = self.master_data_bundles() {
            s.serialize_field("master_data_bundles", &f)?;
        } else {
            s.skip_field("master_data_bundles")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundleBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundleBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_master_data_bundles(
        &mut self,
        master_data_bundles: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_CharacterData_MasterDataBundle<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle::VT_MASTER_DATA_BUNDLES, master_data_bundles);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundleBuilder<'a, 'b, A>
    {
        let start = _fbb.start_table();
        clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle");
        ds.field("master_data_bundles", &self.master_data_bundles());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundleT {
    pub master_data_bundles: Option<Vec<dict__string__clz_Torappu_CharacterData_MasterDataBundleT>>,
}
impl Default for clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundleT {
    fn default() -> Self {
        Self {
            master_data_bundles: None,
        }
    }
}
impl clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle<'b>,
    > {
        let master_data_bundles = self.master_data_bundles.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle::create(
            _fbb,
            &clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundleArgs {
                master_data_bundles,
            },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_simple_kvtable_clz_torappu_character_data_master_data_bundle_unchecked`.
pub fn root_as_clz_torappu_simple_kvtable_clz_torappu_character_data_master_data_bundle(
    buf: &[u8],
) -> Result<
    clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle,
    flatbuffers::InvalidFlatbuffer,
> {
    flatbuffers::root::<clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_simple_kvtable_clz_torappu_character_data_master_data_bundle_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_simple_kvtable_clz_torappu_character_data_master_data_bundle(
    buf: &[u8],
) -> Result<
    clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle,
    flatbuffers::InvalidFlatbuffer,
> {
    flatbuffers::size_prefixed_root::<
        clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle,
    >(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_simple_kvtable_clz_torappu_character_data_master_data_bundle_unchecked`.
pub fn root_as_clz_torappu_simple_kvtable_clz_torappu_character_data_master_data_bundle_with_opts<
    'b,
    'o,
>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<
    clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle<'b>,
    flatbuffers::InvalidFlatbuffer,
> {
    flatbuffers::root_with_opts::<
        clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle<'b>,
    >(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_simple_kvtable_clz_torappu_character_data_master_data_bundle_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_simple_kvtable_clz_torappu_character_data_master_data_bundle_with_opts<
    'b,
    'o,
>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<
    clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle<'b>,
    flatbuffers::InvalidFlatbuffer,
> {
    flatbuffers::size_prefixed_root_with_opts::<
        clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle<'b>,
    >(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle`.
pub unsafe fn root_as_clz_torappu_simple_kvtable_clz_torappu_character_data_master_data_bundle_unchecked(
    buf: &[u8],
) -> clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle {
    unsafe {
        flatbuffers::root_unchecked::<
            clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle,
        >(buf)
    }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle`.
pub unsafe fn size_prefixed_root_as_clz_torappu_simple_kvtable_clz_torappu_character_data_master_data_bundle_unchecked(
    buf: &[u8],
) -> clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle {
    unsafe {
        flatbuffers::size_prefixed_root_unchecked::<
            clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle,
        >(buf)
    }
}
#[inline]
pub fn finish_clz_torappu_simple_kvtable_clz_torappu_character_data_master_data_bundle_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<
        clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle<'a>,
    >,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_simple_kvtable_clz_torappu_character_data_master_data_bundle_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<
        clz_Torappu_SimpleKVTable_clz_Torappu_CharacterData_MasterDataBundle<'a>,
    >,
) {
    fbb.finish_size_prefixed(root, None);
}
