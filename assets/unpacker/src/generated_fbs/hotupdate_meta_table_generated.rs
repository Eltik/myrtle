// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_HOT_UPDATE_META_PIC_DATA_PIC_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_HOT_UPDATE_META_PIC_DATA_PIC_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_HOT_UPDATE_META_PIC_DATA_PIC_TYPE:
    [enum__Torappu_HotUpdateMetaPicData_PicType; 2] = [
    enum__Torappu_HotUpdateMetaPicData_PicType::NONE,
    enum__Torappu_HotUpdateMetaPicData_PicType::SKIN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_HotUpdateMetaPicData_PicType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_HotUpdateMetaPicData_PicType {
    pub const NONE: Self = Self(0);
    pub const SKIN: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::SKIN];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::SKIN => Some("SKIN"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_HotUpdateMetaPicData_PicType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_HotUpdateMetaPicData_PicType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_HotUpdateMetaPicData_PicType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_HotUpdateMetaPicData_PicType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_HotUpdateMetaPicData_PicType {
    type Output = enum__Torappu_HotUpdateMetaPicData_PicType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_HotUpdateMetaPicData_PicType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_HotUpdateMetaPicData_PicType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_HotUpdateMetaPicData_PicType {}
pub enum clz_Torappu_HotUpdateMetaPicDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_HotUpdateMetaPicData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_HotUpdateMetaPicData<'a> {
    type Inner = clz_Torappu_HotUpdateMetaPicData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_HotUpdateMetaPicData<'a> {
    pub const VT_PICID: flatbuffers::VOffsetT = 4;
    pub const VT_GROUPID: flatbuffers::VOffsetT = 6;
    pub const VT_SORTID: flatbuffers::VOffsetT = 8;
    pub const VT_STARTTIME: flatbuffers::VOffsetT = 10;
    pub const VT_ENDTIME: flatbuffers::VOffsetT = 12;
    pub const VT_TEXTLIST: flatbuffers::VOffsetT = 14;
    pub const VT_PICTYPE: flatbuffers::VOffsetT = 16;
    pub const VT_LOGOID: flatbuffers::VOffsetT = 18;
    pub const VT_COLOR: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_HotUpdateMetaPicData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_HotUpdateMetaPicDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HotUpdateMetaPicData<'bldr>> {
        let mut builder = clz_Torappu_HotUpdateMetaPicDataBuilder::new(_fbb);
        builder.add_endTime(args.endTime);
        builder.add_startTime(args.startTime);
        if let Some(x) = args.color {
            builder.add_color(x);
        }
        if let Some(x) = args.logoId {
            builder.add_logoId(x);
        }
        builder.add_picType(args.picType);
        if let Some(x) = args.textList {
            builder.add_textList(x);
        }
        builder.add_sortId(args.sortId);
        builder.add_groupId(args.groupId);
        if let Some(x) = args.picId {
            builder.add_picId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_HotUpdateMetaPicDataT {
        let picId = self.picId().map(|x| x.to_string());
        let groupId = self.groupId();
        let sortId = self.sortId();
        let startTime = self.startTime();
        let endTime = self.endTime();
        let textList = self
            .textList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let picType = self.picType();
        let logoId = self.logoId().map(|x| x.to_string());
        let color = self.color().map(|x| x.to_string());
        clz_Torappu_HotUpdateMetaPicDataT {
            picId,
            groupId,
            sortId,
            startTime,
            endTime,
            textList,
            picType,
            logoId,
            color,
        }
    }

    #[inline]
    pub fn picId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HotUpdateMetaPicData::VT_PICID,
                None,
            )
        }
    }
    #[inline]
    pub fn groupId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_HotUpdateMetaPicData::VT_GROUPID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_HotUpdateMetaPicData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn startTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_HotUpdateMetaPicData::VT_STARTTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_HotUpdateMetaPicData::VT_ENDTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn textList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_HotUpdateMetaPicData::VT_TEXTLIST, None)
        }
    }
    #[inline]
    pub fn picType(&self) -> enum__Torappu_HotUpdateMetaPicData_PicType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_HotUpdateMetaPicData_PicType>(
                    clz_Torappu_HotUpdateMetaPicData::VT_PICTYPE,
                    Some(enum__Torappu_HotUpdateMetaPicData_PicType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn logoId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HotUpdateMetaPicData::VT_LOGOID,
                None,
            )
        }
    }
    #[inline]
    pub fn color(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HotUpdateMetaPicData::VT_COLOR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_HotUpdateMetaPicData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("picId", Self::VT_PICID, false)?
            .visit_field::<i32>("groupId", Self::VT_GROUPID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<i64>("startTime", Self::VT_STARTTIME, false)?
            .visit_field::<i64>("endTime", Self::VT_ENDTIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("textList", Self::VT_TEXTLIST, false)?
            .visit_field::<enum__Torappu_HotUpdateMetaPicData_PicType>(
                "picType",
                Self::VT_PICTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("logoId", Self::VT_LOGOID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("color", Self::VT_COLOR, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_HotUpdateMetaPicDataArgs<'a> {
    pub picId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub groupId: i32,
    pub sortId: i32,
    pub startTime: i64,
    pub endTime: i64,
    pub textList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub picType: enum__Torappu_HotUpdateMetaPicData_PicType,
    pub logoId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub color: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_HotUpdateMetaPicDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_HotUpdateMetaPicDataArgs {
            picId: None,
            groupId: 0,
            sortId: 0,
            startTime: 0,
            endTime: 0,
            textList: None,
            picType: enum__Torappu_HotUpdateMetaPicData_PicType::NONE,
            logoId: None,
            color: None,
        }
    }
}

impl Serialize for clz_Torappu_HotUpdateMetaPicData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_HotUpdateMetaPicData", 9)?;
        if let Some(f) = self.picId() {
            s.serialize_field("picId", &f)?;
        } else {
            s.skip_field("picId")?;
        }
        s.serialize_field("groupId", &self.groupId())?;
        s.serialize_field("sortId", &self.sortId())?;
        s.serialize_field("startTime", &self.startTime())?;
        s.serialize_field("endTime", &self.endTime())?;
        if let Some(f) = self.textList() {
            s.serialize_field("textList", &f)?;
        } else {
            s.skip_field("textList")?;
        }
        s.serialize_field("picType", &self.picType())?;
        if let Some(f) = self.logoId() {
            s.serialize_field("logoId", &f)?;
        } else {
            s.skip_field("logoId")?;
        }
        if let Some(f) = self.color() {
            s.serialize_field("color", &f)?;
        } else {
            s.skip_field("color")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_HotUpdateMetaPicDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_HotUpdateMetaPicDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_picId(&mut self, picId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HotUpdateMetaPicData::VT_PICID,
            picId,
        );
    }
    #[inline]
    pub fn add_groupId(&mut self, groupId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_HotUpdateMetaPicData::VT_GROUPID, groupId, 0);
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_HotUpdateMetaPicData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_startTime(&mut self, startTime: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_HotUpdateMetaPicData::VT_STARTTIME, startTime, 0);
    }
    #[inline]
    pub fn add_endTime(&mut self, endTime: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_HotUpdateMetaPicData::VT_ENDTIME, endTime, 0);
    }
    #[inline]
    pub fn add_textList(
        &mut self,
        textList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HotUpdateMetaPicData::VT_TEXTLIST,
            textList,
        );
    }
    #[inline]
    pub fn add_picType(&mut self, picType: enum__Torappu_HotUpdateMetaPicData_PicType) {
        self.fbb_
            .push_slot::<enum__Torappu_HotUpdateMetaPicData_PicType>(
                clz_Torappu_HotUpdateMetaPicData::VT_PICTYPE,
                picType,
                enum__Torappu_HotUpdateMetaPicData_PicType::NONE,
            );
    }
    #[inline]
    pub fn add_logoId(&mut self, logoId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HotUpdateMetaPicData::VT_LOGOID,
            logoId,
        );
    }
    #[inline]
    pub fn add_color(&mut self, color: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HotUpdateMetaPicData::VT_COLOR,
            color,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_HotUpdateMetaPicDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_HotUpdateMetaPicDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_HotUpdateMetaPicData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_HotUpdateMetaPicData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_HotUpdateMetaPicData");
        ds.field("picId", &self.picId());
        ds.field("groupId", &self.groupId());
        ds.field("sortId", &self.sortId());
        ds.field("startTime", &self.startTime());
        ds.field("endTime", &self.endTime());
        ds.field("textList", &self.textList());
        ds.field("picType", &self.picType());
        ds.field("logoId", &self.logoId());
        ds.field("color", &self.color());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_HotUpdateMetaPicDataT {
    pub picId: Option<String>,
    pub groupId: i32,
    pub sortId: i32,
    pub startTime: i64,
    pub endTime: i64,
    pub textList: Option<Vec<String>>,
    pub picType: enum__Torappu_HotUpdateMetaPicData_PicType,
    pub logoId: Option<String>,
    pub color: Option<String>,
}
impl Default for clz_Torappu_HotUpdateMetaPicDataT {
    fn default() -> Self {
        Self {
            picId: None,
            groupId: 0,
            sortId: 0,
            startTime: 0,
            endTime: 0,
            textList: None,
            picType: enum__Torappu_HotUpdateMetaPicData_PicType::NONE,
            logoId: None,
            color: None,
        }
    }
}
impl clz_Torappu_HotUpdateMetaPicDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HotUpdateMetaPicData<'b>> {
        let picId = self.picId.as_ref().map(|x| _fbb.create_string(x));
        let groupId = self.groupId;
        let sortId = self.sortId;
        let startTime = self.startTime;
        let endTime = self.endTime;
        let textList = self.textList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let picType = self.picType;
        let logoId = self.logoId.as_ref().map(|x| _fbb.create_string(x));
        let color = self.color.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_HotUpdateMetaPicData::create(
            _fbb,
            &clz_Torappu_HotUpdateMetaPicDataArgs {
                picId,
                groupId,
                sortId,
                startTime,
                endTime,
                textList,
                picType,
                logoId,
                color,
            },
        )
    }
}
pub enum clz_Torappu_HotUpdateMetaMovieDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_HotUpdateMetaMovieData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_HotUpdateMetaMovieData<'a> {
    type Inner = clz_Torappu_HotUpdateMetaMovieData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_HotUpdateMetaMovieData<'a> {
    pub const VT_VIDEOID: flatbuffers::VOffsetT = 4;
    pub const VT_VIDEOPATH: flatbuffers::VOffsetT = 6;
    pub const VT_ENDTIME: flatbuffers::VOffsetT = 8;
    pub const VT_SORTID: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_HotUpdateMetaMovieData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_HotUpdateMetaMovieDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HotUpdateMetaMovieData<'bldr>> {
        let mut builder = clz_Torappu_HotUpdateMetaMovieDataBuilder::new(_fbb);
        builder.add_endTime(args.endTime);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.videoPath {
            builder.add_videoPath(x);
        }
        if let Some(x) = args.videoId {
            builder.add_videoId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_HotUpdateMetaMovieDataT {
        let videoId = self.videoId().map(|x| x.to_string());
        let videoPath = self.videoPath().map(|x| x.to_string());
        let endTime = self.endTime();
        let sortId = self.sortId();
        clz_Torappu_HotUpdateMetaMovieDataT {
            videoId,
            videoPath,
            endTime,
            sortId,
        }
    }

    #[inline]
    pub fn videoId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HotUpdateMetaMovieData::VT_VIDEOID,
                None,
            )
        }
    }
    #[inline]
    pub fn videoPath(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_HotUpdateMetaMovieData::VT_VIDEOPATH,
                None,
            )
        }
    }
    #[inline]
    pub fn endTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_HotUpdateMetaMovieData::VT_ENDTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_HotUpdateMetaMovieData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_HotUpdateMetaMovieData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("videoId", Self::VT_VIDEOID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "videoPath",
                Self::VT_VIDEOPATH,
                false,
            )?
            .visit_field::<i64>("endTime", Self::VT_ENDTIME, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_HotUpdateMetaMovieDataArgs<'a> {
    pub videoId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub videoPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub endTime: i64,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_HotUpdateMetaMovieDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_HotUpdateMetaMovieDataArgs {
            videoId: None,
            videoPath: None,
            endTime: 0,
            sortId: 0,
        }
    }
}

impl Serialize for clz_Torappu_HotUpdateMetaMovieData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_HotUpdateMetaMovieData", 4)?;
        if let Some(f) = self.videoId() {
            s.serialize_field("videoId", &f)?;
        } else {
            s.skip_field("videoId")?;
        }
        if let Some(f) = self.videoPath() {
            s.serialize_field("videoPath", &f)?;
        } else {
            s.skip_field("videoPath")?;
        }
        s.serialize_field("endTime", &self.endTime())?;
        s.serialize_field("sortId", &self.sortId())?;
        s.end()
    }
}

pub struct clz_Torappu_HotUpdateMetaMovieDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_HotUpdateMetaMovieDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_videoId(&mut self, videoId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HotUpdateMetaMovieData::VT_VIDEOID,
            videoId,
        );
    }
    #[inline]
    pub fn add_videoPath(&mut self, videoPath: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HotUpdateMetaMovieData::VT_VIDEOPATH,
            videoPath,
        );
    }
    #[inline]
    pub fn add_endTime(&mut self, endTime: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_HotUpdateMetaMovieData::VT_ENDTIME, endTime, 0);
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_HotUpdateMetaMovieData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_HotUpdateMetaMovieDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_HotUpdateMetaMovieDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_HotUpdateMetaMovieData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_HotUpdateMetaMovieData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_HotUpdateMetaMovieData");
        ds.field("videoId", &self.videoId());
        ds.field("videoPath", &self.videoPath());
        ds.field("endTime", &self.endTime());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_HotUpdateMetaMovieDataT {
    pub videoId: Option<String>,
    pub videoPath: Option<String>,
    pub endTime: i64,
    pub sortId: i32,
}
impl Default for clz_Torappu_HotUpdateMetaMovieDataT {
    fn default() -> Self {
        Self {
            videoId: None,
            videoPath: None,
            endTime: 0,
            sortId: 0,
        }
    }
}
impl clz_Torappu_HotUpdateMetaMovieDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HotUpdateMetaMovieData<'b>> {
        let videoId = self.videoId.as_ref().map(|x| _fbb.create_string(x));
        let videoPath = self.videoPath.as_ref().map(|x| _fbb.create_string(x));
        let endTime = self.endTime;
        let sortId = self.sortId;
        clz_Torappu_HotUpdateMetaMovieData::create(
            _fbb,
            &clz_Torappu_HotUpdateMetaMovieDataArgs {
                videoId,
                videoPath,
                endTime,
                sortId,
            },
        )
    }
}
pub enum clz_Torappu_HotUpdateMetaTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_HotUpdateMetaTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_HotUpdateMetaTable<'a> {
    type Inner = clz_Torappu_HotUpdateMetaTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_HotUpdateMetaTable<'a> {
    pub const VT_PICLIST: flatbuffers::VOffsetT = 4;
    pub const VT_MOVIEINFO: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_HotUpdateMetaTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_HotUpdateMetaTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HotUpdateMetaTable<'bldr>> {
        let mut builder = clz_Torappu_HotUpdateMetaTableBuilder::new(_fbb);
        if let Some(x) = args.movieInfo {
            builder.add_movieInfo(x);
        }
        if let Some(x) = args.picList {
            builder.add_picList(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_HotUpdateMetaTableT {
        let picList = self
            .picList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let movieInfo = self.movieInfo().map(|x| Box::new(x.unpack()));
        clz_Torappu_HotUpdateMetaTableT { picList, movieInfo }
    }

    #[inline]
    pub fn picList(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_HotUpdateMetaPicData<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_HotUpdateMetaPicData>,
                >,
            >>(clz_Torappu_HotUpdateMetaTable::VT_PICLIST, None)
        }
    }
    #[inline]
    pub fn movieInfo(&self) -> Option<clz_Torappu_HotUpdateMetaMovieData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_HotUpdateMetaMovieData>>(
                    clz_Torappu_HotUpdateMetaTable::VT_MOVIEINFO,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_HotUpdateMetaTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_HotUpdateMetaPicData>,
                >,
            >>("picList", Self::VT_PICLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_HotUpdateMetaMovieData>>(
                "movieInfo",
                Self::VT_MOVIEINFO,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_HotUpdateMetaTableArgs<'a> {
    pub picList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_HotUpdateMetaPicData<'a>>,
            >,
        >,
    >,
    pub movieInfo: Option<flatbuffers::WIPOffset<clz_Torappu_HotUpdateMetaMovieData<'a>>>,
}
impl<'a> Default for clz_Torappu_HotUpdateMetaTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_HotUpdateMetaTableArgs {
            picList: None,
            movieInfo: None,
        }
    }
}

impl Serialize for clz_Torappu_HotUpdateMetaTable<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_HotUpdateMetaTable", 2)?;
        if let Some(f) = self.picList() {
            s.serialize_field("picList", &f)?;
        } else {
            s.skip_field("picList")?;
        }
        if let Some(f) = self.movieInfo() {
            s.serialize_field("movieInfo", &f)?;
        } else {
            s.skip_field("movieInfo")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_HotUpdateMetaTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_HotUpdateMetaTableBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_picList(
        &mut self,
        picList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_HotUpdateMetaPicData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_HotUpdateMetaTable::VT_PICLIST,
            picList,
        );
    }
    #[inline]
    pub fn add_movieInfo(
        &mut self,
        movieInfo: flatbuffers::WIPOffset<clz_Torappu_HotUpdateMetaMovieData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_HotUpdateMetaMovieData>>(
                clz_Torappu_HotUpdateMetaTable::VT_MOVIEINFO,
                movieInfo,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_HotUpdateMetaTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_HotUpdateMetaTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_HotUpdateMetaTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_HotUpdateMetaTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_HotUpdateMetaTable");
        ds.field("picList", &self.picList());
        ds.field("movieInfo", &self.movieInfo());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_HotUpdateMetaTableT {
    pub picList: Option<Vec<clz_Torappu_HotUpdateMetaPicDataT>>,
    pub movieInfo: Option<Box<clz_Torappu_HotUpdateMetaMovieDataT>>,
}
impl Default for clz_Torappu_HotUpdateMetaTableT {
    fn default() -> Self {
        Self {
            picList: None,
            movieInfo: None,
        }
    }
}
impl clz_Torappu_HotUpdateMetaTableT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_HotUpdateMetaTable<'b>> {
        let picList = self.picList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let movieInfo = self.movieInfo.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_HotUpdateMetaTable::create(
            _fbb,
            &clz_Torappu_HotUpdateMetaTableArgs { picList, movieInfo },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_HotUpdateMetaTable`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_hot_update_meta_table_unchecked`.
pub fn root_as_clz_torappu_hot_update_meta_table(
    buf: &[u8],
) -> Result<clz_Torappu_HotUpdateMetaTable, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_HotUpdateMetaTable>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_HotUpdateMetaTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_hot_update_meta_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_hot_update_meta_table(
    buf: &[u8],
) -> Result<clz_Torappu_HotUpdateMetaTable, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_HotUpdateMetaTable>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_HotUpdateMetaTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_hot_update_meta_table_unchecked`.
pub fn root_as_clz_torappu_hot_update_meta_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_HotUpdateMetaTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_HotUpdateMetaTable<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_HotUpdateMetaTable` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_hot_update_meta_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_hot_update_meta_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_HotUpdateMetaTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_HotUpdateMetaTable<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_HotUpdateMetaTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_HotUpdateMetaTable`.
pub unsafe fn root_as_clz_torappu_hot_update_meta_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_HotUpdateMetaTable {
    unsafe { flatbuffers::root_unchecked::<clz_Torappu_HotUpdateMetaTable>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_HotUpdateMetaTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_HotUpdateMetaTable`.
pub unsafe fn size_prefixed_root_as_clz_torappu_hot_update_meta_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_HotUpdateMetaTable {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_HotUpdateMetaTable>(buf) }
}
#[inline]
pub fn finish_clz_torappu_hot_update_meta_table_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_HotUpdateMetaTable<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_hot_update_meta_table_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_HotUpdateMetaTable<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
