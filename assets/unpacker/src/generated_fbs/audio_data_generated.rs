// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_AUDIO_MIXER_DESC_CATEGORY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_AUDIO_MIXER_DESC_CATEGORY: i32 = 5;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_AUDIO_MIXER_DESC_CATEGORY:
    [enum__Torappu_Audio_MixerDesc_Category; 6] = [
    enum__Torappu_Audio_MixerDesc_Category::CUSTOM,
    enum__Torappu_Audio_MixerDesc_Category::FX_UI,
    enum__Torappu_Audio_MixerDesc_Category::FX_BATTLE,
    enum__Torappu_Audio_MixerDesc_Category::MUSIC,
    enum__Torappu_Audio_MixerDesc_Category::VOICE,
    enum__Torappu_Audio_MixerDesc_Category::MASTER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_Audio_MixerDesc_Category(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_Audio_MixerDesc_Category {
    pub const CUSTOM: Self = Self(0);
    pub const FX_UI: Self = Self(1);
    pub const FX_BATTLE: Self = Self(2);
    pub const MUSIC: Self = Self(3);
    pub const VOICE: Self = Self(4);
    pub const MASTER: Self = Self(5);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 5;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::CUSTOM,
        Self::FX_UI,
        Self::FX_BATTLE,
        Self::MUSIC,
        Self::VOICE,
        Self::MASTER,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::CUSTOM => Some("CUSTOM"),
            Self::FX_UI => Some("FX_UI"),
            Self::FX_BATTLE => Some("FX_BATTLE"),
            Self::MUSIC => Some("MUSIC"),
            Self::VOICE => Some("VOICE"),
            Self::MASTER => Some("MASTER"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_Audio_MixerDesc_Category {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_Audio_MixerDesc_Category {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_Audio_MixerDesc_Category",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_Audio_MixerDesc_Category {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_Audio_MixerDesc_Category {
    type Output = enum__Torappu_Audio_MixerDesc_Category;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_Audio_MixerDesc_Category {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_Audio_MixerDesc_Category {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_Audio_MixerDesc_Category {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BATTLE_VOICE_OPTION_BATTLE_VOICE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BATTLE_VOICE_OPTION_BATTLE_VOICE_TYPE: i32 = 8;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BATTLE_VOICE_OPTION_BATTLE_VOICE_TYPE:
    [enum__Torappu_BattleVoiceOption_BattleVoiceType; 9] = [
    enum__Torappu_BattleVoiceOption_BattleVoiceType::BATTLE_START,
    enum__Torappu_BattleVoiceOption_BattleVoiceType::ENCOUNTER_ENEMY,
    enum__Torappu_BattleVoiceOption_BattleVoiceType::PLACE_CHAR,
    enum__Torappu_BattleVoiceOption_BattleVoiceType::FOCUS_CHAR,
    enum__Torappu_BattleVoiceOption_BattleVoiceType::SKILL_ACTIVE,
    enum__Torappu_BattleVoiceOption_BattleVoiceType::SKILL_PASSIVE_IMP,
    enum__Torappu_BattleVoiceOption_BattleVoiceType::SKILL_PASSIVE_NOR,
    enum__Torappu_BattleVoiceOption_BattleVoiceType::NORMAL_ATTACK,
    enum__Torappu_BattleVoiceOption_BattleVoiceType::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BattleVoiceOption_BattleVoiceType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BattleVoiceOption_BattleVoiceType {
    pub const BATTLE_START: Self = Self(0);
    pub const ENCOUNTER_ENEMY: Self = Self(1);
    pub const PLACE_CHAR: Self = Self(2);
    pub const FOCUS_CHAR: Self = Self(3);
    pub const SKILL_ACTIVE: Self = Self(4);
    pub const SKILL_PASSIVE_IMP: Self = Self(5);
    pub const SKILL_PASSIVE_NOR: Self = Self(6);
    pub const NORMAL_ATTACK: Self = Self(7);
    pub const E_NUM: Self = Self(8);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 8;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::BATTLE_START,
        Self::ENCOUNTER_ENEMY,
        Self::PLACE_CHAR,
        Self::FOCUS_CHAR,
        Self::SKILL_ACTIVE,
        Self::SKILL_PASSIVE_IMP,
        Self::SKILL_PASSIVE_NOR,
        Self::NORMAL_ATTACK,
        Self::E_NUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::BATTLE_START => Some("BATTLE_START"),
            Self::ENCOUNTER_ENEMY => Some("ENCOUNTER_ENEMY"),
            Self::PLACE_CHAR => Some("PLACE_CHAR"),
            Self::FOCUS_CHAR => Some("FOCUS_CHAR"),
            Self::SKILL_ACTIVE => Some("SKILL_ACTIVE"),
            Self::SKILL_PASSIVE_IMP => Some("SKILL_PASSIVE_IMP"),
            Self::SKILL_PASSIVE_NOR => Some("SKILL_PASSIVE_NOR"),
            Self::NORMAL_ATTACK => Some("NORMAL_ATTACK"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BattleVoiceOption_BattleVoiceType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_BattleVoiceOption_BattleVoiceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_BattleVoiceOption_BattleVoiceType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BattleVoiceOption_BattleVoiceType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BattleVoiceOption_BattleVoiceType {
    type Output = enum__Torappu_BattleVoiceOption_BattleVoiceType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BattleVoiceOption_BattleVoiceType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BattleVoiceOption_BattleVoiceType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BattleVoiceOption_BattleVoiceType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_AUDIO_MIDDLEWARE_DATA_AUDIO_FADE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_AUDIO_MIDDLEWARE_DATA_AUDIO_FADE_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_AUDIO_MIDDLEWARE_DATA_AUDIO_FADE_TYPE:
    [enum__Torappu_Audio_Middleware_Data_AudioFadeType; 2] = [
    enum__Torappu_Audio_Middleware_Data_AudioFadeType::LINEAR,
    enum__Torappu_Audio_Middleware_Data_AudioFadeType::CONCAVE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_Audio_Middleware_Data_AudioFadeType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_Audio_Middleware_Data_AudioFadeType {
    pub const LINEAR: Self = Self(0);
    pub const CONCAVE: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::LINEAR, Self::CONCAVE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::LINEAR => Some("LINEAR"),
            Self::CONCAVE => Some("CONCAVE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_Audio_Middleware_Data_AudioFadeType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_Audio_Middleware_Data_AudioFadeType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_Audio_Middleware_Data_AudioFadeType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_Audio_Middleware_Data_AudioFadeType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_Audio_Middleware_Data_AudioFadeType {
    type Output = enum__Torappu_Audio_Middleware_Data_AudioFadeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_Audio_Middleware_Data_AudioFadeType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_Audio_Middleware_Data_AudioFadeType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_Audio_Middleware_Data_AudioFadeType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_VOICE_LANG_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_VOICE_LANG_TYPE: i32 = 11;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_VOICE_LANG_TYPE: [enum__Torappu_VoiceLangType; 12] = [
    enum__Torappu_VoiceLangType::NONE,
    enum__Torappu_VoiceLangType::JP,
    enum__Torappu_VoiceLangType::CN_MANDARIN,
    enum__Torappu_VoiceLangType::EN,
    enum__Torappu_VoiceLangType::KR,
    enum__Torappu_VoiceLangType::CN_TOPOLECT,
    enum__Torappu_VoiceLangType::LINKAGE,
    enum__Torappu_VoiceLangType::ITA,
    enum__Torappu_VoiceLangType::GER,
    enum__Torappu_VoiceLangType::RUS,
    enum__Torappu_VoiceLangType::FRE,
    enum__Torappu_VoiceLangType::SPA,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_VoiceLangType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_VoiceLangType {
    pub const NONE: Self = Self(0);
    pub const JP: Self = Self(1);
    pub const CN_MANDARIN: Self = Self(2);
    pub const EN: Self = Self(3);
    pub const KR: Self = Self(4);
    pub const CN_TOPOLECT: Self = Self(5);
    pub const LINKAGE: Self = Self(6);
    pub const ITA: Self = Self(7);
    pub const GER: Self = Self(8);
    pub const RUS: Self = Self(9);
    pub const FRE: Self = Self(10);
    pub const SPA: Self = Self(11);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 11;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::JP,
        Self::CN_MANDARIN,
        Self::EN,
        Self::KR,
        Self::CN_TOPOLECT,
        Self::LINKAGE,
        Self::ITA,
        Self::GER,
        Self::RUS,
        Self::FRE,
        Self::SPA,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::JP => Some("JP"),
            Self::CN_MANDARIN => Some("CN_MANDARIN"),
            Self::EN => Some("EN"),
            Self::KR => Some("KR"),
            Self::CN_TOPOLECT => Some("CN_TOPOLECT"),
            Self::LINKAGE => Some("LINKAGE"),
            Self::ITA => Some("ITA"),
            Self::GER => Some("GER"),
            Self::RUS => Some("RUS"),
            Self::FRE => Some("FRE"),
            Self::SPA => Some("SPA"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_VoiceLangType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_VoiceLangType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_VoiceLangType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_VoiceLangType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_VoiceLangType {
    type Output = enum__Torappu_VoiceLangType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_VoiceLangType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_VoiceLangType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_VoiceLangType {}
pub enum clz_Torappu_Audio_Middleware_Data_BGMBankOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Audio_Middleware_Data_BGMBank<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Audio_Middleware_Data_BGMBank<'a> {
    type Inner = clz_Torappu_Audio_Middleware_Data_BGMBank<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Audio_Middleware_Data_BGMBank<'a> {
    pub const VT_INTRO: flatbuffers::VOffsetT = 4;
    pub const VT_LOOP_: flatbuffers::VOffsetT = 6;
    pub const VT_VOLUME: flatbuffers::VOffsetT = 8;
    pub const VT_CROSSFADE: flatbuffers::VOffsetT = 10;
    pub const VT_DELAY: flatbuffers::VOffsetT = 12;
    pub const VT_FADESTYLEID: flatbuffers::VOffsetT = 14;
    pub const VT_NAME: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Audio_Middleware_Data_BGMBank { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Audio_Middleware_Data_BGMBankArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_BGMBank<'bldr>> {
        let mut builder = clz_Torappu_Audio_Middleware_Data_BGMBankBuilder::new(_fbb);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.fadeStyleId {
            builder.add_fadeStyleId(x);
        }
        builder.add_delay(args.delay);
        builder.add_crossfade(args.crossfade);
        builder.add_volume(args.volume);
        if let Some(x) = args.loop_ {
            builder.add_loop_(x);
        }
        if let Some(x) = args.intro {
            builder.add_intro(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Audio_Middleware_Data_BGMBankT {
        let intro = self.intro().map(|x| x.to_string());
        let loop_ = self.loop_().map(|x| x.to_string());
        let volume = self.volume();
        let crossfade = self.crossfade();
        let delay = self.delay();
        let fadeStyleId = self.fadeStyleId().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        clz_Torappu_Audio_Middleware_Data_BGMBankT {
            intro,
            loop_,
            volume,
            crossfade,
            delay,
            fadeStyleId,
            name,
        }
    }

    #[inline]
    pub fn intro(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Audio_Middleware_Data_BGMBank::VT_INTRO,
                None,
            )
        }
    }
    #[inline]
    pub fn loop_(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Audio_Middleware_Data_BGMBank::VT_LOOP_,
                None,
            )
        }
    }
    #[inline]
    pub fn volume(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_Audio_Middleware_Data_BGMBank::VT_VOLUME,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn crossfade(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_Audio_Middleware_Data_BGMBank::VT_CROSSFADE,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn delay(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_Audio_Middleware_Data_BGMBank::VT_DELAY,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn fadeStyleId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Audio_Middleware_Data_BGMBank::VT_FADESTYLEID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Audio_Middleware_Data_BGMBank::VT_NAME,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Audio_Middleware_Data_BGMBank<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("intro", Self::VT_INTRO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("loop_", Self::VT_LOOP_, false)?
            .visit_field::<f32>("volume", Self::VT_VOLUME, false)?
            .visit_field::<f32>("crossfade", Self::VT_CROSSFADE, false)?
            .visit_field::<f32>("delay", Self::VT_DELAY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "fadeStyleId",
                Self::VT_FADESTYLEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Audio_Middleware_Data_BGMBankArgs<'a> {
    pub intro: Option<flatbuffers::WIPOffset<&'a str>>,
    pub loop_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub volume: f32,
    pub crossfade: f32,
    pub delay: f32,
    pub fadeStyleId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Audio_Middleware_Data_BGMBankArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Audio_Middleware_Data_BGMBankArgs {
            intro: None,
            loop_: None,
            volume: 0.0,
            crossfade: 0.0,
            delay: 0.0,
            fadeStyleId: None,
            name: None,
        }
    }
}

impl Serialize for clz_Torappu_Audio_Middleware_Data_BGMBank<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Audio_Middleware_Data_BGMBank", 7)?;
        if let Some(f) = self.intro() {
            s.serialize_field("intro", &f)?;
        } else {
            s.skip_field("intro")?;
        }
        if let Some(f) = self.loop_() {
            s.serialize_field("loop_", &f)?;
        } else {
            s.skip_field("loop_")?;
        }
        s.serialize_field("volume", &self.volume())?;
        s.serialize_field("crossfade", &self.crossfade())?;
        s.serialize_field("delay", &self.delay())?;
        if let Some(f) = self.fadeStyleId() {
            s.serialize_field("fadeStyleId", &f)?;
        } else {
            s.skip_field("fadeStyleId")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Audio_Middleware_Data_BGMBankBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Audio_Middleware_Data_BGMBankBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_intro(&mut self, intro: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_BGMBank::VT_INTRO,
            intro,
        );
    }
    #[inline]
    pub fn add_loop_(&mut self, loop_: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_BGMBank::VT_LOOP_,
            loop_,
        );
    }
    #[inline]
    pub fn add_volume(&mut self, volume: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_Audio_Middleware_Data_BGMBank::VT_VOLUME,
            volume,
            0.0,
        );
    }
    #[inline]
    pub fn add_crossfade(&mut self, crossfade: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_Audio_Middleware_Data_BGMBank::VT_CROSSFADE,
            crossfade,
            0.0,
        );
    }
    #[inline]
    pub fn add_delay(&mut self, delay: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_Audio_Middleware_Data_BGMBank::VT_DELAY,
            delay,
            0.0,
        );
    }
    #[inline]
    pub fn add_fadeStyleId(&mut self, fadeStyleId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_BGMBank::VT_FADESTYLEID,
            fadeStyleId,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_BGMBank::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Audio_Middleware_Data_BGMBankBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Audio_Middleware_Data_BGMBankBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_BGMBank<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Audio_Middleware_Data_BGMBank<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Audio_Middleware_Data_BGMBank");
        ds.field("intro", &self.intro());
        ds.field("loop_", &self.loop_());
        ds.field("volume", &self.volume());
        ds.field("crossfade", &self.crossfade());
        ds.field("delay", &self.delay());
        ds.field("fadeStyleId", &self.fadeStyleId());
        ds.field("name", &self.name());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Audio_Middleware_Data_BGMBankT {
    pub intro: Option<String>,
    pub loop_: Option<String>,
    pub volume: f32,
    pub crossfade: f32,
    pub delay: f32,
    pub fadeStyleId: Option<String>,
    pub name: Option<String>,
}
impl Default for clz_Torappu_Audio_Middleware_Data_BGMBankT {
    fn default() -> Self {
        Self {
            intro: None,
            loop_: None,
            volume: 0.0,
            crossfade: 0.0,
            delay: 0.0,
            fadeStyleId: None,
            name: None,
        }
    }
}
impl clz_Torappu_Audio_Middleware_Data_BGMBankT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_BGMBank<'b>> {
        let intro = self.intro.as_ref().map(|x| _fbb.create_string(x));
        let loop_ = self.loop_.as_ref().map(|x| _fbb.create_string(x));
        let volume = self.volume;
        let crossfade = self.crossfade;
        let delay = self.delay;
        let fadeStyleId = self.fadeStyleId.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Audio_Middleware_Data_BGMBank::create(
            _fbb,
            &clz_Torappu_Audio_Middleware_Data_BGMBankArgs {
                intro,
                loop_,
                volume,
                crossfade,
                delay,
                fadeStyleId,
                name,
            },
        )
    }
}
pub enum clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFXOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX<'a> {
    type Inner = clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX<'a> {
    pub const VT_ASSET: flatbuffers::VOffsetT = 4;
    pub const VT_WEIGHT: flatbuffers::VOffsetT = 6;
    pub const VT_IMPORTANT: flatbuffers::VOffsetT = 8;
    pub const VT_IS2D: flatbuffers::VOffsetT = 10;
    pub const VT_DELAY: flatbuffers::VOffsetT = 12;
    pub const VT_MINPITCH: flatbuffers::VOffsetT = 14;
    pub const VT_MAXPITCH: flatbuffers::VOffsetT = 16;
    pub const VT_MINVOLUME: flatbuffers::VOffsetT = 18;
    pub const VT_MAXVOLUME: flatbuffers::VOffsetT = 20;
    pub const VT_IGNORETIMESCALE: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFXArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX<'bldr>> {
        let mut builder = clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFXBuilder::new(_fbb);
        builder.add_maxVolume(args.maxVolume);
        builder.add_minVolume(args.minVolume);
        builder.add_maxPitch(args.maxPitch);
        builder.add_minPitch(args.minPitch);
        builder.add_delay(args.delay);
        builder.add_weight(args.weight);
        if let Some(x) = args.asset {
            builder.add_asset(x);
        }
        builder.add_ignoreTimeScale(args.ignoreTimeScale);
        builder.add_is2D(args.is2D);
        builder.add_important(args.important);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFXT {
        let asset = self.asset().map(|x| x.to_string());
        let weight = self.weight();
        let important = self.important();
        let is2D = self.is2D();
        let delay = self.delay();
        let minPitch = self.minPitch();
        let maxPitch = self.maxPitch();
        let minVolume = self.minVolume();
        let maxVolume = self.maxVolume();
        let ignoreTimeScale = self.ignoreTimeScale();
        clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFXT {
            asset,
            weight,
            important,
            is2D,
            delay,
            minPitch,
            maxPitch,
            minVolume,
            maxVolume,
            ignoreTimeScale,
        }
    }

    #[inline]
    pub fn asset(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX::VT_ASSET,
                None,
            )
        }
    }
    #[inline]
    pub fn weight(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX::VT_WEIGHT,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn important(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX::VT_IMPORTANT,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn is2D(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX::VT_IS2D,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn delay(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX::VT_DELAY,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn minPitch(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX::VT_MINPITCH,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxPitch(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX::VT_MAXPITCH,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn minVolume(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX::VT_MINVOLUME,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxVolume(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX::VT_MAXVOLUME,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn ignoreTimeScale(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX::VT_IGNORETIMESCALE,
                    Some(false),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("asset", Self::VT_ASSET, false)?
            .visit_field::<f32>("weight", Self::VT_WEIGHT, false)?
            .visit_field::<bool>("important", Self::VT_IMPORTANT, false)?
            .visit_field::<bool>("is2D", Self::VT_IS2D, false)?
            .visit_field::<f32>("delay", Self::VT_DELAY, false)?
            .visit_field::<f32>("minPitch", Self::VT_MINPITCH, false)?
            .visit_field::<f32>("maxPitch", Self::VT_MAXPITCH, false)?
            .visit_field::<f32>("minVolume", Self::VT_MINVOLUME, false)?
            .visit_field::<f32>("maxVolume", Self::VT_MAXVOLUME, false)?
            .visit_field::<bool>("ignoreTimeScale", Self::VT_IGNORETIMESCALE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFXArgs<'a> {
    pub asset: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weight: f32,
    pub important: bool,
    pub is2D: bool,
    pub delay: f32,
    pub minPitch: f32,
    pub maxPitch: f32,
    pub minVolume: f32,
    pub maxVolume: f32,
    pub ignoreTimeScale: bool,
}
impl<'a> Default for clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFXArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFXArgs {
            asset: None,
            weight: 0.0,
            important: false,
            is2D: false,
            delay: 0.0,
            minPitch: 0.0,
            maxPitch: 0.0,
            minVolume: 0.0,
            maxVolume: 0.0,
            ignoreTimeScale: false,
        }
    }
}

impl Serialize for clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX", 10)?;
        if let Some(f) = self.asset() {
            s.serialize_field("asset", &f)?;
        } else {
            s.skip_field("asset")?;
        }
        s.serialize_field("weight", &self.weight())?;
        s.serialize_field("important", &self.important())?;
        s.serialize_field("is2D", &self.is2D())?;
        s.serialize_field("delay", &self.delay())?;
        s.serialize_field("minPitch", &self.minPitch())?;
        s.serialize_field("maxPitch", &self.maxPitch())?;
        s.serialize_field("minVolume", &self.minVolume())?;
        s.serialize_field("maxVolume", &self.maxVolume())?;
        s.serialize_field("ignoreTimeScale", &self.ignoreTimeScale())?;
        s.end()
    }
}

pub struct clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFXBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFXBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_asset(&mut self, asset: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX::VT_ASSET,
            asset,
        );
    }
    #[inline]
    pub fn add_weight(&mut self, weight: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX::VT_WEIGHT,
            weight,
            0.0,
        );
    }
    #[inline]
    pub fn add_important(&mut self, important: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX::VT_IMPORTANT,
            important,
            false,
        );
    }
    #[inline]
    pub fn add_is2D(&mut self, is2D: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX::VT_IS2D,
            is2D,
            false,
        );
    }
    #[inline]
    pub fn add_delay(&mut self, delay: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX::VT_DELAY,
            delay,
            0.0,
        );
    }
    #[inline]
    pub fn add_minPitch(&mut self, minPitch: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX::VT_MINPITCH,
            minPitch,
            0.0,
        );
    }
    #[inline]
    pub fn add_maxPitch(&mut self, maxPitch: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX::VT_MAXPITCH,
            maxPitch,
            0.0,
        );
    }
    #[inline]
    pub fn add_minVolume(&mut self, minVolume: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX::VT_MINVOLUME,
            minVolume,
            0.0,
        );
    }
    #[inline]
    pub fn add_maxVolume(&mut self, maxVolume: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX::VT_MAXVOLUME,
            maxVolume,
            0.0,
        );
    }
    #[inline]
    pub fn add_ignoreTimeScale(&mut self, ignoreTimeScale: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX::VT_IGNORETIMESCALE,
            ignoreTimeScale,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFXBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFXBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX");
        ds.field("asset", &self.asset());
        ds.field("weight", &self.weight());
        ds.field("important", &self.important());
        ds.field("is2D", &self.is2D());
        ds.field("delay", &self.delay());
        ds.field("minPitch", &self.minPitch());
        ds.field("maxPitch", &self.maxPitch());
        ds.field("minVolume", &self.minVolume());
        ds.field("maxVolume", &self.maxVolume());
        ds.field("ignoreTimeScale", &self.ignoreTimeScale());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFXT {
    pub asset: Option<String>,
    pub weight: f32,
    pub important: bool,
    pub is2D: bool,
    pub delay: f32,
    pub minPitch: f32,
    pub maxPitch: f32,
    pub minVolume: f32,
    pub maxVolume: f32,
    pub ignoreTimeScale: bool,
}
impl Default for clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFXT {
    fn default() -> Self {
        Self {
            asset: None,
            weight: 0.0,
            important: false,
            is2D: false,
            delay: 0.0,
            minPitch: 0.0,
            maxPitch: 0.0,
            minVolume: 0.0,
            maxVolume: 0.0,
            ignoreTimeScale: false,
        }
    }
}
impl clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFXT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX<'b>> {
        let asset = self.asset.as_ref().map(|x| _fbb.create_string(x));
        let weight = self.weight;
        let important = self.important;
        let is2D = self.is2D;
        let delay = self.delay;
        let minPitch = self.minPitch;
        let maxPitch = self.maxPitch;
        let minVolume = self.minVolume;
        let maxVolume = self.maxVolume;
        let ignoreTimeScale = self.ignoreTimeScale;
        clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX::create(
            _fbb,
            &clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFXArgs {
                asset,
                weight,
                important,
                is2D,
                delay,
                minPitch,
                maxPitch,
                minVolume,
                maxVolume,
                ignoreTimeScale,
            },
        )
    }
}
pub enum clz_Torappu_Audio_MixerDescOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Audio_MixerDesc<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Audio_MixerDesc<'a> {
    type Inner = clz_Torappu_Audio_MixerDesc<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Audio_MixerDesc<'a> {
    pub const VT_CATEGORY: flatbuffers::VOffsetT = 4;
    pub const VT_CUSTOMGROUP: flatbuffers::VOffsetT = 6;
    pub const VT_IMPORTANT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Audio_MixerDesc { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Audio_MixerDescArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_MixerDesc<'bldr>> {
        let mut builder = clz_Torappu_Audio_MixerDescBuilder::new(_fbb);
        if let Some(x) = args.customGroup {
            builder.add_customGroup(x);
        }
        builder.add_category(args.category);
        builder.add_important(args.important);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Audio_MixerDescT {
        let category = self.category();
        let customGroup = self.customGroup().map(|x| x.to_string());
        let important = self.important();
        clz_Torappu_Audio_MixerDescT {
            category,
            customGroup,
            important,
        }
    }

    #[inline]
    pub fn category(&self) -> enum__Torappu_Audio_MixerDesc_Category {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_Audio_MixerDesc_Category>(
                    clz_Torappu_Audio_MixerDesc::VT_CATEGORY,
                    Some(enum__Torappu_Audio_MixerDesc_Category::CUSTOM),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn customGroup(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Audio_MixerDesc::VT_CUSTOMGROUP,
                None,
            )
        }
    }
    #[inline]
    pub fn important(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_Audio_MixerDesc::VT_IMPORTANT, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Audio_MixerDesc<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_Audio_MixerDesc_Category>(
                "category",
                Self::VT_CATEGORY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "customGroup",
                Self::VT_CUSTOMGROUP,
                false,
            )?
            .visit_field::<bool>("important", Self::VT_IMPORTANT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Audio_MixerDescArgs<'a> {
    pub category: enum__Torappu_Audio_MixerDesc_Category,
    pub customGroup: Option<flatbuffers::WIPOffset<&'a str>>,
    pub important: bool,
}
impl<'a> Default for clz_Torappu_Audio_MixerDescArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Audio_MixerDescArgs {
            category: enum__Torappu_Audio_MixerDesc_Category::CUSTOM,
            customGroup: None,
            important: false,
        }
    }
}

impl Serialize for clz_Torappu_Audio_MixerDesc<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Audio_MixerDesc", 3)?;
        s.serialize_field("category", &self.category())?;
        if let Some(f) = self.customGroup() {
            s.serialize_field("customGroup", &f)?;
        } else {
            s.skip_field("customGroup")?;
        }
        s.serialize_field("important", &self.important())?;
        s.end()
    }
}

pub struct clz_Torappu_Audio_MixerDescBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_Audio_MixerDescBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_category(&mut self, category: enum__Torappu_Audio_MixerDesc_Category) {
        self.fbb_
            .push_slot::<enum__Torappu_Audio_MixerDesc_Category>(
                clz_Torappu_Audio_MixerDesc::VT_CATEGORY,
                category,
                enum__Torappu_Audio_MixerDesc_Category::CUSTOM,
            );
    }
    #[inline]
    pub fn add_customGroup(&mut self, customGroup: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_MixerDesc::VT_CUSTOMGROUP,
            customGroup,
        );
    }
    #[inline]
    pub fn add_important(&mut self, important: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_Audio_MixerDesc::VT_IMPORTANT, important, false);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Audio_MixerDescBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Audio_MixerDescBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Audio_MixerDesc<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Audio_MixerDesc<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Audio_MixerDesc");
        ds.field("category", &self.category());
        ds.field("customGroup", &self.customGroup());
        ds.field("important", &self.important());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Audio_MixerDescT {
    pub category: enum__Torappu_Audio_MixerDesc_Category,
    pub customGroup: Option<String>,
    pub important: bool,
}
impl Default for clz_Torappu_Audio_MixerDescT {
    fn default() -> Self {
        Self {
            category: enum__Torappu_Audio_MixerDesc_Category::CUSTOM,
            customGroup: None,
            important: false,
        }
    }
}
impl clz_Torappu_Audio_MixerDescT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_MixerDesc<'b>> {
        let category = self.category;
        let customGroup = self.customGroup.as_ref().map(|x| _fbb.create_string(x));
        let important = self.important;
        clz_Torappu_Audio_MixerDesc::create(
            _fbb,
            &clz_Torappu_Audio_MixerDescArgs {
                category,
                customGroup,
                important,
            },
        )
    }
}
pub enum clz_Torappu_Audio_Middleware_Data_SoundFXBankOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Audio_Middleware_Data_SoundFXBank<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Audio_Middleware_Data_SoundFXBank<'a> {
    type Inner = clz_Torappu_Audio_Middleware_Data_SoundFXBank<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Audio_Middleware_Data_SoundFXBank<'a> {
    pub const VT_SOUNDS: flatbuffers::VOffsetT = 4;
    pub const VT_MAXSOUNDALLOWED: flatbuffers::VOffsetT = 6;
    pub const VT_POPOLDEST: flatbuffers::VOffsetT = 8;
    pub const VT_CUSTOMMIXERGROUP: flatbuffers::VOffsetT = 10;
    pub const VT_LOOP_: flatbuffers::VOffsetT = 12;
    pub const VT_NAME: flatbuffers::VOffsetT = 14;
    pub const VT_MIXERDESC: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Audio_Middleware_Data_SoundFXBank { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Audio_Middleware_Data_SoundFXBankArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_SoundFXBank<'bldr>> {
        let mut builder = clz_Torappu_Audio_Middleware_Data_SoundFXBankBuilder::new(_fbb);
        if let Some(x) = args.mixerDesc {
            builder.add_mixerDesc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.customMixerGroup {
            builder.add_customMixerGroup(x);
        }
        builder.add_maxSoundAllowed(args.maxSoundAllowed);
        if let Some(x) = args.sounds {
            builder.add_sounds(x);
        }
        builder.add_loop_(args.loop_);
        builder.add_popOldest(args.popOldest);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Audio_Middleware_Data_SoundFXBankT {
        let sounds = self
            .sounds()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let maxSoundAllowed = self.maxSoundAllowed();
        let popOldest = self.popOldest();
        let customMixerGroup = self.customMixerGroup().map(|x| x.to_string());
        let loop_ = self.loop_();
        let name = self.name().map(|x| x.to_string());
        let mixerDesc = self.mixerDesc().map(|x| Box::new(x.unpack()));
        clz_Torappu_Audio_Middleware_Data_SoundFXBankT {
            sounds,
            maxSoundAllowed,
            popOldest,
            customMixerGroup,
            loop_,
            name,
            mixerDesc,
        }
    }

    #[inline]
    pub fn sounds(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX,
                    >,
                >,
            >>(
                clz_Torappu_Audio_Middleware_Data_SoundFXBank::VT_SOUNDS,
                None,
            )
        }
    }
    #[inline]
    pub fn maxSoundAllowed(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_Audio_Middleware_Data_SoundFXBank::VT_MAXSOUNDALLOWED,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn popOldest(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Audio_Middleware_Data_SoundFXBank::VT_POPOLDEST,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn customMixerGroup(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Audio_Middleware_Data_SoundFXBank::VT_CUSTOMMIXERGROUP,
                None,
            )
        }
    }
    #[inline]
    pub fn loop_(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Audio_Middleware_Data_SoundFXBank::VT_LOOP_,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Audio_Middleware_Data_SoundFXBank::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn mixerDesc(&self) -> Option<clz_Torappu_Audio_MixerDesc<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Audio_MixerDesc>>(
                    clz_Torappu_Audio_Middleware_Data_SoundFXBank::VT_MIXERDESC,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Audio_Middleware_Data_SoundFXBank<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX,
                    >,
                >,
            >>("sounds", Self::VT_SOUNDS, false)?
            .visit_field::<i32>("maxSoundAllowed", Self::VT_MAXSOUNDALLOWED, false)?
            .visit_field::<bool>("popOldest", Self::VT_POPOLDEST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "customMixerGroup",
                Self::VT_CUSTOMMIXERGROUP,
                false,
            )?
            .visit_field::<bool>("loop_", Self::VT_LOOP_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Audio_MixerDesc>>(
                "mixerDesc",
                Self::VT_MIXERDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Audio_Middleware_Data_SoundFXBankArgs<'a> {
    pub sounds: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX<'a>,
                >,
            >,
        >,
    >,
    pub maxSoundAllowed: i32,
    pub popOldest: bool,
    pub customMixerGroup: Option<flatbuffers::WIPOffset<&'a str>>,
    pub loop_: bool,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mixerDesc: Option<flatbuffers::WIPOffset<clz_Torappu_Audio_MixerDesc<'a>>>,
}
impl<'a> Default for clz_Torappu_Audio_Middleware_Data_SoundFXBankArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Audio_Middleware_Data_SoundFXBankArgs {
            sounds: None,
            maxSoundAllowed: 0,
            popOldest: false,
            customMixerGroup: None,
            loop_: false,
            name: None,
            mixerDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_Audio_Middleware_Data_SoundFXBank<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_Audio_Middleware_Data_SoundFXBank", 7)?;
        if let Some(f) = self.sounds() {
            s.serialize_field("sounds", &f)?;
        } else {
            s.skip_field("sounds")?;
        }
        s.serialize_field("maxSoundAllowed", &self.maxSoundAllowed())?;
        s.serialize_field("popOldest", &self.popOldest())?;
        if let Some(f) = self.customMixerGroup() {
            s.serialize_field("customMixerGroup", &f)?;
        } else {
            s.skip_field("customMixerGroup")?;
        }
        s.serialize_field("loop_", &self.loop_())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.mixerDesc() {
            s.serialize_field("mixerDesc", &f)?;
        } else {
            s.skip_field("mixerDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Audio_Middleware_Data_SoundFXBankBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Audio_Middleware_Data_SoundFXBankBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_sounds(
        &mut self,
        sounds: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFX<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_SoundFXBank::VT_SOUNDS,
            sounds,
        );
    }
    #[inline]
    pub fn add_maxSoundAllowed(&mut self, maxSoundAllowed: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_Audio_Middleware_Data_SoundFXBank::VT_MAXSOUNDALLOWED,
            maxSoundAllowed,
            0,
        );
    }
    #[inline]
    pub fn add_popOldest(&mut self, popOldest: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Audio_Middleware_Data_SoundFXBank::VT_POPOLDEST,
            popOldest,
            false,
        );
    }
    #[inline]
    pub fn add_customMixerGroup(&mut self, customMixerGroup: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_SoundFXBank::VT_CUSTOMMIXERGROUP,
            customMixerGroup,
        );
    }
    #[inline]
    pub fn add_loop_(&mut self, loop_: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Audio_Middleware_Data_SoundFXBank::VT_LOOP_,
            loop_,
            false,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_SoundFXBank::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_mixerDesc(
        &mut self,
        mixerDesc: flatbuffers::WIPOffset<clz_Torappu_Audio_MixerDesc<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Audio_MixerDesc>>(
                clz_Torappu_Audio_Middleware_Data_SoundFXBank::VT_MIXERDESC,
                mixerDesc,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Audio_Middleware_Data_SoundFXBankBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Audio_Middleware_Data_SoundFXBankBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_SoundFXBank<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Audio_Middleware_Data_SoundFXBank<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Audio_Middleware_Data_SoundFXBank");
        ds.field("sounds", &self.sounds());
        ds.field("maxSoundAllowed", &self.maxSoundAllowed());
        ds.field("popOldest", &self.popOldest());
        ds.field("customMixerGroup", &self.customMixerGroup());
        ds.field("loop_", &self.loop_());
        ds.field("name", &self.name());
        ds.field("mixerDesc", &self.mixerDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Audio_Middleware_Data_SoundFXBankT {
    pub sounds: Option<Vec<clz_Torappu_Audio_Middleware_Data_SoundFXBank_SoundFXT>>,
    pub maxSoundAllowed: i32,
    pub popOldest: bool,
    pub customMixerGroup: Option<String>,
    pub loop_: bool,
    pub name: Option<String>,
    pub mixerDesc: Option<Box<clz_Torappu_Audio_MixerDescT>>,
}
impl Default for clz_Torappu_Audio_Middleware_Data_SoundFXBankT {
    fn default() -> Self {
        Self {
            sounds: None,
            maxSoundAllowed: 0,
            popOldest: false,
            customMixerGroup: None,
            loop_: false,
            name: None,
            mixerDesc: None,
        }
    }
}
impl clz_Torappu_Audio_Middleware_Data_SoundFXBankT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_SoundFXBank<'b>> {
        let sounds = self.sounds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let maxSoundAllowed = self.maxSoundAllowed;
        let popOldest = self.popOldest;
        let customMixerGroup = self
            .customMixerGroup
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let loop_ = self.loop_;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let mixerDesc = self.mixerDesc.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_Audio_Middleware_Data_SoundFXBank::create(
            _fbb,
            &clz_Torappu_Audio_Middleware_Data_SoundFXBankArgs {
                sounds,
                maxSoundAllowed,
                popOldest,
                customMixerGroup,
                loop_,
                name,
                mixerDesc,
            },
        )
    }
}
pub enum clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBankOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank<'a> {
    type Inner = clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank<'a> {
    pub const VT_TARGETBANK: flatbuffers::VOffsetT = 4;
    pub const VT_CTRLSTOP: flatbuffers::VOffsetT = 6;
    pub const VT_CTRLSTOPFADETIME: flatbuffers::VOffsetT = 8;
    pub const VT_NAME: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBankArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank<'bldr>> {
        let mut builder = clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBankBuilder::new(_fbb);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_ctrlStopFadetime(args.ctrlStopFadetime);
        if let Some(x) = args.targetBank {
            builder.add_targetBank(x);
        }
        builder.add_ctrlStop(args.ctrlStop);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBankT {
        let targetBank = self.targetBank().map(|x| x.to_string());
        let ctrlStop = self.ctrlStop();
        let ctrlStopFadetime = self.ctrlStopFadetime();
        let name = self.name().map(|x| x.to_string());
        clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBankT {
            targetBank,
            ctrlStop,
            ctrlStopFadetime,
            name,
        }
    }

    #[inline]
    pub fn targetBank(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank::VT_TARGETBANK,
                None,
            )
        }
    }
    #[inline]
    pub fn ctrlStop(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank::VT_CTRLSTOP,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn ctrlStopFadetime(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank::VT_CTRLSTOPFADETIME,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank::VT_NAME,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "targetBank",
                Self::VT_TARGETBANK,
                false,
            )?
            .visit_field::<bool>("ctrlStop", Self::VT_CTRLSTOP, false)?
            .visit_field::<f32>("ctrlStopFadetime", Self::VT_CTRLSTOPFADETIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBankArgs<'a> {
    pub targetBank: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ctrlStop: bool,
    pub ctrlStopFadetime: f32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBankArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBankArgs {
            targetBank: None,
            ctrlStop: false,
            ctrlStopFadetime: 0.0,
            name: None,
        }
    }
}

impl Serialize for clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank", 4)?;
        if let Some(f) = self.targetBank() {
            s.serialize_field("targetBank", &f)?;
        } else {
            s.skip_field("targetBank")?;
        }
        s.serialize_field("ctrlStop", &self.ctrlStop())?;
        s.serialize_field("ctrlStopFadetime", &self.ctrlStopFadetime())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBankBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBankBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_targetBank(&mut self, targetBank: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank::VT_TARGETBANK,
            targetBank,
        );
    }
    #[inline]
    pub fn add_ctrlStop(&mut self, ctrlStop: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank::VT_CTRLSTOP,
            ctrlStop,
            false,
        );
    }
    #[inline]
    pub fn add_ctrlStopFadetime(&mut self, ctrlStopFadetime: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank::VT_CTRLSTOPFADETIME,
            ctrlStopFadetime,
            0.0,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBankBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBankBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank");
        ds.field("targetBank", &self.targetBank());
        ds.field("ctrlStop", &self.ctrlStop());
        ds.field("ctrlStopFadetime", &self.ctrlStopFadetime());
        ds.field("name", &self.name());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBankT {
    pub targetBank: Option<String>,
    pub ctrlStop: bool,
    pub ctrlStopFadetime: f32,
    pub name: Option<String>,
}
impl Default for clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBankT {
    fn default() -> Self {
        Self {
            targetBank: None,
            ctrlStop: false,
            ctrlStopFadetime: 0.0,
            name: None,
        }
    }
}
impl clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBankT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank<'b>> {
        let targetBank = self.targetBank.as_ref().map(|x| _fbb.create_string(x));
        let ctrlStop = self.ctrlStop;
        let ctrlStopFadetime = self.ctrlStopFadetime;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank::create(
            _fbb,
            &clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBankArgs {
                targetBank,
                ctrlStop,
                ctrlStopFadetime,
                name,
            },
        )
    }
}
pub enum clz_Torappu_Audio_Middleware_Data_SnapshotBankOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Audio_Middleware_Data_SnapshotBank<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Audio_Middleware_Data_SnapshotBank<'a> {
    type Inner = clz_Torappu_Audio_Middleware_Data_SnapshotBank<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Audio_Middleware_Data_SnapshotBank<'a> {
    pub const VT_TARGETSNAPSHOT: flatbuffers::VOffsetT = 4;
    pub const VT_HOOKSOUNDFXBANK: flatbuffers::VOffsetT = 6;
    pub const VT_DELAY: flatbuffers::VOffsetT = 8;
    pub const VT_DURATION: flatbuffers::VOffsetT = 10;
    pub const VT_NAME: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Audio_Middleware_Data_SnapshotBank { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Audio_Middleware_Data_SnapshotBankArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_SnapshotBank<'bldr>> {
        let mut builder = clz_Torappu_Audio_Middleware_Data_SnapshotBankBuilder::new(_fbb);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_duration(args.duration);
        builder.add_delay(args.delay);
        if let Some(x) = args.hookSoundFxBank {
            builder.add_hookSoundFxBank(x);
        }
        if let Some(x) = args.targetSnapshot {
            builder.add_targetSnapshot(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Audio_Middleware_Data_SnapshotBankT {
        let targetSnapshot = self.targetSnapshot().map(|x| x.to_string());
        let hookSoundFxBank = self.hookSoundFxBank().map(|x| x.to_string());
        let delay = self.delay();
        let duration = self.duration();
        let name = self.name().map(|x| x.to_string());
        clz_Torappu_Audio_Middleware_Data_SnapshotBankT {
            targetSnapshot,
            hookSoundFxBank,
            delay,
            duration,
            name,
        }
    }

    #[inline]
    pub fn targetSnapshot(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Audio_Middleware_Data_SnapshotBank::VT_TARGETSNAPSHOT,
                None,
            )
        }
    }
    #[inline]
    pub fn hookSoundFxBank(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Audio_Middleware_Data_SnapshotBank::VT_HOOKSOUNDFXBANK,
                None,
            )
        }
    }
    #[inline]
    pub fn delay(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_Audio_Middleware_Data_SnapshotBank::VT_DELAY,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn duration(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_Audio_Middleware_Data_SnapshotBank::VT_DURATION,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Audio_Middleware_Data_SnapshotBank::VT_NAME,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Audio_Middleware_Data_SnapshotBank<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "targetSnapshot",
                Self::VT_TARGETSNAPSHOT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "hookSoundFxBank",
                Self::VT_HOOKSOUNDFXBANK,
                false,
            )?
            .visit_field::<f32>("delay", Self::VT_DELAY, false)?
            .visit_field::<f32>("duration", Self::VT_DURATION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Audio_Middleware_Data_SnapshotBankArgs<'a> {
    pub targetSnapshot: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hookSoundFxBank: Option<flatbuffers::WIPOffset<&'a str>>,
    pub delay: f32,
    pub duration: f32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Audio_Middleware_Data_SnapshotBankArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Audio_Middleware_Data_SnapshotBankArgs {
            targetSnapshot: None,
            hookSoundFxBank: None,
            delay: 0.0,
            duration: 0.0,
            name: None,
        }
    }
}

impl Serialize for clz_Torappu_Audio_Middleware_Data_SnapshotBank<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_Audio_Middleware_Data_SnapshotBank", 5)?;
        if let Some(f) = self.targetSnapshot() {
            s.serialize_field("targetSnapshot", &f)?;
        } else {
            s.skip_field("targetSnapshot")?;
        }
        if let Some(f) = self.hookSoundFxBank() {
            s.serialize_field("hookSoundFxBank", &f)?;
        } else {
            s.skip_field("hookSoundFxBank")?;
        }
        s.serialize_field("delay", &self.delay())?;
        s.serialize_field("duration", &self.duration())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Audio_Middleware_Data_SnapshotBankBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Audio_Middleware_Data_SnapshotBankBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_targetSnapshot(&mut self, targetSnapshot: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_SnapshotBank::VT_TARGETSNAPSHOT,
            targetSnapshot,
        );
    }
    #[inline]
    pub fn add_hookSoundFxBank(&mut self, hookSoundFxBank: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_SnapshotBank::VT_HOOKSOUNDFXBANK,
            hookSoundFxBank,
        );
    }
    #[inline]
    pub fn add_delay(&mut self, delay: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_Audio_Middleware_Data_SnapshotBank::VT_DELAY,
            delay,
            0.0,
        );
    }
    #[inline]
    pub fn add_duration(&mut self, duration: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_Audio_Middleware_Data_SnapshotBank::VT_DURATION,
            duration,
            0.0,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_SnapshotBank::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Audio_Middleware_Data_SnapshotBankBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Audio_Middleware_Data_SnapshotBankBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_SnapshotBank<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Audio_Middleware_Data_SnapshotBank<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Audio_Middleware_Data_SnapshotBank");
        ds.field("targetSnapshot", &self.targetSnapshot());
        ds.field("hookSoundFxBank", &self.hookSoundFxBank());
        ds.field("delay", &self.delay());
        ds.field("duration", &self.duration());
        ds.field("name", &self.name());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Audio_Middleware_Data_SnapshotBankT {
    pub targetSnapshot: Option<String>,
    pub hookSoundFxBank: Option<String>,
    pub delay: f32,
    pub duration: f32,
    pub name: Option<String>,
}
impl Default for clz_Torappu_Audio_Middleware_Data_SnapshotBankT {
    fn default() -> Self {
        Self {
            targetSnapshot: None,
            hookSoundFxBank: None,
            delay: 0.0,
            duration: 0.0,
            name: None,
        }
    }
}
impl clz_Torappu_Audio_Middleware_Data_SnapshotBankT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_SnapshotBank<'b>> {
        let targetSnapshot = self.targetSnapshot.as_ref().map(|x| _fbb.create_string(x));
        let hookSoundFxBank = self.hookSoundFxBank.as_ref().map(|x| _fbb.create_string(x));
        let delay = self.delay;
        let duration = self.duration;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Audio_Middleware_Data_SnapshotBank::create(
            _fbb,
            &clz_Torappu_Audio_Middleware_Data_SnapshotBankArgs {
                targetSnapshot,
                hookSoundFxBank,
                delay,
                duration,
                name,
            },
        )
    }
}
pub enum clz_Torappu_BattleVoiceOptionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BattleVoiceOption<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BattleVoiceOption<'a> {
    type Inner = clz_Torappu_BattleVoiceOption<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_BattleVoiceOption<'a> {
    pub const VT_VOICETYPE: flatbuffers::VOffsetT = 4;
    pub const VT_PRIORITY: flatbuffers::VOffsetT = 6;
    pub const VT_OVERLAPIFSAMEPRIORITY: flatbuffers::VOffsetT = 8;
    pub const VT_COOLDOWN: flatbuffers::VOffsetT = 10;
    pub const VT_DELAY: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BattleVoiceOption { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BattleVoiceOptionArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BattleVoiceOption<'bldr>> {
        let mut builder = clz_Torappu_BattleVoiceOptionBuilder::new(_fbb);
        builder.add_delay(args.delay);
        builder.add_cooldown(args.cooldown);
        builder.add_priority(args.priority);
        builder.add_voiceType(args.voiceType);
        builder.add_overlapIfSamePriority(args.overlapIfSamePriority);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_BattleVoiceOptionT {
        let voiceType = self.voiceType();
        let priority = self.priority();
        let overlapIfSamePriority = self.overlapIfSamePriority();
        let cooldown = self.cooldown();
        let delay = self.delay();
        clz_Torappu_BattleVoiceOptionT {
            voiceType,
            priority,
            overlapIfSamePriority,
            cooldown,
            delay,
        }
    }

    #[inline]
    pub fn voiceType(&self) -> enum__Torappu_BattleVoiceOption_BattleVoiceType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BattleVoiceOption_BattleVoiceType>(
                    clz_Torappu_BattleVoiceOption::VT_VOICETYPE,
                    Some(enum__Torappu_BattleVoiceOption_BattleVoiceType::BATTLE_START),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn priority(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BattleVoiceOption::VT_PRIORITY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn overlapIfSamePriority(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_BattleVoiceOption::VT_OVERLAPIFSAMEPRIORITY,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn cooldown(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_BattleVoiceOption::VT_COOLDOWN, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn delay(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_BattleVoiceOption::VT_DELAY, Some(0.0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BattleVoiceOption<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_BattleVoiceOption_BattleVoiceType>(
                "voiceType",
                Self::VT_VOICETYPE,
                false,
            )?
            .visit_field::<i32>("priority", Self::VT_PRIORITY, false)?
            .visit_field::<bool>(
                "overlapIfSamePriority",
                Self::VT_OVERLAPIFSAMEPRIORITY,
                false,
            )?
            .visit_field::<f32>("cooldown", Self::VT_COOLDOWN, false)?
            .visit_field::<f32>("delay", Self::VT_DELAY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BattleVoiceOptionArgs {
    pub voiceType: enum__Torappu_BattleVoiceOption_BattleVoiceType,
    pub priority: i32,
    pub overlapIfSamePriority: bool,
    pub cooldown: f32,
    pub delay: f32,
}
impl<'a> Default for clz_Torappu_BattleVoiceOptionArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BattleVoiceOptionArgs {
            voiceType: enum__Torappu_BattleVoiceOption_BattleVoiceType::BATTLE_START,
            priority: 0,
            overlapIfSamePriority: false,
            cooldown: 0.0,
            delay: 0.0,
        }
    }
}

impl Serialize for clz_Torappu_BattleVoiceOption<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_BattleVoiceOption", 5)?;
        s.serialize_field("voiceType", &self.voiceType())?;
        s.serialize_field("priority", &self.priority())?;
        s.serialize_field("overlapIfSamePriority", &self.overlapIfSamePriority())?;
        s.serialize_field("cooldown", &self.cooldown())?;
        s.serialize_field("delay", &self.delay())?;
        s.end()
    }
}

pub struct clz_Torappu_BattleVoiceOptionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_BattleVoiceOptionBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_voiceType(&mut self, voiceType: enum__Torappu_BattleVoiceOption_BattleVoiceType) {
        self.fbb_
            .push_slot::<enum__Torappu_BattleVoiceOption_BattleVoiceType>(
                clz_Torappu_BattleVoiceOption::VT_VOICETYPE,
                voiceType,
                enum__Torappu_BattleVoiceOption_BattleVoiceType::BATTLE_START,
            );
    }
    #[inline]
    pub fn add_priority(&mut self, priority: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_BattleVoiceOption::VT_PRIORITY, priority, 0);
    }
    #[inline]
    pub fn add_overlapIfSamePriority(&mut self, overlapIfSamePriority: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_BattleVoiceOption::VT_OVERLAPIFSAMEPRIORITY,
            overlapIfSamePriority,
            false,
        );
    }
    #[inline]
    pub fn add_cooldown(&mut self, cooldown: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_BattleVoiceOption::VT_COOLDOWN, cooldown, 0.0);
    }
    #[inline]
    pub fn add_delay(&mut self, delay: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_BattleVoiceOption::VT_DELAY, delay, 0.0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BattleVoiceOptionBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BattleVoiceOptionBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BattleVoiceOption<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BattleVoiceOption<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BattleVoiceOption");
        ds.field("voiceType", &self.voiceType());
        ds.field("priority", &self.priority());
        ds.field("overlapIfSamePriority", &self.overlapIfSamePriority());
        ds.field("cooldown", &self.cooldown());
        ds.field("delay", &self.delay());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_BattleVoiceOptionT {
    pub voiceType: enum__Torappu_BattleVoiceOption_BattleVoiceType,
    pub priority: i32,
    pub overlapIfSamePriority: bool,
    pub cooldown: f32,
    pub delay: f32,
}
impl Default for clz_Torappu_BattleVoiceOptionT {
    fn default() -> Self {
        Self {
            voiceType: enum__Torappu_BattleVoiceOption_BattleVoiceType::BATTLE_START,
            priority: 0,
            overlapIfSamePriority: false,
            cooldown: 0.0,
            delay: 0.0,
        }
    }
}
impl clz_Torappu_BattleVoiceOptionT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BattleVoiceOption<'b>> {
        let voiceType = self.voiceType;
        let priority = self.priority;
        let overlapIfSamePriority = self.overlapIfSamePriority;
        let cooldown = self.cooldown;
        let delay = self.delay;
        clz_Torappu_BattleVoiceOption::create(
            _fbb,
            &clz_Torappu_BattleVoiceOptionArgs {
                voiceType,
                priority,
                overlapIfSamePriority,
                cooldown,
                delay,
            },
        )
    }
}
pub enum clz_Torappu_BattleVoiceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BattleVoiceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BattleVoiceData<'a> {
    type Inner = clz_Torappu_BattleVoiceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_BattleVoiceData<'a> {
    pub const VT_CROSSFADE: flatbuffers::VOffsetT = 4;
    pub const VT_MINTIMEDELTAFORENEMYENCOUNTER: flatbuffers::VOffsetT = 6;
    pub const VT_MINSPCOSTFORIMPORTANTPASSIVESKILL: flatbuffers::VOffsetT = 8;
    pub const VT_VOICETYPEOPTIONS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BattleVoiceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BattleVoiceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BattleVoiceData<'bldr>> {
        let mut builder = clz_Torappu_BattleVoiceDataBuilder::new(_fbb);
        if let Some(x) = args.voiceTypeOptions {
            builder.add_voiceTypeOptions(x);
        }
        builder.add_minSpCostForImportantPassiveSkill(args.minSpCostForImportantPassiveSkill);
        builder.add_minTimeDeltaForEnemyEncounter(args.minTimeDeltaForEnemyEncounter);
        builder.add_crossfade(args.crossfade);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_BattleVoiceDataT {
        let crossfade = self.crossfade();
        let minTimeDeltaForEnemyEncounter = self.minTimeDeltaForEnemyEncounter();
        let minSpCostForImportantPassiveSkill = self.minSpCostForImportantPassiveSkill();
        let voiceTypeOptions = self
            .voiceTypeOptions()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_BattleVoiceDataT {
            crossfade,
            minTimeDeltaForEnemyEncounter,
            minSpCostForImportantPassiveSkill,
            voiceTypeOptions,
        }
    }

    #[inline]
    pub fn crossfade(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_BattleVoiceData::VT_CROSSFADE, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn minTimeDeltaForEnemyEncounter(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_BattleVoiceData::VT_MINTIMEDELTAFORENEMYENCOUNTER,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn minSpCostForImportantPassiveSkill(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BattleVoiceData::VT_MINSPCOSTFORIMPORTANTPASSIVESKILL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn voiceTypeOptions(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_BattleVoiceOption<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BattleVoiceOption>,
                >,
            >>(clz_Torappu_BattleVoiceData::VT_VOICETYPEOPTIONS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BattleVoiceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("crossfade", Self::VT_CROSSFADE, false)?
            .visit_field::<f32>(
                "minTimeDeltaForEnemyEncounter",
                Self::VT_MINTIMEDELTAFORENEMYENCOUNTER,
                false,
            )?
            .visit_field::<i32>(
                "minSpCostForImportantPassiveSkill",
                Self::VT_MINSPCOSTFORIMPORTANTPASSIVESKILL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BattleVoiceOption>,
                >,
            >>("voiceTypeOptions", Self::VT_VOICETYPEOPTIONS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BattleVoiceDataArgs<'a> {
    pub crossfade: f32,
    pub minTimeDeltaForEnemyEncounter: f32,
    pub minSpCostForImportantPassiveSkill: i32,
    pub voiceTypeOptions: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BattleVoiceOption<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BattleVoiceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BattleVoiceDataArgs {
            crossfade: 0.0,
            minTimeDeltaForEnemyEncounter: 0.0,
            minSpCostForImportantPassiveSkill: 0,
            voiceTypeOptions: None,
        }
    }
}

impl Serialize for clz_Torappu_BattleVoiceData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_BattleVoiceData", 4)?;
        s.serialize_field("crossfade", &self.crossfade())?;
        s.serialize_field(
            "minTimeDeltaForEnemyEncounter",
            &self.minTimeDeltaForEnemyEncounter(),
        )?;
        s.serialize_field(
            "minSpCostForImportantPassiveSkill",
            &self.minSpCostForImportantPassiveSkill(),
        )?;
        if let Some(f) = self.voiceTypeOptions() {
            s.serialize_field("voiceTypeOptions", &f)?;
        } else {
            s.skip_field("voiceTypeOptions")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_BattleVoiceDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_BattleVoiceDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_crossfade(&mut self, crossfade: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_BattleVoiceData::VT_CROSSFADE, crossfade, 0.0);
    }
    #[inline]
    pub fn add_minTimeDeltaForEnemyEncounter(&mut self, minTimeDeltaForEnemyEncounter: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_BattleVoiceData::VT_MINTIMEDELTAFORENEMYENCOUNTER,
            minTimeDeltaForEnemyEncounter,
            0.0,
        );
    }
    #[inline]
    pub fn add_minSpCostForImportantPassiveSkill(
        &mut self,
        minSpCostForImportantPassiveSkill: i32,
    ) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BattleVoiceData::VT_MINSPCOSTFORIMPORTANTPASSIVESKILL,
            minSpCostForImportantPassiveSkill,
            0,
        );
    }
    #[inline]
    pub fn add_voiceTypeOptions(
        &mut self,
        voiceTypeOptions: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BattleVoiceOption<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BattleVoiceData::VT_VOICETYPEOPTIONS,
            voiceTypeOptions,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BattleVoiceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BattleVoiceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BattleVoiceData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BattleVoiceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BattleVoiceData");
        ds.field("crossfade", &self.crossfade());
        ds.field(
            "minTimeDeltaForEnemyEncounter",
            &self.minTimeDeltaForEnemyEncounter(),
        );
        ds.field(
            "minSpCostForImportantPassiveSkill",
            &self.minSpCostForImportantPassiveSkill(),
        );
        ds.field("voiceTypeOptions", &self.voiceTypeOptions());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_BattleVoiceDataT {
    pub crossfade: f32,
    pub minTimeDeltaForEnemyEncounter: f32,
    pub minSpCostForImportantPassiveSkill: i32,
    pub voiceTypeOptions: Option<Vec<clz_Torappu_BattleVoiceOptionT>>,
}
impl Default for clz_Torappu_BattleVoiceDataT {
    fn default() -> Self {
        Self {
            crossfade: 0.0,
            minTimeDeltaForEnemyEncounter: 0.0,
            minSpCostForImportantPassiveSkill: 0,
            voiceTypeOptions: None,
        }
    }
}
impl clz_Torappu_BattleVoiceDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BattleVoiceData<'b>> {
        let crossfade = self.crossfade;
        let minTimeDeltaForEnemyEncounter = self.minTimeDeltaForEnemyEncounter;
        let minSpCostForImportantPassiveSkill = self.minSpCostForImportantPassiveSkill;
        let voiceTypeOptions = self.voiceTypeOptions.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_BattleVoiceData::create(
            _fbb,
            &clz_Torappu_BattleVoiceDataArgs {
                crossfade,
                minTimeDeltaForEnemyEncounter,
                minSpCostForImportantPassiveSkill,
                voiceTypeOptions,
            },
        )
    }
}
pub enum clz_Torappu_Audio_Middleware_Data_MusicDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Audio_Middleware_Data_MusicData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Audio_Middleware_Data_MusicData<'a> {
    type Inner = clz_Torappu_Audio_Middleware_Data_MusicData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Audio_Middleware_Data_MusicData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_BANK: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Audio_Middleware_Data_MusicData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Audio_Middleware_Data_MusicDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_MusicData<'bldr>> {
        let mut builder = clz_Torappu_Audio_Middleware_Data_MusicDataBuilder::new(_fbb);
        if let Some(x) = args.bank {
            builder.add_bank(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Audio_Middleware_Data_MusicDataT {
        let id = self.id().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let bank = self.bank().map(|x| x.to_string());
        clz_Torappu_Audio_Middleware_Data_MusicDataT { id, name, bank }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Audio_Middleware_Data_MusicData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Audio_Middleware_Data_MusicData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn bank(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Audio_Middleware_Data_MusicData::VT_BANK,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Audio_Middleware_Data_MusicData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bank", Self::VT_BANK, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Audio_Middleware_Data_MusicDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bank: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Audio_Middleware_Data_MusicDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Audio_Middleware_Data_MusicDataArgs {
            id: None,
            name: None,
            bank: None,
        }
    }
}

impl Serialize for clz_Torappu_Audio_Middleware_Data_MusicData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_Audio_Middleware_Data_MusicData", 3)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.bank() {
            s.serialize_field("bank", &f)?;
        } else {
            s.skip_field("bank")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Audio_Middleware_Data_MusicDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Audio_Middleware_Data_MusicDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_MusicData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_MusicData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_bank(&mut self, bank: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_MusicData::VT_BANK,
            bank,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Audio_Middleware_Data_MusicDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Audio_Middleware_Data_MusicDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_MusicData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Audio_Middleware_Data_MusicData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Audio_Middleware_Data_MusicData");
        ds.field("id", &self.id());
        ds.field("name", &self.name());
        ds.field("bank", &self.bank());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Audio_Middleware_Data_MusicDataT {
    pub id: Option<String>,
    pub name: Option<String>,
    pub bank: Option<String>,
}
impl Default for clz_Torappu_Audio_Middleware_Data_MusicDataT {
    fn default() -> Self {
        Self {
            id: None,
            name: None,
            bank: None,
        }
    }
}
impl clz_Torappu_Audio_Middleware_Data_MusicDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_MusicData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let bank = self.bank.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Audio_Middleware_Data_MusicData::create(
            _fbb,
            &clz_Torappu_Audio_Middleware_Data_MusicDataArgs { id, name, bank },
        )
    }
}
pub enum clz_Torappu_Audio_Middleware_Data_DuckingDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Audio_Middleware_Data_DuckingData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Audio_Middleware_Data_DuckingData<'a> {
    type Inner = clz_Torappu_Audio_Middleware_Data_DuckingData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Audio_Middleware_Data_DuckingData<'a> {
    pub const VT_BANK: flatbuffers::VOffsetT = 4;
    pub const VT_VOLUME: flatbuffers::VOffsetT = 6;
    pub const VT_FADETIME: flatbuffers::VOffsetT = 8;
    pub const VT_DELAY: flatbuffers::VOffsetT = 10;
    pub const VT_FADESTYLEID: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Audio_Middleware_Data_DuckingData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Audio_Middleware_Data_DuckingDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_DuckingData<'bldr>> {
        let mut builder = clz_Torappu_Audio_Middleware_Data_DuckingDataBuilder::new(_fbb);
        if let Some(x) = args.fadeStyleId {
            builder.add_fadeStyleId(x);
        }
        builder.add_delay(args.delay);
        builder.add_fadeTime(args.fadeTime);
        builder.add_volume(args.volume);
        if let Some(x) = args.bank {
            builder.add_bank(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Audio_Middleware_Data_DuckingDataT {
        let bank = self.bank().map(|x| x.to_string());
        let volume = self.volume();
        let fadeTime = self.fadeTime();
        let delay = self.delay();
        let fadeStyleId = self.fadeStyleId().map(|x| x.to_string());
        clz_Torappu_Audio_Middleware_Data_DuckingDataT {
            bank,
            volume,
            fadeTime,
            delay,
            fadeStyleId,
        }
    }

    #[inline]
    pub fn bank(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Audio_Middleware_Data_DuckingData::VT_BANK,
                None,
            )
        }
    }
    #[inline]
    pub fn volume(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_Audio_Middleware_Data_DuckingData::VT_VOLUME,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn fadeTime(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_Audio_Middleware_Data_DuckingData::VT_FADETIME,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn delay(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_Audio_Middleware_Data_DuckingData::VT_DELAY,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn fadeStyleId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Audio_Middleware_Data_DuckingData::VT_FADESTYLEID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Audio_Middleware_Data_DuckingData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bank", Self::VT_BANK, false)?
            .visit_field::<f32>("volume", Self::VT_VOLUME, false)?
            .visit_field::<f32>("fadeTime", Self::VT_FADETIME, false)?
            .visit_field::<f32>("delay", Self::VT_DELAY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "fadeStyleId",
                Self::VT_FADESTYLEID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Audio_Middleware_Data_DuckingDataArgs<'a> {
    pub bank: Option<flatbuffers::WIPOffset<&'a str>>,
    pub volume: f32,
    pub fadeTime: f32,
    pub delay: f32,
    pub fadeStyleId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Audio_Middleware_Data_DuckingDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Audio_Middleware_Data_DuckingDataArgs {
            bank: None,
            volume: 0.0,
            fadeTime: 0.0,
            delay: 0.0,
            fadeStyleId: None,
        }
    }
}

impl Serialize for clz_Torappu_Audio_Middleware_Data_DuckingData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_Audio_Middleware_Data_DuckingData", 5)?;
        if let Some(f) = self.bank() {
            s.serialize_field("bank", &f)?;
        } else {
            s.skip_field("bank")?;
        }
        s.serialize_field("volume", &self.volume())?;
        s.serialize_field("fadeTime", &self.fadeTime())?;
        s.serialize_field("delay", &self.delay())?;
        if let Some(f) = self.fadeStyleId() {
            s.serialize_field("fadeStyleId", &f)?;
        } else {
            s.skip_field("fadeStyleId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Audio_Middleware_Data_DuckingDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Audio_Middleware_Data_DuckingDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_bank(&mut self, bank: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_DuckingData::VT_BANK,
            bank,
        );
    }
    #[inline]
    pub fn add_volume(&mut self, volume: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_Audio_Middleware_Data_DuckingData::VT_VOLUME,
            volume,
            0.0,
        );
    }
    #[inline]
    pub fn add_fadeTime(&mut self, fadeTime: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_Audio_Middleware_Data_DuckingData::VT_FADETIME,
            fadeTime,
            0.0,
        );
    }
    #[inline]
    pub fn add_delay(&mut self, delay: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_Audio_Middleware_Data_DuckingData::VT_DELAY,
            delay,
            0.0,
        );
    }
    #[inline]
    pub fn add_fadeStyleId(&mut self, fadeStyleId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_DuckingData::VT_FADESTYLEID,
            fadeStyleId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Audio_Middleware_Data_DuckingDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Audio_Middleware_Data_DuckingDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_DuckingData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Audio_Middleware_Data_DuckingData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Audio_Middleware_Data_DuckingData");
        ds.field("bank", &self.bank());
        ds.field("volume", &self.volume());
        ds.field("fadeTime", &self.fadeTime());
        ds.field("delay", &self.delay());
        ds.field("fadeStyleId", &self.fadeStyleId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Audio_Middleware_Data_DuckingDataT {
    pub bank: Option<String>,
    pub volume: f32,
    pub fadeTime: f32,
    pub delay: f32,
    pub fadeStyleId: Option<String>,
}
impl Default for clz_Torappu_Audio_Middleware_Data_DuckingDataT {
    fn default() -> Self {
        Self {
            bank: None,
            volume: 0.0,
            fadeTime: 0.0,
            delay: 0.0,
            fadeStyleId: None,
        }
    }
}
impl clz_Torappu_Audio_Middleware_Data_DuckingDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_DuckingData<'b>> {
        let bank = self.bank.as_ref().map(|x| _fbb.create_string(x));
        let volume = self.volume;
        let fadeTime = self.fadeTime;
        let delay = self.delay;
        let fadeStyleId = self.fadeStyleId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Audio_Middleware_Data_DuckingData::create(
            _fbb,
            &clz_Torappu_Audio_Middleware_Data_DuckingDataArgs {
                bank,
                volume,
                fadeTime,
                delay,
                fadeStyleId,
            },
        )
    }
}
pub enum clz_Torappu_Audio_Middleware_Data_FadeStyleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Audio_Middleware_Data_FadeStyleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Audio_Middleware_Data_FadeStyleData<'a> {
    type Inner = clz_Torappu_Audio_Middleware_Data_FadeStyleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Audio_Middleware_Data_FadeStyleData<'a> {
    pub const VT_STYLENAME: flatbuffers::VOffsetT = 4;
    pub const VT_FADEINTIME: flatbuffers::VOffsetT = 6;
    pub const VT_FADEOUTTIME: flatbuffers::VOffsetT = 8;
    pub const VT_FADEINTYPE: flatbuffers::VOffsetT = 10;
    pub const VT_FADEOUTTYPE: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Audio_Middleware_Data_FadeStyleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Audio_Middleware_Data_FadeStyleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_FadeStyleData<'bldr>> {
        let mut builder = clz_Torappu_Audio_Middleware_Data_FadeStyleDataBuilder::new(_fbb);
        builder.add_fadeoutType(args.fadeoutType);
        builder.add_fadeinType(args.fadeinType);
        builder.add_fadeoutTime(args.fadeoutTime);
        builder.add_fadeinTime(args.fadeinTime);
        if let Some(x) = args.styleName {
            builder.add_styleName(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Audio_Middleware_Data_FadeStyleDataT {
        let styleName = self.styleName().map(|x| x.to_string());
        let fadeinTime = self.fadeinTime();
        let fadeoutTime = self.fadeoutTime();
        let fadeinType = self.fadeinType();
        let fadeoutType = self.fadeoutType();
        clz_Torappu_Audio_Middleware_Data_FadeStyleDataT {
            styleName,
            fadeinTime,
            fadeoutTime,
            fadeinType,
            fadeoutType,
        }
    }

    #[inline]
    pub fn styleName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Audio_Middleware_Data_FadeStyleData::VT_STYLENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn fadeinTime(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_Audio_Middleware_Data_FadeStyleData::VT_FADEINTIME,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn fadeoutTime(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_Audio_Middleware_Data_FadeStyleData::VT_FADEOUTTIME,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn fadeinType(&self) -> enum__Torappu_Audio_Middleware_Data_AudioFadeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_Audio_Middleware_Data_AudioFadeType>(
                    clz_Torappu_Audio_Middleware_Data_FadeStyleData::VT_FADEINTYPE,
                    Some(enum__Torappu_Audio_Middleware_Data_AudioFadeType::LINEAR),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn fadeoutType(&self) -> enum__Torappu_Audio_Middleware_Data_AudioFadeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_Audio_Middleware_Data_AudioFadeType>(
                    clz_Torappu_Audio_Middleware_Data_FadeStyleData::VT_FADEOUTTYPE,
                    Some(enum__Torappu_Audio_Middleware_Data_AudioFadeType::LINEAR),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Audio_Middleware_Data_FadeStyleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "styleName",
                Self::VT_STYLENAME,
                false,
            )?
            .visit_field::<f32>("fadeinTime", Self::VT_FADEINTIME, false)?
            .visit_field::<f32>("fadeoutTime", Self::VT_FADEOUTTIME, false)?
            .visit_field::<enum__Torappu_Audio_Middleware_Data_AudioFadeType>(
                "fadeinType",
                Self::VT_FADEINTYPE,
                false,
            )?
            .visit_field::<enum__Torappu_Audio_Middleware_Data_AudioFadeType>(
                "fadeoutType",
                Self::VT_FADEOUTTYPE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Audio_Middleware_Data_FadeStyleDataArgs<'a> {
    pub styleName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub fadeinTime: f32,
    pub fadeoutTime: f32,
    pub fadeinType: enum__Torappu_Audio_Middleware_Data_AudioFadeType,
    pub fadeoutType: enum__Torappu_Audio_Middleware_Data_AudioFadeType,
}
impl<'a> Default for clz_Torappu_Audio_Middleware_Data_FadeStyleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Audio_Middleware_Data_FadeStyleDataArgs {
            styleName: None,
            fadeinTime: 0.0,
            fadeoutTime: 0.0,
            fadeinType: enum__Torappu_Audio_Middleware_Data_AudioFadeType::LINEAR,
            fadeoutType: enum__Torappu_Audio_Middleware_Data_AudioFadeType::LINEAR,
        }
    }
}

impl Serialize for clz_Torappu_Audio_Middleware_Data_FadeStyleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_Audio_Middleware_Data_FadeStyleData", 5)?;
        if let Some(f) = self.styleName() {
            s.serialize_field("styleName", &f)?;
        } else {
            s.skip_field("styleName")?;
        }
        s.serialize_field("fadeinTime", &self.fadeinTime())?;
        s.serialize_field("fadeoutTime", &self.fadeoutTime())?;
        s.serialize_field("fadeinType", &self.fadeinType())?;
        s.serialize_field("fadeoutType", &self.fadeoutType())?;
        s.end()
    }
}

pub struct clz_Torappu_Audio_Middleware_Data_FadeStyleDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Audio_Middleware_Data_FadeStyleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_styleName(&mut self, styleName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_FadeStyleData::VT_STYLENAME,
            styleName,
        );
    }
    #[inline]
    pub fn add_fadeinTime(&mut self, fadeinTime: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_Audio_Middleware_Data_FadeStyleData::VT_FADEINTIME,
            fadeinTime,
            0.0,
        );
    }
    #[inline]
    pub fn add_fadeoutTime(&mut self, fadeoutTime: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_Audio_Middleware_Data_FadeStyleData::VT_FADEOUTTIME,
            fadeoutTime,
            0.0,
        );
    }
    #[inline]
    pub fn add_fadeinType(
        &mut self,
        fadeinType: enum__Torappu_Audio_Middleware_Data_AudioFadeType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_Audio_Middleware_Data_AudioFadeType>(
                clz_Torappu_Audio_Middleware_Data_FadeStyleData::VT_FADEINTYPE,
                fadeinType,
                enum__Torappu_Audio_Middleware_Data_AudioFadeType::LINEAR,
            );
    }
    #[inline]
    pub fn add_fadeoutType(
        &mut self,
        fadeoutType: enum__Torappu_Audio_Middleware_Data_AudioFadeType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_Audio_Middleware_Data_AudioFadeType>(
                clz_Torappu_Audio_Middleware_Data_FadeStyleData::VT_FADEOUTTYPE,
                fadeoutType,
                enum__Torappu_Audio_Middleware_Data_AudioFadeType::LINEAR,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Audio_Middleware_Data_FadeStyleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Audio_Middleware_Data_FadeStyleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_FadeStyleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Audio_Middleware_Data_FadeStyleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Audio_Middleware_Data_FadeStyleData");
        ds.field("styleName", &self.styleName());
        ds.field("fadeinTime", &self.fadeinTime());
        ds.field("fadeoutTime", &self.fadeoutTime());
        ds.field("fadeinType", &self.fadeinType());
        ds.field("fadeoutType", &self.fadeoutType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Audio_Middleware_Data_FadeStyleDataT {
    pub styleName: Option<String>,
    pub fadeinTime: f32,
    pub fadeoutTime: f32,
    pub fadeinType: enum__Torappu_Audio_Middleware_Data_AudioFadeType,
    pub fadeoutType: enum__Torappu_Audio_Middleware_Data_AudioFadeType,
}
impl Default for clz_Torappu_Audio_Middleware_Data_FadeStyleDataT {
    fn default() -> Self {
        Self {
            styleName: None,
            fadeinTime: 0.0,
            fadeoutTime: 0.0,
            fadeinType: enum__Torappu_Audio_Middleware_Data_AudioFadeType::LINEAR,
            fadeoutType: enum__Torappu_Audio_Middleware_Data_AudioFadeType::LINEAR,
        }
    }
}
impl clz_Torappu_Audio_Middleware_Data_FadeStyleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_FadeStyleData<'b>> {
        let styleName = self.styleName.as_ref().map(|x| _fbb.create_string(x));
        let fadeinTime = self.fadeinTime;
        let fadeoutTime = self.fadeoutTime;
        let fadeinType = self.fadeinType;
        let fadeoutType = self.fadeoutType;
        clz_Torappu_Audio_Middleware_Data_FadeStyleData::create(
            _fbb,
            &clz_Torappu_Audio_Middleware_Data_FadeStyleDataArgs {
                styleName,
                fadeinTime,
                fadeoutTime,
                fadeinType,
                fadeoutType,
            },
        )
    }
}
pub enum dict__enum__Torappu_VoiceLangType__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_VoiceLangType__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__enum__Torappu_VoiceLangType__string<'a> {
    type Inner = dict__enum__Torappu_VoiceLangType__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__enum__Torappu_VoiceLangType__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_VoiceLangType__string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__enum__Torappu_VoiceLangType__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_VoiceLangType__string<'bldr>> {
        let mut builder = dict__enum__Torappu_VoiceLangType__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__enum__Torappu_VoiceLangType__stringT {
        let key = self.key();
        let value = self.value().map(|x| x.to_string());
        dict__enum__Torappu_VoiceLangType__stringT { key, value }
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_VoiceLangType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_VoiceLangType>(
                    dict__enum__Torappu_VoiceLangType__string::VT_KEY,
                    Some(enum__Torappu_VoiceLangType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__enum__Torappu_VoiceLangType__string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_VoiceLangType,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                dict__enum__Torappu_VoiceLangType__string::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for dict__enum__Torappu_VoiceLangType__string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_VoiceLangType>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__enum__Torappu_VoiceLangType__stringArgs<'a> {
    pub key: enum__Torappu_VoiceLangType,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for dict__enum__Torappu_VoiceLangType__stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__enum__Torappu_VoiceLangType__stringArgs {
            key: enum__Torappu_VoiceLangType::NONE,
            value: None,
        }
    }
}

impl Serialize for dict__enum__Torappu_VoiceLangType__string<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__enum__Torappu_VoiceLangType__string", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__enum__Torappu_VoiceLangType__stringBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__enum__Torappu_VoiceLangType__stringBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: enum__Torappu_VoiceLangType) {
        self.fbb_.push_slot::<enum__Torappu_VoiceLangType>(
            dict__enum__Torappu_VoiceLangType__string::VT_KEY,
            key,
            enum__Torappu_VoiceLangType::NONE,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__enum__Torappu_VoiceLangType__string::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__enum__Torappu_VoiceLangType__stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__enum__Torappu_VoiceLangType__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__enum__Torappu_VoiceLangType__string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__enum__Torappu_VoiceLangType__string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__enum__Torappu_VoiceLangType__string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__enum__Torappu_VoiceLangType__stringT {
    pub key: enum__Torappu_VoiceLangType,
    pub value: Option<String>,
}
impl Default for dict__enum__Torappu_VoiceLangType__stringT {
    fn default() -> Self {
        Self {
            key: enum__Torappu_VoiceLangType::NONE,
            value: None,
        }
    }
}
impl dict__enum__Torappu_VoiceLangType__stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_VoiceLangType__string<'b>> {
        let key = self.key;
        let value = self.value.as_ref().map(|x| _fbb.create_string(x));
        dict__enum__Torappu_VoiceLangType__string::create(
            _fbb,
            &dict__enum__Torappu_VoiceLangType__stringArgs { key, value },
        )
    }
}
pub enum dict__string__list_dict__enum__Torappu_VoiceLangType__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_dict__enum__Torappu_VoiceLangType__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__list_dict__enum__Torappu_VoiceLangType__string<'a>
{
    type Inner = dict__string__list_dict__enum__Torappu_VoiceLangType__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__list_dict__enum__Torappu_VoiceLangType__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_dict__enum__Torappu_VoiceLangType__string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_dict__enum__Torappu_VoiceLangType__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__list_dict__enum__Torappu_VoiceLangType__string<'bldr>>
    {
        let mut builder =
            dict__string__list_dict__enum__Torappu_VoiceLangType__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__list_dict__enum__Torappu_VoiceLangType__stringT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| x.iter().map(|t| t.unpack()).collect());
        dict__string__list_dict__enum__Torappu_VoiceLangType__stringT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__list_dict__enum__Torappu_VoiceLangType__string::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__list_dict__enum__Torappu_VoiceLangType__string,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__enum__Torappu_VoiceLangType__string<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__enum__Torappu_VoiceLangType__string>,
                >,
            >>(
                dict__string__list_dict__enum__Torappu_VoiceLangType__string::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__list_dict__enum__Torappu_VoiceLangType__string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__enum__Torappu_VoiceLangType__string>,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_dict__enum__Torappu_VoiceLangType__stringArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__enum__Torappu_VoiceLangType__string<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for dict__string__list_dict__enum__Torappu_VoiceLangType__stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__list_dict__enum__Torappu_VoiceLangType__stringArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__list_dict__enum__Torappu_VoiceLangType__string<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__list_dict__enum__Torappu_VoiceLangType__string",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__list_dict__enum__Torappu_VoiceLangType__stringBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__list_dict__enum__Torappu_VoiceLangType__stringBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_dict__enum__Torappu_VoiceLangType__string::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__enum__Torappu_VoiceLangType__string<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_dict__enum__Torappu_VoiceLangType__string::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__list_dict__enum__Torappu_VoiceLangType__stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__list_dict__enum__Torappu_VoiceLangType__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__list_dict__enum__Torappu_VoiceLangType__string<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__list_dict__enum__Torappu_VoiceLangType__string::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__list_dict__enum__Torappu_VoiceLangType__string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__list_dict__enum__Torappu_VoiceLangType__string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__list_dict__enum__Torappu_VoiceLangType__stringT {
    pub key: String,
    pub value: Option<Vec<dict__enum__Torappu_VoiceLangType__stringT>>,
}
impl Default for dict__string__list_dict__enum__Torappu_VoiceLangType__stringT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__list_dict__enum__Torappu_VoiceLangType__stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__list_dict__enum__Torappu_VoiceLangType__string<'b>>
    {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        dict__string__list_dict__enum__Torappu_VoiceLangType__string::create(
            _fbb,
            &dict__string__list_dict__enum__Torappu_VoiceLangType__stringArgs { key, value },
        )
    }
}
pub enum dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string<'a>
{
    type Inner =
        dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string<'bldr>,
    > {
        let mut builder = dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(
        &self,
    ) -> dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__stringT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| x.iter().map(|t| t.unpack()).collect());
        dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__stringT {
            key,
            value,
        }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string::VT_KEY, None).unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__list_dict__enum__Torappu_VoiceLangType__string<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_dict__enum__Torappu_VoiceLangType__string>>>>(dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__list_dict__enum__Torappu_VoiceLangType__string,
                    >,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__stringArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_dict__enum__Torappu_VoiceLangType__string<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default
    for dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__stringArgs<'a>
{
    #[inline]
    fn default() -> Self {
        dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__stringArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize
    for dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string<'_>
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__stringBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__stringBuilder<
        'a,
        'b,
        A,
    >
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_dict__enum__Torappu_VoiceLangType__string<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__stringBuilder<
        'a,
        'b,
        A,
    > {
        let start = _fbb.start_table();
        dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct(
            "dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string",
        );
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__stringT {
    pub key: String,
    pub value: Option<Vec<dict__string__list_dict__enum__Torappu_VoiceLangType__stringT>>,
}
impl Default for dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__stringT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<
        dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string<'b>,
    > {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string::create(
            _fbb,
            &dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__stringArgs {
                key,
                value,
            },
        )
    }
}
pub enum dict__string__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__string<'a> {
    type Inner = dict__string__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__string<'bldr>> {
        let mut builder = dict__string__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__stringT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| x.to_string());
        dict__string__stringT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__string::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__string::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__stringArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for dict__string__stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__stringArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__string<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__string", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__stringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__stringBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__string::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__string::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, dict__string__string::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__stringT {
    pub key: String,
    pub value: Option<String>,
}
impl Default for dict__string__stringT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__string<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| _fbb.create_string(x));
        dict__string__string::create(_fbb, &dict__string__stringArgs { key, value })
    }
}
pub enum clz_Torappu_Audio_Middleware_Data_TorappuAudioDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Audio_Middleware_Data_TorappuAudioData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Audio_Middleware_Data_TorappuAudioData<'a> {
    type Inner = clz_Torappu_Audio_Middleware_Data_TorappuAudioData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Audio_Middleware_Data_TorappuAudioData<'a> {
    pub const VT_BGMBANKS: flatbuffers::VOffsetT = 4;
    pub const VT_SOUNDFXBANKS: flatbuffers::VOffsetT = 6;
    pub const VT_SOUNDFXCTRLBANKS: flatbuffers::VOffsetT = 8;
    pub const VT_SNAPSHOTBANKS: flatbuffers::VOffsetT = 10;
    pub const VT_BATTLEVOICE: flatbuffers::VOffsetT = 12;
    pub const VT_MUSICS: flatbuffers::VOffsetT = 14;
    pub const VT_DUCKINGS: flatbuffers::VOffsetT = 16;
    pub const VT_FADESTYLES: flatbuffers::VOffsetT = 18;
    pub const VT_SOUNDFXVOICELANG: flatbuffers::VOffsetT = 20;
    pub const VT_BANKALIAS: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Audio_Middleware_Data_TorappuAudioData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Audio_Middleware_Data_TorappuAudioDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_TorappuAudioData<'bldr>> {
        let mut builder = clz_Torappu_Audio_Middleware_Data_TorappuAudioDataBuilder::new(_fbb);
        if let Some(x) = args.bankAlias {
            builder.add_bankAlias(x);
        }
        if let Some(x) = args.soundFxVoiceLang {
            builder.add_soundFxVoiceLang(x);
        }
        if let Some(x) = args.fadeStyles {
            builder.add_fadeStyles(x);
        }
        if let Some(x) = args.duckings {
            builder.add_duckings(x);
        }
        if let Some(x) = args.musics {
            builder.add_musics(x);
        }
        if let Some(x) = args.battleVoice {
            builder.add_battleVoice(x);
        }
        if let Some(x) = args.snapshotBanks {
            builder.add_snapshotBanks(x);
        }
        if let Some(x) = args.soundFXCtrlBanks {
            builder.add_soundFXCtrlBanks(x);
        }
        if let Some(x) = args.soundFXBanks {
            builder.add_soundFXBanks(x);
        }
        if let Some(x) = args.bgmBanks {
            builder.add_bgmBanks(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Audio_Middleware_Data_TorappuAudioDataT {
        let bgmBanks = self
            .bgmBanks()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let soundFXBanks = self
            .soundFXBanks()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let soundFXCtrlBanks = self
            .soundFXCtrlBanks()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let snapshotBanks = self
            .snapshotBanks()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let battleVoice = self.battleVoice().map(|x| Box::new(x.unpack()));
        let musics = self
            .musics()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let duckings = self
            .duckings()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let fadeStyles = self
            .fadeStyles()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let soundFxVoiceLang = self
            .soundFxVoiceLang()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let bankAlias = self
            .bankAlias()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_Audio_Middleware_Data_TorappuAudioDataT {
            bgmBanks,
            soundFXBanks,
            soundFXCtrlBanks,
            snapshotBanks,
            battleVoice,
            musics,
            duckings,
            fadeStyles,
            soundFxVoiceLang,
            bankAlias,
        }
    }

    #[inline]
    pub fn bgmBanks(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_BGMBank<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_BGMBank>,
                >,
            >>(
                clz_Torappu_Audio_Middleware_Data_TorappuAudioData::VT_BGMBANKS,
                None,
            )
        }
    }
    #[inline]
    pub fn soundFXBanks(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_SoundFXBank<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_SoundFXBank>,
                >,
            >>(
                clz_Torappu_Audio_Middleware_Data_TorappuAudioData::VT_SOUNDFXBANKS,
                None,
            )
        }
    }
    #[inline]
    pub fn soundFXCtrlBanks(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank>,
                >,
            >>(
                clz_Torappu_Audio_Middleware_Data_TorappuAudioData::VT_SOUNDFXCTRLBANKS,
                None,
            )
        }
    }
    #[inline]
    pub fn snapshotBanks(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_SnapshotBank<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_SnapshotBank>,
                >,
            >>(
                clz_Torappu_Audio_Middleware_Data_TorappuAudioData::VT_SNAPSHOTBANKS,
                None,
            )
        }
    }
    #[inline]
    pub fn battleVoice(&self) -> Option<clz_Torappu_BattleVoiceData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BattleVoiceData>>(
                    clz_Torappu_Audio_Middleware_Data_TorappuAudioData::VT_BATTLEVOICE,
                    None,
                )
        }
    }
    #[inline]
    pub fn musics(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_MusicData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_MusicData>,
                >,
            >>(
                clz_Torappu_Audio_Middleware_Data_TorappuAudioData::VT_MUSICS,
                None,
            )
        }
    }
    #[inline]
    pub fn duckings(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_DuckingData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_DuckingData>,
                >,
            >>(
                clz_Torappu_Audio_Middleware_Data_TorappuAudioData::VT_DUCKINGS,
                None,
            )
        }
    }
    #[inline]
    pub fn fadeStyles(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_FadeStyleData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_FadeStyleData>,
                >,
            >>(
                clz_Torappu_Audio_Middleware_Data_TorappuAudioData::VT_FADESTYLES,
                None,
            )
        }
    }
    #[inline]
    pub fn soundFxVoiceLang(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string>>>>(clz_Torappu_Audio_Middleware_Data_TorappuAudioData::VT_SOUNDFXVOICELANG, None)
        }
    }
    #[inline]
    pub fn bankAlias(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(
                clz_Torappu_Audio_Middleware_Data_TorappuAudioData::VT_BANKALIAS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Audio_Middleware_Data_TorappuAudioData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_BGMBank>>>>("bgmBanks", Self::VT_BGMBANKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_SoundFXBank>>>>("soundFXBanks", Self::VT_SOUNDFXBANKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank>>>>("soundFXCtrlBanks", Self::VT_SOUNDFXCTRLBANKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_SnapshotBank>>>>("snapshotBanks", Self::VT_SNAPSHOTBANKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BattleVoiceData>>("battleVoice", Self::VT_BATTLEVOICE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_MusicData>>>>("musics", Self::VT_MUSICS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_DuckingData>>>>("duckings", Self::VT_DUCKINGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_FadeStyleData>>>>("fadeStyles", Self::VT_FADESTYLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string>>>>("soundFxVoiceLang", Self::VT_SOUNDFXVOICELANG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>>>("bankAlias", Self::VT_BANKALIAS, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Audio_Middleware_Data_TorappuAudioDataArgs<'a> {
    pub bgmBanks: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_BGMBank<'a>>,
            >,
        >,
    >,
    pub soundFXBanks: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_SoundFXBank<'a>>,
            >,
        >,
    >,
    pub soundFXCtrlBanks: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank<'a>>,
            >,
        >,
    >,
    pub snapshotBanks: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_SnapshotBank<'a>>,
            >,
        >,
    >,
    pub battleVoice: Option<flatbuffers::WIPOffset<clz_Torappu_BattleVoiceData<'a>>>,
    pub musics: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_MusicData<'a>>,
            >,
        >,
    >,
    pub duckings: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_DuckingData<'a>>,
            >,
        >,
    >,
    pub fadeStyles: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_FadeStyleData<'a>>,
            >,
        >,
    >,
    pub soundFxVoiceLang: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string<
                        'a,
                    >,
                >,
            >,
        >,
    >,
    pub bankAlias: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_Audio_Middleware_Data_TorappuAudioDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Audio_Middleware_Data_TorappuAudioDataArgs {
            bgmBanks: None,
            soundFXBanks: None,
            soundFXCtrlBanks: None,
            snapshotBanks: None,
            battleVoice: None,
            musics: None,
            duckings: None,
            fadeStyles: None,
            soundFxVoiceLang: None,
            bankAlias: None,
        }
    }
}

impl Serialize for clz_Torappu_Audio_Middleware_Data_TorappuAudioData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("clz_Torappu_Audio_Middleware_Data_TorappuAudioData", 10)?;
        if let Some(f) = self.bgmBanks() {
            s.serialize_field("bgmBanks", &f)?;
        } else {
            s.skip_field("bgmBanks")?;
        }
        if let Some(f) = self.soundFXBanks() {
            s.serialize_field("soundFXBanks", &f)?;
        } else {
            s.skip_field("soundFXBanks")?;
        }
        if let Some(f) = self.soundFXCtrlBanks() {
            s.serialize_field("soundFXCtrlBanks", &f)?;
        } else {
            s.skip_field("soundFXCtrlBanks")?;
        }
        if let Some(f) = self.snapshotBanks() {
            s.serialize_field("snapshotBanks", &f)?;
        } else {
            s.skip_field("snapshotBanks")?;
        }
        if let Some(f) = self.battleVoice() {
            s.serialize_field("battleVoice", &f)?;
        } else {
            s.skip_field("battleVoice")?;
        }
        if let Some(f) = self.musics() {
            s.serialize_field("musics", &f)?;
        } else {
            s.skip_field("musics")?;
        }
        if let Some(f) = self.duckings() {
            s.serialize_field("duckings", &f)?;
        } else {
            s.skip_field("duckings")?;
        }
        if let Some(f) = self.fadeStyles() {
            s.serialize_field("fadeStyles", &f)?;
        } else {
            s.skip_field("fadeStyles")?;
        }
        if let Some(f) = self.soundFxVoiceLang() {
            s.serialize_field("soundFxVoiceLang", &f)?;
        } else {
            s.skip_field("soundFxVoiceLang")?;
        }
        if let Some(f) = self.bankAlias() {
            s.serialize_field("bankAlias", &f)?;
        } else {
            s.skip_field("bankAlias")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Audio_Middleware_Data_TorappuAudioDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Audio_Middleware_Data_TorappuAudioDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_bgmBanks(
        &mut self,
        bgmBanks: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_BGMBank<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_TorappuAudioData::VT_BGMBANKS,
            bgmBanks,
        );
    }
    #[inline]
    pub fn add_soundFXBanks(
        &mut self,
        soundFXBanks: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_SoundFXBank<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_TorappuAudioData::VT_SOUNDFXBANKS,
            soundFXBanks,
        );
    }
    #[inline]
    pub fn add_soundFXCtrlBanks(
        &mut self,
        soundFXCtrlBanks: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBank<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_TorappuAudioData::VT_SOUNDFXCTRLBANKS,
            soundFXCtrlBanks,
        );
    }
    #[inline]
    pub fn add_snapshotBanks(
        &mut self,
        snapshotBanks: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_SnapshotBank<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_TorappuAudioData::VT_SNAPSHOTBANKS,
            snapshotBanks,
        );
    }
    #[inline]
    pub fn add_battleVoice(
        &mut self,
        battleVoice: flatbuffers::WIPOffset<clz_Torappu_BattleVoiceData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BattleVoiceData>>(
                clz_Torappu_Audio_Middleware_Data_TorappuAudioData::VT_BATTLEVOICE,
                battleVoice,
            );
    }
    #[inline]
    pub fn add_musics(
        &mut self,
        musics: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_MusicData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_TorappuAudioData::VT_MUSICS,
            musics,
        );
    }
    #[inline]
    pub fn add_duckings(
        &mut self,
        duckings: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_DuckingData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_TorappuAudioData::VT_DUCKINGS,
            duckings,
        );
    }
    #[inline]
    pub fn add_fadeStyles(
        &mut self,
        fadeStyles: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Audio_Middleware_Data_FadeStyleData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_TorappuAudioData::VT_FADESTYLES,
            fadeStyles,
        );
    }
    #[inline]
    pub fn add_soundFxVoiceLang(
        &mut self,
        soundFxVoiceLang: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__string<
                        'b,
                    >,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_TorappuAudioData::VT_SOUNDFXVOICELANG,
            soundFxVoiceLang,
        );
    }
    #[inline]
    pub fn add_bankAlias(
        &mut self,
        bankAlias: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Audio_Middleware_Data_TorappuAudioData::VT_BANKALIAS,
            bankAlias,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Audio_Middleware_Data_TorappuAudioDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Audio_Middleware_Data_TorappuAudioDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_TorappuAudioData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Audio_Middleware_Data_TorappuAudioData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Audio_Middleware_Data_TorappuAudioData");
        ds.field("bgmBanks", &self.bgmBanks());
        ds.field("soundFXBanks", &self.soundFXBanks());
        ds.field("soundFXCtrlBanks", &self.soundFXCtrlBanks());
        ds.field("snapshotBanks", &self.snapshotBanks());
        ds.field("battleVoice", &self.battleVoice());
        ds.field("musics", &self.musics());
        ds.field("duckings", &self.duckings());
        ds.field("fadeStyles", &self.fadeStyles());
        ds.field("soundFxVoiceLang", &self.soundFxVoiceLang());
        ds.field("bankAlias", &self.bankAlias());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Audio_Middleware_Data_TorappuAudioDataT {
    pub bgmBanks: Option<Vec<clz_Torappu_Audio_Middleware_Data_BGMBankT>>,
    pub soundFXBanks: Option<Vec<clz_Torappu_Audio_Middleware_Data_SoundFXBankT>>,
    pub soundFXCtrlBanks: Option<Vec<clz_Torappu_Audio_Middleware_Data_SoundFXCtrlBankT>>,
    pub snapshotBanks: Option<Vec<clz_Torappu_Audio_Middleware_Data_SnapshotBankT>>,
    pub battleVoice: Option<Box<clz_Torappu_BattleVoiceDataT>>,
    pub musics: Option<Vec<clz_Torappu_Audio_Middleware_Data_MusicDataT>>,
    pub duckings: Option<Vec<clz_Torappu_Audio_Middleware_Data_DuckingDataT>>,
    pub fadeStyles: Option<Vec<clz_Torappu_Audio_Middleware_Data_FadeStyleDataT>>,
    pub soundFxVoiceLang: Option<
        Vec<dict__string__list_dict__string__list_dict__enum__Torappu_VoiceLangType__stringT>,
    >,
    pub bankAlias: Option<Vec<dict__string__stringT>>,
}
impl Default for clz_Torappu_Audio_Middleware_Data_TorappuAudioDataT {
    fn default() -> Self {
        Self {
            bgmBanks: None,
            soundFXBanks: None,
            soundFXCtrlBanks: None,
            snapshotBanks: None,
            battleVoice: None,
            musics: None,
            duckings: None,
            fadeStyles: None,
            soundFxVoiceLang: None,
            bankAlias: None,
        }
    }
}
impl clz_Torappu_Audio_Middleware_Data_TorappuAudioDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_TorappuAudioData<'b>> {
        let bgmBanks = self.bgmBanks.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let soundFXBanks = self.soundFXBanks.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let soundFXCtrlBanks = self.soundFXCtrlBanks.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let snapshotBanks = self.snapshotBanks.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let battleVoice = self.battleVoice.as_ref().map(|x| x.pack(_fbb));
        let musics = self.musics.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let duckings = self.duckings.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let fadeStyles = self.fadeStyles.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let soundFxVoiceLang = self.soundFxVoiceLang.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let bankAlias = self.bankAlias.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_Audio_Middleware_Data_TorappuAudioData::create(
            _fbb,
            &clz_Torappu_Audio_Middleware_Data_TorappuAudioDataArgs {
                bgmBanks,
                soundFXBanks,
                soundFXCtrlBanks,
                snapshotBanks,
                battleVoice,
                musics,
                duckings,
                fadeStyles,
                soundFxVoiceLang,
                bankAlias,
            },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_Audio_Middleware_Data_TorappuAudioData`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_audio_middleware_data_torappu_audio_data_unchecked`.
pub fn root_as_clz_torappu_audio_middleware_data_torappu_audio_data(
    buf: &[u8],
) -> Result<clz_Torappu_Audio_Middleware_Data_TorappuAudioData<'_>, flatbuffers::InvalidFlatbuffer>
{
    flatbuffers::root::<clz_Torappu_Audio_Middleware_Data_TorappuAudioData>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_Audio_Middleware_Data_TorappuAudioData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_audio_middleware_data_torappu_audio_data_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_audio_middleware_data_torappu_audio_data(
    buf: &[u8],
) -> Result<clz_Torappu_Audio_Middleware_Data_TorappuAudioData<'_>, flatbuffers::InvalidFlatbuffer>
{
    flatbuffers::size_prefixed_root::<clz_Torappu_Audio_Middleware_Data_TorappuAudioData>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_Audio_Middleware_Data_TorappuAudioData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_audio_middleware_data_torappu_audio_data_unchecked`.
pub fn root_as_clz_torappu_audio_middleware_data_torappu_audio_data_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_Audio_Middleware_Data_TorappuAudioData<'b>, flatbuffers::InvalidFlatbuffer>
{
    flatbuffers::root_with_opts::<clz_Torappu_Audio_Middleware_Data_TorappuAudioData<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_Audio_Middleware_Data_TorappuAudioData` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_audio_middleware_data_torappu_audio_data_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_audio_middleware_data_torappu_audio_data_with_opts<
    'b,
    'o,
>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_Audio_Middleware_Data_TorappuAudioData<'b>, flatbuffers::InvalidFlatbuffer>
{
    flatbuffers::size_prefixed_root_with_opts::<
        clz_Torappu_Audio_Middleware_Data_TorappuAudioData<'b>,
    >(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_Audio_Middleware_Data_TorappuAudioData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_Audio_Middleware_Data_TorappuAudioData`.
pub unsafe fn root_as_clz_torappu_audio_middleware_data_torappu_audio_data_unchecked(
    buf: &[u8],
) -> clz_Torappu_Audio_Middleware_Data_TorappuAudioData<'_> {
    unsafe {
        flatbuffers::root_unchecked::<clz_Torappu_Audio_Middleware_Data_TorappuAudioData>(buf)
    }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_Audio_Middleware_Data_TorappuAudioData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_Audio_Middleware_Data_TorappuAudioData`.
pub unsafe fn size_prefixed_root_as_clz_torappu_audio_middleware_data_torappu_audio_data_unchecked(
    buf: &[u8],
) -> clz_Torappu_Audio_Middleware_Data_TorappuAudioData<'_> {
    unsafe {
        flatbuffers::size_prefixed_root_unchecked::<
            clz_Torappu_Audio_Middleware_Data_TorappuAudioData,
        >(buf)
    }
}
#[inline]
pub fn finish_clz_torappu_audio_middleware_data_torappu_audio_data_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_TorappuAudioData<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_audio_middleware_data_torappu_audio_data_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_Audio_Middleware_Data_TorappuAudioData<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
