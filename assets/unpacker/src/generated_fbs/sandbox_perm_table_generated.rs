// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_PERM_TEMPLATE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_PERM_TEMPLATE_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_PERM_TEMPLATE_TYPE:
    [enum__Torappu_SandboxPermTemplateType; 2] = [
    enum__Torappu_SandboxPermTemplateType::NONE,
    enum__Torappu_SandboxPermTemplateType::SANDBOX_V2,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxPermTemplateType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxPermTemplateType {
    pub const NONE: Self = Self(0);
    pub const SANDBOX_V2: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::SANDBOX_V2];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::SANDBOX_V2 => Some("SANDBOX_V2"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxPermTemplateType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxPermTemplateType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxPermTemplateType {
    type Output = enum__Torappu_SandboxPermTemplateType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxPermTemplateType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxPermTemplateType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxPermTemplateType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_TRAP_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_TRAP_ITEM_TYPE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_TRAP_ITEM_TYPE:
    [enum__Torappu_SandboxV2TrapItemType; 5] = [
    enum__Torappu_SandboxV2TrapItemType::NONE,
    enum__Torappu_SandboxV2TrapItemType::BATTLE,
    enum__Torappu_SandboxV2TrapItemType::TACTICAL,
    enum__Torappu_SandboxV2TrapItemType::FUNCTION,
    enum__Torappu_SandboxV2TrapItemType::ANIMAL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2TrapItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2TrapItemType {
    pub const NONE: Self = Self(0);
    pub const BATTLE: Self = Self(1);
    pub const TACTICAL: Self = Self(2);
    pub const FUNCTION: Self = Self(3);
    pub const ANIMAL: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::BATTLE,
        Self::TACTICAL,
        Self::FUNCTION,
        Self::ANIMAL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::BATTLE => Some("BATTLE"),
            Self::TACTICAL => Some("TACTICAL"),
            Self::FUNCTION => Some("FUNCTION"),
            Self::ANIMAL => Some("ANIMAL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2TrapItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2TrapItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2TrapItemType {
    type Output = enum__Torappu_SandboxV2TrapItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2TrapItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2TrapItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2TrapItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_ITEM_TRAP_TAG: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_ITEM_TRAP_TAG: i32 = 8;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_ITEM_TRAP_TAG:
    [enum__Torappu_SandboxV2ItemTrapTag; 9] = [
    enum__Torappu_SandboxV2ItemTrapTag::OUTPUT,
    enum__Torappu_SandboxV2ItemTrapTag::COLLECTION,
    enum__Torappu_SandboxV2ItemTrapTag::IMPAIR,
    enum__Torappu_SandboxV2ItemTrapTag::ENHANCE,
    enum__Torappu_SandboxV2ItemTrapTag::EXPLORE,
    enum__Torappu_SandboxV2ItemTrapTag::SPECTACLE,
    enum__Torappu_SandboxV2ItemTrapTag::DECORATE,
    enum__Torappu_SandboxV2ItemTrapTag::DEFEND,
    enum__Torappu_SandboxV2ItemTrapTag::SCOUT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2ItemTrapTag(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2ItemTrapTag {
    pub const OUTPUT: Self = Self(0);
    pub const COLLECTION: Self = Self(1);
    pub const IMPAIR: Self = Self(2);
    pub const ENHANCE: Self = Self(3);
    pub const EXPLORE: Self = Self(4);
    pub const SPECTACLE: Self = Self(5);
    pub const DECORATE: Self = Self(6);
    pub const DEFEND: Self = Self(7);
    pub const SCOUT: Self = Self(8);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 8;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::OUTPUT,
        Self::COLLECTION,
        Self::IMPAIR,
        Self::ENHANCE,
        Self::EXPLORE,
        Self::SPECTACLE,
        Self::DECORATE,
        Self::DEFEND,
        Self::SCOUT,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::OUTPUT => Some("OUTPUT"),
            Self::COLLECTION => Some("COLLECTION"),
            Self::IMPAIR => Some("IMPAIR"),
            Self::ENHANCE => Some("ENHANCE"),
            Self::EXPLORE => Some("EXPLORE"),
            Self::SPECTACLE => Some("SPECTACLE"),
            Self::DECORATE => Some("DECORATE"),
            Self::DEFEND => Some("DEFEND"),
            Self::SCOUT => Some("SCOUT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2ItemTrapTag {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2ItemTrapTag {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2ItemTrapTag {
    type Output = enum__Torappu_SandboxV2ItemTrapTag;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2ItemTrapTag {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2ItemTrapTag {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2ItemTrapTag {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_CRAFT_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_CRAFT_ITEM_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_CRAFT_ITEM_TYPE:
    [enum__Torappu_SandboxV2CraftItemType; 3] = [
    enum__Torappu_SandboxV2CraftItemType::BASE_BUILDING,
    enum__Torappu_SandboxV2CraftItemType::TACTICAL,
    enum__Torappu_SandboxV2CraftItemType::COMBAT_BUILDING,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2CraftItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2CraftItemType {
    pub const BASE_BUILDING: Self = Self(0);
    pub const TACTICAL: Self = Self(1);
    pub const COMBAT_BUILDING: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::BASE_BUILDING, Self::TACTICAL, Self::COMBAT_BUILDING];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::BASE_BUILDING => Some("BASE_BUILDING"),
            Self::TACTICAL => Some("TACTICAL"),
            Self::COMBAT_BUILDING => Some("COMBAT_BUILDING"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2CraftItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2CraftItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2CraftItemType {
    type Output = enum__Torappu_SandboxV2CraftItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2CraftItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2CraftItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2CraftItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_PERM_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_PERM_ITEM_TYPE: i32 = 15;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_PERM_ITEM_TYPE: [enum__Torappu_SandboxPermItemType;
    14] = [
    enum__Torappu_SandboxPermItemType::NONE,
    enum__Torappu_SandboxPermItemType::TACTICAL,
    enum__Torappu_SandboxPermItemType::BUILDING,
    enum__Torappu_SandboxPermItemType::BUILDINGMAT,
    enum__Torappu_SandboxPermItemType::FOOD,
    enum__Torappu_SandboxPermItemType::FOODMAT,
    enum__Torappu_SandboxPermItemType::SPECIALMAT,
    enum__Torappu_SandboxPermItemType::COIN,
    enum__Torappu_SandboxPermItemType::CRAFT,
    enum__Torappu_SandboxPermItemType::PLACEHOLDER,
    enum__Torappu_SandboxPermItemType::STAMINAPOT,
    enum__Torappu_SandboxPermItemType::ANIMAL,
    enum__Torappu_SandboxPermItemType::INSECT,
    enum__Torappu_SandboxPermItemType::SLUGITEM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxPermItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxPermItemType {
    pub const NONE: Self = Self(0);
    pub const TACTICAL: Self = Self(1);
    pub const BUILDING: Self = Self(2);
    pub const BUILDINGMAT: Self = Self(3);
    pub const FOOD: Self = Self(4);
    pub const FOODMAT: Self = Self(5);
    pub const SPECIALMAT: Self = Self(6);
    pub const COIN: Self = Self(9);
    pub const CRAFT: Self = Self(10);
    pub const PLACEHOLDER: Self = Self(11);
    pub const STAMINAPOT: Self = Self(12);
    pub const ANIMAL: Self = Self(13);
    pub const INSECT: Self = Self(14);
    pub const SLUGITEM: Self = Self(15);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 15;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::TACTICAL,
        Self::BUILDING,
        Self::BUILDINGMAT,
        Self::FOOD,
        Self::FOODMAT,
        Self::SPECIALMAT,
        Self::COIN,
        Self::CRAFT,
        Self::PLACEHOLDER,
        Self::STAMINAPOT,
        Self::ANIMAL,
        Self::INSECT,
        Self::SLUGITEM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::TACTICAL => Some("TACTICAL"),
            Self::BUILDING => Some("BUILDING"),
            Self::BUILDINGMAT => Some("BUILDINGMAT"),
            Self::FOOD => Some("FOOD"),
            Self::FOODMAT => Some("FOODMAT"),
            Self::SPECIALMAT => Some("SPECIALMAT"),
            Self::COIN => Some("COIN"),
            Self::CRAFT => Some("CRAFT"),
            Self::PLACEHOLDER => Some("PLACEHOLDER"),
            Self::STAMINAPOT => Some("STAMINAPOT"),
            Self::ANIMAL => Some("ANIMAL"),
            Self::INSECT => Some("INSECT"),
            Self::SLUGITEM => Some("SLUGITEM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxPermItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxPermItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxPermItemType {
    type Output = enum__Torappu_SandboxPermItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxPermItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxPermItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxPermItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_FOOD_MAT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_FOOD_MAT_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_FOOD_MAT_TYPE:
    [enum__Torappu_SandboxV2FoodMatType; 2] = [
    enum__Torappu_SandboxV2FoodMatType::MAIN,
    enum__Torappu_SandboxV2FoodMatType::SUB,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2FoodMatType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2FoodMatType {
    pub const MAIN: Self = Self(0);
    pub const SUB: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::MAIN, Self::SUB];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::MAIN => Some("MAIN"),
            Self::SUB => Some("SUB"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2FoodMatType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2FoodMatType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2FoodMatType {
    type Output = enum__Torappu_SandboxV2FoodMatType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2FoodMatType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2FoodMatType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2FoodMatType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_FOOD_ATTRIBUTE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_FOOD_ATTRIBUTE: i32 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_FOOD_ATTRIBUTE:
    [enum__Torappu_SandboxV2FoodAttribute; 8] = [
    enum__Torappu_SandboxV2FoodAttribute::NONE,
    enum__Torappu_SandboxV2FoodAttribute::SURVIVE,
    enum__Torappu_SandboxV2FoodAttribute::COST,
    enum__Torappu_SandboxV2FoodAttribute::ATTACK,
    enum__Torappu_SandboxV2FoodAttribute::COOLDOWN,
    enum__Torappu_SandboxV2FoodAttribute::SKILL_POINT,
    enum__Torappu_SandboxV2FoodAttribute::SPECIAL,
    enum__Torappu_SandboxV2FoodAttribute::ENHANCED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2FoodAttribute(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2FoodAttribute {
    pub const NONE: Self = Self(0);
    pub const SURVIVE: Self = Self(1);
    pub const COST: Self = Self(2);
    pub const ATTACK: Self = Self(3);
    pub const COOLDOWN: Self = Self(4);
    pub const SKILL_POINT: Self = Self(5);
    pub const SPECIAL: Self = Self(6);
    pub const ENHANCED: Self = Self(7);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 7;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::SURVIVE,
        Self::COST,
        Self::ATTACK,
        Self::COOLDOWN,
        Self::SKILL_POINT,
        Self::SPECIAL,
        Self::ENHANCED,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::SURVIVE => Some("SURVIVE"),
            Self::COST => Some("COST"),
            Self::ATTACK => Some("ATTACK"),
            Self::COOLDOWN => Some("COOLDOWN"),
            Self::SKILL_POINT => Some("SKILL_POINT"),
            Self::SPECIAL => Some("SPECIAL"),
            Self::ENHANCED => Some("ENHANCED"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2FoodAttribute {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2FoodAttribute {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2FoodAttribute {
    type Output = enum__Torappu_SandboxV2FoodAttribute;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2FoodAttribute {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2FoodAttribute {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2FoodAttribute {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_FOOD_VARIANT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_FOOD_VARIANT_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_FOOD_VARIANT_TYPE:
    [enum__Torappu_SandboxV2FoodVariantType; 4] = [
    enum__Torappu_SandboxV2FoodVariantType::NONE,
    enum__Torappu_SandboxV2FoodVariantType::ALPHA,
    enum__Torappu_SandboxV2FoodVariantType::BETA,
    enum__Torappu_SandboxV2FoodVariantType::GAMMA,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2FoodVariantType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2FoodVariantType {
    pub const NONE: Self = Self(0);
    pub const ALPHA: Self = Self(1);
    pub const BETA: Self = Self(2);
    pub const GAMMA: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::ALPHA, Self::BETA, Self::GAMMA];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ALPHA => Some("ALPHA"),
            Self::BETA => Some("BETA"),
            Self::GAMMA => Some("GAMMA"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2FoodVariantType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2FoodVariantType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2FoodVariantType {
    type Output = enum__Torappu_SandboxV2FoodVariantType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2FoodVariantType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2FoodVariantType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2FoodVariantType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_NODE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_NODE_TYPE: i32 = 17;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_NODE_TYPE: [enum__Torappu_SandboxV2NodeType; 18] = [
    enum__Torappu_SandboxV2NodeType::NONE,
    enum__Torappu_SandboxV2NodeType::HOME,
    enum__Torappu_SandboxV2NodeType::HOME_OUTPOST,
    enum__Torappu_SandboxV2NodeType::BATTLE,
    enum__Torappu_SandboxV2NodeType::NEST,
    enum__Torappu_SandboxV2NodeType::COLLECT,
    enum__Torappu_SandboxV2NodeType::HUNT,
    enum__Torappu_SandboxV2NodeType::CAVE,
    enum__Torappu_SandboxV2NodeType::MINE,
    enum__Torappu_SandboxV2NodeType::ENCOUNTER,
    enum__Torappu_SandboxV2NodeType::EXPEDITION,
    enum__Torappu_SandboxV2NodeType::SHOP,
    enum__Torappu_SandboxV2NodeType::GATE,
    enum__Torappu_SandboxV2NodeType::MARKET,
    enum__Torappu_SandboxV2NodeType::HOME_PORTABLE,
    enum__Torappu_SandboxV2NodeType::HOME_PORTABLE_RIFT,
    enum__Torappu_SandboxV2NodeType::SELECTION,
    enum__Torappu_SandboxV2NodeType::RACING,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2NodeType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2NodeType {
    pub const NONE: Self = Self(0);
    pub const HOME: Self = Self(1);
    pub const HOME_OUTPOST: Self = Self(2);
    pub const BATTLE: Self = Self(3);
    pub const NEST: Self = Self(4);
    pub const COLLECT: Self = Self(5);
    pub const HUNT: Self = Self(6);
    pub const CAVE: Self = Self(7);
    pub const MINE: Self = Self(8);
    pub const ENCOUNTER: Self = Self(9);
    pub const EXPEDITION: Self = Self(10);
    pub const SHOP: Self = Self(11);
    pub const GATE: Self = Self(12);
    pub const MARKET: Self = Self(13);
    pub const HOME_PORTABLE: Self = Self(14);
    pub const HOME_PORTABLE_RIFT: Self = Self(15);
    pub const SELECTION: Self = Self(16);
    pub const RACING: Self = Self(17);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 17;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::HOME,
        Self::HOME_OUTPOST,
        Self::BATTLE,
        Self::NEST,
        Self::COLLECT,
        Self::HUNT,
        Self::CAVE,
        Self::MINE,
        Self::ENCOUNTER,
        Self::EXPEDITION,
        Self::SHOP,
        Self::GATE,
        Self::MARKET,
        Self::HOME_PORTABLE,
        Self::HOME_PORTABLE_RIFT,
        Self::SELECTION,
        Self::RACING,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::HOME => Some("HOME"),
            Self::HOME_OUTPOST => Some("HOME_OUTPOST"),
            Self::BATTLE => Some("BATTLE"),
            Self::NEST => Some("NEST"),
            Self::COLLECT => Some("COLLECT"),
            Self::HUNT => Some("HUNT"),
            Self::CAVE => Some("CAVE"),
            Self::MINE => Some("MINE"),
            Self::ENCOUNTER => Some("ENCOUNTER"),
            Self::EXPEDITION => Some("EXPEDITION"),
            Self::SHOP => Some("SHOP"),
            Self::GATE => Some("GATE"),
            Self::MARKET => Some("MARKET"),
            Self::HOME_PORTABLE => Some("HOME_PORTABLE"),
            Self::HOME_PORTABLE_RIFT => Some("HOME_PORTABLE_RIFT"),
            Self::SELECTION => Some("SELECTION"),
            Self::RACING => Some("RACING"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2NodeType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2NodeType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2NodeType {
    type Output = enum__Torappu_SandboxV2NodeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2NodeType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2NodeType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2NodeType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_WEATHER_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_WEATHER_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_WEATHER_TYPE: [enum__Torappu_SandboxV2WeatherType;
    4] = [
    enum__Torappu_SandboxV2WeatherType::NORMAL,
    enum__Torappu_SandboxV2WeatherType::RAINFOREST,
    enum__Torappu_SandboxV2WeatherType::VOLCANO,
    enum__Torappu_SandboxV2WeatherType::DESERT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2WeatherType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2WeatherType {
    pub const NORMAL: Self = Self(0);
    pub const RAINFOREST: Self = Self(1);
    pub const VOLCANO: Self = Self(2);
    pub const DESERT: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NORMAL, Self::RAINFOREST, Self::VOLCANO, Self::DESERT];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NORMAL => Some("NORMAL"),
            Self::RAINFOREST => Some("RAINFOREST"),
            Self::VOLCANO => Some("VOLCANO"),
            Self::DESERT => Some("DESERT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2WeatherType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2WeatherType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2WeatherType {
    type Output = enum__Torappu_SandboxV2WeatherType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2WeatherType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2WeatherType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2WeatherType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_ENEMY_RUSH_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_ENEMY_RUSH_TYPE: i32 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_ENEMY_RUSH_TYPE:
    [enum__Torappu_SandboxV2EnemyRushType; 8] = [
    enum__Torappu_SandboxV2EnemyRushType::NORMAL,
    enum__Torappu_SandboxV2EnemyRushType::ELITE,
    enum__Torappu_SandboxV2EnemyRushType::BOSS,
    enum__Torappu_SandboxV2EnemyRushType::BANDIT,
    enum__Torappu_SandboxV2EnemyRushType::RALLY,
    enum__Torappu_SandboxV2EnemyRushType::THIEF,
    enum__Torappu_SandboxV2EnemyRushType::MESSENGER,
    enum__Torappu_SandboxV2EnemyRushType::INSECT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2EnemyRushType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2EnemyRushType {
    pub const NORMAL: Self = Self(0);
    pub const ELITE: Self = Self(1);
    pub const BOSS: Self = Self(2);
    pub const BANDIT: Self = Self(3);
    pub const RALLY: Self = Self(4);
    pub const THIEF: Self = Self(5);
    pub const MESSENGER: Self = Self(6);
    pub const INSECT: Self = Self(7);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 7;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NORMAL,
        Self::ELITE,
        Self::BOSS,
        Self::BANDIT,
        Self::RALLY,
        Self::THIEF,
        Self::MESSENGER,
        Self::INSECT,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NORMAL => Some("NORMAL"),
            Self::ELITE => Some("ELITE"),
            Self::BOSS => Some("BOSS"),
            Self::BANDIT => Some("BANDIT"),
            Self::RALLY => Some("RALLY"),
            Self::THIEF => Some("THIEF"),
            Self::MESSENGER => Some("MESSENGER"),
            Self::INSECT => Some("INSECT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2EnemyRushType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2EnemyRushType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2EnemyRushType {
    type Output = enum__Torappu_SandboxV2EnemyRushType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2EnemyRushType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2EnemyRushType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2EnemyRushType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_SEASON_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_SEASON_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_SEASON_TYPE: [enum__Torappu_SandboxV2SeasonType;
    4] = [
    enum__Torappu_SandboxV2SeasonType::NONE,
    enum__Torappu_SandboxV2SeasonType::DRY,
    enum__Torappu_SandboxV2SeasonType::RAINY,
    enum__Torappu_SandboxV2SeasonType::CHALLENGE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2SeasonType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2SeasonType {
    pub const NONE: Self = Self(0);
    pub const DRY: Self = Self(1);
    pub const RAINY: Self = Self(2);
    pub const CHALLENGE: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::DRY, Self::RAINY, Self::CHALLENGE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::DRY => Some("DRY"),
            Self::RAINY => Some("RAINY"),
            Self::CHALLENGE => Some("CHALLENGE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2SeasonType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2SeasonType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2SeasonType {
    type Output = enum__Torappu_SandboxV2SeasonType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2SeasonType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2SeasonType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2SeasonType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ITEM_TYPE: i32 = 90;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ITEM_TYPE: [enum__Torappu_ItemType; 91] = [
    enum__Torappu_ItemType::NONE,
    enum__Torappu_ItemType::CHAR,
    enum__Torappu_ItemType::CARD_EXP,
    enum__Torappu_ItemType::MATERIAL,
    enum__Torappu_ItemType::GOLD,
    enum__Torappu_ItemType::EXP_PLAYER,
    enum__Torappu_ItemType::TKT_TRY,
    enum__Torappu_ItemType::TKT_RECRUIT,
    enum__Torappu_ItemType::TKT_INST_FIN,
    enum__Torappu_ItemType::TKT_GACHA,
    enum__Torappu_ItemType::ACTIVITY_COIN,
    enum__Torappu_ItemType::DIAMOND,
    enum__Torappu_ItemType::DIAMOND_SHD,
    enum__Torappu_ItemType::HGG_SHD,
    enum__Torappu_ItemType::LGG_SHD,
    enum__Torappu_ItemType::FURN,
    enum__Torappu_ItemType::AP_GAMEPLAY,
    enum__Torappu_ItemType::AP_BASE,
    enum__Torappu_ItemType::SOCIAL_PT,
    enum__Torappu_ItemType::CHAR_SKIN,
    enum__Torappu_ItemType::TKT_GACHA_10,
    enum__Torappu_ItemType::TKT_GACHA_PRSV,
    enum__Torappu_ItemType::AP_ITEM,
    enum__Torappu_ItemType::AP_SUPPLY,
    enum__Torappu_ItemType::RENAMING_CARD,
    enum__Torappu_ItemType::RENAMING_CARD_2,
    enum__Torappu_ItemType::ET_STAGE,
    enum__Torappu_ItemType::ACTIVITY_ITEM,
    enum__Torappu_ItemType::VOUCHER_PICK,
    enum__Torappu_ItemType::VOUCHER_CGACHA,
    enum__Torappu_ItemType::VOUCHER_MGACHA,
    enum__Torappu_ItemType::CRS_SHOP_COIN,
    enum__Torappu_ItemType::CRS_RUNE_COIN,
    enum__Torappu_ItemType::LMTGS_COIN,
    enum__Torappu_ItemType::EPGS_COIN,
    enum__Torappu_ItemType::LIMITED_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_FREE_GACHA,
    enum__Torappu_ItemType::REP_COIN,
    enum__Torappu_ItemType::ROGUELIKE,
    enum__Torappu_ItemType::LINKAGE_TKT_GACHA_10,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_4,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_5,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_6,
    enum__Torappu_ItemType::VOUCHER_SKIN,
    enum__Torappu_ItemType::RETRO_COIN,
    enum__Torappu_ItemType::PLAYER_AVATAR,
    enum__Torappu_ItemType::UNI_COLLECTION,
    enum__Torappu_ItemType::VOUCHER_FULL_POTENTIAL,
    enum__Torappu_ItemType::RL_COIN,
    enum__Torappu_ItemType::RETURN_CREDIT,
    enum__Torappu_ItemType::MEDAL,
    enum__Torappu_ItemType::CHARM,
    enum__Torappu_ItemType::HOME_BACKGROUND,
    enum__Torappu_ItemType::EXTERMINATION_AGENT,
    enum__Torappu_ItemType::OPTIONAL_VOUCHER_PICK,
    enum__Torappu_ItemType::ACT_CART_COMPONENT,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_4,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_4,
    enum__Torappu_ItemType::ACTIVITY_POTENTIAL,
    enum__Torappu_ItemType::ITEM_PACK,
    enum__Torappu_ItemType::SANDBOX,
    enum__Torappu_ItemType::FAVOR_ADD_ITEM,
    enum__Torappu_ItemType::CLASSIC_SHD,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_BUFF,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_5,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_6,
    enum__Torappu_ItemType::RETURN_PROGRESS,
    enum__Torappu_ItemType::NEW_PROGRESS,
    enum__Torappu_ItemType::MCARD_VOUCHER,
    enum__Torappu_ItemType::MATERIAL_ISSUE_VOUCHER,
    enum__Torappu_ItemType::CRS_SHOP_COIN_V2,
    enum__Torappu_ItemType::HOME_THEME,
    enum__Torappu_ItemType::SANDBOX_PERM,
    enum__Torappu_ItemType::SANDBOX_TOKEN,
    enum__Torappu_ItemType::TEMPLATE_TRAP,
    enum__Torappu_ItemType::NAME_CARD_SKIN,
    enum__Torappu_ItemType::EMOTICON_SET,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA_10,
    enum__Torappu_ItemType::SO_CHAR_EXP,
    enum__Torappu_ItemType::GIFTPACKAGE_TKT,
    enum__Torappu_ItemType::VOUCHER_SKIN_V2,
    enum__Torappu_ItemType::RANDOM_VOUCHER_SKIN,
    enum__Torappu_ItemType::ACT1VHALFIDLE_ITEM,
    enum__Torappu_ItemType::PLOT_ITEM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ItemType {
    pub const NONE: Self = Self(0);
    pub const CHAR: Self = Self(1);
    pub const CARD_EXP: Self = Self(2);
    pub const MATERIAL: Self = Self(3);
    pub const GOLD: Self = Self(4);
    pub const EXP_PLAYER: Self = Self(5);
    pub const TKT_TRY: Self = Self(6);
    pub const TKT_RECRUIT: Self = Self(7);
    pub const TKT_INST_FIN: Self = Self(8);
    pub const TKT_GACHA: Self = Self(9);
    pub const ACTIVITY_COIN: Self = Self(10);
    pub const DIAMOND: Self = Self(11);
    pub const DIAMOND_SHD: Self = Self(12);
    pub const HGG_SHD: Self = Self(13);
    pub const LGG_SHD: Self = Self(14);
    pub const FURN: Self = Self(15);
    pub const AP_GAMEPLAY: Self = Self(16);
    pub const AP_BASE: Self = Self(17);
    pub const SOCIAL_PT: Self = Self(18);
    pub const CHAR_SKIN: Self = Self(19);
    pub const TKT_GACHA_10: Self = Self(20);
    pub const TKT_GACHA_PRSV: Self = Self(21);
    pub const AP_ITEM: Self = Self(22);
    pub const AP_SUPPLY: Self = Self(23);
    pub const RENAMING_CARD: Self = Self(24);
    pub const RENAMING_CARD_2: Self = Self(25);
    pub const ET_STAGE: Self = Self(26);
    pub const ACTIVITY_ITEM: Self = Self(27);
    pub const VOUCHER_PICK: Self = Self(28);
    pub const VOUCHER_CGACHA: Self = Self(29);
    pub const VOUCHER_MGACHA: Self = Self(30);
    pub const CRS_SHOP_COIN: Self = Self(31);
    pub const CRS_RUNE_COIN: Self = Self(32);
    pub const LMTGS_COIN: Self = Self(33);
    pub const EPGS_COIN: Self = Self(34);
    pub const LIMITED_TKT_GACHA_10: Self = Self(35);
    pub const LIMITED_FREE_GACHA: Self = Self(36);
    pub const REP_COIN: Self = Self(37);
    pub const ROGUELIKE: Self = Self(38);
    pub const LINKAGE_TKT_GACHA_10: Self = Self(39);
    pub const VOUCHER_ELITE_II_4: Self = Self(40);
    pub const VOUCHER_ELITE_II_5: Self = Self(41);
    pub const VOUCHER_ELITE_II_6: Self = Self(42);
    pub const VOUCHER_SKIN: Self = Self(43);
    pub const RETRO_COIN: Self = Self(44);
    pub const PLAYER_AVATAR: Self = Self(45);
    pub const UNI_COLLECTION: Self = Self(46);
    pub const VOUCHER_FULL_POTENTIAL: Self = Self(47);
    pub const RL_COIN: Self = Self(48);
    pub const RETURN_CREDIT: Self = Self(49);
    pub const MEDAL: Self = Self(50);
    pub const CHARM: Self = Self(51);
    pub const HOME_BACKGROUND: Self = Self(52);
    pub const EXTERMINATION_AGENT: Self = Self(53);
    pub const OPTIONAL_VOUCHER_PICK: Self = Self(54);
    pub const ACT_CART_COMPONENT: Self = Self(55);
    pub const VOUCHER_LEVELMAX_6: Self = Self(56);
    pub const VOUCHER_LEVELMAX_5: Self = Self(57);
    pub const VOUCHER_LEVELMAX_4: Self = Self(58);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_6: Self = Self(59);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_5: Self = Self(60);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_4: Self = Self(61);
    pub const ACTIVITY_POTENTIAL: Self = Self(62);
    pub const ITEM_PACK: Self = Self(63);
    pub const SANDBOX: Self = Self(64);
    pub const FAVOR_ADD_ITEM: Self = Self(65);
    pub const CLASSIC_SHD: Self = Self(66);
    pub const CLASSIC_TKT_GACHA: Self = Self(67);
    pub const CLASSIC_TKT_GACHA_10: Self = Self(68);
    pub const LIMITED_BUFF: Self = Self(69);
    pub const CLASSIC_FES_PICK_TIER_5: Self = Self(70);
    pub const CLASSIC_FES_PICK_TIER_6: Self = Self(71);
    pub const RETURN_PROGRESS: Self = Self(72);
    pub const NEW_PROGRESS: Self = Self(73);
    pub const MCARD_VOUCHER: Self = Self(74);
    pub const MATERIAL_ISSUE_VOUCHER: Self = Self(75);
    pub const CRS_SHOP_COIN_V2: Self = Self(76);
    pub const HOME_THEME: Self = Self(77);
    pub const SANDBOX_PERM: Self = Self(78);
    pub const SANDBOX_TOKEN: Self = Self(79);
    pub const TEMPLATE_TRAP: Self = Self(80);
    pub const NAME_CARD_SKIN: Self = Self(81);
    pub const EMOTICON_SET: Self = Self(82);
    pub const EXCLUSIVE_TKT_GACHA: Self = Self(83);
    pub const EXCLUSIVE_TKT_GACHA_10: Self = Self(84);
    pub const SO_CHAR_EXP: Self = Self(85);
    pub const GIFTPACKAGE_TKT: Self = Self(86);
    pub const VOUCHER_SKIN_V2: Self = Self(87);
    pub const RANDOM_VOUCHER_SKIN: Self = Self(88);
    pub const ACT1VHALFIDLE_ITEM: Self = Self(89);
    pub const PLOT_ITEM: Self = Self(90);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 90;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::CHAR,
        Self::CARD_EXP,
        Self::MATERIAL,
        Self::GOLD,
        Self::EXP_PLAYER,
        Self::TKT_TRY,
        Self::TKT_RECRUIT,
        Self::TKT_INST_FIN,
        Self::TKT_GACHA,
        Self::ACTIVITY_COIN,
        Self::DIAMOND,
        Self::DIAMOND_SHD,
        Self::HGG_SHD,
        Self::LGG_SHD,
        Self::FURN,
        Self::AP_GAMEPLAY,
        Self::AP_BASE,
        Self::SOCIAL_PT,
        Self::CHAR_SKIN,
        Self::TKT_GACHA_10,
        Self::TKT_GACHA_PRSV,
        Self::AP_ITEM,
        Self::AP_SUPPLY,
        Self::RENAMING_CARD,
        Self::RENAMING_CARD_2,
        Self::ET_STAGE,
        Self::ACTIVITY_ITEM,
        Self::VOUCHER_PICK,
        Self::VOUCHER_CGACHA,
        Self::VOUCHER_MGACHA,
        Self::CRS_SHOP_COIN,
        Self::CRS_RUNE_COIN,
        Self::LMTGS_COIN,
        Self::EPGS_COIN,
        Self::LIMITED_TKT_GACHA_10,
        Self::LIMITED_FREE_GACHA,
        Self::REP_COIN,
        Self::ROGUELIKE,
        Self::LINKAGE_TKT_GACHA_10,
        Self::VOUCHER_ELITE_II_4,
        Self::VOUCHER_ELITE_II_5,
        Self::VOUCHER_ELITE_II_6,
        Self::VOUCHER_SKIN,
        Self::RETRO_COIN,
        Self::PLAYER_AVATAR,
        Self::UNI_COLLECTION,
        Self::VOUCHER_FULL_POTENTIAL,
        Self::RL_COIN,
        Self::RETURN_CREDIT,
        Self::MEDAL,
        Self::CHARM,
        Self::HOME_BACKGROUND,
        Self::EXTERMINATION_AGENT,
        Self::OPTIONAL_VOUCHER_PICK,
        Self::ACT_CART_COMPONENT,
        Self::VOUCHER_LEVELMAX_6,
        Self::VOUCHER_LEVELMAX_5,
        Self::VOUCHER_LEVELMAX_4,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_6,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_5,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_4,
        Self::ACTIVITY_POTENTIAL,
        Self::ITEM_PACK,
        Self::SANDBOX,
        Self::FAVOR_ADD_ITEM,
        Self::CLASSIC_SHD,
        Self::CLASSIC_TKT_GACHA,
        Self::CLASSIC_TKT_GACHA_10,
        Self::LIMITED_BUFF,
        Self::CLASSIC_FES_PICK_TIER_5,
        Self::CLASSIC_FES_PICK_TIER_6,
        Self::RETURN_PROGRESS,
        Self::NEW_PROGRESS,
        Self::MCARD_VOUCHER,
        Self::MATERIAL_ISSUE_VOUCHER,
        Self::CRS_SHOP_COIN_V2,
        Self::HOME_THEME,
        Self::SANDBOX_PERM,
        Self::SANDBOX_TOKEN,
        Self::TEMPLATE_TRAP,
        Self::NAME_CARD_SKIN,
        Self::EMOTICON_SET,
        Self::EXCLUSIVE_TKT_GACHA,
        Self::EXCLUSIVE_TKT_GACHA_10,
        Self::SO_CHAR_EXP,
        Self::GIFTPACKAGE_TKT,
        Self::VOUCHER_SKIN_V2,
        Self::RANDOM_VOUCHER_SKIN,
        Self::ACT1VHALFIDLE_ITEM,
        Self::PLOT_ITEM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::CHAR => Some("CHAR"),
            Self::CARD_EXP => Some("CARD_EXP"),
            Self::MATERIAL => Some("MATERIAL"),
            Self::GOLD => Some("GOLD"),
            Self::EXP_PLAYER => Some("EXP_PLAYER"),
            Self::TKT_TRY => Some("TKT_TRY"),
            Self::TKT_RECRUIT => Some("TKT_RECRUIT"),
            Self::TKT_INST_FIN => Some("TKT_INST_FIN"),
            Self::TKT_GACHA => Some("TKT_GACHA"),
            Self::ACTIVITY_COIN => Some("ACTIVITY_COIN"),
            Self::DIAMOND => Some("DIAMOND"),
            Self::DIAMOND_SHD => Some("DIAMOND_SHD"),
            Self::HGG_SHD => Some("HGG_SHD"),
            Self::LGG_SHD => Some("LGG_SHD"),
            Self::FURN => Some("FURN"),
            Self::AP_GAMEPLAY => Some("AP_GAMEPLAY"),
            Self::AP_BASE => Some("AP_BASE"),
            Self::SOCIAL_PT => Some("SOCIAL_PT"),
            Self::CHAR_SKIN => Some("CHAR_SKIN"),
            Self::TKT_GACHA_10 => Some("TKT_GACHA_10"),
            Self::TKT_GACHA_PRSV => Some("TKT_GACHA_PRSV"),
            Self::AP_ITEM => Some("AP_ITEM"),
            Self::AP_SUPPLY => Some("AP_SUPPLY"),
            Self::RENAMING_CARD => Some("RENAMING_CARD"),
            Self::RENAMING_CARD_2 => Some("RENAMING_CARD_2"),
            Self::ET_STAGE => Some("ET_STAGE"),
            Self::ACTIVITY_ITEM => Some("ACTIVITY_ITEM"),
            Self::VOUCHER_PICK => Some("VOUCHER_PICK"),
            Self::VOUCHER_CGACHA => Some("VOUCHER_CGACHA"),
            Self::VOUCHER_MGACHA => Some("VOUCHER_MGACHA"),
            Self::CRS_SHOP_COIN => Some("CRS_SHOP_COIN"),
            Self::CRS_RUNE_COIN => Some("CRS_RUNE_COIN"),
            Self::LMTGS_COIN => Some("LMTGS_COIN"),
            Self::EPGS_COIN => Some("EPGS_COIN"),
            Self::LIMITED_TKT_GACHA_10 => Some("LIMITED_TKT_GACHA_10"),
            Self::LIMITED_FREE_GACHA => Some("LIMITED_FREE_GACHA"),
            Self::REP_COIN => Some("REP_COIN"),
            Self::ROGUELIKE => Some("ROGUELIKE"),
            Self::LINKAGE_TKT_GACHA_10 => Some("LINKAGE_TKT_GACHA_10"),
            Self::VOUCHER_ELITE_II_4 => Some("VOUCHER_ELITE_II_4"),
            Self::VOUCHER_ELITE_II_5 => Some("VOUCHER_ELITE_II_5"),
            Self::VOUCHER_ELITE_II_6 => Some("VOUCHER_ELITE_II_6"),
            Self::VOUCHER_SKIN => Some("VOUCHER_SKIN"),
            Self::RETRO_COIN => Some("RETRO_COIN"),
            Self::PLAYER_AVATAR => Some("PLAYER_AVATAR"),
            Self::UNI_COLLECTION => Some("UNI_COLLECTION"),
            Self::VOUCHER_FULL_POTENTIAL => Some("VOUCHER_FULL_POTENTIAL"),
            Self::RL_COIN => Some("RL_COIN"),
            Self::RETURN_CREDIT => Some("RETURN_CREDIT"),
            Self::MEDAL => Some("MEDAL"),
            Self::CHARM => Some("CHARM"),
            Self::HOME_BACKGROUND => Some("HOME_BACKGROUND"),
            Self::EXTERMINATION_AGENT => Some("EXTERMINATION_AGENT"),
            Self::OPTIONAL_VOUCHER_PICK => Some("OPTIONAL_VOUCHER_PICK"),
            Self::ACT_CART_COMPONENT => Some("ACT_CART_COMPONENT"),
            Self::VOUCHER_LEVELMAX_6 => Some("VOUCHER_LEVELMAX_6"),
            Self::VOUCHER_LEVELMAX_5 => Some("VOUCHER_LEVELMAX_5"),
            Self::VOUCHER_LEVELMAX_4 => Some("VOUCHER_LEVELMAX_4"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_6 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_6"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_5 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_5"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_4 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_4"),
            Self::ACTIVITY_POTENTIAL => Some("ACTIVITY_POTENTIAL"),
            Self::ITEM_PACK => Some("ITEM_PACK"),
            Self::SANDBOX => Some("SANDBOX"),
            Self::FAVOR_ADD_ITEM => Some("FAVOR_ADD_ITEM"),
            Self::CLASSIC_SHD => Some("CLASSIC_SHD"),
            Self::CLASSIC_TKT_GACHA => Some("CLASSIC_TKT_GACHA"),
            Self::CLASSIC_TKT_GACHA_10 => Some("CLASSIC_TKT_GACHA_10"),
            Self::LIMITED_BUFF => Some("LIMITED_BUFF"),
            Self::CLASSIC_FES_PICK_TIER_5 => Some("CLASSIC_FES_PICK_TIER_5"),
            Self::CLASSIC_FES_PICK_TIER_6 => Some("CLASSIC_FES_PICK_TIER_6"),
            Self::RETURN_PROGRESS => Some("RETURN_PROGRESS"),
            Self::NEW_PROGRESS => Some("NEW_PROGRESS"),
            Self::MCARD_VOUCHER => Some("MCARD_VOUCHER"),
            Self::MATERIAL_ISSUE_VOUCHER => Some("MATERIAL_ISSUE_VOUCHER"),
            Self::CRS_SHOP_COIN_V2 => Some("CRS_SHOP_COIN_V2"),
            Self::HOME_THEME => Some("HOME_THEME"),
            Self::SANDBOX_PERM => Some("SANDBOX_PERM"),
            Self::SANDBOX_TOKEN => Some("SANDBOX_TOKEN"),
            Self::TEMPLATE_TRAP => Some("TEMPLATE_TRAP"),
            Self::NAME_CARD_SKIN => Some("NAME_CARD_SKIN"),
            Self::EMOTICON_SET => Some("EMOTICON_SET"),
            Self::EXCLUSIVE_TKT_GACHA => Some("EXCLUSIVE_TKT_GACHA"),
            Self::EXCLUSIVE_TKT_GACHA_10 => Some("EXCLUSIVE_TKT_GACHA_10"),
            Self::SO_CHAR_EXP => Some("SO_CHAR_EXP"),
            Self::GIFTPACKAGE_TKT => Some("GIFTPACKAGE_TKT"),
            Self::VOUCHER_SKIN_V2 => Some("VOUCHER_SKIN_V2"),
            Self::RANDOM_VOUCHER_SKIN => Some("RANDOM_VOUCHER_SKIN"),
            Self::ACT1VHALFIDLE_ITEM => Some("ACT1VHALFIDLE_ITEM"),
            Self::PLOT_ITEM => Some("PLOT_ITEM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ItemType {
    type Output = enum__Torappu_ItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_TIP_DATA_CATEGORY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_TIP_DATA_CATEGORY: i32 = 31;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_TIP_DATA_CATEGORY: [enum__Torappu_TipData_Category; 7] = [
    enum__Torappu_TipData_Category::NONE,
    enum__Torappu_TipData_Category::BATTLE,
    enum__Torappu_TipData_Category::UI,
    enum__Torappu_TipData_Category::BUILDING,
    enum__Torappu_TipData_Category::GACHA,
    enum__Torappu_TipData_Category::MISC,
    enum__Torappu_TipData_Category::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_TipData_Category(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_TipData_Category {
    pub const NONE: Self = Self(0);
    pub const BATTLE: Self = Self(1);
    pub const UI: Self = Self(2);
    pub const BUILDING: Self = Self(4);
    pub const GACHA: Self = Self(8);
    pub const MISC: Self = Self(16);
    pub const ALL: Self = Self(31);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 31;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::BATTLE,
        Self::UI,
        Self::BUILDING,
        Self::GACHA,
        Self::MISC,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::BATTLE => Some("BATTLE"),
            Self::UI => Some("UI"),
            Self::BUILDING => Some("BUILDING"),
            Self::GACHA => Some("GACHA"),
            Self::MISC => Some("MISC"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_TipData_Category {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_TipData_Category {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_TipData_Category {
    type Output = enum__Torappu_TipData_Category;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_TipData_Category {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_TipData_Category {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_TipData_Category {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_PROFESSION_CATEGORY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_PROFESSION_CATEGORY: i32 = 512;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_PROFESSION_CATEGORY: [enum__Torappu_ProfessionCategory; 11] = [
    enum__Torappu_ProfessionCategory::NONE,
    enum__Torappu_ProfessionCategory::WARRIOR,
    enum__Torappu_ProfessionCategory::SNIPER,
    enum__Torappu_ProfessionCategory::TANK,
    enum__Torappu_ProfessionCategory::MEDIC,
    enum__Torappu_ProfessionCategory::SUPPORT,
    enum__Torappu_ProfessionCategory::CASTER,
    enum__Torappu_ProfessionCategory::SPECIAL,
    enum__Torappu_ProfessionCategory::TOKEN,
    enum__Torappu_ProfessionCategory::TRAP,
    enum__Torappu_ProfessionCategory::PIONEER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ProfessionCategory(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ProfessionCategory {
    pub const NONE: Self = Self(0);
    pub const WARRIOR: Self = Self(1);
    pub const SNIPER: Self = Self(2);
    pub const TANK: Self = Self(4);
    pub const MEDIC: Self = Self(8);
    pub const SUPPORT: Self = Self(16);
    pub const CASTER: Self = Self(32);
    pub const SPECIAL: Self = Self(64);
    pub const TOKEN: Self = Self(128);
    pub const TRAP: Self = Self(256);
    pub const PIONEER: Self = Self(512);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 512;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::WARRIOR,
        Self::SNIPER,
        Self::TANK,
        Self::MEDIC,
        Self::SUPPORT,
        Self::CASTER,
        Self::SPECIAL,
        Self::TOKEN,
        Self::TRAP,
        Self::PIONEER,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::WARRIOR => Some("WARRIOR"),
            Self::SNIPER => Some("SNIPER"),
            Self::TANK => Some("TANK"),
            Self::MEDIC => Some("MEDIC"),
            Self::SUPPORT => Some("SUPPORT"),
            Self::CASTER => Some("CASTER"),
            Self::SPECIAL => Some("SPECIAL"),
            Self::TOKEN => Some("TOKEN"),
            Self::TRAP => Some("TRAP"),
            Self::PIONEER => Some("PIONEER"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ProfessionCategory {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ProfessionCategory {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ProfessionCategory {
    type Output = enum__Torappu_ProfessionCategory;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ProfessionCategory {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ProfessionCategory {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ProfessionCategory {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUILDABLE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUILDABLE_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUILDABLE_TYPE: [enum__Torappu_BuildableType; 4] = [
    enum__Torappu_BuildableType::NONE,
    enum__Torappu_BuildableType::MELEE,
    enum__Torappu_BuildableType::RANGED,
    enum__Torappu_BuildableType::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuildableType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuildableType {
    pub const NONE: Self = Self(0);
    pub const MELEE: Self = Self(1);
    pub const RANGED: Self = Self(2);
    pub const ALL: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::MELEE, Self::RANGED, Self::ALL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MELEE => Some("MELEE"),
            Self::RANGED => Some("RANGED"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuildableType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuildableType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuildableType {
    type Output = enum__Torappu_BuildableType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuildableType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuildableType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuildableType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_PLAYER_SIDE_MASK: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_PLAYER_SIDE_MASK: u8 = 255;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_PLAYER_SIDE_MASK: [enum__Torappu_PlayerSideMask; 4] = [
    enum__Torappu_PlayerSideMask::ALL,
    enum__Torappu_PlayerSideMask::SIDE_A,
    enum__Torappu_PlayerSideMask::SIDE_B,
    enum__Torappu_PlayerSideMask::NONE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_PlayerSideMask(pub u8);
#[allow(non_upper_case_globals)]
impl enum__Torappu_PlayerSideMask {
    pub const ALL: Self = Self(0);
    pub const SIDE_A: Self = Self(2);
    pub const SIDE_B: Self = Self(4);
    pub const NONE: Self = Self(255);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 255;
    pub const ENUM_VALUES: &'static [Self] = &[Self::ALL, Self::SIDE_A, Self::SIDE_B, Self::NONE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ALL => Some("ALL"),
            Self::SIDE_A => Some("SIDE_A"),
            Self::SIDE_B => Some("SIDE_B"),
            Self::NONE => Some("NONE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_PlayerSideMask {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_PlayerSideMask {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_PlayerSideMask {
    type Output = enum__Torappu_PlayerSideMask;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_PlayerSideMask {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_PlayerSideMask {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_PlayerSideMask {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BATTLE_SIDE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BATTLE_SIDE_TYPE: i32 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BATTLE_SIDE_TYPE: [enum__Torappu_Battle_SideType; 6] = [
    enum__Torappu_Battle_SideType::NONE,
    enum__Torappu_Battle_SideType::ALLY,
    enum__Torappu_Battle_SideType::ENEMY,
    enum__Torappu_Battle_SideType::BOTH_ALLY_AND_ENEMY,
    enum__Torappu_Battle_SideType::NEUTRAL,
    enum__Torappu_Battle_SideType::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_Battle_SideType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_Battle_SideType {
    pub const NONE: Self = Self(0);
    pub const ALLY: Self = Self(1);
    pub const ENEMY: Self = Self(2);
    pub const BOTH_ALLY_AND_ENEMY: Self = Self(3);
    pub const NEUTRAL: Self = Self(4);
    pub const ALL: Self = Self(7);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 7;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ALLY,
        Self::ENEMY,
        Self::BOTH_ALLY_AND_ENEMY,
        Self::NEUTRAL,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ALLY => Some("ALLY"),
            Self::ENEMY => Some("ENEMY"),
            Self::BOTH_ALLY_AND_ENEMY => Some("BOTH_ALLY_AND_ENEMY"),
            Self::NEUTRAL => Some("NEUTRAL"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_Battle_SideType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_Battle_SideType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_Battle_SideType {
    type Output = enum__Torappu_Battle_SideType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_Battle_SideType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_Battle_SideType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_Battle_SideType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_TILE_DATA_HEIGHT_TYPE_MASK: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_TILE_DATA_HEIGHT_TYPE_MASK: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_TILE_DATA_HEIGHT_TYPE_MASK:
    [enum__Torappu_TileData_HeightTypeMask; 4] = [
    enum__Torappu_TileData_HeightTypeMask::NONE,
    enum__Torappu_TileData_HeightTypeMask::LOWLAND,
    enum__Torappu_TileData_HeightTypeMask::HIGHLAND,
    enum__Torappu_TileData_HeightTypeMask::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_TileData_HeightTypeMask(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_TileData_HeightTypeMask {
    pub const NONE: Self = Self(0);
    pub const LOWLAND: Self = Self(1);
    pub const HIGHLAND: Self = Self(2);
    pub const ALL: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::LOWLAND, Self::HIGHLAND, Self::ALL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::LOWLAND => Some("LOWLAND"),
            Self::HIGHLAND => Some("HIGHLAND"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_TileData_HeightTypeMask {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_TileData_HeightTypeMask {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_TileData_HeightTypeMask {
    type Output = enum__Torappu_TileData_HeightTypeMask;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_TileData_HeightTypeMask {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_TileData_HeightTypeMask {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_TileData_HeightTypeMask {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_LEVEL_DATA_DIFFICULTY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_LEVEL_DATA_DIFFICULTY: i32 = 15;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_LEVEL_DATA_DIFFICULTY: [enum__Torappu_LevelData_Difficulty; 6] = [
    enum__Torappu_LevelData_Difficulty::NONE,
    enum__Torappu_LevelData_Difficulty::NORMAL,
    enum__Torappu_LevelData_Difficulty::FOUR_STAR,
    enum__Torappu_LevelData_Difficulty::EASY,
    enum__Torappu_LevelData_Difficulty::SIX_STAR,
    enum__Torappu_LevelData_Difficulty::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_LevelData_Difficulty(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_LevelData_Difficulty {
    pub const NONE: Self = Self(0);
    pub const NORMAL: Self = Self(1);
    pub const FOUR_STAR: Self = Self(2);
    pub const EASY: Self = Self(4);
    pub const SIX_STAR: Self = Self(8);
    pub const ALL: Self = Self(15);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 15;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::NORMAL,
        Self::FOUR_STAR,
        Self::EASY,
        Self::SIX_STAR,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::NORMAL => Some("NORMAL"),
            Self::FOUR_STAR => Some("FOUR_STAR"),
            Self::EASY => Some("EASY"),
            Self::SIX_STAR => Some("SIX_STAR"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_LevelData_Difficulty {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_LevelData_Difficulty {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_LevelData_Difficulty {
    type Output = enum__Torappu_LevelData_Difficulty;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_LevelData_Difficulty {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_LevelData_Difficulty {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_LevelData_Difficulty {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_QUEST_ROUTE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_QUEST_ROUTE_TYPE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_QUEST_ROUTE_TYPE:
    [enum__Torappu_SandboxV2QuestRouteType; 5] = [
    enum__Torappu_SandboxV2QuestRouteType::NONE,
    enum__Torappu_SandboxV2QuestRouteType::ENEMY_RUSH,
    enum__Torappu_SandboxV2QuestRouteType::EVENT,
    enum__Torappu_SandboxV2QuestRouteType::NODE,
    enum__Torappu_SandboxV2QuestRouteType::NPC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2QuestRouteType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2QuestRouteType {
    pub const NONE: Self = Self(0);
    pub const ENEMY_RUSH: Self = Self(1);
    pub const EVENT: Self = Self(2);
    pub const NODE: Self = Self(3);
    pub const NPC: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ENEMY_RUSH,
        Self::EVENT,
        Self::NODE,
        Self::NPC,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ENEMY_RUSH => Some("ENEMY_RUSH"),
            Self::EVENT => Some("EVENT"),
            Self::NODE => Some("NODE"),
            Self::NPC => Some("NPC"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2QuestRouteType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2QuestRouteType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2QuestRouteType {
    type Output = enum__Torappu_SandboxV2QuestRouteType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2QuestRouteType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2QuestRouteType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2QuestRouteType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_QUEST_LINE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_QUEST_LINE_TYPE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_QUEST_LINE_TYPE:
    [enum__Torappu_SandboxV2QuestLineType; 5] = [
    enum__Torappu_SandboxV2QuestLineType::NONE,
    enum__Torappu_SandboxV2QuestLineType::MAIN,
    enum__Torappu_SandboxV2QuestLineType::SIDE,
    enum__Torappu_SandboxV2QuestLineType::GUIDE,
    enum__Torappu_SandboxV2QuestLineType::TRAINING,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2QuestLineType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2QuestLineType {
    pub const NONE: Self = Self(0);
    pub const MAIN: Self = Self(1);
    pub const SIDE: Self = Self(2);
    pub const GUIDE: Self = Self(3);
    pub const TRAINING: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::MAIN,
        Self::SIDE,
        Self::GUIDE,
        Self::TRAINING,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MAIN => Some("MAIN"),
            Self::SIDE => Some("SIDE"),
            Self::GUIDE => Some("GUIDE"),
            Self::TRAINING => Some("TRAINING"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2QuestLineType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2QuestLineType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2QuestLineType {
    type Output = enum__Torappu_SandboxV2QuestLineType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2QuestLineType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2QuestLineType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2QuestLineType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_NPC_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_NPC_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_NPC_TYPE: [enum__Torappu_SandboxV2NpcType; 4] = [
    enum__Torappu_SandboxV2NpcType::NORMAL,
    enum__Torappu_SandboxV2NpcType::FIXED_RIFT,
    enum__Torappu_SandboxV2NpcType::RANDOM_RIFT,
    enum__Torappu_SandboxV2NpcType::PREY_RIFT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2NpcType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2NpcType {
    pub const NORMAL: Self = Self(0);
    pub const FIXED_RIFT: Self = Self(1);
    pub const RANDOM_RIFT: Self = Self(2);
    pub const PREY_RIFT: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NORMAL,
        Self::FIXED_RIFT,
        Self::RANDOM_RIFT,
        Self::PREY_RIFT,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NORMAL => Some("NORMAL"),
            Self::FIXED_RIFT => Some("FIXED_RIFT"),
            Self::RANDOM_RIFT => Some("RANDOM_RIFT"),
            Self::PREY_RIFT => Some("PREY_RIFT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2NpcType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2NpcType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2NpcType {
    type Output = enum__Torappu_SandboxV2NpcType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2NpcType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2NpcType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2NpcType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BATTLE_DIALOG_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BATTLE_DIALOG_TYPE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BATTLE_DIALOG_TYPE: [enum__Torappu_BattleDialogType; 5] = [
    enum__Torappu_BattleDialogType::NONE,
    enum__Torappu_BattleDialogType::BEFORE,
    enum__Torappu_BattleDialogType::REACT,
    enum__Torappu_BattleDialogType::AFTER,
    enum__Torappu_BattleDialogType::ENUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BattleDialogType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BattleDialogType {
    pub const NONE: Self = Self(0);
    pub const BEFORE: Self = Self(1);
    pub const REACT: Self = Self(2);
    pub const AFTER: Self = Self(3);
    pub const ENUM: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::BEFORE,
        Self::REACT,
        Self::AFTER,
        Self::ENUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::BEFORE => Some("BEFORE"),
            Self::REACT => Some("REACT"),
            Self::AFTER => Some("AFTER"),
            Self::ENUM => Some("ENUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BattleDialogType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BattleDialogType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BattleDialogType {
    type Output = enum__Torappu_BattleDialogType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BattleDialogType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BattleDialogType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BattleDialogType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SHARED_CONSTS_DIRECTION: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SHARED_CONSTS_DIRECTION: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SHARED_CONSTS_DIRECTION:
    [enum__Torappu_SharedConsts_Direction; 6] = [
    enum__Torappu_SharedConsts_Direction::UP,
    enum__Torappu_SharedConsts_Direction::RIGHT,
    enum__Torappu_SharedConsts_Direction::DOWN,
    enum__Torappu_SharedConsts_Direction::LEFT,
    enum__Torappu_SharedConsts_Direction::E_NUM,
    enum__Torappu_SharedConsts_Direction::INVALID,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SharedConsts_Direction(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SharedConsts_Direction {
    pub const UP: Self = Self(0);
    pub const RIGHT: Self = Self(1);
    pub const DOWN: Self = Self(2);
    pub const LEFT: Self = Self(3);
    pub const E_NUM: Self = Self(4);
    pub const INVALID: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::UP,
        Self::RIGHT,
        Self::DOWN,
        Self::LEFT,
        Self::E_NUM,
        Self::INVALID,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::UP => Some("UP"),
            Self::RIGHT => Some("RIGHT"),
            Self::DOWN => Some("DOWN"),
            Self::LEFT => Some("LEFT"),
            Self::E_NUM => Some("E_NUM"),
            Self::INVALID => Some("INVALID"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SharedConsts_Direction {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SharedConsts_Direction {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SharedConsts_Direction {
    type Output = enum__Torappu_SharedConsts_Direction;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SharedConsts_Direction {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SharedConsts_Direction {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SharedConsts_Direction {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_QUEST_LINE_BADGE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_QUEST_LINE_BADGE_TYPE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_QUEST_LINE_BADGE_TYPE:
    [enum__Torappu_SandboxV2QuestLineBadgeType; 5] = [
    enum__Torappu_SandboxV2QuestLineBadgeType::NONE,
    enum__Torappu_SandboxV2QuestLineBadgeType::SIDE,
    enum__Torappu_SandboxV2QuestLineBadgeType::GUIDE,
    enum__Torappu_SandboxV2QuestLineBadgeType::MAIN,
    enum__Torappu_SandboxV2QuestLineBadgeType::RIFT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2QuestLineBadgeType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2QuestLineBadgeType {
    pub const NONE: Self = Self(0);
    pub const SIDE: Self = Self(1);
    pub const GUIDE: Self = Self(2);
    pub const MAIN: Self = Self(3);
    pub const RIFT: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::SIDE, Self::GUIDE, Self::MAIN, Self::RIFT];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::SIDE => Some("SIDE"),
            Self::GUIDE => Some("GUIDE"),
            Self::MAIN => Some("MAIN"),
            Self::RIFT => Some("RIFT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2QuestLineBadgeType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2QuestLineBadgeType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2QuestLineBadgeType {
    type Output = enum__Torappu_SandboxV2QuestLineBadgeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2QuestLineBadgeType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2QuestLineBadgeType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2QuestLineBadgeType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_QUEST_LINE_SCOPE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_QUEST_LINE_SCOPE_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_QUEST_LINE_SCOPE_TYPE:
    [enum__Torappu_SandboxV2QuestLineScopeType; 3] = [
    enum__Torappu_SandboxV2QuestLineScopeType::MAIN,
    enum__Torappu_SandboxV2QuestLineScopeType::RIFT,
    enum__Torappu_SandboxV2QuestLineScopeType::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2QuestLineScopeType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2QuestLineScopeType {
    pub const MAIN: Self = Self(0);
    pub const RIFT: Self = Self(1);
    pub const ALL: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::MAIN, Self::RIFT, Self::ALL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::MAIN => Some("MAIN"),
            Self::RIFT => Some("RIFT"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2QuestLineScopeType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2QuestLineScopeType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2QuestLineScopeType {
    type Output = enum__Torappu_SandboxV2QuestLineScopeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2QuestLineScopeType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2QuestLineScopeType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2QuestLineScopeType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_DEVELOPMENT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_DEVELOPMENT_TYPE: i32 = 5;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_DEVELOPMENT_TYPE:
    [enum__Torappu_SandboxV2DevelopmentType; 6] = [
    enum__Torappu_SandboxV2DevelopmentType::NONE,
    enum__Torappu_SandboxV2DevelopmentType::SURVIVE,
    enum__Torappu_SandboxV2DevelopmentType::COLLECT,
    enum__Torappu_SandboxV2DevelopmentType::SHOP,
    enum__Torappu_SandboxV2DevelopmentType::BATTLE,
    enum__Torappu_SandboxV2DevelopmentType::DUNGEON,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2DevelopmentType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2DevelopmentType {
    pub const NONE: Self = Self(0);
    pub const SURVIVE: Self = Self(1);
    pub const COLLECT: Self = Self(2);
    pub const SHOP: Self = Self(3);
    pub const BATTLE: Self = Self(4);
    pub const DUNGEON: Self = Self(5);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 5;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::SURVIVE,
        Self::COLLECT,
        Self::SHOP,
        Self::BATTLE,
        Self::DUNGEON,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::SURVIVE => Some("SURVIVE"),
            Self::COLLECT => Some("COLLECT"),
            Self::SHOP => Some("SHOP"),
            Self::BATTLE => Some("BATTLE"),
            Self::DUNGEON => Some("DUNGEON"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2DevelopmentType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2DevelopmentType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2DevelopmentType {
    type Output = enum__Torappu_SandboxV2DevelopmentType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2DevelopmentType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2DevelopmentType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2DevelopmentType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_EVENT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_EVENT_TYPE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_EVENT_TYPE: [enum__Torappu_SandboxV2EventType; 5] = [
    enum__Torappu_SandboxV2EventType::NONE,
    enum__Torappu_SandboxV2EventType::EVENT,
    enum__Torappu_SandboxV2EventType::MISSION,
    enum__Torappu_SandboxV2EventType::QUEST_EVENT,
    enum__Torappu_SandboxV2EventType::QUEST_MISSION,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2EventType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2EventType {
    pub const NONE: Self = Self(0);
    pub const EVENT: Self = Self(1);
    pub const MISSION: Self = Self(2);
    pub const QUEST_EVENT: Self = Self(3);
    pub const QUEST_MISSION: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::EVENT,
        Self::MISSION,
        Self::QUEST_EVENT,
        Self::QUEST_MISSION,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::EVENT => Some("EVENT"),
            Self::MISSION => Some("MISSION"),
            Self::QUEST_EVENT => Some("QUEST_EVENT"),
            Self::QUEST_MISSION => Some("QUEST_MISSION"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2EventType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2EventType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2EventType {
    type Output = enum__Torappu_SandboxV2EventType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2EventType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2EventType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2EventType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_EVENT_CHOICE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_EVENT_CHOICE_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_EVENT_CHOICE_TYPE:
    [enum__Torappu_SandboxV2EventChoiceType; 4] = [
    enum__Torappu_SandboxV2EventChoiceType::NONE,
    enum__Torappu_SandboxV2EventChoiceType::NEXT,
    enum__Torappu_SandboxV2EventChoiceType::LEAVE,
    enum__Torappu_SandboxV2EventChoiceType::MISSION,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2EventChoiceType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2EventChoiceType {
    pub const NONE: Self = Self(0);
    pub const NEXT: Self = Self(1);
    pub const LEAVE: Self = Self(2);
    pub const MISSION: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::NEXT, Self::LEAVE, Self::MISSION];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::NEXT => Some("NEXT"),
            Self::LEAVE => Some("LEAVE"),
            Self::MISSION => Some("MISSION"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2EventChoiceType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2EventChoiceType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2EventChoiceType {
    type Output = enum__Torappu_SandboxV2EventChoiceType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2EventChoiceType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2EventChoiceType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2EventChoiceType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_PROFESSION_ID: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_PROFESSION_ID: i32 = 9;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_PROFESSION_ID: [enum__Torappu_ProfessionID; 10] = [
    enum__Torappu_ProfessionID::WARRIOR,
    enum__Torappu_ProfessionID::SNIPER,
    enum__Torappu_ProfessionID::TANK,
    enum__Torappu_ProfessionID::MEDIC,
    enum__Torappu_ProfessionID::SUPPORT,
    enum__Torappu_ProfessionID::CASTER,
    enum__Torappu_ProfessionID::SPECIAL,
    enum__Torappu_ProfessionID::TOKEN,
    enum__Torappu_ProfessionID::TRAP,
    enum__Torappu_ProfessionID::PIONEER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ProfessionID(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ProfessionID {
    pub const WARRIOR: Self = Self(0);
    pub const SNIPER: Self = Self(1);
    pub const TANK: Self = Self(2);
    pub const MEDIC: Self = Self(3);
    pub const SUPPORT: Self = Self(4);
    pub const CASTER: Self = Self(5);
    pub const SPECIAL: Self = Self(6);
    pub const TOKEN: Self = Self(7);
    pub const TRAP: Self = Self(8);
    pub const PIONEER: Self = Self(9);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 9;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::WARRIOR,
        Self::SNIPER,
        Self::TANK,
        Self::MEDIC,
        Self::SUPPORT,
        Self::CASTER,
        Self::SPECIAL,
        Self::TOKEN,
        Self::TRAP,
        Self::PIONEER,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::WARRIOR => Some("WARRIOR"),
            Self::SNIPER => Some("SNIPER"),
            Self::TANK => Some("TANK"),
            Self::MEDIC => Some("MEDIC"),
            Self::SUPPORT => Some("SUPPORT"),
            Self::CASTER => Some("CASTER"),
            Self::SPECIAL => Some("SPECIAL"),
            Self::TOKEN => Some("TOKEN"),
            Self::TRAP => Some("TRAP"),
            Self::PIONEER => Some("PIONEER"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ProfessionID {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ProfessionID {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ProfessionID {
    type Output = enum__Torappu_ProfessionID;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ProfessionID {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ProfessionID {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ProfessionID {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_COIN_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_COIN_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_COIN_TYPE: [enum__Torappu_SandboxV2CoinType; 2] = [
    enum__Torappu_SandboxV2CoinType::DIMENSION_COIN,
    enum__Torappu_SandboxV2CoinType::GOLD,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2CoinType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2CoinType {
    pub const DIMENSION_COIN: Self = Self(0);
    pub const GOLD: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::DIMENSION_COIN, Self::GOLD];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::DIMENSION_COIN => Some("DIMENSION_COIN"),
            Self::GOLD => Some("GOLD"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2CoinType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2CoinType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2CoinType {
    type Output = enum__Torappu_SandboxV2CoinType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2CoinType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2CoinType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2CoinType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_RIFT_MAIN_TARGET_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_RIFT_MAIN_TARGET_TYPE: i32 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_RIFT_MAIN_TARGET_TYPE:
    [enum__Torappu_SandboxV2RiftMainTargetType; 8] = [
    enum__Torappu_SandboxV2RiftMainTargetType::NONE,
    enum__Torappu_SandboxV2RiftMainTargetType::FIND,
    enum__Torappu_SandboxV2RiftMainTargetType::BOSS_HUNT,
    enum__Torappu_SandboxV2RiftMainTargetType::WILD_HUNT,
    enum__Torappu_SandboxV2RiftMainTargetType::PROTECT,
    enum__Torappu_SandboxV2RiftMainTargetType::FIGHT,
    enum__Torappu_SandboxV2RiftMainTargetType::CATCH_THIEF,
    enum__Torappu_SandboxV2RiftMainTargetType::PREY_HUNT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2RiftMainTargetType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2RiftMainTargetType {
    pub const NONE: Self = Self(0);
    pub const FIND: Self = Self(1);
    pub const BOSS_HUNT: Self = Self(2);
    pub const WILD_HUNT: Self = Self(3);
    pub const PROTECT: Self = Self(4);
    pub const FIGHT: Self = Self(5);
    pub const CATCH_THIEF: Self = Self(6);
    pub const PREY_HUNT: Self = Self(7);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 7;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::FIND,
        Self::BOSS_HUNT,
        Self::WILD_HUNT,
        Self::PROTECT,
        Self::FIGHT,
        Self::CATCH_THIEF,
        Self::PREY_HUNT,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::FIND => Some("FIND"),
            Self::BOSS_HUNT => Some("BOSS_HUNT"),
            Self::WILD_HUNT => Some("WILD_HUNT"),
            Self::PROTECT => Some("PROTECT"),
            Self::FIGHT => Some("FIGHT"),
            Self::CATCH_THIEF => Some("CATCH_THIEF"),
            Self::PREY_HUNT => Some("PREY_HUNT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2RiftMainTargetType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2RiftMainTargetType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2RiftMainTargetType {
    type Output = enum__Torappu_SandboxV2RiftMainTargetType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2RiftMainTargetType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2RiftMainTargetType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2RiftMainTargetType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_ARCHIVE_QUEST_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_ARCHIVE_QUEST_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_ARCHIVE_QUEST_TYPE:
    [enum__Torappu_SandboxV2ArchiveQuestType; 3] = [
    enum__Torappu_SandboxV2ArchiveQuestType::NONE,
    enum__Torappu_SandboxV2ArchiveQuestType::MAIN,
    enum__Torappu_SandboxV2ArchiveQuestType::SIDE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2ArchiveQuestType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2ArchiveQuestType {
    pub const NONE: Self = Self(0);
    pub const MAIN: Self = Self(1);
    pub const SIDE: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::MAIN, Self::SIDE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MAIN => Some("MAIN"),
            Self::SIDE => Some("SIDE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2ArchiveQuestType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2ArchiveQuestType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2ArchiveQuestType {
    type Output = enum__Torappu_SandboxV2ArchiveQuestType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2ArchiveQuestType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2ArchiveQuestType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2ArchiveQuestType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_BASE_UNLOCK_FUNC_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_BASE_UNLOCK_FUNC_TYPE: i32 = 8;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_BASE_UNLOCK_FUNC_TYPE:
    [enum__Torappu_SandboxV2BaseUnlockFuncType; 9] = [
    enum__Torappu_SandboxV2BaseUnlockFuncType::NONE,
    enum__Torappu_SandboxV2BaseUnlockFuncType::HOME_PUTPOST,
    enum__Torappu_SandboxV2BaseUnlockFuncType::HOME_PORTABLE,
    enum__Torappu_SandboxV2BaseUnlockFuncType::REWARDSHOP,
    enum__Torappu_SandboxV2BaseUnlockFuncType::TECH,
    enum__Torappu_SandboxV2BaseUnlockFuncType::REAR,
    enum__Torappu_SandboxV2BaseUnlockFuncType::BUILD,
    enum__Torappu_SandboxV2BaseUnlockFuncType::SHOP,
    enum__Torappu_SandboxV2BaseUnlockFuncType::RACING,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2BaseUnlockFuncType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2BaseUnlockFuncType {
    pub const NONE: Self = Self(0);
    pub const HOME_PUTPOST: Self = Self(1);
    pub const HOME_PORTABLE: Self = Self(2);
    pub const REWARDSHOP: Self = Self(3);
    pub const TECH: Self = Self(4);
    pub const REAR: Self = Self(5);
    pub const BUILD: Self = Self(6);
    pub const SHOP: Self = Self(7);
    pub const RACING: Self = Self(8);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 8;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::HOME_PUTPOST,
        Self::HOME_PORTABLE,
        Self::REWARDSHOP,
        Self::TECH,
        Self::REAR,
        Self::BUILD,
        Self::SHOP,
        Self::RACING,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::HOME_PUTPOST => Some("HOME_PUTPOST"),
            Self::HOME_PORTABLE => Some("HOME_PORTABLE"),
            Self::REWARDSHOP => Some("REWARDSHOP"),
            Self::TECH => Some("TECH"),
            Self::REAR => Some("REAR"),
            Self::BUILD => Some("BUILD"),
            Self::SHOP => Some("SHOP"),
            Self::RACING => Some("RACING"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2BaseUnlockFuncType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2BaseUnlockFuncType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2BaseUnlockFuncType {
    type Output = enum__Torappu_SandboxV2BaseUnlockFuncType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2BaseUnlockFuncType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2BaseUnlockFuncType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2BaseUnlockFuncType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_BASE_UNLOCK_FUNC_DISPLAY_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_BASE_UNLOCK_FUNC_DISPLAY_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_BASE_UNLOCK_FUNC_DISPLAY_TYPE:
    [enum__Torappu_SandboxV2BaseUnlockFuncDisplayType; 4] = [
    enum__Torappu_SandboxV2BaseUnlockFuncDisplayType::NONE,
    enum__Torappu_SandboxV2BaseUnlockFuncDisplayType::NEW,
    enum__Torappu_SandboxV2BaseUnlockFuncDisplayType::UPDATE,
    enum__Torappu_SandboxV2BaseUnlockFuncDisplayType::NUMBER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2BaseUnlockFuncDisplayType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2BaseUnlockFuncDisplayType {
    pub const NONE: Self = Self(0);
    pub const NEW: Self = Self(1);
    pub const UPDATE: Self = Self(2);
    pub const NUMBER: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::NEW, Self::UPDATE, Self::NUMBER];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::NEW => Some("NEW"),
            Self::UPDATE => Some("UPDATE"),
            Self::NUMBER => Some("NUMBER"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2BaseUnlockFuncDisplayType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2BaseUnlockFuncDisplayType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2BaseUnlockFuncDisplayType {
    type Output = enum__Torappu_SandboxV2BaseUnlockFuncDisplayType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2BaseUnlockFuncDisplayType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2BaseUnlockFuncDisplayType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2BaseUnlockFuncDisplayType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_DEVELOPMENT_LINE_STYLE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_DEVELOPMENT_LINE_STYLE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_DEVELOPMENT_LINE_STYLE:
    [enum__Torappu_SandboxV2DevelopmentLineStyle; 3] = [
    enum__Torappu_SandboxV2DevelopmentLineStyle::EMPTY,
    enum__Torappu_SandboxV2DevelopmentLineStyle::LEVEL_PASS,
    enum__Torappu_SandboxV2DevelopmentLineStyle::LEVEL_BLOCK,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2DevelopmentLineStyle(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2DevelopmentLineStyle {
    pub const EMPTY: Self = Self(0);
    pub const LEVEL_PASS: Self = Self(1);
    pub const LEVEL_BLOCK: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::EMPTY, Self::LEVEL_PASS, Self::LEVEL_BLOCK];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::EMPTY => Some("EMPTY"),
            Self::LEVEL_PASS => Some("LEVEL_PASS"),
            Self::LEVEL_BLOCK => Some("LEVEL_BLOCK"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2DevelopmentLineStyle {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2DevelopmentLineStyle {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2DevelopmentLineStyle {
    type Output = enum__Torappu_SandboxV2DevelopmentLineStyle;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2DevelopmentLineStyle {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2DevelopmentLineStyle {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2DevelopmentLineStyle {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_CONFIRM_ICON_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_CONFIRM_ICON_TYPE: i32 = 10;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_CONFIRM_ICON_TYPE:
    [enum__Torappu_SandboxV2ConfirmIconType; 11] = [
    enum__Torappu_SandboxV2ConfirmIconType::COMMON,
    enum__Torappu_SandboxV2ConfirmIconType::EMERGENCY,
    enum__Torappu_SandboxV2ConfirmIconType::QUIT,
    enum__Torappu_SandboxV2ConfirmIconType::EVACUATE,
    enum__Torappu_SandboxV2ConfirmIconType::EVACUATELOSS,
    enum__Torappu_SandboxV2ConfirmIconType::NORMAL,
    enum__Torappu_SandboxV2ConfirmIconType::COMBAT,
    enum__Torappu_SandboxV2ConfirmIconType::CONSTRUCT,
    enum__Torappu_SandboxV2ConfirmIconType::NEXTDAY,
    enum__Torappu_SandboxV2ConfirmIconType::RIFT_EXIT,
    enum__Torappu_SandboxV2ConfirmIconType::LOAD_ARCHIVE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2ConfirmIconType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2ConfirmIconType {
    pub const COMMON: Self = Self(0);
    pub const EMERGENCY: Self = Self(1);
    pub const QUIT: Self = Self(2);
    pub const EVACUATE: Self = Self(3);
    pub const EVACUATELOSS: Self = Self(4);
    pub const NORMAL: Self = Self(5);
    pub const COMBAT: Self = Self(6);
    pub const CONSTRUCT: Self = Self(7);
    pub const NEXTDAY: Self = Self(8);
    pub const RIFT_EXIT: Self = Self(9);
    pub const LOAD_ARCHIVE: Self = Self(10);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 10;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::COMMON,
        Self::EMERGENCY,
        Self::QUIT,
        Self::EVACUATE,
        Self::EVACUATELOSS,
        Self::NORMAL,
        Self::COMBAT,
        Self::CONSTRUCT,
        Self::NEXTDAY,
        Self::RIFT_EXIT,
        Self::LOAD_ARCHIVE,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::COMMON => Some("COMMON"),
            Self::EMERGENCY => Some("EMERGENCY"),
            Self::QUIT => Some("QUIT"),
            Self::EVACUATE => Some("EVACUATE"),
            Self::EVACUATELOSS => Some("EVACUATELOSS"),
            Self::NORMAL => Some("NORMAL"),
            Self::COMBAT => Some("COMBAT"),
            Self::CONSTRUCT => Some("CONSTRUCT"),
            Self::NEXTDAY => Some("NEXTDAY"),
            Self::RIFT_EXIT => Some("RIFT_EXIT"),
            Self::LOAD_ARCHIVE => Some("LOAD_ARCHIVE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2ConfirmIconType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2ConfirmIconType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2ConfirmIconType {
    type Output = enum__Torappu_SandboxV2ConfirmIconType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2ConfirmIconType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2ConfirmIconType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2ConfirmIconType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_EVOLVE_PHASE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_EVOLVE_PHASE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_EVOLVE_PHASE: [enum__Torappu_EvolvePhase; 5] = [
    enum__Torappu_EvolvePhase::PHASE_0,
    enum__Torappu_EvolvePhase::PHASE_1,
    enum__Torappu_EvolvePhase::PHASE_2,
    enum__Torappu_EvolvePhase::PHASE_3,
    enum__Torappu_EvolvePhase::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_EvolvePhase(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_EvolvePhase {
    pub const PHASE_0: Self = Self(0);
    pub const PHASE_1: Self = Self(1);
    pub const PHASE_2: Self = Self(2);
    pub const PHASE_3: Self = Self(3);
    pub const E_NUM: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::PHASE_0,
        Self::PHASE_1,
        Self::PHASE_2,
        Self::PHASE_3,
        Self::E_NUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::PHASE_0 => Some("PHASE_0"),
            Self::PHASE_1 => Some("PHASE_1"),
            Self::PHASE_2 => Some("PHASE_2"),
            Self::PHASE_3 => Some("PHASE_3"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_EvolvePhase {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_EvolvePhase {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_EvolvePhase {
    type Output = enum__Torappu_EvolvePhase;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_EvolvePhase {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_EvolvePhase {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_EvolvePhase {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_RACER_TALENT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_RACER_TALENT_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_RACER_TALENT_TYPE:
    [enum__Torappu_SandboxV2RacerTalentType; 2] = [
    enum__Torappu_SandboxV2RacerTalentType::BORN,
    enum__Torappu_SandboxV2RacerTalentType::LEARNED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2RacerTalentType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2RacerTalentType {
    pub const BORN: Self = Self(0);
    pub const LEARNED: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::BORN, Self::LEARNED];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::BORN => Some("BORN"),
            Self::LEARNED => Some("LEARNED"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2RacerTalentType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2RacerTalentType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2RacerTalentType {
    type Output = enum__Torappu_SandboxV2RacerTalentType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2RacerTalentType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2RacerTalentType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2RacerTalentType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_RACER_NAME_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_RACER_NAME_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_RACER_NAME_TYPE:
    [enum__Torappu_SandboxV2RacerNameType; 2] = [
    enum__Torappu_SandboxV2RacerNameType::PREFIX,
    enum__Torappu_SandboxV2RacerNameType::SUFFIX,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2RacerNameType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2RacerNameType {
    pub const PREFIX: Self = Self(0);
    pub const SUFFIX: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::PREFIX, Self::SUFFIX];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::PREFIX => Some("PREFIX"),
            Self::SUFFIX => Some("SUFFIX"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2RacerNameType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2RacerNameType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2RacerNameType {
    type Output = enum__Torappu_SandboxV2RacerNameType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2RacerNameType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2RacerNameType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2RacerNameType {}
pub enum clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'a> {
    type Inner = clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'a> {
    pub const VT_DISPLAYID: flatbuffers::VOffsetT = 4;
    pub const VT_TOPICID: flatbuffers::VOffsetT = 6;
    pub const VT_STARTTS: flatbuffers::VOffsetT = 8;
    pub const VT_ENDTS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'bldr>> {
        let mut builder = clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataBuilder::new(_fbb);
        builder.add_endTs(args.endTs);
        builder.add_startTs(args.startTs);
        if let Some(x) = args.topicId {
            builder.add_topicId(x);
        }
        if let Some(x) = args.displayId {
            builder.add_displayId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn displayId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData::VT_DISPLAYID,
                None,
            )
        }
    }
    #[inline]
    pub fn topicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData::VT_TOPICID,
                None,
            )
        }
    }
    #[inline]
    pub fn startTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData::VT_STARTTS,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn endTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData::VT_ENDTS,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "displayId",
                Self::VT_DISPLAYID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("topicId", Self::VT_TOPICID, false)?
            .visit_field::<i64>("startTs", Self::VT_STARTTS, false)?
            .visit_field::<i64>("endTs", Self::VT_ENDTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataArgs<'a> {
    pub displayId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub topicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub startTs: i64,
    pub endTs: i64,
}
impl<'a> Default for clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataArgs {
            displayId: None,
            topicId: None,
            startTs: 0,
            endTs: 0,
        }
    }
}

pub struct clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_displayId(&mut self, displayId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData::VT_DISPLAYID,
            displayId,
        );
    }
    #[inline]
    pub fn add_topicId(&mut self, topicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData::VT_TOPICID,
            topicId,
        );
    }
    #[inline]
    pub fn add_startTs(&mut self, startTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData::VT_STARTTS,
            startTs,
            0,
        );
    }
    #[inline]
    pub fn add_endTs(&mut self, endTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData::VT_ENDTS,
            endTs,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData");
        ds.field("displayId", &self.displayId());
        ds.field("topicId", &self.topicId());
        ds.field("startTs", &self.startTs());
        ds.field("endTs", &self.endTs());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxPermBasicDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxPermBasicData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxPermBasicData<'a> {
    type Inner = clz_Torappu_SandboxPermBasicData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxPermBasicData<'a> {
    pub const VT_TOPICID: flatbuffers::VOffsetT = 4;
    pub const VT_TOPICTEMPLATE: flatbuffers::VOffsetT = 6;
    pub const VT_TOPICNAME: flatbuffers::VOffsetT = 8;
    pub const VT_TOPICSTARTTIME: flatbuffers::VOffsetT = 10;
    pub const VT_FULLSTOREDTIME: flatbuffers::VOffsetT = 12;
    pub const VT_SORTID: flatbuffers::VOffsetT = 14;
    pub const VT_PRICEITEMID: flatbuffers::VOffsetT = 16;
    pub const VT_TEMPLATESHOPID: flatbuffers::VOffsetT = 18;
    pub const VT_HOMEENTRYDISPLAYDATA: flatbuffers::VOffsetT = 20;
    pub const VT_WEBBUSTYPE: flatbuffers::VOffsetT = 22;
    pub const VT_MEDALGROUPID: flatbuffers::VOffsetT = 24;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxPermBasicData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxPermBasicDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermBasicData<'bldr>> {
        let mut builder = clz_Torappu_SandboxPermBasicDataBuilder::new(_fbb);
        builder.add_fullStoredTime(args.fullStoredTime);
        builder.add_topicStartTime(args.topicStartTime);
        if let Some(x) = args.medalGroupId {
            builder.add_medalGroupId(x);
        }
        if let Some(x) = args.webBusType {
            builder.add_webBusType(x);
        }
        if let Some(x) = args.homeEntryDisplayData {
            builder.add_homeEntryDisplayData(x);
        }
        if let Some(x) = args.templateShopId {
            builder.add_templateShopId(x);
        }
        if let Some(x) = args.priceItemId {
            builder.add_priceItemId(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.topicName {
            builder.add_topicName(x);
        }
        builder.add_topicTemplate(args.topicTemplate);
        if let Some(x) = args.topicId {
            builder.add_topicId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn topicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermBasicData::VT_TOPICID,
                None,
            )
        }
    }
    #[inline]
    pub fn topicTemplate(&self) -> enum__Torappu_SandboxPermTemplateType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxPermTemplateType>(
                    clz_Torappu_SandboxPermBasicData::VT_TOPICTEMPLATE,
                    Some(enum__Torappu_SandboxPermTemplateType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn topicName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermBasicData::VT_TOPICNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn topicStartTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_SandboxPermBasicData::VT_TOPICSTARTTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn fullStoredTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_SandboxPermBasicData::VT_FULLSTOREDTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxPermBasicData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn priceItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermBasicData::VT_PRICEITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn templateShopId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermBasicData::VT_TEMPLATESHOPID,
                None,
            )
        }
    }
    #[inline]
    pub fn homeEntryDisplayData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData,
                    >,
                >,
            >>(
                clz_Torappu_SandboxPermBasicData::VT_HOMEENTRYDISPLAYDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn webBusType(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermBasicData::VT_WEBBUSTYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn medalGroupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermBasicData::VT_MEDALGROUPID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxPermBasicData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("topicId", Self::VT_TOPICID, false)?
            .visit_field::<enum__Torappu_SandboxPermTemplateType>(
                "topicTemplate",
                Self::VT_TOPICTEMPLATE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "topicName",
                Self::VT_TOPICNAME,
                false,
            )?
            .visit_field::<i64>("topicStartTime", Self::VT_TOPICSTARTTIME, false)?
            .visit_field::<i64>("fullStoredTime", Self::VT_FULLSTOREDTIME, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "priceItemId",
                Self::VT_PRICEITEMID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "templateShopId",
                Self::VT_TEMPLATESHOPID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData,
                    >,
                >,
            >>("homeEntryDisplayData", Self::VT_HOMEENTRYDISPLAYDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "webBusType",
                Self::VT_WEBBUSTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "medalGroupId",
                Self::VT_MEDALGROUPID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxPermBasicDataArgs<'a> {
    pub topicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub topicTemplate: enum__Torappu_SandboxPermTemplateType,
    pub topicName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub topicStartTime: i64,
    pub fullStoredTime: i64,
    pub sortId: i32,
    pub priceItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub templateShopId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub homeEntryDisplayData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'a>,
                >,
            >,
        >,
    >,
    pub webBusType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub medalGroupId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxPermBasicDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxPermBasicDataArgs {
            topicId: None,
            topicTemplate: enum__Torappu_SandboxPermTemplateType::NONE,
            topicName: None,
            topicStartTime: 0,
            fullStoredTime: 0,
            sortId: 0,
            priceItemId: None,
            templateShopId: None,
            homeEntryDisplayData: None,
            webBusType: None,
            medalGroupId: None,
        }
    }
}

pub struct clz_Torappu_SandboxPermBasicDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxPermBasicDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_topicId(&mut self, topicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermBasicData::VT_TOPICID,
            topicId,
        );
    }
    #[inline]
    pub fn add_topicTemplate(&mut self, topicTemplate: enum__Torappu_SandboxPermTemplateType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxPermTemplateType>(
                clz_Torappu_SandboxPermBasicData::VT_TOPICTEMPLATE,
                topicTemplate,
                enum__Torappu_SandboxPermTemplateType::NONE,
            );
    }
    #[inline]
    pub fn add_topicName(&mut self, topicName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermBasicData::VT_TOPICNAME,
            topicName,
        );
    }
    #[inline]
    pub fn add_topicStartTime(&mut self, topicStartTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_SandboxPermBasicData::VT_TOPICSTARTTIME,
            topicStartTime,
            0,
        );
    }
    #[inline]
    pub fn add_fullStoredTime(&mut self, fullStoredTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_SandboxPermBasicData::VT_FULLSTOREDTIME,
            fullStoredTime,
            0,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxPermBasicData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_priceItemId(&mut self, priceItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermBasicData::VT_PRICEITEMID,
            priceItemId,
        );
    }
    #[inline]
    pub fn add_templateShopId(&mut self, templateShopId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermBasicData::VT_TEMPLATESHOPID,
            templateShopId,
        );
    }
    #[inline]
    pub fn add_homeEntryDisplayData(
        &mut self,
        homeEntryDisplayData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermBasicData::VT_HOMEENTRYDISPLAYDATA,
            homeEntryDisplayData,
        );
    }
    #[inline]
    pub fn add_webBusType(&mut self, webBusType: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermBasicData::VT_WEBBUSTYPE,
            webBusType,
        );
    }
    #[inline]
    pub fn add_medalGroupId(&mut self, medalGroupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermBasicData::VT_MEDALGROUPID,
            medalGroupId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxPermBasicDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxPermBasicDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermBasicData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxPermBasicData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxPermBasicData");
        ds.field("topicId", &self.topicId());
        ds.field("topicTemplate", &self.topicTemplate());
        ds.field("topicName", &self.topicName());
        ds.field("topicStartTime", &self.topicStartTime());
        ds.field("fullStoredTime", &self.fullStoredTime());
        ds.field("sortId", &self.sortId());
        ds.field("priceItemId", &self.priceItemId());
        ds.field("templateShopId", &self.templateShopId());
        ds.field("homeEntryDisplayData", &self.homeEntryDisplayData());
        ds.field("webBusType", &self.webBusType());
        ds.field("medalGroupId", &self.medalGroupId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxPermBasicDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxPermBasicData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxPermBasicData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxPermBasicData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxPermBasicData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxPermBasicData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxPermBasicDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxPermBasicData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxPermBasicDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxPermBasicData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxPermBasicData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxPermBasicData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxPermBasicData>>(
                    dict__string__clz_Torappu_SandboxPermBasicData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxPermBasicData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxPermBasicData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxPermBasicDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxPermBasicData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxPermBasicDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxPermBasicDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxPermBasicDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxPermBasicDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxPermBasicData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxPermBasicData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxPermBasicData>>(
                dict__string__clz_Torappu_SandboxPermBasicData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxPermBasicDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxPermBasicDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxPermBasicData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxPermBasicData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxPermBasicData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxPermBasicData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2NodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2NodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2NodeData<'a> {
    type Inner = clz_Torappu_SandboxV2NodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2NodeData<'a> {
    pub const VT_MINDISTANCE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2NodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2NodeDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2NodeDataBuilder::new(_fbb);
        builder.add_minDistance(args.minDistance);
        builder.finish()
    }

    #[inline]
    pub fn minDistance(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_SandboxV2NodeData::VT_MINDISTANCE, Some(0.0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2NodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("minDistance", Self::VT_MINDISTANCE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2NodeDataArgs {
    pub minDistance: f32,
}
impl<'a> Default for clz_Torappu_SandboxV2NodeDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2NodeDataArgs { minDistance: 0.0 }
    }
}

pub struct clz_Torappu_SandboxV2NodeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2NodeDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_minDistance(&mut self, minDistance: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2NodeData::VT_MINDISTANCE,
            minDistance,
            0.0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2NodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2NodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2NodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2NodeData");
        ds.field("minDistance", &self.minDistance());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2NodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2NodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2NodeData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2NodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2NodeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2NodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2NodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NodeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2NodeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2NodeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2NodeData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2NodeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2NodeData>>(
                    dict__string__clz_Torappu_SandboxV2NodeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2NodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2NodeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2NodeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2NodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2NodeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2NodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2NodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2NodeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeData>>(
                dict__string__clz_Torappu_SandboxV2NodeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2NodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2NodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2NodeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2NodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2NodeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_UnityEngine_Vector2Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_UnityEngine_Vector2<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_UnityEngine_Vector2<'a> {
    type Inner = clz_UnityEngine_Vector2<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_UnityEngine_Vector2<'a> {
    pub const VT_X: flatbuffers::VOffsetT = 4;
    pub const VT_Y: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_UnityEngine_Vector2 { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_UnityEngine_Vector2Args,
    ) -> flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'bldr>> {
        let mut builder = clz_UnityEngine_Vector2Builder::new(_fbb);
        builder.add_y(args.y);
        builder.add_x(args.x);
        builder.finish()
    }

    #[inline]
    pub fn x(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_UnityEngine_Vector2::VT_X, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn y(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_UnityEngine_Vector2::VT_Y, Some(0.0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_UnityEngine_Vector2<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("x", Self::VT_X, false)?
            .visit_field::<f32>("y", Self::VT_Y, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_UnityEngine_Vector2Args {
    pub x: f32,
    pub y: f32,
}
impl<'a> Default for clz_UnityEngine_Vector2Args {
    #[inline]
    fn default() -> Self {
        clz_UnityEngine_Vector2Args { x: 0.0, y: 0.0 }
    }
}

pub struct clz_UnityEngine_Vector2Builder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_UnityEngine_Vector2Builder<'a, 'b, A> {
    #[inline]
    pub fn add_x(&mut self, x: f32) {
        self.fbb_
            .push_slot::<f32>(clz_UnityEngine_Vector2::VT_X, x, 0.0);
    }
    #[inline]
    pub fn add_y(&mut self, y: f32) {
        self.fbb_
            .push_slot::<f32>(clz_UnityEngine_Vector2::VT_Y, y, 0.0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_UnityEngine_Vector2Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_UnityEngine_Vector2Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_UnityEngine_Vector2<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_UnityEngine_Vector2");
        ds.field("x", &self.x());
        ds.field("y", &self.y());
        ds.finish()
    }
}
pub enum list_intOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct list_int<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for list_int<'a> {
    type Inner = list_int<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> list_int<'a> {
    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        list_int { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args list_intArgs<'args>,
    ) -> flatbuffers::WIPOffset<list_int<'bldr>> {
        let mut builder = list_intBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn values(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    list_int::VT_VALUES,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for list_int<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "values",
                Self::VT_VALUES,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct list_intArgs<'a> {
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for list_intArgs<'a> {
    #[inline]
    fn default() -> Self {
        list_intArgs { values: None }
    }
}

pub struct list_intBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> list_intBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(list_int::VT_VALUES, values);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> list_intBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        list_intBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<list_int<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for list_int<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("list_int");
        ds.field("values", &self.values());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2MapZoneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2MapZoneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2MapZoneData<'a> {
    type Inner = clz_Torappu_SandboxV2MapZoneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2MapZoneData<'a> {
    pub const VT_ZONEID: flatbuffers::VOffsetT = 4;
    pub const VT_CENTER: flatbuffers::VOffsetT = 6;
    pub const VT_VERTICES: flatbuffers::VOffsetT = 8;
    pub const VT_TRIANGLES: flatbuffers::VOffsetT = 10;
    pub const VT_HASBORDER: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2MapZoneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2MapZoneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapZoneData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2MapZoneDataBuilder::new(_fbb);
        if let Some(x) = args.triangles {
            builder.add_triangles(x);
        }
        if let Some(x) = args.vertices {
            builder.add_vertices(x);
        }
        if let Some(x) = args.center {
            builder.add_center(x);
        }
        if let Some(x) = args.zoneId {
            builder.add_zoneId(x);
        }
        builder.add_hasBorder(args.hasBorder);
        builder.finish()
    }

    #[inline]
    pub fn zoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MapZoneData::VT_ZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn center(&self) -> Option<clz_UnityEngine_Vector2<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                    clz_Torappu_SandboxV2MapZoneData::VT_CENTER,
                    None,
                )
        }
    }
    #[inline]
    pub fn vertices(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>,
            >>(clz_Torappu_SandboxV2MapZoneData::VT_VERTICES, None)
        }
    }
    #[inline]
    pub fn triangles(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<list_int<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<list_int>>,
            >>(clz_Torappu_SandboxV2MapZoneData::VT_TRIANGLES, None)
        }
    }
    #[inline]
    pub fn hasBorder(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_SandboxV2MapZoneData::VT_HASBORDER, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2MapZoneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zoneId", Self::VT_ZONEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                "center",
                Self::VT_CENTER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>,
            >>("vertices", Self::VT_VERTICES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<list_int>>,
            >>("triangles", Self::VT_TRIANGLES, false)?
            .visit_field::<bool>("hasBorder", Self::VT_HASBORDER, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2MapZoneDataArgs<'a> {
    pub zoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub center: Option<flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'a>>>,
    pub vertices: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2<'a>>>,
        >,
    >,
    pub triangles: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<list_int<'a>>>>,
    >,
    pub hasBorder: bool,
}
impl<'a> Default for clz_Torappu_SandboxV2MapZoneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2MapZoneDataArgs {
            zoneId: None,
            center: None,
            vertices: None,
            triangles: None,
            hasBorder: false,
        }
    }
}

pub struct clz_Torappu_SandboxV2MapZoneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2MapZoneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_zoneId(&mut self, zoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MapZoneData::VT_ZONEID,
            zoneId,
        );
    }
    #[inline]
    pub fn add_center(&mut self, center: flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_UnityEngine_Vector2>>(
                clz_Torappu_SandboxV2MapZoneData::VT_CENTER,
                center,
            );
    }
    #[inline]
    pub fn add_vertices(
        &mut self,
        vertices: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MapZoneData::VT_VERTICES,
            vertices,
        );
    }
    #[inline]
    pub fn add_triangles(
        &mut self,
        triangles: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<list_int<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MapZoneData::VT_TRIANGLES,
            triangles,
        );
    }
    #[inline]
    pub fn add_hasBorder(&mut self, hasBorder: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SandboxV2MapZoneData::VT_HASBORDER,
            hasBorder,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2MapZoneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2MapZoneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapZoneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2MapZoneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2MapZoneData");
        ds.field("zoneId", &self.zoneId());
        ds.field("center", &self.center());
        ds.field("vertices", &self.vertices());
        ds.field("triangles", &self.triangles());
        ds.field("hasBorder", &self.hasBorder());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2MapZoneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2MapZoneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2MapZoneData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2MapZoneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2MapZoneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2MapZoneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2MapZoneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2MapZoneData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2MapZoneDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2MapZoneData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2MapZoneData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2MapZoneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2MapZoneData>>(
                    dict__string__clz_Torappu_SandboxV2MapZoneData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2MapZoneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2MapZoneData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2MapZoneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapZoneData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2MapZoneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2MapZoneDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2MapZoneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2MapZoneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2MapZoneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapZoneData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapZoneData>>(
                dict__string__clz_Torappu_SandboxV2MapZoneData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2MapZoneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2MapZoneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2MapZoneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2MapZoneData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2MapZoneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2MapZoneData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2MapConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2MapConfig<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2MapConfig<'a> {
    type Inner = clz_Torappu_SandboxV2MapConfig<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2MapConfig<'a> {
    pub const VT_ISRIFT: flatbuffers::VOffsetT = 4;
    pub const VT_ISGUIDE: flatbuffers::VOffsetT = 6;
    pub const VT_CAMERABOUNDMIN: flatbuffers::VOffsetT = 8;
    pub const VT_CAMERABOUNDMAX: flatbuffers::VOffsetT = 10;
    pub const VT_CAMERAMAXNORMALIZEDZOOM: flatbuffers::VOffsetT = 12;
    pub const VT_BACKGROUNDID: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2MapConfig { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2MapConfigArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapConfig<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2MapConfigBuilder::new(_fbb);
        if let Some(x) = args.backgroundId {
            builder.add_backgroundId(x);
        }
        builder.add_cameraMaxNormalizedZoom(args.cameraMaxNormalizedZoom);
        if let Some(x) = args.cameraBoundMax {
            builder.add_cameraBoundMax(x);
        }
        if let Some(x) = args.cameraBoundMin {
            builder.add_cameraBoundMin(x);
        }
        builder.add_isGuide(args.isGuide);
        builder.add_isRift(args.isRift);
        builder.finish()
    }

    #[inline]
    pub fn isRift(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_SandboxV2MapConfig::VT_ISRIFT, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn isGuide(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_SandboxV2MapConfig::VT_ISGUIDE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn cameraBoundMin(&self) -> Option<clz_UnityEngine_Vector2<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                    clz_Torappu_SandboxV2MapConfig::VT_CAMERABOUNDMIN,
                    None,
                )
        }
    }
    #[inline]
    pub fn cameraBoundMax(&self) -> Option<clz_UnityEngine_Vector2<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                    clz_Torappu_SandboxV2MapConfig::VT_CAMERABOUNDMAX,
                    None,
                )
        }
    }
    #[inline]
    pub fn cameraMaxNormalizedZoom(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2MapConfig::VT_CAMERAMAXNORMALIZEDZOOM,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn backgroundId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MapConfig::VT_BACKGROUNDID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2MapConfig<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("isRift", Self::VT_ISRIFT, false)?
            .visit_field::<bool>("isGuide", Self::VT_ISGUIDE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                "cameraBoundMin",
                Self::VT_CAMERABOUNDMIN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                "cameraBoundMax",
                Self::VT_CAMERABOUNDMAX,
                false,
            )?
            .visit_field::<f32>(
                "cameraMaxNormalizedZoom",
                Self::VT_CAMERAMAXNORMALIZEDZOOM,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "backgroundId",
                Self::VT_BACKGROUNDID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2MapConfigArgs<'a> {
    pub isRift: bool,
    pub isGuide: bool,
    pub cameraBoundMin: Option<flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'a>>>,
    pub cameraBoundMax: Option<flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'a>>>,
    pub cameraMaxNormalizedZoom: f32,
    pub backgroundId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2MapConfigArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2MapConfigArgs {
            isRift: false,
            isGuide: false,
            cameraBoundMin: None,
            cameraBoundMax: None,
            cameraMaxNormalizedZoom: 0.0,
            backgroundId: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2MapConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2MapConfigBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_isRift(&mut self, isRift: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_SandboxV2MapConfig::VT_ISRIFT, isRift, false);
    }
    #[inline]
    pub fn add_isGuide(&mut self, isGuide: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_SandboxV2MapConfig::VT_ISGUIDE, isGuide, false);
    }
    #[inline]
    pub fn add_cameraBoundMin(
        &mut self,
        cameraBoundMin: flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_UnityEngine_Vector2>>(
                clz_Torappu_SandboxV2MapConfig::VT_CAMERABOUNDMIN,
                cameraBoundMin,
            );
    }
    #[inline]
    pub fn add_cameraBoundMax(
        &mut self,
        cameraBoundMax: flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_UnityEngine_Vector2>>(
                clz_Torappu_SandboxV2MapConfig::VT_CAMERABOUNDMAX,
                cameraBoundMax,
            );
    }
    #[inline]
    pub fn add_cameraMaxNormalizedZoom(&mut self, cameraMaxNormalizedZoom: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2MapConfig::VT_CAMERAMAXNORMALIZEDZOOM,
            cameraMaxNormalizedZoom,
            0.0,
        );
    }
    #[inline]
    pub fn add_backgroundId(&mut self, backgroundId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MapConfig::VT_BACKGROUNDID,
            backgroundId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2MapConfigBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2MapConfigBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapConfig<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2MapConfig<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2MapConfig");
        ds.field("isRift", &self.isRift());
        ds.field("isGuide", &self.isGuide());
        ds.field("cameraBoundMin", &self.cameraBoundMin());
        ds.field("cameraBoundMax", &self.cameraBoundMax());
        ds.field("cameraMaxNormalizedZoom", &self.cameraMaxNormalizedZoom());
        ds.field("backgroundId", &self.backgroundId());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2MapDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2MapData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2MapData<'a> {
    type Inner = clz_Torappu_SandboxV2MapData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2MapData<'a> {
    pub const VT_NODES: flatbuffers::VOffsetT = 4;
    pub const VT_ZONES: flatbuffers::VOffsetT = 6;
    pub const VT_MAPCONFIG: flatbuffers::VOffsetT = 8;
    pub const VT_CENTERNODEID: flatbuffers::VOffsetT = 10;
    pub const VT_MONTHMODENODEID: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2MapData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2MapDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2MapDataBuilder::new(_fbb);
        if let Some(x) = args.monthModeNodeId {
            builder.add_monthModeNodeId(x);
        }
        if let Some(x) = args.centerNodeId {
            builder.add_centerNodeId(x);
        }
        if let Some(x) = args.mapConfig {
            builder.add_mapConfig(x);
        }
        if let Some(x) = args.zones {
            builder.add_zones(x);
        }
        if let Some(x) = args.nodes {
            builder.add_nodes(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn nodes(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeData>,
                >,
            >>(clz_Torappu_SandboxV2MapData::VT_NODES, None)
        }
    }
    #[inline]
    pub fn zones(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2MapZoneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2MapZoneData>,
                >,
            >>(clz_Torappu_SandboxV2MapData::VT_ZONES, None)
        }
    }
    #[inline]
    pub fn mapConfig(&self) -> Option<clz_Torappu_SandboxV2MapConfig<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2MapConfig>>(
                    clz_Torappu_SandboxV2MapData::VT_MAPCONFIG,
                    None,
                )
        }
    }
    #[inline]
    pub fn centerNodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MapData::VT_CENTERNODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn monthModeNodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MapData::VT_MONTHMODENODEID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2MapData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeData>,
                >,
            >>("nodes", Self::VT_NODES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2MapZoneData>,
                >,
            >>("zones", Self::VT_ZONES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2MapConfig>>(
                "mapConfig",
                Self::VT_MAPCONFIG,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "centerNodeId",
                Self::VT_CENTERNODEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "monthModeNodeId",
                Self::VT_MONTHMODENODEID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2MapDataArgs<'a> {
    pub nodes: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeData<'a>>,
            >,
        >,
    >,
    pub zones: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2MapZoneData<'a>>,
            >,
        >,
    >,
    pub mapConfig: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapConfig<'a>>>,
    pub centerNodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub monthModeNodeId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2MapDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2MapDataArgs {
            nodes: None,
            zones: None,
            mapConfig: None,
            centerNodeId: None,
            monthModeNodeId: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2MapDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2MapDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_nodes(
        &mut self,
        nodes: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MapData::VT_NODES,
            nodes,
        );
    }
    #[inline]
    pub fn add_zones(
        &mut self,
        zones: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2MapZoneData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MapData::VT_ZONES,
            zones,
        );
    }
    #[inline]
    pub fn add_mapConfig(
        &mut self,
        mapConfig: flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapConfig<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapConfig>>(
                clz_Torappu_SandboxV2MapData::VT_MAPCONFIG,
                mapConfig,
            );
    }
    #[inline]
    pub fn add_centerNodeId(&mut self, centerNodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MapData::VT_CENTERNODEID,
            centerNodeId,
        );
    }
    #[inline]
    pub fn add_monthModeNodeId(&mut self, monthModeNodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MapData::VT_MONTHMODENODEID,
            monthModeNodeId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2MapDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2MapDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2MapData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2MapData");
        ds.field("nodes", &self.nodes());
        ds.field("zones", &self.zones());
        ds.field("mapConfig", &self.mapConfig());
        ds.field("centerNodeId", &self.centerNodeId());
        ds.field("monthModeNodeId", &self.monthModeNodeId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2MapDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2MapData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2MapData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2MapData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2MapData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2MapData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2MapDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2MapData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2MapDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2MapData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2MapData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2MapData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2MapData>>(
                    dict__string__clz_Torappu_SandboxV2MapData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2MapData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2MapData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2MapDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2MapDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2MapDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2MapDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2MapDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2MapData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapData>>(
                dict__string__clz_Torappu_SandboxV2MapData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2MapDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2MapDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2MapData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_SandboxV2MapData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2MapData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2MapData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2ItemTrapDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ItemTrapData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ItemTrapData<'a> {
    type Inner = clz_Torappu_SandboxV2ItemTrapData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ItemTrapData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_TRAPID: flatbuffers::VOffsetT = 6;
    pub const VT_TRAPPHASE: flatbuffers::VOffsetT = 8;
    pub const VT_TRAPLEVEL: flatbuffers::VOffsetT = 10;
    pub const VT_SKILLINDEX: flatbuffers::VOffsetT = 12;
    pub const VT_SKILLLEVEL: flatbuffers::VOffsetT = 14;
    pub const VT_BUILDINGLEVEL: flatbuffers::VOffsetT = 16;
    pub const VT_UPDATEDITEMID: flatbuffers::VOffsetT = 18;
    pub const VT_MINLEVELITEMID: flatbuffers::VOffsetT = 20;
    pub const VT_BASEITEMNAME: flatbuffers::VOffsetT = 22;
    pub const VT_ITEMTYPE: flatbuffers::VOffsetT = 24;
    pub const VT_ITEMTAG: flatbuffers::VOffsetT = 26;
    pub const VT_BUFFID: flatbuffers::VOffsetT = 28;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ItemTrapData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ItemTrapDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ItemTrapData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ItemTrapDataBuilder::new(_fbb);
        if let Some(x) = args.buffId {
            builder.add_buffId(x);
        }
        builder.add_itemTag(args.itemTag);
        builder.add_itemType(args.itemType);
        if let Some(x) = args.baseItemName {
            builder.add_baseItemName(x);
        }
        if let Some(x) = args.minLevelItemId {
            builder.add_minLevelItemId(x);
        }
        if let Some(x) = args.updatedItemId {
            builder.add_updatedItemId(x);
        }
        builder.add_buildingLevel(args.buildingLevel);
        builder.add_skillLevel(args.skillLevel);
        builder.add_skillIndex(args.skillIndex);
        builder.add_trapLevel(args.trapLevel);
        builder.add_trapPhase(args.trapPhase);
        if let Some(x) = args.trapId {
            builder.add_trapId(x);
        }
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ItemTrapData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn trapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ItemTrapData::VT_TRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn trapPhase(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ItemTrapData::VT_TRAPPHASE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn trapLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ItemTrapData::VT_TRAPLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn skillIndex(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ItemTrapData::VT_SKILLINDEX, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn skillLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ItemTrapData::VT_SKILLLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn buildingLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ItemTrapData::VT_BUILDINGLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn updatedItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ItemTrapData::VT_UPDATEDITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn minLevelItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ItemTrapData::VT_MINLEVELITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn baseItemName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ItemTrapData::VT_BASEITEMNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn itemType(&self) -> enum__Torappu_SandboxV2TrapItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2TrapItemType>(
                    clz_Torappu_SandboxV2ItemTrapData::VT_ITEMTYPE,
                    Some(enum__Torappu_SandboxV2TrapItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn itemTag(&self) -> enum__Torappu_SandboxV2ItemTrapTag {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2ItemTrapTag>(
                    clz_Torappu_SandboxV2ItemTrapData::VT_ITEMTAG,
                    Some(enum__Torappu_SandboxV2ItemTrapTag::OUTPUT),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn buffId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ItemTrapData::VT_BUFFID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ItemTrapData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("trapId", Self::VT_TRAPID, false)?
            .visit_field::<i32>("trapPhase", Self::VT_TRAPPHASE, false)?
            .visit_field::<i32>("trapLevel", Self::VT_TRAPLEVEL, false)?
            .visit_field::<i32>("skillIndex", Self::VT_SKILLINDEX, false)?
            .visit_field::<i32>("skillLevel", Self::VT_SKILLLEVEL, false)?
            .visit_field::<i32>("buildingLevel", Self::VT_BUILDINGLEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "updatedItemId",
                Self::VT_UPDATEDITEMID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "minLevelItemId",
                Self::VT_MINLEVELITEMID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "baseItemName",
                Self::VT_BASEITEMNAME,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxV2TrapItemType>(
                "itemType",
                Self::VT_ITEMTYPE,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxV2ItemTrapTag>("itemTag", Self::VT_ITEMTAG, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buffId", Self::VT_BUFFID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ItemTrapDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trapPhase: i32,
    pub trapLevel: i32,
    pub skillIndex: i32,
    pub skillLevel: i32,
    pub buildingLevel: i32,
    pub updatedItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub minLevelItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub baseItemName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemType: enum__Torappu_SandboxV2TrapItemType,
    pub itemTag: enum__Torappu_SandboxV2ItemTrapTag,
    pub buffId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ItemTrapDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ItemTrapDataArgs {
            itemId: None,
            trapId: None,
            trapPhase: 0,
            trapLevel: 0,
            skillIndex: 0,
            skillLevel: 0,
            buildingLevel: 0,
            updatedItemId: None,
            minLevelItemId: None,
            baseItemName: None,
            itemType: enum__Torappu_SandboxV2TrapItemType::NONE,
            itemTag: enum__Torappu_SandboxV2ItemTrapTag::OUTPUT,
            buffId: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2ItemTrapDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ItemTrapDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ItemTrapData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_trapId(&mut self, trapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ItemTrapData::VT_TRAPID,
            trapId,
        );
    }
    #[inline]
    pub fn add_trapPhase(&mut self, trapPhase: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ItemTrapData::VT_TRAPPHASE,
            trapPhase,
            0,
        );
    }
    #[inline]
    pub fn add_trapLevel(&mut self, trapLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ItemTrapData::VT_TRAPLEVEL,
            trapLevel,
            0,
        );
    }
    #[inline]
    pub fn add_skillIndex(&mut self, skillIndex: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ItemTrapData::VT_SKILLINDEX,
            skillIndex,
            0,
        );
    }
    #[inline]
    pub fn add_skillLevel(&mut self, skillLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ItemTrapData::VT_SKILLLEVEL,
            skillLevel,
            0,
        );
    }
    #[inline]
    pub fn add_buildingLevel(&mut self, buildingLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ItemTrapData::VT_BUILDINGLEVEL,
            buildingLevel,
            0,
        );
    }
    #[inline]
    pub fn add_updatedItemId(&mut self, updatedItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ItemTrapData::VT_UPDATEDITEMID,
            updatedItemId,
        );
    }
    #[inline]
    pub fn add_minLevelItemId(&mut self, minLevelItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ItemTrapData::VT_MINLEVELITEMID,
            minLevelItemId,
        );
    }
    #[inline]
    pub fn add_baseItemName(&mut self, baseItemName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ItemTrapData::VT_BASEITEMNAME,
            baseItemName,
        );
    }
    #[inline]
    pub fn add_itemType(&mut self, itemType: enum__Torappu_SandboxV2TrapItemType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2TrapItemType>(
            clz_Torappu_SandboxV2ItemTrapData::VT_ITEMTYPE,
            itemType,
            enum__Torappu_SandboxV2TrapItemType::NONE,
        );
    }
    #[inline]
    pub fn add_itemTag(&mut self, itemTag: enum__Torappu_SandboxV2ItemTrapTag) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2ItemTrapTag>(
            clz_Torappu_SandboxV2ItemTrapData::VT_ITEMTAG,
            itemTag,
            enum__Torappu_SandboxV2ItemTrapTag::OUTPUT,
        );
    }
    #[inline]
    pub fn add_buffId(&mut self, buffId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ItemTrapData::VT_BUFFID,
            buffId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ItemTrapDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ItemTrapDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ItemTrapData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ItemTrapData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ItemTrapData");
        ds.field("itemId", &self.itemId());
        ds.field("trapId", &self.trapId());
        ds.field("trapPhase", &self.trapPhase());
        ds.field("trapLevel", &self.trapLevel());
        ds.field("skillIndex", &self.skillIndex());
        ds.field("skillLevel", &self.skillLevel());
        ds.field("buildingLevel", &self.buildingLevel());
        ds.field("updatedItemId", &self.updatedItemId());
        ds.field("minLevelItemId", &self.minLevelItemId());
        ds.field("baseItemName", &self.baseItemName());
        ds.field("itemType", &self.itemType());
        ds.field("itemTag", &self.itemTag());
        ds.field("buffId", &self.buffId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ItemTrapDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ItemTrapData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2ItemTrapData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2ItemTrapData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ItemTrapData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ItemTrapData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ItemTrapDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ItemTrapData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2ItemTrapDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ItemTrapData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2ItemTrapData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ItemTrapData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ItemTrapData>>(
                    dict__string__clz_Torappu_SandboxV2ItemTrapData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ItemTrapData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ItemTrapData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ItemTrapDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ItemTrapData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ItemTrapDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ItemTrapDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ItemTrapDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ItemTrapDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ItemTrapData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ItemTrapData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ItemTrapData>>(
                dict__string__clz_Torappu_SandboxV2ItemTrapData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ItemTrapDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ItemTrapDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ItemTrapData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ItemTrapData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ItemTrapData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2ItemTrapData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2ItemTrapTagDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ItemTrapTagData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ItemTrapTagData<'a> {
    type Inner = clz_Torappu_SandboxV2ItemTrapTagData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ItemTrapTagData<'a> {
    pub const VT_TAG: flatbuffers::VOffsetT = 4;
    pub const VT_TAGNAME: flatbuffers::VOffsetT = 6;
    pub const VT_TAGPIC: flatbuffers::VOffsetT = 8;
    pub const VT_SORTID: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ItemTrapTagData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ItemTrapTagDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ItemTrapTagData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ItemTrapTagDataBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.tagPic {
            builder.add_tagPic(x);
        }
        if let Some(x) = args.tagName {
            builder.add_tagName(x);
        }
        builder.add_tag(args.tag);
        builder.finish()
    }

    #[inline]
    pub fn tag(&self) -> enum__Torappu_SandboxV2ItemTrapTag {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2ItemTrapTag>(
                    clz_Torappu_SandboxV2ItemTrapTagData::VT_TAG,
                    Some(enum__Torappu_SandboxV2ItemTrapTag::OUTPUT),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn tagName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ItemTrapTagData::VT_TAGNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn tagPic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ItemTrapTagData::VT_TAGPIC,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ItemTrapTagData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ItemTrapTagData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxV2ItemTrapTag>("tag", Self::VT_TAG, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tagName", Self::VT_TAGNAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tagPic", Self::VT_TAGPIC, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ItemTrapTagDataArgs<'a> {
    pub tag: enum__Torappu_SandboxV2ItemTrapTag,
    pub tagName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tagPic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2ItemTrapTagDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ItemTrapTagDataArgs {
            tag: enum__Torappu_SandboxV2ItemTrapTag::OUTPUT,
            tagName: None,
            tagPic: None,
            sortId: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2ItemTrapTagDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ItemTrapTagDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_tag(&mut self, tag: enum__Torappu_SandboxV2ItemTrapTag) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2ItemTrapTag>(
            clz_Torappu_SandboxV2ItemTrapTagData::VT_TAG,
            tag,
            enum__Torappu_SandboxV2ItemTrapTag::OUTPUT,
        );
    }
    #[inline]
    pub fn add_tagName(&mut self, tagName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ItemTrapTagData::VT_TAGNAME,
            tagName,
        );
    }
    #[inline]
    pub fn add_tagPic(&mut self, tagPic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ItemTrapTagData::VT_TAGPIC,
            tagPic,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2ItemTrapTagData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ItemTrapTagDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ItemTrapTagDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ItemTrapTagData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ItemTrapTagData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ItemTrapTagData");
        ds.field("tag", &self.tag());
        ds.field("tagName", &self.tagName());
        ds.field("tagPic", &self.tagPic());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ItemTrapTagDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ItemTrapTagData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ItemTrapTagDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2ItemTrapTagDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ItemTrapTagData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2ItemTrapTagData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ItemTrapTagData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ItemTrapTagData>>(
                    dict__string__clz_Torappu_SandboxV2ItemTrapTagData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ItemTrapTagData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ItemTrapTagDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ItemTrapTagData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ItemTrapTagDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ItemTrapTagDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ItemTrapTagDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ItemTrapTagDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ItemTrapTagData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ItemTrapTagData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ItemTrapTagData>>(
                dict__string__clz_Torappu_SandboxV2ItemTrapTagData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ItemTrapTagDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ItemTrapTagDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ItemTrapTagData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2ItemTrapTagData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2BuildingItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2BuildingItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2BuildingItemData<'a> {
    type Inner = clz_Torappu_SandboxV2BuildingItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2BuildingItemData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_ITEMRARITY: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2BuildingItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2BuildingItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BuildingItemData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2BuildingItemDataBuilder::new(_fbb);
        builder.add_itemRarity(args.itemRarity);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BuildingItemData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn itemRarity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BuildingItemData::VT_ITEMRARITY,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2BuildingItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<i32>("itemRarity", Self::VT_ITEMRARITY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2BuildingItemDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemRarity: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2BuildingItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2BuildingItemDataArgs {
            itemId: None,
            itemRarity: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2BuildingItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2BuildingItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BuildingItemData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_itemRarity(&mut self, itemRarity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BuildingItemData::VT_ITEMRARITY,
            itemRarity,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2BuildingItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2BuildingItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BuildingItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2BuildingItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2BuildingItemData");
        ds.field("itemId", &self.itemId());
        ds.field("itemRarity", &self.itemRarity());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2BuildingItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2BuildingItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2BuildingItemData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2BuildingItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2BuildingItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2BuildingItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2BuildingItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2BuildingItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2BuildingItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2BuildingItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2BuildingItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2BuildingItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BuildingItemData>>(
                    dict__string__clz_Torappu_SandboxV2BuildingItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2BuildingItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BuildingItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2BuildingItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2BuildingItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2BuildingItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2BuildingItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2BuildingItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2BuildingItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2BuildingItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2BuildingItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2BuildingItemData>>(
                dict__string__clz_Torappu_SandboxV2BuildingItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2BuildingItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2BuildingItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2BuildingItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2BuildingItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2BuildingItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2BuildingItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum dict__string__intOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__int<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__int<'a> {
    type Inner = dict__string__int<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__int<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__int { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__intArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__int<'bldr>> {
        let mut builder = dict__string__intBuilder::new(_fbb);
        builder.add_value(args.value);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__int::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__int) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(dict__string__int::VT_VALUE, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for dict__string__int<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<i32>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__intArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: i32,
}
impl<'a> Default for dict__string__intArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__intArgs {
            key: None, // required field
            value: 0,
        }
    }
}

pub struct dict__string__intBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__intBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__int::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(&mut self, value: i32) {
        self.fbb_
            .push_slot::<i32>(dict__string__int::VT_VALUE, value, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__intBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__intBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__int<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, dict__string__int::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__int<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__int");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2CraftItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2CraftItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2CraftItemData<'a> {
    type Inner = clz_Torappu_SandboxV2CraftItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2CraftItemData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_BUILDINGUNLOCKDESC: flatbuffers::VOffsetT = 8;
    pub const VT_MATERIALITEMS: flatbuffers::VOffsetT = 10;
    pub const VT_UPGRADEITEMS: flatbuffers::VOffsetT = 12;
    pub const VT_OUTPUTRATIO: flatbuffers::VOffsetT = 14;
    pub const VT_WITHDRAWRATIO: flatbuffers::VOffsetT = 16;
    pub const VT_REPAIRCOST: flatbuffers::VOffsetT = 18;
    pub const VT_ISHIDDEN: flatbuffers::VOffsetT = 20;
    pub const VT_CRAFTGROUPID: flatbuffers::VOffsetT = 22;
    pub const VT_RECIPELEVEL: flatbuffers::VOffsetT = 24;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2CraftItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2CraftItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2CraftItemData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2CraftItemDataBuilder::new(_fbb);
        builder.add_recipeLevel(args.recipeLevel);
        if let Some(x) = args.craftGroupId {
            builder.add_craftGroupId(x);
        }
        builder.add_repairCost(args.repairCost);
        builder.add_withdrawRatio(args.withdrawRatio);
        builder.add_outputRatio(args.outputRatio);
        if let Some(x) = args.upgradeItems {
            builder.add_upgradeItems(x);
        }
        if let Some(x) = args.materialItems {
            builder.add_materialItems(x);
        }
        if let Some(x) = args.buildingUnlockDesc {
            builder.add_buildingUnlockDesc(x);
        }
        builder.add_type_(args.type_);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.add_isHidden(args.isHidden);
        builder.finish()
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2CraftItemData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_SandboxV2CraftItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2CraftItemType>(
                    clz_Torappu_SandboxV2CraftItemData::VT_TYPE_,
                    Some(enum__Torappu_SandboxV2CraftItemType::BASE_BUILDING),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn buildingUnlockDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2CraftItemData::VT_BUILDINGUNLOCKDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn materialItems(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>(clz_Torappu_SandboxV2CraftItemData::VT_MATERIALITEMS, None)
        }
    }
    #[inline]
    pub fn upgradeItems(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>(clz_Torappu_SandboxV2CraftItemData::VT_UPGRADEITEMS, None)
        }
    }
    #[inline]
    pub fn outputRatio(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2CraftItemData::VT_OUTPUTRATIO, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn withdrawRatio(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2CraftItemData::VT_WITHDRAWRATIO,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn repairCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2CraftItemData::VT_REPAIRCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn isHidden(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_SandboxV2CraftItemData::VT_ISHIDDEN, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn craftGroupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2CraftItemData::VT_CRAFTGROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn recipeLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2CraftItemData::VT_RECIPELEVEL, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2CraftItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<enum__Torappu_SandboxV2CraftItemType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buildingUnlockDesc",
                Self::VT_BUILDINGUNLOCKDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>("materialItems", Self::VT_MATERIALITEMS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>("upgradeItems", Self::VT_UPGRADEITEMS, false)?
            .visit_field::<i32>("outputRatio", Self::VT_OUTPUTRATIO, false)?
            .visit_field::<i32>("withdrawRatio", Self::VT_WITHDRAWRATIO, false)?
            .visit_field::<i32>("repairCost", Self::VT_REPAIRCOST, false)?
            .visit_field::<bool>("isHidden", Self::VT_ISHIDDEN, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "craftGroupId",
                Self::VT_CRAFTGROUPID,
                false,
            )?
            .visit_field::<i32>("recipeLevel", Self::VT_RECIPELEVEL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2CraftItemDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_SandboxV2CraftItemType,
    pub buildingUnlockDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub materialItems: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>,
        >,
    >,
    pub upgradeItems: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>,
        >,
    >,
    pub outputRatio: i32,
    pub withdrawRatio: i32,
    pub repairCost: i32,
    pub isHidden: bool,
    pub craftGroupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub recipeLevel: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2CraftItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2CraftItemDataArgs {
            itemId: None,
            type_: enum__Torappu_SandboxV2CraftItemType::BASE_BUILDING,
            buildingUnlockDesc: None,
            materialItems: None,
            upgradeItems: None,
            outputRatio: 0,
            withdrawRatio: 0,
            repairCost: 0,
            isHidden: false,
            craftGroupId: None,
            recipeLevel: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2CraftItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2CraftItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2CraftItemData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_SandboxV2CraftItemType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2CraftItemType>(
            clz_Torappu_SandboxV2CraftItemData::VT_TYPE_,
            type_,
            enum__Torappu_SandboxV2CraftItemType::BASE_BUILDING,
        );
    }
    #[inline]
    pub fn add_buildingUnlockDesc(&mut self, buildingUnlockDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2CraftItemData::VT_BUILDINGUNLOCKDESC,
            buildingUnlockDesc,
        );
    }
    #[inline]
    pub fn add_materialItems(
        &mut self,
        materialItems: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__int<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2CraftItemData::VT_MATERIALITEMS,
            materialItems,
        );
    }
    #[inline]
    pub fn add_upgradeItems(
        &mut self,
        upgradeItems: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__int<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2CraftItemData::VT_UPGRADEITEMS,
            upgradeItems,
        );
    }
    #[inline]
    pub fn add_outputRatio(&mut self, outputRatio: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2CraftItemData::VT_OUTPUTRATIO,
            outputRatio,
            0,
        );
    }
    #[inline]
    pub fn add_withdrawRatio(&mut self, withdrawRatio: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2CraftItemData::VT_WITHDRAWRATIO,
            withdrawRatio,
            0,
        );
    }
    #[inline]
    pub fn add_repairCost(&mut self, repairCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2CraftItemData::VT_REPAIRCOST,
            repairCost,
            0,
        );
    }
    #[inline]
    pub fn add_isHidden(&mut self, isHidden: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SandboxV2CraftItemData::VT_ISHIDDEN,
            isHidden,
            false,
        );
    }
    #[inline]
    pub fn add_craftGroupId(&mut self, craftGroupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2CraftItemData::VT_CRAFTGROUPID,
            craftGroupId,
        );
    }
    #[inline]
    pub fn add_recipeLevel(&mut self, recipeLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2CraftItemData::VT_RECIPELEVEL,
            recipeLevel,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2CraftItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2CraftItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2CraftItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2CraftItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2CraftItemData");
        ds.field("itemId", &self.itemId());
        ds.field("type_", &self.type_());
        ds.field("buildingUnlockDesc", &self.buildingUnlockDesc());
        ds.field("materialItems", &self.materialItems());
        ds.field("upgradeItems", &self.upgradeItems());
        ds.field("outputRatio", &self.outputRatio());
        ds.field("withdrawRatio", &self.withdrawRatio());
        ds.field("repairCost", &self.repairCost());
        ds.field("isHidden", &self.isHidden());
        ds.field("craftGroupId", &self.craftGroupId());
        ds.field("recipeLevel", &self.recipeLevel());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2CraftItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2CraftItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2CraftItemData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2CraftItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2CraftItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2CraftItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2CraftItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2CraftItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2CraftItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2CraftItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2CraftItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2CraftItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2CraftItemData>>(
                    dict__string__clz_Torappu_SandboxV2CraftItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2CraftItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2CraftItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2CraftItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2CraftItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2CraftItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2CraftItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2CraftItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2CraftItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2CraftItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2CraftItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2CraftItemData>>(
                dict__string__clz_Torappu_SandboxV2CraftItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2CraftItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2CraftItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2CraftItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2CraftItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2CraftItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2CraftItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2LivestockDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2LivestockData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2LivestockData<'a> {
    type Inner = clz_Torappu_SandboxV2LivestockData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2LivestockData<'a> {
    pub const VT_LIVESTOCKITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_SHINYLIVESTOCKITEMID: flatbuffers::VOffsetT = 6;
    pub const VT_LIVESTOCKENEMYID: flatbuffers::VOffsetT = 8;
    pub const VT_TARGETFENCEID: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2LivestockData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2LivestockDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2LivestockData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2LivestockDataBuilder::new(_fbb);
        if let Some(x) = args.targetFenceId {
            builder.add_targetFenceId(x);
        }
        if let Some(x) = args.livestockEnemyId {
            builder.add_livestockEnemyId(x);
        }
        if let Some(x) = args.shinyLivestockItemId {
            builder.add_shinyLivestockItemId(x);
        }
        if let Some(x) = args.livestockItemId {
            builder.add_livestockItemId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn livestockItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2LivestockData::VT_LIVESTOCKITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn shinyLivestockItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2LivestockData::VT_SHINYLIVESTOCKITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn livestockEnemyId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2LivestockData::VT_LIVESTOCKENEMYID,
                None,
            )
        }
    }
    #[inline]
    pub fn targetFenceId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2LivestockData::VT_TARGETFENCEID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2LivestockData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "livestockItemId",
                Self::VT_LIVESTOCKITEMID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "shinyLivestockItemId",
                Self::VT_SHINYLIVESTOCKITEMID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "livestockEnemyId",
                Self::VT_LIVESTOCKENEMYID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "targetFenceId",
                Self::VT_TARGETFENCEID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2LivestockDataArgs<'a> {
    pub livestockItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub shinyLivestockItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub livestockEnemyId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub targetFenceId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2LivestockDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2LivestockDataArgs {
            livestockItemId: None,
            shinyLivestockItemId: None,
            livestockEnemyId: None,
            targetFenceId: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2LivestockDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2LivestockDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_livestockItemId(&mut self, livestockItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2LivestockData::VT_LIVESTOCKITEMID,
            livestockItemId,
        );
    }
    #[inline]
    pub fn add_shinyLivestockItemId(
        &mut self,
        shinyLivestockItemId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2LivestockData::VT_SHINYLIVESTOCKITEMID,
            shinyLivestockItemId,
        );
    }
    #[inline]
    pub fn add_livestockEnemyId(&mut self, livestockEnemyId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2LivestockData::VT_LIVESTOCKENEMYID,
            livestockEnemyId,
        );
    }
    #[inline]
    pub fn add_targetFenceId(&mut self, targetFenceId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2LivestockData::VT_TARGETFENCEID,
            targetFenceId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2LivestockDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2LivestockDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2LivestockData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2LivestockData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2LivestockData");
        ds.field("livestockItemId", &self.livestockItemId());
        ds.field("shinyLivestockItemId", &self.shinyLivestockItemId());
        ds.field("livestockEnemyId", &self.livestockEnemyId());
        ds.field("targetFenceId", &self.targetFenceId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2LivestockDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2LivestockData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2LivestockData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2LivestockData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2LivestockData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2LivestockData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2LivestockDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2LivestockData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2LivestockDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2LivestockData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2LivestockData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2LivestockData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LivestockData>>(
                    dict__string__clz_Torappu_SandboxV2LivestockData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2LivestockData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LivestockData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2LivestockDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2LivestockData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2LivestockDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2LivestockDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2LivestockDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2LivestockDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2LivestockData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2LivestockData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2LivestockData>>(
                dict__string__clz_Torappu_SandboxV2LivestockData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2LivestockDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2LivestockDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2LivestockData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2LivestockData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2LivestockData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2LivestockData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2CraftGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2CraftGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2CraftGroupData<'a> {
    type Inner = clz_Torappu_SandboxV2CraftGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2CraftGroupData<'a> {
    pub const VT_ITEMS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2CraftGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2CraftGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2CraftGroupData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2CraftGroupDataBuilder::new(_fbb);
        if let Some(x) = args.items {
            builder.add_items(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn items(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxV2CraftGroupData::VT_ITEMS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2CraftGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("items", Self::VT_ITEMS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2CraftGroupDataArgs<'a> {
    pub items: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2CraftGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2CraftGroupDataArgs { items: None }
    }
}

pub struct clz_Torappu_SandboxV2CraftGroupDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2CraftGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_items(
        &mut self,
        items: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2CraftGroupData::VT_ITEMS,
            items,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2CraftGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2CraftGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2CraftGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2CraftGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2CraftGroupData");
        ds.field("items", &self.items());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2CraftGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2CraftGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2CraftGroupData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2CraftGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2CraftGroupData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2CraftGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2CraftGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2CraftGroupData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2CraftGroupDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2CraftGroupData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2CraftGroupData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2CraftGroupData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2CraftGroupData>>(
                    dict__string__clz_Torappu_SandboxV2CraftGroupData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2CraftGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2CraftGroupData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2CraftGroupDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2CraftGroupData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2CraftGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2CraftGroupDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2CraftGroupDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2CraftGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2CraftGroupData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2CraftGroupData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2CraftGroupData>>(
                dict__string__clz_Torappu_SandboxV2CraftGroupData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2CraftGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2CraftGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2CraftGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2CraftGroupData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2CraftGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2CraftGroupData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2AlchemyMaterialDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2AlchemyMaterialData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2AlchemyMaterialData<'a> {
    type Inner = clz_Torappu_SandboxV2AlchemyMaterialData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2AlchemyMaterialData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_COUNT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2AlchemyMaterialData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2AlchemyMaterialDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2AlchemyMaterialData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2AlchemyMaterialDataBuilder::new(_fbb);
        builder.add_count(args.count);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2AlchemyMaterialData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2AlchemyMaterialData::VT_COUNT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2AlchemyMaterialData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2AlchemyMaterialDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2AlchemyMaterialDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2AlchemyMaterialDataArgs {
            itemId: None,
            count: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2AlchemyMaterialDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2AlchemyMaterialDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2AlchemyMaterialData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2AlchemyMaterialData::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2AlchemyMaterialDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2AlchemyMaterialDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2AlchemyMaterialData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2AlchemyMaterialData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2AlchemyMaterialData");
        ds.field("itemId", &self.itemId());
        ds.field("count", &self.count());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2AlchemyRecipeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2AlchemyRecipeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2AlchemyRecipeData<'a> {
    type Inner = clz_Torappu_SandboxV2AlchemyRecipeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2AlchemyRecipeData<'a> {
    pub const VT_RECIPEID: flatbuffers::VOffsetT = 4;
    pub const VT_MATERIALS: flatbuffers::VOffsetT = 6;
    pub const VT_ITEMID: flatbuffers::VOffsetT = 8;
    pub const VT_ONCEALCHEMYRATIO: flatbuffers::VOffsetT = 10;
    pub const VT_RECIPELEVEL: flatbuffers::VOffsetT = 12;
    pub const VT_UNLOCKDESC: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2AlchemyRecipeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2AlchemyRecipeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2AlchemyRecipeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2AlchemyRecipeDataBuilder::new(_fbb);
        if let Some(x) = args.unlockDesc {
            builder.add_unlockDesc(x);
        }
        builder.add_recipeLevel(args.recipeLevel);
        builder.add_onceAlchemyRatio(args.onceAlchemyRatio);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        if let Some(x) = args.materials {
            builder.add_materials(x);
        }
        if let Some(x) = args.recipeId {
            builder.add_recipeId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn recipeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2AlchemyRecipeData::VT_RECIPEID,
                None,
            )
        }
    }
    #[inline]
    pub fn materials(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2AlchemyMaterialData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2AlchemyMaterialData>,
                >,
            >>(clz_Torappu_SandboxV2AlchemyRecipeData::VT_MATERIALS, None)
        }
    }
    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2AlchemyRecipeData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn onceAlchemyRatio(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2AlchemyRecipeData::VT_ONCEALCHEMYRATIO,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn recipeLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2AlchemyRecipeData::VT_RECIPELEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2AlchemyRecipeData::VT_UNLOCKDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2AlchemyRecipeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "recipeId",
                Self::VT_RECIPEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2AlchemyMaterialData>,
                >,
            >>("materials", Self::VT_MATERIALS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<i32>("onceAlchemyRatio", Self::VT_ONCEALCHEMYRATIO, false)?
            .visit_field::<i32>("recipeLevel", Self::VT_RECIPELEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockDesc",
                Self::VT_UNLOCKDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2AlchemyRecipeDataArgs<'a> {
    pub recipeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub materials: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2AlchemyMaterialData<'a>>,
            >,
        >,
    >,
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub onceAlchemyRatio: i32,
    pub recipeLevel: i32,
    pub unlockDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2AlchemyRecipeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2AlchemyRecipeDataArgs {
            recipeId: None,
            materials: None,
            itemId: None,
            onceAlchemyRatio: 0,
            recipeLevel: 0,
            unlockDesc: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2AlchemyRecipeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2AlchemyRecipeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_recipeId(&mut self, recipeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2AlchemyRecipeData::VT_RECIPEID,
            recipeId,
        );
    }
    #[inline]
    pub fn add_materials(
        &mut self,
        materials: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2AlchemyMaterialData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2AlchemyRecipeData::VT_MATERIALS,
            materials,
        );
    }
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2AlchemyRecipeData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_onceAlchemyRatio(&mut self, onceAlchemyRatio: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2AlchemyRecipeData::VT_ONCEALCHEMYRATIO,
            onceAlchemyRatio,
            0,
        );
    }
    #[inline]
    pub fn add_recipeLevel(&mut self, recipeLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2AlchemyRecipeData::VT_RECIPELEVEL,
            recipeLevel,
            0,
        );
    }
    #[inline]
    pub fn add_unlockDesc(&mut self, unlockDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2AlchemyRecipeData::VT_UNLOCKDESC,
            unlockDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2AlchemyRecipeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2AlchemyRecipeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2AlchemyRecipeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2AlchemyRecipeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2AlchemyRecipeData");
        ds.field("recipeId", &self.recipeId());
        ds.field("materials", &self.materials());
        ds.field("itemId", &self.itemId());
        ds.field("onceAlchemyRatio", &self.onceAlchemyRatio());
        ds.field("recipeLevel", &self.recipeLevel());
        ds.field("unlockDesc", &self.unlockDesc());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2AlchemyRecipeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2AlchemyRecipeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2AlchemyRecipeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2AlchemyRecipeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2AlchemyRecipeData>>(
                    dict__string__clz_Torappu_SandboxV2AlchemyRecipeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2AlchemyRecipeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2AlchemyRecipeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2AlchemyRecipeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2AlchemyRecipeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2AlchemyRecipeData>>(
                dict__string__clz_Torappu_SandboxV2AlchemyRecipeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2AlchemyRecipeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2AlchemyRecipeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2DrinkMatDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2DrinkMatData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2DrinkMatData<'a> {
    type Inner = clz_Torappu_SandboxV2DrinkMatData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2DrinkMatData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_COUNT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2DrinkMatData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2DrinkMatDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DrinkMatData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2DrinkMatDataBuilder::new(_fbb);
        builder.add_count(args.count);
        builder.add_type_(args.type_);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DrinkMatData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_SandboxPermItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxPermItemType>(
                    clz_Torappu_SandboxV2DrinkMatData::VT_TYPE_,
                    Some(enum__Torappu_SandboxPermItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2DrinkMatData::VT_COUNT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2DrinkMatData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_SandboxPermItemType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2DrinkMatDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_SandboxPermItemType,
    pub count: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2DrinkMatDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2DrinkMatDataArgs {
            id: None,
            type_: enum__Torappu_SandboxPermItemType::NONE,
            count: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2DrinkMatDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2DrinkMatDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DrinkMatData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_SandboxPermItemType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxPermItemType>(
            clz_Torappu_SandboxV2DrinkMatData::VT_TYPE_,
            type_,
            enum__Torappu_SandboxPermItemType::NONE,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2DrinkMatData::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2DrinkMatDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2DrinkMatDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DrinkMatData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2DrinkMatData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2DrinkMatData");
        ds.field("id", &self.id());
        ds.field("type_", &self.type_());
        ds.field("count", &self.count());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2DrinkMatDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2DrinkMatData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2DrinkMatData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2DrinkMatData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2DrinkMatData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2DrinkMatData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2DrinkMatDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2DrinkMatData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2DrinkMatDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2DrinkMatData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2DrinkMatData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2DrinkMatData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DrinkMatData>>(
                    dict__string__clz_Torappu_SandboxV2DrinkMatData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2DrinkMatData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DrinkMatData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2DrinkMatDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2DrinkMatData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2DrinkMatDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2DrinkMatDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2DrinkMatDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2DrinkMatDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2DrinkMatData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2DrinkMatData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2DrinkMatData>>(
                dict__string__clz_Torappu_SandboxV2DrinkMatData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2DrinkMatDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2DrinkMatDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2DrinkMatData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2DrinkMatData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2DrinkMatData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2DrinkMatData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2FoodMatDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2FoodMatData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2FoodMatData<'a> {
    type Inner = clz_Torappu_SandboxV2FoodMatData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2FoodMatData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_ATTRIBUTE: flatbuffers::VOffsetT = 8;
    pub const VT_VARIANTTYPE: flatbuffers::VOffsetT = 10;
    pub const VT_BONUSDURATION: flatbuffers::VOffsetT = 12;
    pub const VT_BUFFDESC: flatbuffers::VOffsetT = 14;
    pub const VT_SORTID: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2FoodMatData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2FoodMatDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodMatData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2FoodMatDataBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.buffDesc {
            builder.add_buffDesc(x);
        }
        builder.add_bonusDuration(args.bonusDuration);
        builder.add_variantType(args.variantType);
        builder.add_attribute(args.attribute);
        builder.add_type_(args.type_);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2FoodMatData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_SandboxV2FoodMatType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2FoodMatType>(
                    clz_Torappu_SandboxV2FoodMatData::VT_TYPE_,
                    Some(enum__Torappu_SandboxV2FoodMatType::MAIN),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn attribute(&self) -> enum__Torappu_SandboxV2FoodAttribute {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2FoodAttribute>(
                    clz_Torappu_SandboxV2FoodMatData::VT_ATTRIBUTE,
                    Some(enum__Torappu_SandboxV2FoodAttribute::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn variantType(&self) -> enum__Torappu_SandboxV2FoodVariantType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2FoodVariantType>(
                    clz_Torappu_SandboxV2FoodMatData::VT_VARIANTTYPE,
                    Some(enum__Torappu_SandboxV2FoodVariantType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn bonusDuration(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2FoodMatData::VT_BONUSDURATION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn buffDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2FoodMatData::VT_BUFFDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2FoodMatData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2FoodMatData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_SandboxV2FoodMatType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<enum__Torappu_SandboxV2FoodAttribute>(
                "attribute",
                Self::VT_ATTRIBUTE,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxV2FoodVariantType>(
                "variantType",
                Self::VT_VARIANTTYPE,
                false,
            )?
            .visit_field::<i32>("bonusDuration", Self::VT_BONUSDURATION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffDesc",
                Self::VT_BUFFDESC,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2FoodMatDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_SandboxV2FoodMatType,
    pub attribute: enum__Torappu_SandboxV2FoodAttribute,
    pub variantType: enum__Torappu_SandboxV2FoodVariantType,
    pub bonusDuration: i32,
    pub buffDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2FoodMatDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2FoodMatDataArgs {
            id: None,
            type_: enum__Torappu_SandboxV2FoodMatType::MAIN,
            attribute: enum__Torappu_SandboxV2FoodAttribute::NONE,
            variantType: enum__Torappu_SandboxV2FoodVariantType::NONE,
            bonusDuration: 0,
            buffDesc: None,
            sortId: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2FoodMatDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2FoodMatDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FoodMatData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_SandboxV2FoodMatType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2FoodMatType>(
            clz_Torappu_SandboxV2FoodMatData::VT_TYPE_,
            type_,
            enum__Torappu_SandboxV2FoodMatType::MAIN,
        );
    }
    #[inline]
    pub fn add_attribute(&mut self, attribute: enum__Torappu_SandboxV2FoodAttribute) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2FoodAttribute>(
            clz_Torappu_SandboxV2FoodMatData::VT_ATTRIBUTE,
            attribute,
            enum__Torappu_SandboxV2FoodAttribute::NONE,
        );
    }
    #[inline]
    pub fn add_variantType(&mut self, variantType: enum__Torappu_SandboxV2FoodVariantType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2FoodVariantType>(
                clz_Torappu_SandboxV2FoodMatData::VT_VARIANTTYPE,
                variantType,
                enum__Torappu_SandboxV2FoodVariantType::NONE,
            );
    }
    #[inline]
    pub fn add_bonusDuration(&mut self, bonusDuration: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2FoodMatData::VT_BONUSDURATION,
            bonusDuration,
            0,
        );
    }
    #[inline]
    pub fn add_buffDesc(&mut self, buffDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FoodMatData::VT_BUFFDESC,
            buffDesc,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2FoodMatData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2FoodMatDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2FoodMatDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodMatData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2FoodMatData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2FoodMatData");
        ds.field("id", &self.id());
        ds.field("type_", &self.type_());
        ds.field("attribute", &self.attribute());
        ds.field("variantType", &self.variantType());
        ds.field("bonusDuration", &self.bonusDuration());
        ds.field("buffDesc", &self.buffDesc());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2FoodMatDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2FoodMatData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2FoodMatData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2FoodMatData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2FoodMatData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2FoodMatData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2FoodMatDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2FoodMatData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2FoodMatDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2FoodMatData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2FoodMatData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2FoodMatData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodMatData>>(
                    dict__string__clz_Torappu_SandboxV2FoodMatData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2FoodMatData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodMatData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2FoodMatDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodMatData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2FoodMatDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2FoodMatDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2FoodMatDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2FoodMatDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2FoodMatData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodMatData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodMatData>>(
                dict__string__clz_Torappu_SandboxV2FoodMatData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2FoodMatDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2FoodMatDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2FoodMatData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2FoodMatData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2FoodMatData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2FoodMatData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2FoodRecipeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2FoodRecipeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2FoodRecipeData<'a> {
    type Inner = clz_Torappu_SandboxV2FoodRecipeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2FoodRecipeData<'a> {
    pub const VT_FOODID: flatbuffers::VOffsetT = 4;
    pub const VT_MATS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2FoodRecipeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2FoodRecipeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodRecipeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2FoodRecipeDataBuilder::new(_fbb);
        if let Some(x) = args.mats {
            builder.add_mats(x);
        }
        if let Some(x) = args.foodId {
            builder.add_foodId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn foodId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2FoodRecipeData::VT_FOODID,
                None,
            )
        }
    }
    #[inline]
    pub fn mats(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxV2FoodRecipeData::VT_MATS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2FoodRecipeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("foodId", Self::VT_FOODID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("mats", Self::VT_MATS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2FoodRecipeDataArgs<'a> {
    pub foodId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mats: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2FoodRecipeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2FoodRecipeDataArgs {
            foodId: None,
            mats: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2FoodRecipeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2FoodRecipeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_foodId(&mut self, foodId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FoodRecipeData::VT_FOODID,
            foodId,
        );
    }
    #[inline]
    pub fn add_mats(
        &mut self,
        mats: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FoodRecipeData::VT_MATS,
            mats,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2FoodRecipeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2FoodRecipeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodRecipeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2FoodRecipeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2FoodRecipeData");
        ds.field("foodId", &self.foodId());
        ds.field("mats", &self.mats());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2FoodVariantDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2FoodVariantData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2FoodVariantData<'a> {
    type Inner = clz_Torappu_SandboxV2FoodVariantData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2FoodVariantData<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_USAGE: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2FoodVariantData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2FoodVariantDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodVariantData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2FoodVariantDataBuilder::new(_fbb);
        if let Some(x) = args.usage {
            builder.add_usage(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    #[inline]
    pub fn type_(&self) -> enum__Torappu_SandboxV2FoodVariantType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2FoodVariantType>(
                    clz_Torappu_SandboxV2FoodVariantData::VT_TYPE_,
                    Some(enum__Torappu_SandboxV2FoodVariantType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2FoodVariantData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn usage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2FoodVariantData::VT_USAGE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2FoodVariantData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxV2FoodVariantType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("usage", Self::VT_USAGE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2FoodVariantDataArgs<'a> {
    pub type_: enum__Torappu_SandboxV2FoodVariantType,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub usage: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2FoodVariantDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2FoodVariantDataArgs {
            type_: enum__Torappu_SandboxV2FoodVariantType::NONE,
            name: None,
            usage: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2FoodVariantDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2FoodVariantDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_SandboxV2FoodVariantType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2FoodVariantType>(
                clz_Torappu_SandboxV2FoodVariantData::VT_TYPE_,
                type_,
                enum__Torappu_SandboxV2FoodVariantType::NONE,
            );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FoodVariantData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_usage(&mut self, usage: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FoodVariantData::VT_USAGE,
            usage,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2FoodVariantDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2FoodVariantDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodVariantData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2FoodVariantData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2FoodVariantData");
        ds.field("type_", &self.type_());
        ds.field("name", &self.name());
        ds.field("usage", &self.usage());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2FoodDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2FoodData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2FoodData<'a> {
    type Inner = clz_Torappu_SandboxV2FoodData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2FoodData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 6;
    pub const VT_RECIPES: flatbuffers::VOffsetT = 8;
    pub const VT_VARIANTS: flatbuffers::VOffsetT = 10;
    pub const VT_DURATION: flatbuffers::VOffsetT = 12;
    pub const VT_SORTID: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2FoodData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2FoodDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2FoodDataBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        builder.add_duration(args.duration);
        if let Some(x) = args.variants {
            builder.add_variants(x);
        }
        if let Some(x) = args.recipes {
            builder.add_recipes(x);
        }
        if let Some(x) = args.attributes {
            builder.add_attributes(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2FoodData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn attributes(
        &self,
    ) -> Option<flatbuffers::Vector<'a, enum__Torappu_SandboxV2FoodAttribute>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_SandboxV2FoodAttribute>,
            >>(clz_Torappu_SandboxV2FoodData::VT_ATTRIBUTES, None)
        }
    }
    #[inline]
    pub fn recipes(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodRecipeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodRecipeData>,
                >,
            >>(clz_Torappu_SandboxV2FoodData::VT_RECIPES, None)
        }
    }
    #[inline]
    pub fn variants(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodVariantData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodVariantData>,
                >,
            >>(clz_Torappu_SandboxV2FoodData::VT_VARIANTS, None)
        }
    }
    #[inline]
    pub fn duration(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2FoodData::VT_DURATION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2FoodData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2FoodData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, enum__Torappu_SandboxV2FoodAttribute>,
            >>("attributes", Self::VT_ATTRIBUTES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodRecipeData>,
                >,
            >>("recipes", Self::VT_RECIPES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodVariantData>,
                >,
            >>("variants", Self::VT_VARIANTS, false)?
            .visit_field::<i32>("duration", Self::VT_DURATION, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2FoodDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub attributes: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_SandboxV2FoodAttribute>>,
    >,
    pub recipes: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodRecipeData<'a>>,
            >,
        >,
    >,
    pub variants: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodVariantData<'a>>,
            >,
        >,
    >,
    pub duration: i32,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2FoodDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2FoodDataArgs {
            id: None,
            attributes: None,
            recipes: None,
            variants: None,
            duration: 0,
            sortId: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2FoodDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2FoodDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FoodData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_attributes(
        &mut self,
        attributes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, enum__Torappu_SandboxV2FoodAttribute>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FoodData::VT_ATTRIBUTES,
            attributes,
        );
    }
    #[inline]
    pub fn add_recipes(
        &mut self,
        recipes: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodRecipeData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FoodData::VT_RECIPES,
            recipes,
        );
    }
    #[inline]
    pub fn add_variants(
        &mut self,
        variants: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodVariantData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FoodData::VT_VARIANTS,
            variants,
        );
    }
    #[inline]
    pub fn add_duration(&mut self, duration: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2FoodData::VT_DURATION, duration, 0);
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2FoodData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2FoodDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2FoodDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2FoodData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2FoodData");
        ds.field("id", &self.id());
        ds.field("attributes", &self.attributes());
        ds.field("recipes", &self.recipes());
        ds.field("variants", &self.variants());
        ds.field("duration", &self.duration());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2FoodDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2FoodData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2FoodData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2FoodData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2FoodData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2FoodData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2FoodDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2FoodData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2FoodDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2FoodData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2FoodData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2FoodData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodData>>(
                    dict__string__clz_Torappu_SandboxV2FoodData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2FoodData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2FoodDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2FoodDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2FoodDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2FoodDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2FoodDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2FoodData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodData>>(
                dict__string__clz_Torappu_SandboxV2FoodData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2FoodDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2FoodDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2FoodData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2FoodData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2FoodData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2FoodData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2NodeTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2NodeTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2NodeTypeData<'a> {
    type Inner = clz_Torappu_SandboxV2NodeTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2NodeTypeData<'a> {
    pub const VT_NODETYPE: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_ICONID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2NodeTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2NodeTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeTypeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2NodeTypeDataBuilder::new(_fbb);
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_nodeType(args.nodeType);
        builder.finish()
    }

    #[inline]
    pub fn nodeType(&self) -> enum__Torappu_SandboxV2NodeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2NodeType>(
                    clz_Torappu_SandboxV2NodeTypeData::VT_NODETYPE,
                    Some(enum__Torappu_SandboxV2NodeType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeTypeData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeTypeData::VT_ICONID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2NodeTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxV2NodeType>("nodeType", Self::VT_NODETYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2NodeTypeDataArgs<'a> {
    pub nodeType: enum__Torappu_SandboxV2NodeType,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2NodeTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2NodeTypeDataArgs {
            nodeType: enum__Torappu_SandboxV2NodeType::NONE,
            name: None,
            iconId: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2NodeTypeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2NodeTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeType(&mut self, nodeType: enum__Torappu_SandboxV2NodeType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2NodeType>(
            clz_Torappu_SandboxV2NodeTypeData::VT_NODETYPE,
            nodeType,
            enum__Torappu_SandboxV2NodeType::NONE,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeTypeData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeTypeData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2NodeTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2NodeTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2NodeTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2NodeTypeData");
        ds.field("nodeType", &self.nodeType());
        ds.field("name", &self.name());
        ds.field("iconId", &self.iconId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2NodeTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2NodeTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2NodeTypeData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2NodeTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2NodeTypeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2NodeTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2NodeTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NodeTypeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2NodeTypeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2NodeTypeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2NodeTypeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2NodeTypeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2NodeTypeData>>(
                    dict__string__clz_Torappu_SandboxV2NodeTypeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2NodeTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2NodeTypeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2NodeTypeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeTypeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2NodeTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2NodeTypeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2NodeTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2NodeTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2NodeTypeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeTypeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeTypeData>>(
                dict__string__clz_Torappu_SandboxV2NodeTypeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2NodeTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2NodeTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NodeTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2NodeTypeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2NodeTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2NodeTypeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2NodeUpgradeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2NodeUpgradeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2NodeUpgradeData<'a> {
    type Inner = clz_Torappu_SandboxV2NodeUpgradeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2NodeUpgradeData<'a> {
    pub const VT_NODEUPGRADEID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 8;
    pub const VT_UPGRADEDESC: flatbuffers::VOffsetT = 10;
    pub const VT_UPGRADETIPS: flatbuffers::VOffsetT = 12;
    pub const VT_ITEMTYPE: flatbuffers::VOffsetT = 14;
    pub const VT_ITEMTAG: flatbuffers::VOffsetT = 16;
    pub const VT_ITEMCNT: flatbuffers::VOffsetT = 18;
    pub const VT_ITEMRARITY: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2NodeUpgradeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2NodeUpgradeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeUpgradeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2NodeUpgradeDataBuilder::new(_fbb);
        builder.add_itemRarity(args.itemRarity);
        builder.add_itemCnt(args.itemCnt);
        builder.add_itemTag(args.itemTag);
        builder.add_itemType(args.itemType);
        if let Some(x) = args.upgradeTips {
            builder.add_upgradeTips(x);
        }
        if let Some(x) = args.upgradeDesc {
            builder.add_upgradeDesc(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.nodeUpgradeId {
            builder.add_nodeUpgradeId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn nodeUpgradeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeUpgradeData::VT_NODEUPGRADEID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeUpgradeData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeUpgradeData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn upgradeDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeUpgradeData::VT_UPGRADEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn upgradeTips(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeUpgradeData::VT_UPGRADETIPS,
                None,
            )
        }
    }
    #[inline]
    pub fn itemType(&self) -> enum__Torappu_SandboxPermItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxPermItemType>(
                    clz_Torappu_SandboxV2NodeUpgradeData::VT_ITEMTYPE,
                    Some(enum__Torappu_SandboxPermItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn itemTag(&self) -> enum__Torappu_SandboxV2ItemTrapTag {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2ItemTrapTag>(
                    clz_Torappu_SandboxV2NodeUpgradeData::VT_ITEMTAG,
                    Some(enum__Torappu_SandboxV2ItemTrapTag::OUTPUT),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn itemCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2NodeUpgradeData::VT_ITEMCNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn itemRarity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2NodeUpgradeData::VT_ITEMRARITY, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2NodeUpgradeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nodeUpgradeId",
                Self::VT_NODEUPGRADEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "upgradeDesc",
                Self::VT_UPGRADEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "upgradeTips",
                Self::VT_UPGRADETIPS,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxPermItemType>("itemType", Self::VT_ITEMTYPE, false)?
            .visit_field::<enum__Torappu_SandboxV2ItemTrapTag>("itemTag", Self::VT_ITEMTAG, false)?
            .visit_field::<i32>("itemCnt", Self::VT_ITEMCNT, false)?
            .visit_field::<i32>("itemRarity", Self::VT_ITEMRARITY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2NodeUpgradeDataArgs<'a> {
    pub nodeUpgradeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub upgradeDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub upgradeTips: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemType: enum__Torappu_SandboxPermItemType,
    pub itemTag: enum__Torappu_SandboxV2ItemTrapTag,
    pub itemCnt: i32,
    pub itemRarity: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2NodeUpgradeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2NodeUpgradeDataArgs {
            nodeUpgradeId: None,
            name: None,
            description: None,
            upgradeDesc: None,
            upgradeTips: None,
            itemType: enum__Torappu_SandboxPermItemType::NONE,
            itemTag: enum__Torappu_SandboxV2ItemTrapTag::OUTPUT,
            itemCnt: 0,
            itemRarity: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2NodeUpgradeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2NodeUpgradeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeUpgradeId(&mut self, nodeUpgradeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeUpgradeData::VT_NODEUPGRADEID,
            nodeUpgradeId,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeUpgradeData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeUpgradeData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_upgradeDesc(&mut self, upgradeDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeUpgradeData::VT_UPGRADEDESC,
            upgradeDesc,
        );
    }
    #[inline]
    pub fn add_upgradeTips(&mut self, upgradeTips: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeUpgradeData::VT_UPGRADETIPS,
            upgradeTips,
        );
    }
    #[inline]
    pub fn add_itemType(&mut self, itemType: enum__Torappu_SandboxPermItemType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxPermItemType>(
            clz_Torappu_SandboxV2NodeUpgradeData::VT_ITEMTYPE,
            itemType,
            enum__Torappu_SandboxPermItemType::NONE,
        );
    }
    #[inline]
    pub fn add_itemTag(&mut self, itemTag: enum__Torappu_SandboxV2ItemTrapTag) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2ItemTrapTag>(
            clz_Torappu_SandboxV2NodeUpgradeData::VT_ITEMTAG,
            itemTag,
            enum__Torappu_SandboxV2ItemTrapTag::OUTPUT,
        );
    }
    #[inline]
    pub fn add_itemCnt(&mut self, itemCnt: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2NodeUpgradeData::VT_ITEMCNT, itemCnt, 0);
    }
    #[inline]
    pub fn add_itemRarity(&mut self, itemRarity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2NodeUpgradeData::VT_ITEMRARITY,
            itemRarity,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2NodeUpgradeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2NodeUpgradeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeUpgradeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2NodeUpgradeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2NodeUpgradeData");
        ds.field("nodeUpgradeId", &self.nodeUpgradeId());
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.field("upgradeDesc", &self.upgradeDesc());
        ds.field("upgradeTips", &self.upgradeTips());
        ds.field("itemType", &self.itemType());
        ds.field("itemTag", &self.itemTag());
        ds.field("itemCnt", &self.itemCnt());
        ds.field("itemRarity", &self.itemRarity());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2NodeUpgradeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2NodeUpgradeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2NodeUpgradeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2NodeUpgradeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2NodeUpgradeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2NodeUpgradeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2NodeUpgradeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2NodeUpgradeData>>(
                    dict__string__clz_Torappu_SandboxV2NodeUpgradeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2NodeUpgradeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2NodeUpgradeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeUpgradeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2NodeUpgradeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2NodeUpgradeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2NodeUpgradeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2NodeUpgradeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2NodeUpgradeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeUpgradeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeUpgradeData>>(
                dict__string__clz_Torappu_SandboxV2NodeUpgradeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2NodeUpgradeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2NodeUpgradeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2NodeUpgradeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2NodeUpgradeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2WeatherDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2WeatherData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2WeatherData<'a> {
    type Inner = clz_Torappu_SandboxV2WeatherData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2WeatherData<'a> {
    pub const VT_WEATHERID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_WEATHERLEVEL: flatbuffers::VOffsetT = 8;
    pub const VT_WEATHERTYPE: flatbuffers::VOffsetT = 10;
    pub const VT_WEATHERTYPENAME: flatbuffers::VOffsetT = 12;
    pub const VT_WEATHERICONID: flatbuffers::VOffsetT = 14;
    pub const VT_FUNCTIONDESC: flatbuffers::VOffsetT = 16;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 18;
    pub const VT_BUFFID: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2WeatherData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2WeatherDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2WeatherData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2WeatherDataBuilder::new(_fbb);
        if let Some(x) = args.buffId {
            builder.add_buffId(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.functionDesc {
            builder.add_functionDesc(x);
        }
        if let Some(x) = args.weatherIconId {
            builder.add_weatherIconId(x);
        }
        if let Some(x) = args.weatherTypeName {
            builder.add_weatherTypeName(x);
        }
        builder.add_weatherType(args.weatherType);
        builder.add_weatherLevel(args.weatherLevel);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.weatherId {
            builder.add_weatherId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn weatherId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2WeatherData::VT_WEATHERID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2WeatherData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn weatherLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2WeatherData::VT_WEATHERLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn weatherType(&self) -> enum__Torappu_SandboxV2WeatherType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2WeatherType>(
                    clz_Torappu_SandboxV2WeatherData::VT_WEATHERTYPE,
                    Some(enum__Torappu_SandboxV2WeatherType::NORMAL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn weatherTypeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2WeatherData::VT_WEATHERTYPENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn weatherIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2WeatherData::VT_WEATHERICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn functionDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2WeatherData::VT_FUNCTIONDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2WeatherData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn buffId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2WeatherData::VT_BUFFID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2WeatherData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "weatherId",
                Self::VT_WEATHERID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<i32>("weatherLevel", Self::VT_WEATHERLEVEL, false)?
            .visit_field::<enum__Torappu_SandboxV2WeatherType>(
                "weatherType",
                Self::VT_WEATHERTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "weatherTypeName",
                Self::VT_WEATHERTYPENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "weatherIconId",
                Self::VT_WEATHERICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "functionDesc",
                Self::VT_FUNCTIONDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buffId", Self::VT_BUFFID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2WeatherDataArgs<'a> {
    pub weatherId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weatherLevel: i32,
    pub weatherType: enum__Torappu_SandboxV2WeatherType,
    pub weatherTypeName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weatherIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub functionDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2WeatherDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2WeatherDataArgs {
            weatherId: None,
            name: None,
            weatherLevel: 0,
            weatherType: enum__Torappu_SandboxV2WeatherType::NORMAL,
            weatherTypeName: None,
            weatherIconId: None,
            functionDesc: None,
            description: None,
            buffId: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2WeatherDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2WeatherDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_weatherId(&mut self, weatherId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2WeatherData::VT_WEATHERID,
            weatherId,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2WeatherData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_weatherLevel(&mut self, weatherLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2WeatherData::VT_WEATHERLEVEL,
            weatherLevel,
            0,
        );
    }
    #[inline]
    pub fn add_weatherType(&mut self, weatherType: enum__Torappu_SandboxV2WeatherType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2WeatherType>(
            clz_Torappu_SandboxV2WeatherData::VT_WEATHERTYPE,
            weatherType,
            enum__Torappu_SandboxV2WeatherType::NORMAL,
        );
    }
    #[inline]
    pub fn add_weatherTypeName(&mut self, weatherTypeName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2WeatherData::VT_WEATHERTYPENAME,
            weatherTypeName,
        );
    }
    #[inline]
    pub fn add_weatherIconId(&mut self, weatherIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2WeatherData::VT_WEATHERICONID,
            weatherIconId,
        );
    }
    #[inline]
    pub fn add_functionDesc(&mut self, functionDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2WeatherData::VT_FUNCTIONDESC,
            functionDesc,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2WeatherData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_buffId(&mut self, buffId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2WeatherData::VT_BUFFID,
            buffId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2WeatherDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2WeatherDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2WeatherData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2WeatherData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2WeatherData");
        ds.field("weatherId", &self.weatherId());
        ds.field("name", &self.name());
        ds.field("weatherLevel", &self.weatherLevel());
        ds.field("weatherType", &self.weatherType());
        ds.field("weatherTypeName", &self.weatherTypeName());
        ds.field("weatherIconId", &self.weatherIconId());
        ds.field("functionDesc", &self.functionDesc());
        ds.field("description", &self.description());
        ds.field("buffId", &self.buffId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2WeatherDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2WeatherData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2WeatherData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2WeatherData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2WeatherData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2WeatherData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2WeatherDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2WeatherData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2WeatherDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2WeatherData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2WeatherData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2WeatherData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2WeatherData>>(
                    dict__string__clz_Torappu_SandboxV2WeatherData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2WeatherData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2WeatherData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2WeatherDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2WeatherData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2WeatherDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2WeatherDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2WeatherDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2WeatherDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2WeatherData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2WeatherData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2WeatherData>>(
                dict__string__clz_Torappu_SandboxV2WeatherData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2WeatherDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2WeatherDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2WeatherData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2WeatherData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2WeatherData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2WeatherData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2StageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2StageData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2StageData<'a> {
    type Inner = clz_Torappu_SandboxV2StageData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2StageData<'a> {
    pub const VT_STAGEID: flatbuffers::VOffsetT = 4;
    pub const VT_LEVELID: flatbuffers::VOffsetT = 6;
    pub const VT_CODE: flatbuffers::VOffsetT = 8;
    pub const VT_NAME: flatbuffers::VOffsetT = 10;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 12;
    pub const VT_ACTIONCOST: flatbuffers::VOffsetT = 14;
    pub const VT_ACTIONCOSTENEMYRUSH: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2StageData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2StageDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2StageData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2StageDataBuilder::new(_fbb);
        builder.add_actionCostEnemyRush(args.actionCostEnemyRush);
        builder.add_actionCost(args.actionCost);
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.code {
            builder.add_code(x);
        }
        if let Some(x) = args.levelId {
            builder.add_levelId(x);
        }
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2StageData::VT_STAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn levelId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2StageData::VT_LEVELID,
                None,
            )
        }
    }
    #[inline]
    pub fn code(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2StageData::VT_CODE,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2StageData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2StageData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn actionCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2StageData::VT_ACTIONCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn actionCostEnemyRush(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2StageData::VT_ACTIONCOSTENEMYRUSH,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2StageData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("levelId", Self::VT_LEVELID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("code", Self::VT_CODE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<i32>("actionCost", Self::VT_ACTIONCOST, false)?
            .visit_field::<i32>("actionCostEnemyRush", Self::VT_ACTIONCOSTENEMYRUSH, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2StageDataArgs<'a> {
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub levelId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub code: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub actionCost: i32,
    pub actionCostEnemyRush: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2StageDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2StageDataArgs {
            stageId: None,
            levelId: None,
            code: None,
            name: None,
            description: None,
            actionCost: 0,
            actionCostEnemyRush: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2StageDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2StageDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2StageData::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn add_levelId(&mut self, levelId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2StageData::VT_LEVELID,
            levelId,
        );
    }
    #[inline]
    pub fn add_code(&mut self, code: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2StageData::VT_CODE,
            code,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2StageData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2StageData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_actionCost(&mut self, actionCost: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2StageData::VT_ACTIONCOST, actionCost, 0);
    }
    #[inline]
    pub fn add_actionCostEnemyRush(&mut self, actionCostEnemyRush: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2StageData::VT_ACTIONCOSTENEMYRUSH,
            actionCostEnemyRush,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2StageDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2StageDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2StageData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2StageData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2StageData");
        ds.field("stageId", &self.stageId());
        ds.field("levelId", &self.levelId());
        ds.field("code", &self.code());
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.field("actionCost", &self.actionCost());
        ds.field("actionCostEnemyRush", &self.actionCostEnemyRush());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2StageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2StageData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2StageData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2StageData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2StageData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2StageData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2StageDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2StageData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2StageDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2StageData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2StageData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2StageData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2StageData>>(
                    dict__string__clz_Torappu_SandboxV2StageData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2StageData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2StageData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2StageDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2StageData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2StageDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2StageDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2StageDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2StageDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2StageData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2StageData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2StageData>>(
                dict__string__clz_Torappu_SandboxV2StageData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2StageDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2StageDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2StageData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2StageData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2StageData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2StageData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2ZoneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ZoneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ZoneData<'a> {
    type Inner = clz_Torappu_SandboxV2ZoneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ZoneData<'a> {
    pub const VT_ZONEID: flatbuffers::VOffsetT = 4;
    pub const VT_ZONENAME: flatbuffers::VOffsetT = 6;
    pub const VT_DISPLAYNAME: flatbuffers::VOffsetT = 8;
    pub const VT_APPELLATION: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ZoneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ZoneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ZoneData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ZoneDataBuilder::new(_fbb);
        if let Some(x) = args.appellation {
            builder.add_appellation(x);
        }
        if let Some(x) = args.zoneName {
            builder.add_zoneName(x);
        }
        if let Some(x) = args.zoneId {
            builder.add_zoneId(x);
        }
        builder.add_displayName(args.displayName);
        builder.finish()
    }

    #[inline]
    pub fn zoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ZoneData::VT_ZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn zoneName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ZoneData::VT_ZONENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn displayName(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_SandboxV2ZoneData::VT_DISPLAYNAME, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn appellation(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ZoneData::VT_APPELLATION,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ZoneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zoneId", Self::VT_ZONEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "zoneName",
                Self::VT_ZONENAME,
                false,
            )?
            .visit_field::<bool>("displayName", Self::VT_DISPLAYNAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "appellation",
                Self::VT_APPELLATION,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ZoneDataArgs<'a> {
    pub zoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub displayName: bool,
    pub appellation: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ZoneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ZoneDataArgs {
            zoneId: None,
            zoneName: None,
            displayName: false,
            appellation: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2ZoneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2ZoneDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_zoneId(&mut self, zoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ZoneData::VT_ZONEID,
            zoneId,
        );
    }
    #[inline]
    pub fn add_zoneName(&mut self, zoneName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ZoneData::VT_ZONENAME,
            zoneName,
        );
    }
    #[inline]
    pub fn add_displayName(&mut self, displayName: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SandboxV2ZoneData::VT_DISPLAYNAME,
            displayName,
            false,
        );
    }
    #[inline]
    pub fn add_appellation(&mut self, appellation: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ZoneData::VT_APPELLATION,
            appellation,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ZoneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ZoneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ZoneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ZoneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ZoneData");
        ds.field("zoneId", &self.zoneId());
        ds.field("zoneName", &self.zoneName());
        ds.field("displayName", &self.displayName());
        ds.field("appellation", &self.appellation());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ZoneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ZoneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2ZoneData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2ZoneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ZoneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ZoneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ZoneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ZoneData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2ZoneDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ZoneData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2ZoneData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ZoneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ZoneData>>(
                    dict__string__clz_Torappu_SandboxV2ZoneData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ZoneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ZoneData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ZoneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ZoneData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ZoneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ZoneDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ZoneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ZoneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ZoneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ZoneData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ZoneData>>(
                dict__string__clz_Torappu_SandboxV2ZoneData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ZoneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ZoneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ZoneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ZoneData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ZoneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2ZoneData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2NodeBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2NodeBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2NodeBuffData<'a> {
    type Inner = clz_Torappu_SandboxV2NodeBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2NodeBuffData<'a> {
    pub const VT_RUNEID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 8;
    pub const VT_EXTRA: flatbuffers::VOffsetT = 10;
    pub const VT_ICONID: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2NodeBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2NodeBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeBuffData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2NodeBuffDataBuilder::new(_fbb);
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.extra {
            builder.add_extra(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.runeId {
            builder.add_runeId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn runeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeBuffData::VT_RUNEID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeBuffData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeBuffData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn extra(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeBuffData::VT_EXTRA,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeBuffData::VT_ICONID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2NodeBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("runeId", Self::VT_RUNEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("extra", Self::VT_EXTRA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2NodeBuffDataArgs<'a> {
    pub runeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub extra: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2NodeBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2NodeBuffDataArgs {
            runeId: None,
            name: None,
            description: None,
            extra: None,
            iconId: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2NodeBuffDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2NodeBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_runeId(&mut self, runeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeBuffData::VT_RUNEID,
            runeId,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeBuffData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeBuffData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_extra(&mut self, extra: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeBuffData::VT_EXTRA,
            extra,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeBuffData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2NodeBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2NodeBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2NodeBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2NodeBuffData");
        ds.field("runeId", &self.runeId());
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.field("extra", &self.extra());
        ds.field("iconId", &self.iconId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2NodeBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2NodeBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2NodeBuffData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2NodeBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2NodeBuffData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2NodeBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2NodeBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NodeBuffData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2NodeBuffDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2NodeBuffData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2NodeBuffData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2NodeBuffData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2NodeBuffData>>(
                    dict__string__clz_Torappu_SandboxV2NodeBuffData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2NodeBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2NodeBuffData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2NodeBuffDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeBuffData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2NodeBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2NodeBuffDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2NodeBuffDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2NodeBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2NodeBuffData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeBuffData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeBuffData>>(
                dict__string__clz_Torappu_SandboxV2NodeBuffData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2NodeBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2NodeBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NodeBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2NodeBuffData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2NodeBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2NodeBuffData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2RewardItemConfigDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RewardItemConfigData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RewardItemConfigData<'a> {
    type Inner = clz_Torappu_SandboxV2RewardItemConfigData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RewardItemConfigData<'a> {
    pub const VT_REWARDITEM: flatbuffers::VOffsetT = 4;
    pub const VT_REWARDTYPE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RewardItemConfigData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RewardItemConfigDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardItemConfigData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RewardItemConfigDataBuilder::new(_fbb);
        builder.add_rewardType(args.rewardType);
        if let Some(x) = args.rewardItem {
            builder.add_rewardItem(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn rewardItem(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RewardItemConfigData::VT_REWARDITEM,
                None,
            )
        }
    }
    #[inline]
    pub fn rewardType(&self) -> enum__Torappu_SandboxPermItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxPermItemType>(
                    clz_Torappu_SandboxV2RewardItemConfigData::VT_REWARDTYPE,
                    Some(enum__Torappu_SandboxPermItemType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RewardItemConfigData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rewardItem",
                Self::VT_REWARDITEM,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxPermItemType>(
                "rewardType",
                Self::VT_REWARDTYPE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RewardItemConfigDataArgs<'a> {
    pub rewardItem: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewardType: enum__Torappu_SandboxPermItemType,
}
impl<'a> Default for clz_Torappu_SandboxV2RewardItemConfigDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RewardItemConfigDataArgs {
            rewardItem: None,
            rewardType: enum__Torappu_SandboxPermItemType::NONE,
        }
    }
}

pub struct clz_Torappu_SandboxV2RewardItemConfigDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RewardItemConfigDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_rewardItem(&mut self, rewardItem: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RewardItemConfigData::VT_REWARDITEM,
            rewardItem,
        );
    }
    #[inline]
    pub fn add_rewardType(&mut self, rewardType: enum__Torappu_SandboxPermItemType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxPermItemType>(
            clz_Torappu_SandboxV2RewardItemConfigData::VT_REWARDTYPE,
            rewardType,
            enum__Torappu_SandboxPermItemType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RewardItemConfigDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RewardItemConfigDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardItemConfigData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RewardItemConfigData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RewardItemConfigData");
        ds.field("rewardItem", &self.rewardItem());
        ds.field("rewardType", &self.rewardType());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2RewardDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RewardData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RewardData<'a> {
    type Inner = clz_Torappu_SandboxV2RewardData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RewardData<'a> {
    pub const VT_REWARDLIST: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RewardData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RewardDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RewardDataBuilder::new(_fbb);
        if let Some(x) = args.rewardList {
            builder.add_rewardList(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn rewardList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RewardItemConfigData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RewardItemConfigData>,
                >,
            >>(clz_Torappu_SandboxV2RewardData::VT_REWARDLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RewardData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RewardItemConfigData>,
                >,
            >>("rewardList", Self::VT_REWARDLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RewardDataArgs<'a> {
    pub rewardList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RewardItemConfigData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2RewardDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RewardDataArgs { rewardList: None }
    }
}

pub struct clz_Torappu_SandboxV2RewardDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2RewardDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_rewardList(
        &mut self,
        rewardList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RewardItemConfigData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RewardData::VT_REWARDLIST,
            rewardList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RewardDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RewardDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RewardData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RewardData");
        ds.field("rewardList", &self.rewardList());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RewardDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RewardData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RewardData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RewardData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RewardData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RewardData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RewardDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RewardData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2RewardDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RewardData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2RewardData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RewardData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RewardData>>(
                    dict__string__clz_Torappu_SandboxV2RewardData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RewardData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RewardData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RewardDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RewardDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RewardDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RewardDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RewardDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RewardData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardData>>(
                dict__string__clz_Torappu_SandboxV2RewardData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RewardDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RewardDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RewardData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RewardData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RewardData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RewardData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2RewardCommonConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RewardCommonConfig<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RewardCommonConfig<'a> {
    type Inner = clz_Torappu_SandboxV2RewardCommonConfig<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RewardCommonConfig<'a> {
    pub const VT_REWARDITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_REWARDITEMTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_COUNT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RewardCommonConfig { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RewardCommonConfigArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardCommonConfig<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RewardCommonConfigBuilder::new(_fbb);
        builder.add_count(args.count);
        builder.add_rewardItemType(args.rewardItemType);
        if let Some(x) = args.rewardItemId {
            builder.add_rewardItemId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn rewardItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RewardCommonConfig::VT_REWARDITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn rewardItemType(&self) -> enum__Torappu_SandboxPermItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxPermItemType>(
                    clz_Torappu_SandboxV2RewardCommonConfig::VT_REWARDITEMTYPE,
                    Some(enum__Torappu_SandboxPermItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2RewardCommonConfig::VT_COUNT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RewardCommonConfig<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rewardItemId",
                Self::VT_REWARDITEMID,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxPermItemType>(
                "rewardItemType",
                Self::VT_REWARDITEMTYPE,
                false,
            )?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RewardCommonConfigArgs<'a> {
    pub rewardItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewardItemType: enum__Torappu_SandboxPermItemType,
    pub count: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2RewardCommonConfigArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RewardCommonConfigArgs {
            rewardItemId: None,
            rewardItemType: enum__Torappu_SandboxPermItemType::NONE,
            count: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2RewardCommonConfigBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RewardCommonConfigBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_rewardItemId(&mut self, rewardItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RewardCommonConfig::VT_REWARDITEMID,
            rewardItemId,
        );
    }
    #[inline]
    pub fn add_rewardItemType(&mut self, rewardItemType: enum__Torappu_SandboxPermItemType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxPermItemType>(
            clz_Torappu_SandboxV2RewardCommonConfig::VT_REWARDITEMTYPE,
            rewardItemType,
            enum__Torappu_SandboxPermItemType::NONE,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2RewardCommonConfig::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RewardCommonConfigBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RewardCommonConfigBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardCommonConfig<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RewardCommonConfig<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RewardCommonConfig");
        ds.field("rewardItemId", &self.rewardItemId());
        ds.field("rewardItemType", &self.rewardItemType());
        ds.field("count", &self.count());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RewardCommonConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RewardCommonConfig { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RewardCommonConfigArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2RewardCommonConfigBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RewardCommonConfig::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2RewardCommonConfig,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RewardCommonConfig<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RewardCommonConfig>>(
                    dict__string__clz_Torappu_SandboxV2RewardCommonConfig::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RewardCommonConfig>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RewardCommonConfigArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardCommonConfig<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RewardCommonConfigArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RewardCommonConfigArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RewardCommonConfigBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RewardCommonConfigBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RewardCommonConfig::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardCommonConfig<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardCommonConfig>>(
                dict__string__clz_Torappu_SandboxV2RewardCommonConfig::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RewardCommonConfigBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RewardCommonConfigBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RewardCommonConfig::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RewardCommonConfig");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2RewardConfigGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RewardConfigGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RewardConfigGroupData<'a> {
    type Inner = clz_Torappu_SandboxV2RewardConfigGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RewardConfigGroupData<'a> {
    pub const VT_STAGEMAPPREVIEWREWARDDICT: flatbuffers::VOffsetT = 4;
    pub const VT_STAGEDETAILPREVIEWREWARDDICT: flatbuffers::VOffsetT = 6;
    pub const VT_TRAPREWARDDICT: flatbuffers::VOffsetT = 8;
    pub const VT_ENEMYREWARDDICT: flatbuffers::VOffsetT = 10;
    pub const VT_UNITPREVIEWREWARDDICT: flatbuffers::VOffsetT = 12;
    pub const VT_STAGEREWARDDICT: flatbuffers::VOffsetT = 14;
    pub const VT_RUSHPREVIEWREWARDDICT: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RewardConfigGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RewardConfigGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardConfigGroupData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RewardConfigGroupDataBuilder::new(_fbb);
        if let Some(x) = args.rushPreviewRewardDict {
            builder.add_rushPreviewRewardDict(x);
        }
        if let Some(x) = args.stageRewardDict {
            builder.add_stageRewardDict(x);
        }
        if let Some(x) = args.unitPreviewRewardDict {
            builder.add_unitPreviewRewardDict(x);
        }
        if let Some(x) = args.enemyRewardDict {
            builder.add_enemyRewardDict(x);
        }
        if let Some(x) = args.trapRewardDict {
            builder.add_trapRewardDict(x);
        }
        if let Some(x) = args.stageDetailPreviewRewardDict {
            builder.add_stageDetailPreviewRewardDict(x);
        }
        if let Some(x) = args.stageMapPreviewRewardDict {
            builder.add_stageMapPreviewRewardDict(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn stageMapPreviewRewardDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData>,
                >,
            >>(
                clz_Torappu_SandboxV2RewardConfigGroupData::VT_STAGEMAPPREVIEWREWARDDICT,
                None,
            )
        }
    }
    #[inline]
    pub fn stageDetailPreviewRewardDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData>,
                >,
            >>(
                clz_Torappu_SandboxV2RewardConfigGroupData::VT_STAGEDETAILPREVIEWREWARDDICT,
                None,
            )
        }
    }
    #[inline]
    pub fn trapRewardDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2RewardCommonConfig,
                    >,
                >,
            >>(
                clz_Torappu_SandboxV2RewardConfigGroupData::VT_TRAPREWARDDICT,
                None,
            )
        }
    }
    #[inline]
    pub fn enemyRewardDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2RewardCommonConfig,
                    >,
                >,
            >>(
                clz_Torappu_SandboxV2RewardConfigGroupData::VT_ENEMYREWARDDICT,
                None,
            )
        }
    }
    #[inline]
    pub fn unitPreviewRewardDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData>,
                >,
            >>(
                clz_Torappu_SandboxV2RewardConfigGroupData::VT_UNITPREVIEWREWARDDICT,
                None,
            )
        }
    }
    #[inline]
    pub fn stageRewardDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData>,
                >,
            >>(
                clz_Torappu_SandboxV2RewardConfigGroupData::VT_STAGEREWARDDICT,
                None,
            )
        }
    }
    #[inline]
    pub fn rushPreviewRewardDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData>,
                >,
            >>(
                clz_Torappu_SandboxV2RewardConfigGroupData::VT_RUSHPREVIEWREWARDDICT,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RewardConfigGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData>,
                >,
            >>(
                "stageMapPreviewRewardDict",
                Self::VT_STAGEMAPPREVIEWREWARDDICT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData>,
                >,
            >>(
                "stageDetailPreviewRewardDict",
                Self::VT_STAGEDETAILPREVIEWREWARDDICT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2RewardCommonConfig,
                    >,
                >,
            >>("trapRewardDict", Self::VT_TRAPREWARDDICT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2RewardCommonConfig,
                    >,
                >,
            >>("enemyRewardDict", Self::VT_ENEMYREWARDDICT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData>,
                >,
            >>(
                "unitPreviewRewardDict",
                Self::VT_UNITPREVIEWREWARDDICT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData>,
                >,
            >>("stageRewardDict", Self::VT_STAGEREWARDDICT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData>,
                >,
            >>(
                "rushPreviewRewardDict",
                Self::VT_RUSHPREVIEWREWARDDICT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RewardConfigGroupDataArgs<'a> {
    pub stageMapPreviewRewardDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'a>>,
            >,
        >,
    >,
    pub stageDetailPreviewRewardDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'a>>,
            >,
        >,
    >,
    pub trapRewardDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'a>,
                >,
            >,
        >,
    >,
    pub enemyRewardDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'a>,
                >,
            >,
        >,
    >,
    pub unitPreviewRewardDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'a>>,
            >,
        >,
    >,
    pub stageRewardDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'a>>,
            >,
        >,
    >,
    pub rushPreviewRewardDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2RewardConfigGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RewardConfigGroupDataArgs {
            stageMapPreviewRewardDict: None,
            stageDetailPreviewRewardDict: None,
            trapRewardDict: None,
            enemyRewardDict: None,
            unitPreviewRewardDict: None,
            stageRewardDict: None,
            rushPreviewRewardDict: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2RewardConfigGroupDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RewardConfigGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_stageMapPreviewRewardDict(
        &mut self,
        stageMapPreviewRewardDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RewardConfigGroupData::VT_STAGEMAPPREVIEWREWARDDICT,
            stageMapPreviewRewardDict,
        );
    }
    #[inline]
    pub fn add_stageDetailPreviewRewardDict(
        &mut self,
        stageDetailPreviewRewardDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RewardConfigGroupData::VT_STAGEDETAILPREVIEWREWARDDICT,
            stageDetailPreviewRewardDict,
        );
    }
    #[inline]
    pub fn add_trapRewardDict(
        &mut self,
        trapRewardDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RewardConfigGroupData::VT_TRAPREWARDDICT,
            trapRewardDict,
        );
    }
    #[inline]
    pub fn add_enemyRewardDict(
        &mut self,
        enemyRewardDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RewardConfigGroupData::VT_ENEMYREWARDDICT,
            enemyRewardDict,
        );
    }
    #[inline]
    pub fn add_unitPreviewRewardDict(
        &mut self,
        unitPreviewRewardDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RewardConfigGroupData::VT_UNITPREVIEWREWARDDICT,
            unitPreviewRewardDict,
        );
    }
    #[inline]
    pub fn add_stageRewardDict(
        &mut self,
        stageRewardDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RewardConfigGroupData::VT_STAGEREWARDDICT,
            stageRewardDict,
        );
    }
    #[inline]
    pub fn add_rushPreviewRewardDict(
        &mut self,
        rushPreviewRewardDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RewardConfigGroupData::VT_RUSHPREVIEWREWARDDICT,
            rushPreviewRewardDict,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RewardConfigGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RewardConfigGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardConfigGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RewardConfigGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RewardConfigGroupData");
        ds.field(
            "stageMapPreviewRewardDict",
            &self.stageMapPreviewRewardDict(),
        );
        ds.field(
            "stageDetailPreviewRewardDict",
            &self.stageDetailPreviewRewardDict(),
        );
        ds.field("trapRewardDict", &self.trapRewardDict());
        ds.field("enemyRewardDict", &self.enemyRewardDict());
        ds.field("unitPreviewRewardDict", &self.unitPreviewRewardDict());
        ds.field("stageRewardDict", &self.stageRewardDict());
        ds.field("rushPreviewRewardDict", &self.rushPreviewRewardDict());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2FloatIconDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2FloatIconData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2FloatIconData<'a> {
    type Inner = clz_Torappu_SandboxV2FloatIconData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2FloatIconData<'a> {
    pub const VT_PICID: flatbuffers::VOffsetT = 4;
    pub const VT_PICNAME: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2FloatIconData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2FloatIconDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FloatIconData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2FloatIconDataBuilder::new(_fbb);
        if let Some(x) = args.picName {
            builder.add_picName(x);
        }
        if let Some(x) = args.picId {
            builder.add_picId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn picId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2FloatIconData::VT_PICID,
                None,
            )
        }
    }
    #[inline]
    pub fn picName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2FloatIconData::VT_PICNAME,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2FloatIconData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("picId", Self::VT_PICID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("picName", Self::VT_PICNAME, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2FloatIconDataArgs<'a> {
    pub picId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub picName: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2FloatIconDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2FloatIconDataArgs {
            picId: None,
            picName: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2FloatIconDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2FloatIconDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_picId(&mut self, picId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FloatIconData::VT_PICID,
            picId,
        );
    }
    #[inline]
    pub fn add_picName(&mut self, picName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FloatIconData::VT_PICNAME,
            picName,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2FloatIconDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2FloatIconDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FloatIconData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2FloatIconData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2FloatIconData");
        ds.field("picId", &self.picId());
        ds.field("picName", &self.picName());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2FloatIconDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2FloatIconData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2FloatIconData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2FloatIconData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2FloatIconData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2FloatIconData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2FloatIconDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2FloatIconData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2FloatIconDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2FloatIconData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2FloatIconData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2FloatIconData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FloatIconData>>(
                    dict__string__clz_Torappu_SandboxV2FloatIconData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2FloatIconData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FloatIconData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2FloatIconDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2FloatIconData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2FloatIconDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2FloatIconDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2FloatIconDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2FloatIconDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2FloatIconData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2FloatIconData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2FloatIconData>>(
                dict__string__clz_Torappu_SandboxV2FloatIconData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2FloatIconDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2FloatIconDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2FloatIconData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2FloatIconData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2FloatIconData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2FloatIconData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2EnemyRushTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2EnemyRushTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2EnemyRushTypeData<'a> {
    type Inner = clz_Torappu_SandboxV2EnemyRushTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2EnemyRushTypeData<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
    pub const VT_SORTID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2EnemyRushTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2EnemyRushTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EnemyRushTypeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2EnemyRushTypeDataBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    #[inline]
    pub fn type_(&self) -> enum__Torappu_SandboxV2EnemyRushType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2EnemyRushType>(
                    clz_Torappu_SandboxV2EnemyRushTypeData::VT_TYPE_,
                    Some(enum__Torappu_SandboxV2EnemyRushType::NORMAL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EnemyRushTypeData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2EnemyRushTypeData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2EnemyRushTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxV2EnemyRushType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2EnemyRushTypeDataArgs<'a> {
    pub type_: enum__Torappu_SandboxV2EnemyRushType,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2EnemyRushTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2EnemyRushTypeDataArgs {
            type_: enum__Torappu_SandboxV2EnemyRushType::NORMAL,
            description: None,
            sortId: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2EnemyRushTypeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2EnemyRushTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_SandboxV2EnemyRushType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2EnemyRushType>(
            clz_Torappu_SandboxV2EnemyRushTypeData::VT_TYPE_,
            type_,
            enum__Torappu_SandboxV2EnemyRushType::NORMAL,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EnemyRushTypeData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2EnemyRushTypeData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2EnemyRushTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2EnemyRushTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EnemyRushTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2EnemyRushTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2EnemyRushTypeData");
        ds.field("type_", &self.type_());
        ds.field("description", &self.description());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2EnemyRushTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2EnemyRushTypeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2EnemyRushTypeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2EnemyRushTypeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2EnemyRushTypeData>>(
                    dict__string__clz_Torappu_SandboxV2EnemyRushTypeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2EnemyRushTypeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2EnemyRushTypeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2EnemyRushTypeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2EnemyRushTypeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2EnemyRushTypeData>>(
                dict__string__clz_Torappu_SandboxV2EnemyRushTypeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2EnemyRushTypeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2EnemyRushTypeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2BattleRushEnemyConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2BattleRushEnemyConfig<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2BattleRushEnemyConfig<'a> {
    type Inner = clz_Torappu_SandboxV2BattleRushEnemyConfig<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2BattleRushEnemyConfig<'a> {
    pub const VT_ENEMYKEY: flatbuffers::VOffsetT = 4;
    pub const VT_BRANCHID: flatbuffers::VOffsetT = 6;
    pub const VT_COUNT: flatbuffers::VOffsetT = 8;
    pub const VT_INTERVAL: flatbuffers::VOffsetT = 10;
    pub const VT_PREDELAY: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2BattleRushEnemyConfig { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2BattleRushEnemyConfigArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyConfig<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2BattleRushEnemyConfigBuilder::new(_fbb);
        builder.add_preDelay(args.preDelay);
        builder.add_interval(args.interval);
        builder.add_count(args.count);
        if let Some(x) = args.branchId {
            builder.add_branchId(x);
        }
        if let Some(x) = args.enemyKey {
            builder.add_enemyKey(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn enemyKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BattleRushEnemyConfig::VT_ENEMYKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn branchId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BattleRushEnemyConfig::VT_BRANCHID,
                None,
            )
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BattleRushEnemyConfig::VT_COUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn interval(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2BattleRushEnemyConfig::VT_INTERVAL,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn preDelay(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2BattleRushEnemyConfig::VT_PREDELAY,
                    Some(0.0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2BattleRushEnemyConfig<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enemyKey",
                Self::VT_ENEMYKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "branchId",
                Self::VT_BRANCHID,
                false,
            )?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<f32>("interval", Self::VT_INTERVAL, false)?
            .visit_field::<f32>("preDelay", Self::VT_PREDELAY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2BattleRushEnemyConfigArgs<'a> {
    pub enemyKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub branchId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
    pub interval: f32,
    pub preDelay: f32,
}
impl<'a> Default for clz_Torappu_SandboxV2BattleRushEnemyConfigArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2BattleRushEnemyConfigArgs {
            enemyKey: None,
            branchId: None,
            count: 0,
            interval: 0.0,
            preDelay: 0.0,
        }
    }
}

pub struct clz_Torappu_SandboxV2BattleRushEnemyConfigBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2BattleRushEnemyConfigBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_enemyKey(&mut self, enemyKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BattleRushEnemyConfig::VT_ENEMYKEY,
            enemyKey,
        );
    }
    #[inline]
    pub fn add_branchId(&mut self, branchId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BattleRushEnemyConfig::VT_BRANCHID,
            branchId,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BattleRushEnemyConfig::VT_COUNT,
            count,
            0,
        );
    }
    #[inline]
    pub fn add_interval(&mut self, interval: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2BattleRushEnemyConfig::VT_INTERVAL,
            interval,
            0.0,
        );
    }
    #[inline]
    pub fn add_preDelay(&mut self, preDelay: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2BattleRushEnemyConfig::VT_PREDELAY,
            preDelay,
            0.0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2BattleRushEnemyConfigBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2BattleRushEnemyConfigBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyConfig<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2BattleRushEnemyConfig<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2BattleRushEnemyConfig");
        ds.field("enemyKey", &self.enemyKey());
        ds.field("branchId", &self.branchId());
        ds.field("count", &self.count());
        ds.field("interval", &self.interval());
        ds.field("preDelay", &self.preDelay());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2BattleRushEnemyGroupConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a> {
    type Inner = clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a> {
    pub const VT_ENEMYGROUPKEY: flatbuffers::VOffsetT = 4;
    pub const VT_ENEMY: flatbuffers::VOffsetT = 6;
    pub const VT_DYNAMICENEMY: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2BattleRushEnemyGroupConfig { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2BattleRushEnemyGroupConfigArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2BattleRushEnemyGroupConfigBuilder::new(_fbb);
        if let Some(x) = args.dynamicEnemy {
            builder.add_dynamicEnemy(x);
        }
        if let Some(x) = args.enemy {
            builder.add_enemy(x);
        }
        if let Some(x) = args.enemyGroupKey {
            builder.add_enemyGroupKey(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn enemyGroupKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BattleRushEnemyGroupConfig::VT_ENEMYGROUPKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn enemy(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyConfig<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyConfig>,
                >,
            >>(
                clz_Torappu_SandboxV2BattleRushEnemyGroupConfig::VT_ENEMY,
                None,
            )
        }
    }
    #[inline]
    pub fn dynamicEnemy(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2BattleRushEnemyGroupConfig::VT_DYNAMICENEMY,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enemyGroupKey",
                Self::VT_ENEMYGROUPKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyConfig>,
                >,
            >>("enemy", Self::VT_ENEMY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("dynamicEnemy", Self::VT_DYNAMICENEMY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2BattleRushEnemyGroupConfigArgs<'a> {
    pub enemyGroupKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub enemy: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyConfig<'a>>,
            >,
        >,
    >,
    pub dynamicEnemy: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2BattleRushEnemyGroupConfigArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2BattleRushEnemyGroupConfigArgs {
            enemyGroupKey: None,
            enemy: None,
            dynamicEnemy: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2BattleRushEnemyGroupConfigBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2BattleRushEnemyGroupConfigBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_enemyGroupKey(&mut self, enemyGroupKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BattleRushEnemyGroupConfig::VT_ENEMYGROUPKEY,
            enemyGroupKey,
        );
    }
    #[inline]
    pub fn add_enemy(
        &mut self,
        enemy: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyConfig<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BattleRushEnemyGroupConfig::VT_ENEMY,
            enemy,
        );
    }
    #[inline]
    pub fn add_dynamicEnemy(
        &mut self,
        dynamicEnemy: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BattleRushEnemyGroupConfig::VT_DYNAMICENEMY,
            dynamicEnemy,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2BattleRushEnemyGroupConfigBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2BattleRushEnemyGroupConfigBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2BattleRushEnemyGroupConfig");
        ds.field("enemyGroupKey", &self.enemyGroupKey());
        ds.field("enemy", &self.enemy());
        ds.field("dynamicEnemy", &self.dynamicEnemy());
        ds.finish()
    }
}
pub enum dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigOffset
{}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<
    'a,
> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a> {
  type Inner = dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a>
    dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<
        'a,
    >
{
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig { _tab: table }
    }
    #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigArgs<'args>
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'bldr>>{
        let mut builder = dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_SandboxV2EnemyRushType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<enum__Torappu_SandboxV2EnemyRushType>(dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig::VT_KEY, Some(enum__Torappu_SandboxV2EnemyRushType::NORMAL)).unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_SandboxV2EnemyRushType,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyGroupConfig>>>>(dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<enum__Torappu_SandboxV2EnemyRushType>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyGroupConfig>>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigArgs<
    'a,
> {
    pub key: enum__Torappu_SandboxV2EnemyRushType,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigArgs<'a> {
  #[inline]
  fn default() -> Self {
    dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigArgs {
      key: enum__Torappu_SandboxV2EnemyRushType::NORMAL,
      value: None,
    }
  }
}

pub struct dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: enum__Torappu_SandboxV2EnemyRushType) {
    self.fbb_.push_slot::<enum__Torappu_SandboxV2EnemyRushType>(dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig::VT_KEY, key, enum__Torappu_SandboxV2EnemyRushType::NORMAL);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'a> {
    type Inner = clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'bldr>>
    {
        let mut builder = clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefBuilder::new(_fbb);
        builder.add_level(args.level);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef::VT_LEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub level: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefArgs { id: None, level: 0 }
    }
}

pub struct clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef::VT_LEVEL,
            level,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef");
        ds.field("id", &self.id());
        ds.field("level", &self.level());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2BattleRushEnemyDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2BattleRushEnemyData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2BattleRushEnemyData<'a> {
    type Inner = clz_Torappu_SandboxV2BattleRushEnemyData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2BattleRushEnemyData<'a> {
    pub const VT_RUSHENEMYGROUPCONFIGS: flatbuffers::VOffsetT = 4;
    pub const VT_RUSHENEMYDBREF: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2BattleRushEnemyData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2BattleRushEnemyDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2BattleRushEnemyDataBuilder::new(_fbb);
        if let Some(x) = args.rushEnemyDbRef {
            builder.add_rushEnemyDbRef(x);
        }
        if let Some(x) = args.rushEnemyGroupConfigs {
            builder.add_rushEnemyGroupConfigs(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn rushEnemyGroupConfigs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a>>>>{
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig>>>>(clz_Torappu_SandboxV2BattleRushEnemyData::VT_RUSHENEMYGROUPCONFIGS, None)
        }
    }
    #[inline]
    pub fn rushEnemyDbRef(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef,
                    >,
                >,
            >>(
                clz_Torappu_SandboxV2BattleRushEnemyData::VT_RUSHENEMYDBREF,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2BattleRushEnemyData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig>>>>("rushEnemyGroupConfigs", Self::VT_RUSHENEMYGROUPCONFIGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef>>>>("rushEnemyDbRef", Self::VT_RUSHENEMYDBREF, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2BattleRushEnemyDataArgs<'a> {
    pub rushEnemyGroupConfigs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a>>>>>,
    pub rushEnemyDbRef: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'a>>>>>,
}
impl<'a> Default for clz_Torappu_SandboxV2BattleRushEnemyDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2BattleRushEnemyDataArgs {
            rushEnemyGroupConfigs: None,
            rushEnemyDbRef: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2BattleRushEnemyDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2BattleRushEnemyDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_rushEnemyGroupConfigs(
        &mut self,
        rushEnemyGroupConfigs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'b >>>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BattleRushEnemyData::VT_RUSHENEMYGROUPCONFIGS,
            rushEnemyGroupConfigs,
        );
    }
    #[inline]
    pub fn add_rushEnemyDbRef(
        &mut self,
        rushEnemyDbRef: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BattleRushEnemyData::VT_RUSHENEMYDBREF,
            rushEnemyDbRef,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2BattleRushEnemyDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2BattleRushEnemyDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2BattleRushEnemyData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2BattleRushEnemyData");
        ds.field("rushEnemyGroupConfigs", &self.rushEnemyGroupConfigs());
        ds.field("rushEnemyDbRef", &self.rushEnemyDbRef());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2GameConstOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2GameConst<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2GameConst<'a> {
    type Inner = clz_Torappu_SandboxV2GameConst<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2GameConst<'a> {
    pub const VT_MAINMAPID: flatbuffers::VOffsetT = 4;
    pub const VT_BASETRAPID: flatbuffers::VOffsetT = 6;
    pub const VT_PORTABLETRAPID: flatbuffers::VOffsetT = 8;
    pub const VT_DOORTRAPID: flatbuffers::VOffsetT = 10;
    pub const VT_MINETRAPID: flatbuffers::VOffsetT = 12;
    pub const VT_NEUTRALBOSSENEMYID: flatbuffers::VOffsetT = 14;
    pub const VT_NESTTRAPID: flatbuffers::VOffsetT = 16;
    pub const VT_SHOPNPCNAME: flatbuffers::VOffsetT = 18;
    pub const VT_DAYSBETWEENASSESSMENT: flatbuffers::VOffsetT = 20;
    pub const VT_PORTABLECONSTRUCTUNLOCKLEVEL: flatbuffers::VOffsetT = 22;
    pub const VT_OUTPOSTCONSTRUCTUNLOCKLEVEL: flatbuffers::VOffsetT = 24;
    pub const VT_MAXENEMYCOUNTSAMETIMEINRUSH: flatbuffers::VOffsetT = 26;
    pub const VT_MAXPREDELAYTIMEINRUSH: flatbuffers::VOffsetT = 28;
    pub const VT_MAXSAVECNT: flatbuffers::VOffsetT = 30;
    pub const VT_FIRSTSEASONDURATION: flatbuffers::VOffsetT = 32;
    pub const VT_SEASONTRANSITIONLOOP: flatbuffers::VOffsetT = 34;
    pub const VT_SEASONDURATIONLOOP: flatbuffers::VOffsetT = 36;
    pub const VT_FIRSTSEASONSTARTANGLE: flatbuffers::VOffsetT = 38;
    pub const VT_SEASONTRANSITIONANGLELOOP: flatbuffers::VOffsetT = 40;
    pub const VT_SEASONANGLE: flatbuffers::VOffsetT = 42;
    pub const VT_BATTLEITEMDESC: flatbuffers::VOffsetT = 44;
    pub const VT_FOODDESC: flatbuffers::VOffsetT = 46;
    pub const VT_MULTIPLESURVIVALDAYDESC: flatbuffers::VOffsetT = 48;
    pub const VT_MULTIPLETIPS: flatbuffers::VOffsetT = 50;
    pub const VT_TECHPROGRESSSCORE: flatbuffers::VOffsetT = 52;
    pub const VT_OTHERENEMYRUSHNAME: flatbuffers::VOffsetT = 54;
    pub const VT_SURVIVEDAYTEXT: flatbuffers::VOffsetT = 56;
    pub const VT_SURVIVEPERIODTEXT: flatbuffers::VOffsetT = 58;
    pub const VT_SURVIVESCORETEXT: flatbuffers::VOffsetT = 60;
    pub const VT_ACTIONPOINTSCORETEXT: flatbuffers::VOffsetT = 62;
    pub const VT_NODEEXPLOREDESC: flatbuffers::VOffsetT = 64;
    pub const VT_DUNGEONEXPLOREDESC: flatbuffers::VOffsetT = 66;
    pub const VT_NODECOMPLETEDESC: flatbuffers::VOffsetT = 68;
    pub const VT_NORIFTDUNGEONDESC: flatbuffers::VOffsetT = 70;
    pub const VT_BASERUSHEDDESC: flatbuffers::VOffsetT = 72;
    pub const VT_RIFTBASEDESC: flatbuffers::VOffsetT = 74;
    pub const VT_RIFTBASERUSHEDDESC: flatbuffers::VOffsetT = 76;
    pub const VT_DUNGEONTRIGGEREDGUIDEQUESTLIST: flatbuffers::VOffsetT = 78;
    pub const VT_NOLOGINENEMYSTATSENEMYID: flatbuffers::VOffsetT = 80;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2GameConst { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2GameConstArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2GameConst<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2GameConstBuilder::new(_fbb);
        if let Some(x) = args.noLogInEnemyStatsEnemyId {
            builder.add_noLogInEnemyStatsEnemyId(x);
        }
        if let Some(x) = args.dungeonTriggeredGuideQuestList {
            builder.add_dungeonTriggeredGuideQuestList(x);
        }
        if let Some(x) = args.riftBaseRushedDesc {
            builder.add_riftBaseRushedDesc(x);
        }
        if let Some(x) = args.riftBaseDesc {
            builder.add_riftBaseDesc(x);
        }
        if let Some(x) = args.baseRushedDesc {
            builder.add_baseRushedDesc(x);
        }
        if let Some(x) = args.noRiftDungeonDesc {
            builder.add_noRiftDungeonDesc(x);
        }
        if let Some(x) = args.nodeCompleteDesc {
            builder.add_nodeCompleteDesc(x);
        }
        if let Some(x) = args.dungeonExploreDesc {
            builder.add_dungeonExploreDesc(x);
        }
        if let Some(x) = args.nodeExploreDesc {
            builder.add_nodeExploreDesc(x);
        }
        if let Some(x) = args.actionPointScoreText {
            builder.add_actionPointScoreText(x);
        }
        if let Some(x) = args.surviveScoreText {
            builder.add_surviveScoreText(x);
        }
        if let Some(x) = args.survivePeriodText {
            builder.add_survivePeriodText(x);
        }
        if let Some(x) = args.surviveDayText {
            builder.add_surviveDayText(x);
        }
        if let Some(x) = args.otherEnemyRushName {
            builder.add_otherEnemyRushName(x);
        }
        builder.add_techProgressScore(args.techProgressScore);
        if let Some(x) = args.multipleTips {
            builder.add_multipleTips(x);
        }
        if let Some(x) = args.multipleSurvivalDayDesc {
            builder.add_multipleSurvivalDayDesc(x);
        }
        if let Some(x) = args.foodDesc {
            builder.add_foodDesc(x);
        }
        if let Some(x) = args.battleItemDesc {
            builder.add_battleItemDesc(x);
        }
        builder.add_seasonAngle(args.seasonAngle);
        if let Some(x) = args.seasonTransitionAngleLoop {
            builder.add_seasonTransitionAngleLoop(x);
        }
        builder.add_firstSeasonStartAngle(args.firstSeasonStartAngle);
        if let Some(x) = args.seasonDurationLoop {
            builder.add_seasonDurationLoop(x);
        }
        if let Some(x) = args.seasonTransitionLoop {
            builder.add_seasonTransitionLoop(x);
        }
        builder.add_firstSeasonDuration(args.firstSeasonDuration);
        builder.add_maxSaveCnt(args.maxSaveCnt);
        builder.add_maxPreDelayTimeInRush(args.maxPreDelayTimeInRush);
        builder.add_maxEnemyCountSameTimeInRush(args.maxEnemyCountSameTimeInRush);
        builder.add_outpostConstructUnlockLevel(args.outpostConstructUnlockLevel);
        builder.add_portableConstructUnlockLevel(args.portableConstructUnlockLevel);
        builder.add_daysBetweenAssessment(args.daysBetweenAssessment);
        if let Some(x) = args.shopNpcName {
            builder.add_shopNpcName(x);
        }
        if let Some(x) = args.nestTrapId {
            builder.add_nestTrapId(x);
        }
        if let Some(x) = args.neutralBossEnemyId {
            builder.add_neutralBossEnemyId(x);
        }
        if let Some(x) = args.mineTrapId {
            builder.add_mineTrapId(x);
        }
        if let Some(x) = args.doorTrapId {
            builder.add_doorTrapId(x);
        }
        if let Some(x) = args.portableTrapId {
            builder.add_portableTrapId(x);
        }
        if let Some(x) = args.baseTrapId {
            builder.add_baseTrapId(x);
        }
        if let Some(x) = args.mainMapId {
            builder.add_mainMapId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn mainMapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_MAINMAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn baseTrapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_BASETRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn portableTrapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_PORTABLETRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn doorTrapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_DOORTRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn mineTrapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_MINETRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn neutralBossEnemyId(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxV2GameConst::VT_NEUTRALBOSSENEMYID, None)
        }
    }
    #[inline]
    pub fn nestTrapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_NESTTRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn shopNpcName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_SHOPNPCNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn daysBetweenAssessment(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2GameConst::VT_DAYSBETWEENASSESSMENT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn portableConstructUnlockLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2GameConst::VT_PORTABLECONSTRUCTUNLOCKLEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn outpostConstructUnlockLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2GameConst::VT_OUTPOSTCONSTRUCTUNLOCKLEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxEnemyCountSameTimeInRush(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2GameConst::VT_MAXENEMYCOUNTSAMETIMEINRUSH,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxPreDelayTimeInRush(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2GameConst::VT_MAXPREDELAYTIMEINRUSH,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxSaveCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2GameConst::VT_MAXSAVECNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn firstSeasonDuration(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2GameConst::VT_FIRSTSEASONDURATION,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn seasonTransitionLoop(
        &self,
    ) -> Option<flatbuffers::Vector<'a, enum__Torappu_SandboxV2SeasonType>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_SandboxV2SeasonType>,
            >>(
                clz_Torappu_SandboxV2GameConst::VT_SEASONTRANSITIONLOOP,
                None,
            )
        }
    }
    #[inline]
    pub fn seasonDurationLoop(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    clz_Torappu_SandboxV2GameConst::VT_SEASONDURATIONLOOP,
                    None,
                )
        }
    }
    #[inline]
    pub fn firstSeasonStartAngle(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2GameConst::VT_FIRSTSEASONSTARTANGLE,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn seasonTransitionAngleLoop(&self) -> Option<flatbuffers::Vector<'a, f32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    clz_Torappu_SandboxV2GameConst::VT_SEASONTRANSITIONANGLELOOP,
                    None,
                )
        }
    }
    #[inline]
    pub fn seasonAngle(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_SandboxV2GameConst::VT_SEASONANGLE, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn battleItemDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_BATTLEITEMDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn foodDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_FOODDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn multipleSurvivalDayDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_MULTIPLESURVIVALDAYDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn multipleTips(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_MULTIPLETIPS,
                None,
            )
        }
    }
    #[inline]
    pub fn techProgressScore(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2GameConst::VT_TECHPROGRESSSCORE,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn otherEnemyRushName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_OTHERENEMYRUSHNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn surviveDayText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_SURVIVEDAYTEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn survivePeriodText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_SURVIVEPERIODTEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn surviveScoreText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_SURVIVESCORETEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn actionPointScoreText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_ACTIONPOINTSCORETEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeExploreDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_NODEEXPLOREDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn dungeonExploreDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_DUNGEONEXPLOREDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeCompleteDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_NODECOMPLETEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn noRiftDungeonDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_NORIFTDUNGEONDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn baseRushedDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_BASERUSHEDDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn riftBaseDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_RIFTBASEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn riftBaseRushedDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_RIFTBASERUSHEDDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn dungeonTriggeredGuideQuestList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2GameConst::VT_DUNGEONTRIGGEREDGUIDEQUESTLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn noLogInEnemyStatsEnemyId(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2GameConst::VT_NOLOGINENEMYSTATSENEMYID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2GameConst<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "mainMapId",
                Self::VT_MAINMAPID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "baseTrapId",
                Self::VT_BASETRAPID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "portableTrapId",
                Self::VT_PORTABLETRAPID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "doorTrapId",
                Self::VT_DOORTRAPID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "mineTrapId",
                Self::VT_MINETRAPID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("neutralBossEnemyId", Self::VT_NEUTRALBOSSENEMYID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nestTrapId",
                Self::VT_NESTTRAPID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "shopNpcName",
                Self::VT_SHOPNPCNAME,
                false,
            )?
            .visit_field::<i32>(
                "daysBetweenAssessment",
                Self::VT_DAYSBETWEENASSESSMENT,
                false,
            )?
            .visit_field::<i32>(
                "portableConstructUnlockLevel",
                Self::VT_PORTABLECONSTRUCTUNLOCKLEVEL,
                false,
            )?
            .visit_field::<i32>(
                "outpostConstructUnlockLevel",
                Self::VT_OUTPOSTCONSTRUCTUNLOCKLEVEL,
                false,
            )?
            .visit_field::<i32>(
                "maxEnemyCountSameTimeInRush",
                Self::VT_MAXENEMYCOUNTSAMETIMEINRUSH,
                false,
            )?
            .visit_field::<f32>(
                "maxPreDelayTimeInRush",
                Self::VT_MAXPREDELAYTIMEINRUSH,
                false,
            )?
            .visit_field::<i32>("maxSaveCnt", Self::VT_MAXSAVECNT, false)?
            .visit_field::<i32>("firstSeasonDuration", Self::VT_FIRSTSEASONDURATION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, enum__Torappu_SandboxV2SeasonType>,
            >>("seasonTransitionLoop", Self::VT_SEASONTRANSITIONLOOP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "seasonDurationLoop",
                Self::VT_SEASONDURATIONLOOP,
                false,
            )?
            .visit_field::<f32>(
                "firstSeasonStartAngle",
                Self::VT_FIRSTSEASONSTARTANGLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "seasonTransitionAngleLoop",
                Self::VT_SEASONTRANSITIONANGLELOOP,
                false,
            )?
            .visit_field::<f32>("seasonAngle", Self::VT_SEASONANGLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "battleItemDesc",
                Self::VT_BATTLEITEMDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "foodDesc",
                Self::VT_FOODDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "multipleSurvivalDayDesc",
                Self::VT_MULTIPLESURVIVALDAYDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "multipleTips",
                Self::VT_MULTIPLETIPS,
                false,
            )?
            .visit_field::<i32>("techProgressScore", Self::VT_TECHPROGRESSSCORE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "otherEnemyRushName",
                Self::VT_OTHERENEMYRUSHNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "surviveDayText",
                Self::VT_SURVIVEDAYTEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "survivePeriodText",
                Self::VT_SURVIVEPERIODTEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "surviveScoreText",
                Self::VT_SURVIVESCORETEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "actionPointScoreText",
                Self::VT_ACTIONPOINTSCORETEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nodeExploreDesc",
                Self::VT_NODEEXPLOREDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dungeonExploreDesc",
                Self::VT_DUNGEONEXPLOREDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nodeCompleteDesc",
                Self::VT_NODECOMPLETEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "noRiftDungeonDesc",
                Self::VT_NORIFTDUNGEONDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "baseRushedDesc",
                Self::VT_BASERUSHEDDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "riftBaseDesc",
                Self::VT_RIFTBASEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "riftBaseRushedDesc",
                Self::VT_RIFTBASERUSHEDDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "dungeonTriggeredGuideQuestList",
                Self::VT_DUNGEONTRIGGEREDGUIDEQUESTLIST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "noLogInEnemyStatsEnemyId",
                Self::VT_NOLOGINENEMYSTATSENEMYID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2GameConstArgs<'a> {
    pub mainMapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub baseTrapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub portableTrapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub doorTrapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mineTrapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub neutralBossEnemyId: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub nestTrapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub shopNpcName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub daysBetweenAssessment: i32,
    pub portableConstructUnlockLevel: i32,
    pub outpostConstructUnlockLevel: i32,
    pub maxEnemyCountSameTimeInRush: i32,
    pub maxPreDelayTimeInRush: f32,
    pub maxSaveCnt: i32,
    pub firstSeasonDuration: i32,
    pub seasonTransitionLoop:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_SandboxV2SeasonType>>>,
    pub seasonDurationLoop: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub firstSeasonStartAngle: f32,
    pub seasonTransitionAngleLoop: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub seasonAngle: f32,
    pub battleItemDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub foodDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub multipleSurvivalDayDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub multipleTips: Option<flatbuffers::WIPOffset<&'a str>>,
    pub techProgressScore: i32,
    pub otherEnemyRushName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub surviveDayText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub survivePeriodText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub surviveScoreText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub actionPointScoreText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nodeExploreDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dungeonExploreDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nodeCompleteDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub noRiftDungeonDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub baseRushedDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub riftBaseDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub riftBaseRushedDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dungeonTriggeredGuideQuestList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub noLogInEnemyStatsEnemyId: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2GameConstArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2GameConstArgs {
            mainMapId: None,
            baseTrapId: None,
            portableTrapId: None,
            doorTrapId: None,
            mineTrapId: None,
            neutralBossEnemyId: None,
            nestTrapId: None,
            shopNpcName: None,
            daysBetweenAssessment: 0,
            portableConstructUnlockLevel: 0,
            outpostConstructUnlockLevel: 0,
            maxEnemyCountSameTimeInRush: 0,
            maxPreDelayTimeInRush: 0.0,
            maxSaveCnt: 0,
            firstSeasonDuration: 0,
            seasonTransitionLoop: None,
            seasonDurationLoop: None,
            firstSeasonStartAngle: 0.0,
            seasonTransitionAngleLoop: None,
            seasonAngle: 0.0,
            battleItemDesc: None,
            foodDesc: None,
            multipleSurvivalDayDesc: None,
            multipleTips: None,
            techProgressScore: 0,
            otherEnemyRushName: None,
            surviveDayText: None,
            survivePeriodText: None,
            surviveScoreText: None,
            actionPointScoreText: None,
            nodeExploreDesc: None,
            dungeonExploreDesc: None,
            nodeCompleteDesc: None,
            noRiftDungeonDesc: None,
            baseRushedDesc: None,
            riftBaseDesc: None,
            riftBaseRushedDesc: None,
            dungeonTriggeredGuideQuestList: None,
            noLogInEnemyStatsEnemyId: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2GameConstBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2GameConstBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_mainMapId(&mut self, mainMapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_MAINMAPID,
            mainMapId,
        );
    }
    #[inline]
    pub fn add_baseTrapId(&mut self, baseTrapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_BASETRAPID,
            baseTrapId,
        );
    }
    #[inline]
    pub fn add_portableTrapId(&mut self, portableTrapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_PORTABLETRAPID,
            portableTrapId,
        );
    }
    #[inline]
    pub fn add_doorTrapId(&mut self, doorTrapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_DOORTRAPID,
            doorTrapId,
        );
    }
    #[inline]
    pub fn add_mineTrapId(&mut self, mineTrapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_MINETRAPID,
            mineTrapId,
        );
    }
    #[inline]
    pub fn add_neutralBossEnemyId(
        &mut self,
        neutralBossEnemyId: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_NEUTRALBOSSENEMYID,
            neutralBossEnemyId,
        );
    }
    #[inline]
    pub fn add_nestTrapId(&mut self, nestTrapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_NESTTRAPID,
            nestTrapId,
        );
    }
    #[inline]
    pub fn add_shopNpcName(&mut self, shopNpcName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_SHOPNPCNAME,
            shopNpcName,
        );
    }
    #[inline]
    pub fn add_daysBetweenAssessment(&mut self, daysBetweenAssessment: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2GameConst::VT_DAYSBETWEENASSESSMENT,
            daysBetweenAssessment,
            0,
        );
    }
    #[inline]
    pub fn add_portableConstructUnlockLevel(&mut self, portableConstructUnlockLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2GameConst::VT_PORTABLECONSTRUCTUNLOCKLEVEL,
            portableConstructUnlockLevel,
            0,
        );
    }
    #[inline]
    pub fn add_outpostConstructUnlockLevel(&mut self, outpostConstructUnlockLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2GameConst::VT_OUTPOSTCONSTRUCTUNLOCKLEVEL,
            outpostConstructUnlockLevel,
            0,
        );
    }
    #[inline]
    pub fn add_maxEnemyCountSameTimeInRush(&mut self, maxEnemyCountSameTimeInRush: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2GameConst::VT_MAXENEMYCOUNTSAMETIMEINRUSH,
            maxEnemyCountSameTimeInRush,
            0,
        );
    }
    #[inline]
    pub fn add_maxPreDelayTimeInRush(&mut self, maxPreDelayTimeInRush: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2GameConst::VT_MAXPREDELAYTIMEINRUSH,
            maxPreDelayTimeInRush,
            0.0,
        );
    }
    #[inline]
    pub fn add_maxSaveCnt(&mut self, maxSaveCnt: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2GameConst::VT_MAXSAVECNT, maxSaveCnt, 0);
    }
    #[inline]
    pub fn add_firstSeasonDuration(&mut self, firstSeasonDuration: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2GameConst::VT_FIRSTSEASONDURATION,
            firstSeasonDuration,
            0,
        );
    }
    #[inline]
    pub fn add_seasonTransitionLoop(
        &mut self,
        seasonTransitionLoop: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, enum__Torappu_SandboxV2SeasonType>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_SEASONTRANSITIONLOOP,
            seasonTransitionLoop,
        );
    }
    #[inline]
    pub fn add_seasonDurationLoop(
        &mut self,
        seasonDurationLoop: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_SEASONDURATIONLOOP,
            seasonDurationLoop,
        );
    }
    #[inline]
    pub fn add_firstSeasonStartAngle(&mut self, firstSeasonStartAngle: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2GameConst::VT_FIRSTSEASONSTARTANGLE,
            firstSeasonStartAngle,
            0.0,
        );
    }
    #[inline]
    pub fn add_seasonTransitionAngleLoop(
        &mut self,
        seasonTransitionAngleLoop: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_SEASONTRANSITIONANGLELOOP,
            seasonTransitionAngleLoop,
        );
    }
    #[inline]
    pub fn add_seasonAngle(&mut self, seasonAngle: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2GameConst::VT_SEASONANGLE,
            seasonAngle,
            0.0,
        );
    }
    #[inline]
    pub fn add_battleItemDesc(&mut self, battleItemDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_BATTLEITEMDESC,
            battleItemDesc,
        );
    }
    #[inline]
    pub fn add_foodDesc(&mut self, foodDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_FOODDESC,
            foodDesc,
        );
    }
    #[inline]
    pub fn add_multipleSurvivalDayDesc(
        &mut self,
        multipleSurvivalDayDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_MULTIPLESURVIVALDAYDESC,
            multipleSurvivalDayDesc,
        );
    }
    #[inline]
    pub fn add_multipleTips(&mut self, multipleTips: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_MULTIPLETIPS,
            multipleTips,
        );
    }
    #[inline]
    pub fn add_techProgressScore(&mut self, techProgressScore: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2GameConst::VT_TECHPROGRESSSCORE,
            techProgressScore,
            0,
        );
    }
    #[inline]
    pub fn add_otherEnemyRushName(&mut self, otherEnemyRushName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_OTHERENEMYRUSHNAME,
            otherEnemyRushName,
        );
    }
    #[inline]
    pub fn add_surviveDayText(&mut self, surviveDayText: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_SURVIVEDAYTEXT,
            surviveDayText,
        );
    }
    #[inline]
    pub fn add_survivePeriodText(&mut self, survivePeriodText: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_SURVIVEPERIODTEXT,
            survivePeriodText,
        );
    }
    #[inline]
    pub fn add_surviveScoreText(&mut self, surviveScoreText: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_SURVIVESCORETEXT,
            surviveScoreText,
        );
    }
    #[inline]
    pub fn add_actionPointScoreText(
        &mut self,
        actionPointScoreText: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_ACTIONPOINTSCORETEXT,
            actionPointScoreText,
        );
    }
    #[inline]
    pub fn add_nodeExploreDesc(&mut self, nodeExploreDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_NODEEXPLOREDESC,
            nodeExploreDesc,
        );
    }
    #[inline]
    pub fn add_dungeonExploreDesc(&mut self, dungeonExploreDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_DUNGEONEXPLOREDESC,
            dungeonExploreDesc,
        );
    }
    #[inline]
    pub fn add_nodeCompleteDesc(&mut self, nodeCompleteDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_NODECOMPLETEDESC,
            nodeCompleteDesc,
        );
    }
    #[inline]
    pub fn add_noRiftDungeonDesc(&mut self, noRiftDungeonDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_NORIFTDUNGEONDESC,
            noRiftDungeonDesc,
        );
    }
    #[inline]
    pub fn add_baseRushedDesc(&mut self, baseRushedDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_BASERUSHEDDESC,
            baseRushedDesc,
        );
    }
    #[inline]
    pub fn add_riftBaseDesc(&mut self, riftBaseDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_RIFTBASEDESC,
            riftBaseDesc,
        );
    }
    #[inline]
    pub fn add_riftBaseRushedDesc(&mut self, riftBaseRushedDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_RIFTBASERUSHEDDESC,
            riftBaseRushedDesc,
        );
    }
    #[inline]
    pub fn add_dungeonTriggeredGuideQuestList(
        &mut self,
        dungeonTriggeredGuideQuestList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_DUNGEONTRIGGEREDGUIDEQUESTLIST,
            dungeonTriggeredGuideQuestList,
        );
    }
    #[inline]
    pub fn add_noLogInEnemyStatsEnemyId(
        &mut self,
        noLogInEnemyStatsEnemyId: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_NOLOGINENEMYSTATSENEMYID,
            noLogInEnemyStatsEnemyId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2GameConstBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2GameConstBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2GameConst<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2GameConst<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2GameConst");
        ds.field("mainMapId", &self.mainMapId());
        ds.field("baseTrapId", &self.baseTrapId());
        ds.field("portableTrapId", &self.portableTrapId());
        ds.field("doorTrapId", &self.doorTrapId());
        ds.field("mineTrapId", &self.mineTrapId());
        ds.field("neutralBossEnemyId", &self.neutralBossEnemyId());
        ds.field("nestTrapId", &self.nestTrapId());
        ds.field("shopNpcName", &self.shopNpcName());
        ds.field("daysBetweenAssessment", &self.daysBetweenAssessment());
        ds.field(
            "portableConstructUnlockLevel",
            &self.portableConstructUnlockLevel(),
        );
        ds.field(
            "outpostConstructUnlockLevel",
            &self.outpostConstructUnlockLevel(),
        );
        ds.field(
            "maxEnemyCountSameTimeInRush",
            &self.maxEnemyCountSameTimeInRush(),
        );
        ds.field("maxPreDelayTimeInRush", &self.maxPreDelayTimeInRush());
        ds.field("maxSaveCnt", &self.maxSaveCnt());
        ds.field("firstSeasonDuration", &self.firstSeasonDuration());
        ds.field("seasonTransitionLoop", &self.seasonTransitionLoop());
        ds.field("seasonDurationLoop", &self.seasonDurationLoop());
        ds.field("firstSeasonStartAngle", &self.firstSeasonStartAngle());
        ds.field(
            "seasonTransitionAngleLoop",
            &self.seasonTransitionAngleLoop(),
        );
        ds.field("seasonAngle", &self.seasonAngle());
        ds.field("battleItemDesc", &self.battleItemDesc());
        ds.field("foodDesc", &self.foodDesc());
        ds.field("multipleSurvivalDayDesc", &self.multipleSurvivalDayDesc());
        ds.field("multipleTips", &self.multipleTips());
        ds.field("techProgressScore", &self.techProgressScore());
        ds.field("otherEnemyRushName", &self.otherEnemyRushName());
        ds.field("surviveDayText", &self.surviveDayText());
        ds.field("survivePeriodText", &self.survivePeriodText());
        ds.field("surviveScoreText", &self.surviveScoreText());
        ds.field("actionPointScoreText", &self.actionPointScoreText());
        ds.field("nodeExploreDesc", &self.nodeExploreDesc());
        ds.field("dungeonExploreDesc", &self.dungeonExploreDesc());
        ds.field("nodeCompleteDesc", &self.nodeCompleteDesc());
        ds.field("noRiftDungeonDesc", &self.noRiftDungeonDesc());
        ds.field("baseRushedDesc", &self.baseRushedDesc());
        ds.field("riftBaseDesc", &self.riftBaseDesc());
        ds.field("riftBaseRushedDesc", &self.riftBaseRushedDesc());
        ds.field(
            "dungeonTriggeredGuideQuestList",
            &self.dungeonTriggeredGuideQuestList(),
        );
        ds.field("noLogInEnemyStatsEnemyId", &self.noLogInEnemyStatsEnemyId());
        ds.finish()
    }
}
pub enum clz_Torappu_ItemBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ItemBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ItemBundle<'a> {
    type Inner = clz_Torappu_ItemBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ItemBundle<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_COUNT: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ItemBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ItemBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'bldr>> {
        let mut builder = clz_Torappu_ItemBundleBuilder::new(_fbb);
        builder.add_type_(args.type_);
        builder.add_count(args.count);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_ItemBundle::VT_ID, None)
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ItemBundle::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_ItemBundle::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ItemBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ItemBundleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl<'a> Default for clz_Torappu_ItemBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ItemBundleArgs {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}

pub struct clz_Torappu_ItemBundleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ItemBundle::VT_ID, id);
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ItemBundle::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_ItemBundle::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ItemBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ItemBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ItemBundle");
        ds.field("id", &self.id());
        ds.field("count", &self.count());
        ds.field("type_", &self.type_());
        ds.finish()
    }
}
pub enum dict__string__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__string<'a> {
    type Inner = dict__string__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__string<'bldr>> {
        let mut builder = dict__string__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__string::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__string::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__stringArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for dict__string__stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__stringArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__stringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__stringBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__string::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__string::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, dict__string__string::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2DiffModeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2DiffModeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2DiffModeData<'a> {
    type Inner = clz_Torappu_SandboxV2DiffModeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2DiffModeData<'a> {
    pub const VT_TITLE: flatbuffers::VOffsetT = 4;
    pub const VT_DESC: flatbuffers::VOffsetT = 6;
    pub const VT_BUFFLIST: flatbuffers::VOffsetT = 8;
    pub const VT_DETAILLIST: flatbuffers::VOffsetT = 10;
    pub const VT_SORTID: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2DiffModeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2DiffModeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DiffModeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2DiffModeDataBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.detailList {
            builder.add_detailList(x);
        }
        if let Some(x) = args.buffList {
            builder.add_buffList(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.title {
            builder.add_title(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn title(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DiffModeData::VT_TITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DiffModeData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn buffList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxV2DiffModeData::VT_BUFFLIST, None)
        }
    }
    #[inline]
    pub fn detailList(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DiffModeData::VT_DETAILLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2DiffModeData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2DiffModeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("buffList", Self::VT_BUFFLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "detailList",
                Self::VT_DETAILLIST,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2DiffModeDataArgs<'a> {
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub detailList: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2DiffModeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2DiffModeDataArgs {
            title: None,
            desc: None,
            buffList: None,
            detailList: None,
            sortId: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2DiffModeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2DiffModeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DiffModeData::VT_TITLE,
            title,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DiffModeData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_buffList(
        &mut self,
        buffList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DiffModeData::VT_BUFFLIST,
            buffList,
        );
    }
    #[inline]
    pub fn add_detailList(&mut self, detailList: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DiffModeData::VT_DETAILLIST,
            detailList,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2DiffModeData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2DiffModeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2DiffModeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DiffModeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2DiffModeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2DiffModeData");
        ds.field("title", &self.title());
        ds.field("desc", &self.desc());
        ds.field("buffList", &self.buffList());
        ds.field("detailList", &self.detailList());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2BasicConstOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2BasicConst<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2BasicConst<'a> {
    type Inner = clz_Torappu_SandboxV2BasicConst<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2BasicConst<'a> {
    pub const VT_STAMINAITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_GOLDITEMID: flatbuffers::VOffsetT = 6;
    pub const VT_DIMENSIONCOINITEMID: flatbuffers::VOffsetT = 8;
    pub const VT_ALWAYSSHOWITEMIDSCONSTRUCT: flatbuffers::VOffsetT = 10;
    pub const VT_ALWAYSSHOWITEMIDS: flatbuffers::VOffsetT = 12;
    pub const VT_BAGBOTTOMBARRESTYPE: flatbuffers::VOffsetT = 14;
    pub const VT_FAILEDCOOKFOOD: flatbuffers::VOffsetT = 16;
    pub const VT_MAXFOODDURATION: flatbuffers::VOffsetT = 18;
    pub const VT_DRINKCOSTONCE: flatbuffers::VOffsetT = 20;
    pub const VT_DRINKMAKELIMIT: flatbuffers::VOffsetT = 22;
    pub const VT_SPECIALMATWATER: flatbuffers::VOffsetT = 24;
    pub const VT_WORKBENCHMAKELIMIT: flatbuffers::VOffsetT = 26;
    pub const VT_LOGISTICSPOSLIMIT: flatbuffers::VOffsetT = 28;
    pub const VT_LOGISTICSUNLOCKLEVEL: flatbuffers::VOffsetT = 30;
    pub const VT_LOGISTICSDRINKCOST: flatbuffers::VOffsetT = 32;
    pub const VT_LOGISTICSEVACUATETIPS: flatbuffers::VOffsetT = 34;
    pub const VT_LOGISTICSEVACUATEWARNING: flatbuffers::VOffsetT = 36;
    pub const VT_BASEREPAIRCOST: flatbuffers::VOffsetT = 38;
    pub const VT_PORTREPAIRCOST: flatbuffers::VOffsetT = 40;
    pub const VT_UNITFENCELIMIT: flatbuffers::VOffsetT = 42;
    pub const VT_UNITRAREFENCELIMIT: flatbuffers::VOffsetT = 44;
    pub const VT_CAGEID: flatbuffers::VOffsetT = 46;
    pub const VT_FENCEID: flatbuffers::VOffsetT = 48;
    pub const VT_RAREFENCEID: flatbuffers::VOffsetT = 50;
    pub const VT_MONTHLYRUSHENTRYTEXT1: flatbuffers::VOffsetT = 52;
    pub const VT_MONTHLYENTRYUNLOCKTEXT: flatbuffers::VOffsetT = 54;
    pub const VT_MONTHLYENTRYRIFTTEXT: flatbuffers::VOffsetT = 56;
    pub const VT_MONTHLYRUSHINTRO: flatbuffers::VOffsetT = 58;
    pub const VT_MONTHLYCOIN: flatbuffers::VOffsetT = 60;
    pub const VT_CHARRARITYCOLORLIST: flatbuffers::VOffsetT = 62;
    pub const VT_SQUADCHARCAPACITY: flatbuffers::VOffsetT = 64;
    pub const VT_TOTALSQUADCNT: flatbuffers::VOffsetT = 66;
    pub const VT_TOOLBOXCAPACITY: flatbuffers::VOffsetT = 68;
    pub const VT_TOOLCNTLIMITINSQUAD: flatbuffers::VOffsetT = 70;
    pub const VT_MINISQUADCHARCAPACITY: flatbuffers::VOffsetT = 72;
    pub const VT_MINISQUADDRINKCOST: flatbuffers::VOffsetT = 74;
    pub const VT_NORMALSQUADDRINKCOST: flatbuffers::VOffsetT = 76;
    pub const VT_EMPTYSQUADDRINKCOST: flatbuffers::VOffsetT = 78;
    pub const VT_ACHIEVETYPEALL: flatbuffers::VOffsetT = 80;
    pub const VT_CONSTRUCTMODEBGMHOME: flatbuffers::VOffsetT = 82;
    pub const VT_BATTLEBGMCOLLECT: flatbuffers::VOffsetT = 84;
    pub const VT_BATTLEBGMHUNT: flatbuffers::VOffsetT = 86;
    pub const VT_BATTLEBGMENEMYRUSH: flatbuffers::VOffsetT = 88;
    pub const VT_BATTLEBGMBOSSRUSH: flatbuffers::VOffsetT = 90;
    pub const VT_IMGLOADINGNORMALNAME: flatbuffers::VOffsetT = 92;
    pub const VT_IMGLOADINGBASENAME: flatbuffers::VOffsetT = 94;
    pub const VT_IMGUNLOADINGBASENAME: flatbuffers::VOffsetT = 96;
    pub const VT_ISCHALLENGEOPEN: flatbuffers::VOffsetT = 98;
    pub const VT_ISRACINGOPEN: flatbuffers::VOffsetT = 100;
    pub const VT_HASEXPLOREMODE: flatbuffers::VOffsetT = 102;
    pub const VT_EXPLOREMODEBUFFDESCS: flatbuffers::VOffsetT = 104;
    pub const VT_MODESELECTTIPS: flatbuffers::VOffsetT = 106;
    pub const VT_STRINGRES: flatbuffers::VOffsetT = 108;
    pub const VT_DIFFLIST: flatbuffers::VOffsetT = 110;
    pub const VT_BATTLEPRELOADENEMIES: flatbuffers::VOffsetT = 112;
    pub const VT_BATTLEEXCLUDEDTRAPSINRUSH: flatbuffers::VOffsetT = 114;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2BasicConst { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2BasicConstArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BasicConst<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2BasicConstBuilder::new(_fbb);
        if let Some(x) = args.battleExcludedTrapsInRush {
            builder.add_battleExcludedTrapsInRush(x);
        }
        if let Some(x) = args.battlePreloadEnemies {
            builder.add_battlePreloadEnemies(x);
        }
        if let Some(x) = args.diffList {
            builder.add_diffList(x);
        }
        if let Some(x) = args.stringRes {
            builder.add_stringRes(x);
        }
        if let Some(x) = args.modeSelectTips {
            builder.add_modeSelectTips(x);
        }
        if let Some(x) = args.exploreModeBuffDescs {
            builder.add_exploreModeBuffDescs(x);
        }
        if let Some(x) = args.imgUnloadingBaseName {
            builder.add_imgUnloadingBaseName(x);
        }
        if let Some(x) = args.imgLoadingBaseName {
            builder.add_imgLoadingBaseName(x);
        }
        if let Some(x) = args.imgLoadingNormalName {
            builder.add_imgLoadingNormalName(x);
        }
        if let Some(x) = args.battleBgmBossRush {
            builder.add_battleBgmBossRush(x);
        }
        if let Some(x) = args.battleBgmEnemyRush {
            builder.add_battleBgmEnemyRush(x);
        }
        if let Some(x) = args.battleBgmHunt {
            builder.add_battleBgmHunt(x);
        }
        if let Some(x) = args.battleBgmCollect {
            builder.add_battleBgmCollect(x);
        }
        if let Some(x) = args.constructModeBgmHome {
            builder.add_constructModeBgmHome(x);
        }
        if let Some(x) = args.achieveTypeAll {
            builder.add_achieveTypeAll(x);
        }
        builder.add_emptySquadDrinkCost(args.emptySquadDrinkCost);
        builder.add_normalSquadDrinkCost(args.normalSquadDrinkCost);
        builder.add_miniSquadDrinkCost(args.miniSquadDrinkCost);
        builder.add_miniSquadCharCapacity(args.miniSquadCharCapacity);
        builder.add_toolCntLimitInSquad(args.toolCntLimitInSquad);
        builder.add_toolboxCapacity(args.toolboxCapacity);
        builder.add_totalSquadCnt(args.totalSquadCnt);
        builder.add_squadCharCapacity(args.squadCharCapacity);
        if let Some(x) = args.charRarityColorList {
            builder.add_charRarityColorList(x);
        }
        if let Some(x) = args.monthlyCoin {
            builder.add_monthlyCoin(x);
        }
        if let Some(x) = args.monthlyRushIntro {
            builder.add_monthlyRushIntro(x);
        }
        if let Some(x) = args.monthlyEntryRiftText {
            builder.add_monthlyEntryRiftText(x);
        }
        if let Some(x) = args.monthlyEntryUnlockText {
            builder.add_monthlyEntryUnlockText(x);
        }
        if let Some(x) = args.monthlyRushEntryText1 {
            builder.add_monthlyRushEntryText1(x);
        }
        if let Some(x) = args.rareFenceId {
            builder.add_rareFenceId(x);
        }
        if let Some(x) = args.fenceId {
            builder.add_fenceId(x);
        }
        if let Some(x) = args.cageId {
            builder.add_cageId(x);
        }
        builder.add_unitRareFenceLimit(args.unitRareFenceLimit);
        builder.add_unitFenceLimit(args.unitFenceLimit);
        builder.add_portRepairCost(args.portRepairCost);
        builder.add_baseRepairCost(args.baseRepairCost);
        if let Some(x) = args.logisticsEvacuateWarning {
            builder.add_logisticsEvacuateWarning(x);
        }
        if let Some(x) = args.logisticsEvacuateTips {
            builder.add_logisticsEvacuateTips(x);
        }
        builder.add_logisticsDrinkCost(args.logisticsDrinkCost);
        builder.add_logisticsUnlockLevel(args.logisticsUnlockLevel);
        builder.add_logisticsPosLimit(args.logisticsPosLimit);
        builder.add_workbenchMakeLimit(args.workbenchMakeLimit);
        if let Some(x) = args.specialMatWater {
            builder.add_specialMatWater(x);
        }
        builder.add_drinkMakeLimit(args.drinkMakeLimit);
        builder.add_drinkCostOnce(args.drinkCostOnce);
        builder.add_maxFoodDuration(args.maxFoodDuration);
        if let Some(x) = args.failedCookFood {
            builder.add_failedCookFood(x);
        }
        if let Some(x) = args.bagBottomBarResType {
            builder.add_bagBottomBarResType(x);
        }
        if let Some(x) = args.alwaysShowItemIds {
            builder.add_alwaysShowItemIds(x);
        }
        if let Some(x) = args.alwaysShowItemIdsConstruct {
            builder.add_alwaysShowItemIdsConstruct(x);
        }
        if let Some(x) = args.dimensioncoinItemId {
            builder.add_dimensioncoinItemId(x);
        }
        if let Some(x) = args.goldItemId {
            builder.add_goldItemId(x);
        }
        if let Some(x) = args.staminaItemId {
            builder.add_staminaItemId(x);
        }
        builder.add_hasExploreMode(args.hasExploreMode);
        builder.add_isRacingOpen(args.isRacingOpen);
        builder.add_isChallengeOpen(args.isChallengeOpen);
        builder.finish()
    }

    #[inline]
    pub fn staminaItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_STAMINAITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn goldItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_GOLDITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn dimensioncoinItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_DIMENSIONCOINITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn alwaysShowItemIdsConstruct(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2BasicConst::VT_ALWAYSSHOWITEMIDSCONSTRUCT,
                None,
            )
        }
    }
    #[inline]
    pub fn alwaysShowItemIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxV2BasicConst::VT_ALWAYSSHOWITEMIDS, None)
        }
    }
    #[inline]
    pub fn bagBottomBarResType(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2BasicConst::VT_BAGBOTTOMBARRESTYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn failedCookFood(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_FAILEDCOOKFOOD,
                None,
            )
        }
    }
    #[inline]
    pub fn maxFoodDuration(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2BasicConst::VT_MAXFOODDURATION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn drinkCostOnce(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2BasicConst::VT_DRINKCOSTONCE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn drinkMakeLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2BasicConst::VT_DRINKMAKELIMIT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn specialMatWater(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_SPECIALMATWATER,
                None,
            )
        }
    }
    #[inline]
    pub fn workbenchMakeLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BasicConst::VT_WORKBENCHMAKELIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn logisticsPosLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BasicConst::VT_LOGISTICSPOSLIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn logisticsUnlockLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BasicConst::VT_LOGISTICSUNLOCKLEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn logisticsDrinkCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BasicConst::VT_LOGISTICSDRINKCOST,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn logisticsEvacuateTips(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_LOGISTICSEVACUATETIPS,
                None,
            )
        }
    }
    #[inline]
    pub fn logisticsEvacuateWarning(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_LOGISTICSEVACUATEWARNING,
                None,
            )
        }
    }
    #[inline]
    pub fn baseRepairCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2BasicConst::VT_BASEREPAIRCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn portRepairCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2BasicConst::VT_PORTREPAIRCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn unitFenceLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2BasicConst::VT_UNITFENCELIMIT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn unitRareFenceLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BasicConst::VT_UNITRAREFENCELIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn cageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_CAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn fenceId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_FENCEID,
                None,
            )
        }
    }
    #[inline]
    pub fn rareFenceId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_RAREFENCEID,
                None,
            )
        }
    }
    #[inline]
    pub fn monthlyRushEntryText1(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_MONTHLYRUSHENTRYTEXT1,
                None,
            )
        }
    }
    #[inline]
    pub fn monthlyEntryUnlockText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_MONTHLYENTRYUNLOCKTEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn monthlyEntryRiftText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_MONTHLYENTRYRIFTTEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn monthlyRushIntro(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_MONTHLYRUSHINTRO,
                None,
            )
        }
    }
    #[inline]
    pub fn monthlyCoin(&self) -> Option<clz_Torappu_ItemBundle<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>(
                    clz_Torappu_SandboxV2BasicConst::VT_MONTHLYCOIN,
                    None,
                )
        }
    }
    #[inline]
    pub fn charRarityColorList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2BasicConst::VT_CHARRARITYCOLORLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn squadCharCapacity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BasicConst::VT_SQUADCHARCAPACITY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn totalSquadCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2BasicConst::VT_TOTALSQUADCNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn toolboxCapacity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2BasicConst::VT_TOOLBOXCAPACITY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn toolCntLimitInSquad(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BasicConst::VT_TOOLCNTLIMITINSQUAD,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn miniSquadCharCapacity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BasicConst::VT_MINISQUADCHARCAPACITY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn miniSquadDrinkCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BasicConst::VT_MINISQUADDRINKCOST,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn normalSquadDrinkCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BasicConst::VT_NORMALSQUADDRINKCOST,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn emptySquadDrinkCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BasicConst::VT_EMPTYSQUADDRINKCOST,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn achieveTypeAll(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_ACHIEVETYPEALL,
                None,
            )
        }
    }
    #[inline]
    pub fn constructModeBgmHome(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_CONSTRUCTMODEBGMHOME,
                None,
            )
        }
    }
    #[inline]
    pub fn battleBgmCollect(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_BATTLEBGMCOLLECT,
                None,
            )
        }
    }
    #[inline]
    pub fn battleBgmHunt(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_BATTLEBGMHUNT,
                None,
            )
        }
    }
    #[inline]
    pub fn battleBgmEnemyRush(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_BATTLEBGMENEMYRUSH,
                None,
            )
        }
    }
    #[inline]
    pub fn battleBgmBossRush(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_BATTLEBGMBOSSRUSH,
                None,
            )
        }
    }
    #[inline]
    pub fn imgLoadingNormalName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_IMGLOADINGNORMALNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn imgLoadingBaseName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_IMGLOADINGBASENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn imgUnloadingBaseName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_IMGUNLOADINGBASENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn isChallengeOpen(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_SandboxV2BasicConst::VT_ISCHALLENGEOPEN,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn isRacingOpen(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_SandboxV2BasicConst::VT_ISRACINGOPEN,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn hasExploreMode(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_SandboxV2BasicConst::VT_HASEXPLOREMODE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn exploreModeBuffDescs(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2BasicConst::VT_EXPLOREMODEBUFFDESCS,
                None,
            )
        }
    }
    #[inline]
    pub fn modeSelectTips(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_MODESELECTTIPS,
                None,
            )
        }
    }
    #[inline]
    pub fn stringRes(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(clz_Torappu_SandboxV2BasicConst::VT_STRINGRES, None)
        }
    }
    #[inline]
    pub fn diffList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DiffModeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DiffModeData>,
                >,
            >>(clz_Torappu_SandboxV2BasicConst::VT_DIFFLIST, None)
        }
    }
    #[inline]
    pub fn battlePreloadEnemies(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2BasicConst::VT_BATTLEPRELOADENEMIES,
                None,
            )
        }
    }
    #[inline]
    pub fn battleExcludedTrapsInRush(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2BasicConst::VT_BATTLEEXCLUDEDTRAPSINRUSH,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2BasicConst<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "staminaItemId",
                Self::VT_STAMINAITEMID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "goldItemId",
                Self::VT_GOLDITEMID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dimensioncoinItemId",
                Self::VT_DIMENSIONCOINITEMID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "alwaysShowItemIdsConstruct",
                Self::VT_ALWAYSSHOWITEMIDSCONSTRUCT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("alwaysShowItemIds", Self::VT_ALWAYSSHOWITEMIDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("bagBottomBarResType", Self::VT_BAGBOTTOMBARRESTYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "failedCookFood",
                Self::VT_FAILEDCOOKFOOD,
                false,
            )?
            .visit_field::<i32>("maxFoodDuration", Self::VT_MAXFOODDURATION, false)?
            .visit_field::<i32>("drinkCostOnce", Self::VT_DRINKCOSTONCE, false)?
            .visit_field::<i32>("drinkMakeLimit", Self::VT_DRINKMAKELIMIT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "specialMatWater",
                Self::VT_SPECIALMATWATER,
                false,
            )?
            .visit_field::<i32>("workbenchMakeLimit", Self::VT_WORKBENCHMAKELIMIT, false)?
            .visit_field::<i32>("logisticsPosLimit", Self::VT_LOGISTICSPOSLIMIT, false)?
            .visit_field::<i32>("logisticsUnlockLevel", Self::VT_LOGISTICSUNLOCKLEVEL, false)?
            .visit_field::<i32>("logisticsDrinkCost", Self::VT_LOGISTICSDRINKCOST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "logisticsEvacuateTips",
                Self::VT_LOGISTICSEVACUATETIPS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "logisticsEvacuateWarning",
                Self::VT_LOGISTICSEVACUATEWARNING,
                false,
            )?
            .visit_field::<i32>("baseRepairCost", Self::VT_BASEREPAIRCOST, false)?
            .visit_field::<i32>("portRepairCost", Self::VT_PORTREPAIRCOST, false)?
            .visit_field::<i32>("unitFenceLimit", Self::VT_UNITFENCELIMIT, false)?
            .visit_field::<i32>("unitRareFenceLimit", Self::VT_UNITRAREFENCELIMIT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cageId", Self::VT_CAGEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fenceId", Self::VT_FENCEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rareFenceId",
                Self::VT_RAREFENCEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "monthlyRushEntryText1",
                Self::VT_MONTHLYRUSHENTRYTEXT1,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "monthlyEntryUnlockText",
                Self::VT_MONTHLYENTRYUNLOCKTEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "monthlyEntryRiftText",
                Self::VT_MONTHLYENTRYRIFTTEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "monthlyRushIntro",
                Self::VT_MONTHLYRUSHINTRO,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>(
                "monthlyCoin",
                Self::VT_MONTHLYCOIN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("charRarityColorList", Self::VT_CHARRARITYCOLORLIST, false)?
            .visit_field::<i32>("squadCharCapacity", Self::VT_SQUADCHARCAPACITY, false)?
            .visit_field::<i32>("totalSquadCnt", Self::VT_TOTALSQUADCNT, false)?
            .visit_field::<i32>("toolboxCapacity", Self::VT_TOOLBOXCAPACITY, false)?
            .visit_field::<i32>("toolCntLimitInSquad", Self::VT_TOOLCNTLIMITINSQUAD, false)?
            .visit_field::<i32>(
                "miniSquadCharCapacity",
                Self::VT_MINISQUADCHARCAPACITY,
                false,
            )?
            .visit_field::<i32>("miniSquadDrinkCost", Self::VT_MINISQUADDRINKCOST, false)?
            .visit_field::<i32>("normalSquadDrinkCost", Self::VT_NORMALSQUADDRINKCOST, false)?
            .visit_field::<i32>("emptySquadDrinkCost", Self::VT_EMPTYSQUADDRINKCOST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "achieveTypeAll",
                Self::VT_ACHIEVETYPEALL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "constructModeBgmHome",
                Self::VT_CONSTRUCTMODEBGMHOME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "battleBgmCollect",
                Self::VT_BATTLEBGMCOLLECT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "battleBgmHunt",
                Self::VT_BATTLEBGMHUNT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "battleBgmEnemyRush",
                Self::VT_BATTLEBGMENEMYRUSH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "battleBgmBossRush",
                Self::VT_BATTLEBGMBOSSRUSH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "imgLoadingNormalName",
                Self::VT_IMGLOADINGNORMALNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "imgLoadingBaseName",
                Self::VT_IMGLOADINGBASENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "imgUnloadingBaseName",
                Self::VT_IMGUNLOADINGBASENAME,
                false,
            )?
            .visit_field::<bool>("isChallengeOpen", Self::VT_ISCHALLENGEOPEN, false)?
            .visit_field::<bool>("isRacingOpen", Self::VT_ISRACINGOPEN, false)?
            .visit_field::<bool>("hasExploreMode", Self::VT_HASEXPLOREMODE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("exploreModeBuffDescs", Self::VT_EXPLOREMODEBUFFDESCS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "modeSelectTips",
                Self::VT_MODESELECTTIPS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>("stringRes", Self::VT_STRINGRES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DiffModeData>,
                >,
            >>("diffList", Self::VT_DIFFLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("battlePreloadEnemies", Self::VT_BATTLEPRELOADENEMIES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "battleExcludedTrapsInRush",
                Self::VT_BATTLEEXCLUDEDTRAPSINRUSH,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2BasicConstArgs<'a> {
    pub staminaItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub goldItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dimensioncoinItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub alwaysShowItemIdsConstruct: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub alwaysShowItemIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub bagBottomBarResType: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub failedCookFood: Option<flatbuffers::WIPOffset<&'a str>>,
    pub maxFoodDuration: i32,
    pub drinkCostOnce: i32,
    pub drinkMakeLimit: i32,
    pub specialMatWater: Option<flatbuffers::WIPOffset<&'a str>>,
    pub workbenchMakeLimit: i32,
    pub logisticsPosLimit: i32,
    pub logisticsUnlockLevel: i32,
    pub logisticsDrinkCost: i32,
    pub logisticsEvacuateTips: Option<flatbuffers::WIPOffset<&'a str>>,
    pub logisticsEvacuateWarning: Option<flatbuffers::WIPOffset<&'a str>>,
    pub baseRepairCost: i32,
    pub portRepairCost: i32,
    pub unitFenceLimit: i32,
    pub unitRareFenceLimit: i32,
    pub cageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub fenceId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rareFenceId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub monthlyRushEntryText1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub monthlyEntryUnlockText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub monthlyEntryRiftText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub monthlyRushIntro: Option<flatbuffers::WIPOffset<&'a str>>,
    pub monthlyCoin: Option<flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'a>>>,
    pub charRarityColorList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub squadCharCapacity: i32,
    pub totalSquadCnt: i32,
    pub toolboxCapacity: i32,
    pub toolCntLimitInSquad: i32,
    pub miniSquadCharCapacity: i32,
    pub miniSquadDrinkCost: i32,
    pub normalSquadDrinkCost: i32,
    pub emptySquadDrinkCost: i32,
    pub achieveTypeAll: Option<flatbuffers::WIPOffset<&'a str>>,
    pub constructModeBgmHome: Option<flatbuffers::WIPOffset<&'a str>>,
    pub battleBgmCollect: Option<flatbuffers::WIPOffset<&'a str>>,
    pub battleBgmHunt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub battleBgmEnemyRush: Option<flatbuffers::WIPOffset<&'a str>>,
    pub battleBgmBossRush: Option<flatbuffers::WIPOffset<&'a str>>,
    pub imgLoadingNormalName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub imgLoadingBaseName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub imgUnloadingBaseName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isChallengeOpen: bool,
    pub isRacingOpen: bool,
    pub hasExploreMode: bool,
    pub exploreModeBuffDescs: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub modeSelectTips: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stringRes: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>,
        >,
    >,
    pub diffList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DiffModeData<'a>>,
            >,
        >,
    >,
    pub battlePreloadEnemies: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub battleExcludedTrapsInRush: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2BasicConstArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2BasicConstArgs {
            staminaItemId: None,
            goldItemId: None,
            dimensioncoinItemId: None,
            alwaysShowItemIdsConstruct: None,
            alwaysShowItemIds: None,
            bagBottomBarResType: None,
            failedCookFood: None,
            maxFoodDuration: 0,
            drinkCostOnce: 0,
            drinkMakeLimit: 0,
            specialMatWater: None,
            workbenchMakeLimit: 0,
            logisticsPosLimit: 0,
            logisticsUnlockLevel: 0,
            logisticsDrinkCost: 0,
            logisticsEvacuateTips: None,
            logisticsEvacuateWarning: None,
            baseRepairCost: 0,
            portRepairCost: 0,
            unitFenceLimit: 0,
            unitRareFenceLimit: 0,
            cageId: None,
            fenceId: None,
            rareFenceId: None,
            monthlyRushEntryText1: None,
            monthlyEntryUnlockText: None,
            monthlyEntryRiftText: None,
            monthlyRushIntro: None,
            monthlyCoin: None,
            charRarityColorList: None,
            squadCharCapacity: 0,
            totalSquadCnt: 0,
            toolboxCapacity: 0,
            toolCntLimitInSquad: 0,
            miniSquadCharCapacity: 0,
            miniSquadDrinkCost: 0,
            normalSquadDrinkCost: 0,
            emptySquadDrinkCost: 0,
            achieveTypeAll: None,
            constructModeBgmHome: None,
            battleBgmCollect: None,
            battleBgmHunt: None,
            battleBgmEnemyRush: None,
            battleBgmBossRush: None,
            imgLoadingNormalName: None,
            imgLoadingBaseName: None,
            imgUnloadingBaseName: None,
            isChallengeOpen: false,
            isRacingOpen: false,
            hasExploreMode: false,
            exploreModeBuffDescs: None,
            modeSelectTips: None,
            stringRes: None,
            diffList: None,
            battlePreloadEnemies: None,
            battleExcludedTrapsInRush: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2BasicConstBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2BasicConstBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_staminaItemId(&mut self, staminaItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_STAMINAITEMID,
            staminaItemId,
        );
    }
    #[inline]
    pub fn add_goldItemId(&mut self, goldItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_GOLDITEMID,
            goldItemId,
        );
    }
    #[inline]
    pub fn add_dimensioncoinItemId(
        &mut self,
        dimensioncoinItemId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_DIMENSIONCOINITEMID,
            dimensioncoinItemId,
        );
    }
    #[inline]
    pub fn add_alwaysShowItemIdsConstruct(
        &mut self,
        alwaysShowItemIdsConstruct: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_ALWAYSSHOWITEMIDSCONSTRUCT,
            alwaysShowItemIdsConstruct,
        );
    }
    #[inline]
    pub fn add_alwaysShowItemIds(
        &mut self,
        alwaysShowItemIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_ALWAYSSHOWITEMIDS,
            alwaysShowItemIds,
        );
    }
    #[inline]
    pub fn add_bagBottomBarResType(
        &mut self,
        bagBottomBarResType: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_BAGBOTTOMBARRESTYPE,
            bagBottomBarResType,
        );
    }
    #[inline]
    pub fn add_failedCookFood(&mut self, failedCookFood: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_FAILEDCOOKFOOD,
            failedCookFood,
        );
    }
    #[inline]
    pub fn add_maxFoodDuration(&mut self, maxFoodDuration: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_MAXFOODDURATION,
            maxFoodDuration,
            0,
        );
    }
    #[inline]
    pub fn add_drinkCostOnce(&mut self, drinkCostOnce: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_DRINKCOSTONCE,
            drinkCostOnce,
            0,
        );
    }
    #[inline]
    pub fn add_drinkMakeLimit(&mut self, drinkMakeLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_DRINKMAKELIMIT,
            drinkMakeLimit,
            0,
        );
    }
    #[inline]
    pub fn add_specialMatWater(&mut self, specialMatWater: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_SPECIALMATWATER,
            specialMatWater,
        );
    }
    #[inline]
    pub fn add_workbenchMakeLimit(&mut self, workbenchMakeLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_WORKBENCHMAKELIMIT,
            workbenchMakeLimit,
            0,
        );
    }
    #[inline]
    pub fn add_logisticsPosLimit(&mut self, logisticsPosLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_LOGISTICSPOSLIMIT,
            logisticsPosLimit,
            0,
        );
    }
    #[inline]
    pub fn add_logisticsUnlockLevel(&mut self, logisticsUnlockLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_LOGISTICSUNLOCKLEVEL,
            logisticsUnlockLevel,
            0,
        );
    }
    #[inline]
    pub fn add_logisticsDrinkCost(&mut self, logisticsDrinkCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_LOGISTICSDRINKCOST,
            logisticsDrinkCost,
            0,
        );
    }
    #[inline]
    pub fn add_logisticsEvacuateTips(
        &mut self,
        logisticsEvacuateTips: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_LOGISTICSEVACUATETIPS,
            logisticsEvacuateTips,
        );
    }
    #[inline]
    pub fn add_logisticsEvacuateWarning(
        &mut self,
        logisticsEvacuateWarning: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_LOGISTICSEVACUATEWARNING,
            logisticsEvacuateWarning,
        );
    }
    #[inline]
    pub fn add_baseRepairCost(&mut self, baseRepairCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_BASEREPAIRCOST,
            baseRepairCost,
            0,
        );
    }
    #[inline]
    pub fn add_portRepairCost(&mut self, portRepairCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_PORTREPAIRCOST,
            portRepairCost,
            0,
        );
    }
    #[inline]
    pub fn add_unitFenceLimit(&mut self, unitFenceLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_UNITFENCELIMIT,
            unitFenceLimit,
            0,
        );
    }
    #[inline]
    pub fn add_unitRareFenceLimit(&mut self, unitRareFenceLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_UNITRAREFENCELIMIT,
            unitRareFenceLimit,
            0,
        );
    }
    #[inline]
    pub fn add_cageId(&mut self, cageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_CAGEID,
            cageId,
        );
    }
    #[inline]
    pub fn add_fenceId(&mut self, fenceId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_FENCEID,
            fenceId,
        );
    }
    #[inline]
    pub fn add_rareFenceId(&mut self, rareFenceId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_RAREFENCEID,
            rareFenceId,
        );
    }
    #[inline]
    pub fn add_monthlyRushEntryText1(
        &mut self,
        monthlyRushEntryText1: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_MONTHLYRUSHENTRYTEXT1,
            monthlyRushEntryText1,
        );
    }
    #[inline]
    pub fn add_monthlyEntryUnlockText(
        &mut self,
        monthlyEntryUnlockText: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_MONTHLYENTRYUNLOCKTEXT,
            monthlyEntryUnlockText,
        );
    }
    #[inline]
    pub fn add_monthlyEntryRiftText(
        &mut self,
        monthlyEntryRiftText: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_MONTHLYENTRYRIFTTEXT,
            monthlyEntryRiftText,
        );
    }
    #[inline]
    pub fn add_monthlyRushIntro(&mut self, monthlyRushIntro: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_MONTHLYRUSHINTRO,
            monthlyRushIntro,
        );
    }
    #[inline]
    pub fn add_monthlyCoin(
        &mut self,
        monthlyCoin: flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ItemBundle>>(
                clz_Torappu_SandboxV2BasicConst::VT_MONTHLYCOIN,
                monthlyCoin,
            );
    }
    #[inline]
    pub fn add_charRarityColorList(
        &mut self,
        charRarityColorList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_CHARRARITYCOLORLIST,
            charRarityColorList,
        );
    }
    #[inline]
    pub fn add_squadCharCapacity(&mut self, squadCharCapacity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_SQUADCHARCAPACITY,
            squadCharCapacity,
            0,
        );
    }
    #[inline]
    pub fn add_totalSquadCnt(&mut self, totalSquadCnt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_TOTALSQUADCNT,
            totalSquadCnt,
            0,
        );
    }
    #[inline]
    pub fn add_toolboxCapacity(&mut self, toolboxCapacity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_TOOLBOXCAPACITY,
            toolboxCapacity,
            0,
        );
    }
    #[inline]
    pub fn add_toolCntLimitInSquad(&mut self, toolCntLimitInSquad: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_TOOLCNTLIMITINSQUAD,
            toolCntLimitInSquad,
            0,
        );
    }
    #[inline]
    pub fn add_miniSquadCharCapacity(&mut self, miniSquadCharCapacity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_MINISQUADCHARCAPACITY,
            miniSquadCharCapacity,
            0,
        );
    }
    #[inline]
    pub fn add_miniSquadDrinkCost(&mut self, miniSquadDrinkCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_MINISQUADDRINKCOST,
            miniSquadDrinkCost,
            0,
        );
    }
    #[inline]
    pub fn add_normalSquadDrinkCost(&mut self, normalSquadDrinkCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_NORMALSQUADDRINKCOST,
            normalSquadDrinkCost,
            0,
        );
    }
    #[inline]
    pub fn add_emptySquadDrinkCost(&mut self, emptySquadDrinkCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_EMPTYSQUADDRINKCOST,
            emptySquadDrinkCost,
            0,
        );
    }
    #[inline]
    pub fn add_achieveTypeAll(&mut self, achieveTypeAll: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_ACHIEVETYPEALL,
            achieveTypeAll,
        );
    }
    #[inline]
    pub fn add_constructModeBgmHome(
        &mut self,
        constructModeBgmHome: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_CONSTRUCTMODEBGMHOME,
            constructModeBgmHome,
        );
    }
    #[inline]
    pub fn add_battleBgmCollect(&mut self, battleBgmCollect: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_BATTLEBGMCOLLECT,
            battleBgmCollect,
        );
    }
    #[inline]
    pub fn add_battleBgmHunt(&mut self, battleBgmHunt: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_BATTLEBGMHUNT,
            battleBgmHunt,
        );
    }
    #[inline]
    pub fn add_battleBgmEnemyRush(&mut self, battleBgmEnemyRush: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_BATTLEBGMENEMYRUSH,
            battleBgmEnemyRush,
        );
    }
    #[inline]
    pub fn add_battleBgmBossRush(&mut self, battleBgmBossRush: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_BATTLEBGMBOSSRUSH,
            battleBgmBossRush,
        );
    }
    #[inline]
    pub fn add_imgLoadingNormalName(
        &mut self,
        imgLoadingNormalName: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_IMGLOADINGNORMALNAME,
            imgLoadingNormalName,
        );
    }
    #[inline]
    pub fn add_imgLoadingBaseName(&mut self, imgLoadingBaseName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_IMGLOADINGBASENAME,
            imgLoadingBaseName,
        );
    }
    #[inline]
    pub fn add_imgUnloadingBaseName(
        &mut self,
        imgUnloadingBaseName: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_IMGUNLOADINGBASENAME,
            imgUnloadingBaseName,
        );
    }
    #[inline]
    pub fn add_isChallengeOpen(&mut self, isChallengeOpen: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SandboxV2BasicConst::VT_ISCHALLENGEOPEN,
            isChallengeOpen,
            false,
        );
    }
    #[inline]
    pub fn add_isRacingOpen(&mut self, isRacingOpen: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SandboxV2BasicConst::VT_ISRACINGOPEN,
            isRacingOpen,
            false,
        );
    }
    #[inline]
    pub fn add_hasExploreMode(&mut self, hasExploreMode: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SandboxV2BasicConst::VT_HASEXPLOREMODE,
            hasExploreMode,
            false,
        );
    }
    #[inline]
    pub fn add_exploreModeBuffDescs(
        &mut self,
        exploreModeBuffDescs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_EXPLOREMODEBUFFDESCS,
            exploreModeBuffDescs,
        );
    }
    #[inline]
    pub fn add_modeSelectTips(&mut self, modeSelectTips: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_MODESELECTTIPS,
            modeSelectTips,
        );
    }
    #[inline]
    pub fn add_stringRes(
        &mut self,
        stringRes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_STRINGRES,
            stringRes,
        );
    }
    #[inline]
    pub fn add_diffList(
        &mut self,
        diffList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DiffModeData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_DIFFLIST,
            diffList,
        );
    }
    #[inline]
    pub fn add_battlePreloadEnemies(
        &mut self,
        battlePreloadEnemies: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_BATTLEPRELOADENEMIES,
            battlePreloadEnemies,
        );
    }
    #[inline]
    pub fn add_battleExcludedTrapsInRush(
        &mut self,
        battleExcludedTrapsInRush: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_BATTLEEXCLUDEDTRAPSINRUSH,
            battleExcludedTrapsInRush,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2BasicConstBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2BasicConstBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BasicConst<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2BasicConst<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2BasicConst");
        ds.field("staminaItemId", &self.staminaItemId());
        ds.field("goldItemId", &self.goldItemId());
        ds.field("dimensioncoinItemId", &self.dimensioncoinItemId());
        ds.field(
            "alwaysShowItemIdsConstruct",
            &self.alwaysShowItemIdsConstruct(),
        );
        ds.field("alwaysShowItemIds", &self.alwaysShowItemIds());
        ds.field("bagBottomBarResType", &self.bagBottomBarResType());
        ds.field("failedCookFood", &self.failedCookFood());
        ds.field("maxFoodDuration", &self.maxFoodDuration());
        ds.field("drinkCostOnce", &self.drinkCostOnce());
        ds.field("drinkMakeLimit", &self.drinkMakeLimit());
        ds.field("specialMatWater", &self.specialMatWater());
        ds.field("workbenchMakeLimit", &self.workbenchMakeLimit());
        ds.field("logisticsPosLimit", &self.logisticsPosLimit());
        ds.field("logisticsUnlockLevel", &self.logisticsUnlockLevel());
        ds.field("logisticsDrinkCost", &self.logisticsDrinkCost());
        ds.field("logisticsEvacuateTips", &self.logisticsEvacuateTips());
        ds.field("logisticsEvacuateWarning", &self.logisticsEvacuateWarning());
        ds.field("baseRepairCost", &self.baseRepairCost());
        ds.field("portRepairCost", &self.portRepairCost());
        ds.field("unitFenceLimit", &self.unitFenceLimit());
        ds.field("unitRareFenceLimit", &self.unitRareFenceLimit());
        ds.field("cageId", &self.cageId());
        ds.field("fenceId", &self.fenceId());
        ds.field("rareFenceId", &self.rareFenceId());
        ds.field("monthlyRushEntryText1", &self.monthlyRushEntryText1());
        ds.field("monthlyEntryUnlockText", &self.monthlyEntryUnlockText());
        ds.field("monthlyEntryRiftText", &self.monthlyEntryRiftText());
        ds.field("monthlyRushIntro", &self.monthlyRushIntro());
        ds.field("monthlyCoin", &self.monthlyCoin());
        ds.field("charRarityColorList", &self.charRarityColorList());
        ds.field("squadCharCapacity", &self.squadCharCapacity());
        ds.field("totalSquadCnt", &self.totalSquadCnt());
        ds.field("toolboxCapacity", &self.toolboxCapacity());
        ds.field("toolCntLimitInSquad", &self.toolCntLimitInSquad());
        ds.field("miniSquadCharCapacity", &self.miniSquadCharCapacity());
        ds.field("miniSquadDrinkCost", &self.miniSquadDrinkCost());
        ds.field("normalSquadDrinkCost", &self.normalSquadDrinkCost());
        ds.field("emptySquadDrinkCost", &self.emptySquadDrinkCost());
        ds.field("achieveTypeAll", &self.achieveTypeAll());
        ds.field("constructModeBgmHome", &self.constructModeBgmHome());
        ds.field("battleBgmCollect", &self.battleBgmCollect());
        ds.field("battleBgmHunt", &self.battleBgmHunt());
        ds.field("battleBgmEnemyRush", &self.battleBgmEnemyRush());
        ds.field("battleBgmBossRush", &self.battleBgmBossRush());
        ds.field("imgLoadingNormalName", &self.imgLoadingNormalName());
        ds.field("imgLoadingBaseName", &self.imgLoadingBaseName());
        ds.field("imgUnloadingBaseName", &self.imgUnloadingBaseName());
        ds.field("isChallengeOpen", &self.isChallengeOpen());
        ds.field("isRacingOpen", &self.isRacingOpen());
        ds.field("hasExploreMode", &self.hasExploreMode());
        ds.field("exploreModeBuffDescs", &self.exploreModeBuffDescs());
        ds.field("modeSelectTips", &self.modeSelectTips());
        ds.field("stringRes", &self.stringRes());
        ds.field("diffList", &self.diffList());
        ds.field("battlePreloadEnemies", &self.battlePreloadEnemies());
        ds.field(
            "battleExcludedTrapsInRush",
            &self.battleExcludedTrapsInRush(),
        );
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2RiftConstOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RiftConst<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RiftConst<'a> {
    type Inner = clz_Torappu_SandboxV2RiftConst<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RiftConst<'a> {
    pub const VT_REFRESHRATE: flatbuffers::VOffsetT = 4;
    pub const VT_RANDOMDUNGEONID: flatbuffers::VOffsetT = 6;
    pub const VT_HUNTDUNGEONID: flatbuffers::VOffsetT = 8;
    pub const VT_SUBTARGETREWARDID: flatbuffers::VOffsetT = 10;
    pub const VT_PREYQUESTREWARDID: flatbuffers::VOffsetT = 12;
    pub const VT_DUNGEONSEASONID: flatbuffers::VOffsetT = 14;
    pub const VT_FIXEDDUNGEONTYPENAME: flatbuffers::VOffsetT = 16;
    pub const VT_RANDOMDUNGEONTYPENAME: flatbuffers::VOffsetT = 18;
    pub const VT_PREYDUNGEONTYPENAME: flatbuffers::VOffsetT = 20;
    pub const VT_NOTEAMDESCRIPTION: flatbuffers::VOffsetT = 22;
    pub const VT_NOTEAMNAME: flatbuffers::VOffsetT = 24;
    pub const VT_NOTEAMBACKGROUNDID: flatbuffers::VOffsetT = 26;
    pub const VT_NOTEAMSMALLICONID: flatbuffers::VOffsetT = 28;
    pub const VT_NOTEAMBIGICONID: flatbuffers::VOffsetT = 30;
    pub const VT_MESSENGERENEMYID: flatbuffers::VOffsetT = 32;
    pub const VT_RIFTRUSHENEMYGROUPLIMIT: flatbuffers::VOffsetT = 34;
    pub const VT_RIFTRUSHSPAWNCD: flatbuffers::VOffsetT = 36;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RiftConst { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RiftConstArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftConst<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RiftConstBuilder::new(_fbb);
        builder.add_riftRushSpawnCd(args.riftRushSpawnCd);
        builder.add_riftRushEnemyGroupLimit(args.riftRushEnemyGroupLimit);
        if let Some(x) = args.messengerEnemyId {
            builder.add_messengerEnemyId(x);
        }
        if let Some(x) = args.noTeamBigIconId {
            builder.add_noTeamBigIconId(x);
        }
        if let Some(x) = args.noTeamSmallIconId {
            builder.add_noTeamSmallIconId(x);
        }
        if let Some(x) = args.noTeamBackgroundId {
            builder.add_noTeamBackgroundId(x);
        }
        if let Some(x) = args.noTeamName {
            builder.add_noTeamName(x);
        }
        if let Some(x) = args.noTeamDescription {
            builder.add_noTeamDescription(x);
        }
        if let Some(x) = args.preyDungeonTypeName {
            builder.add_preyDungeonTypeName(x);
        }
        if let Some(x) = args.randomDungeonTypeName {
            builder.add_randomDungeonTypeName(x);
        }
        if let Some(x) = args.fixedDungeonTypeName {
            builder.add_fixedDungeonTypeName(x);
        }
        builder.add_dungeonSeasonId(args.dungeonSeasonId);
        if let Some(x) = args.preyQuestRewardId {
            builder.add_preyQuestRewardId(x);
        }
        if let Some(x) = args.subTargetRewardId {
            builder.add_subTargetRewardId(x);
        }
        if let Some(x) = args.huntDungeonId {
            builder.add_huntDungeonId(x);
        }
        if let Some(x) = args.randomDungeonId {
            builder.add_randomDungeonId(x);
        }
        builder.add_refreshRate(args.refreshRate);
        builder.finish()
    }

    #[inline]
    pub fn refreshRate(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2RiftConst::VT_REFRESHRATE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn randomDungeonId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_RANDOMDUNGEONID,
                None,
            )
        }
    }
    #[inline]
    pub fn huntDungeonId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_HUNTDUNGEONID,
                None,
            )
        }
    }
    #[inline]
    pub fn subTargetRewardId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_SUBTARGETREWARDID,
                None,
            )
        }
    }
    #[inline]
    pub fn preyQuestRewardId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_PREYQUESTREWARDID,
                None,
            )
        }
    }
    #[inline]
    pub fn dungeonSeasonId(&self) -> enum__Torappu_SandboxV2SeasonType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2SeasonType>(
                    clz_Torappu_SandboxV2RiftConst::VT_DUNGEONSEASONID,
                    Some(enum__Torappu_SandboxV2SeasonType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn fixedDungeonTypeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_FIXEDDUNGEONTYPENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn randomDungeonTypeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_RANDOMDUNGEONTYPENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn preyDungeonTypeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_PREYDUNGEONTYPENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn noTeamDescription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_NOTEAMDESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn noTeamName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_NOTEAMNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn noTeamBackgroundId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_NOTEAMBACKGROUNDID,
                None,
            )
        }
    }
    #[inline]
    pub fn noTeamSmallIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_NOTEAMSMALLICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn noTeamBigIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_NOTEAMBIGICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn messengerEnemyId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_MESSENGERENEMYID,
                None,
            )
        }
    }
    #[inline]
    pub fn riftRushEnemyGroupLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2RiftConst::VT_RIFTRUSHENEMYGROUPLIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn riftRushSpawnCd(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2RiftConst::VT_RIFTRUSHSPAWNCD, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RiftConst<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("refreshRate", Self::VT_REFRESHRATE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "randomDungeonId",
                Self::VT_RANDOMDUNGEONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "huntDungeonId",
                Self::VT_HUNTDUNGEONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "subTargetRewardId",
                Self::VT_SUBTARGETREWARDID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "preyQuestRewardId",
                Self::VT_PREYQUESTREWARDID,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxV2SeasonType>(
                "dungeonSeasonId",
                Self::VT_DUNGEONSEASONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "fixedDungeonTypeName",
                Self::VT_FIXEDDUNGEONTYPENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "randomDungeonTypeName",
                Self::VT_RANDOMDUNGEONTYPENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "preyDungeonTypeName",
                Self::VT_PREYDUNGEONTYPENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "noTeamDescription",
                Self::VT_NOTEAMDESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "noTeamName",
                Self::VT_NOTEAMNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "noTeamBackgroundId",
                Self::VT_NOTEAMBACKGROUNDID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "noTeamSmallIconId",
                Self::VT_NOTEAMSMALLICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "noTeamBigIconId",
                Self::VT_NOTEAMBIGICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "messengerEnemyId",
                Self::VT_MESSENGERENEMYID,
                false,
            )?
            .visit_field::<i32>(
                "riftRushEnemyGroupLimit",
                Self::VT_RIFTRUSHENEMYGROUPLIMIT,
                false,
            )?
            .visit_field::<i32>("riftRushSpawnCd", Self::VT_RIFTRUSHSPAWNCD, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RiftConstArgs<'a> {
    pub refreshRate: i32,
    pub randomDungeonId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub huntDungeonId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub subTargetRewardId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub preyQuestRewardId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dungeonSeasonId: enum__Torappu_SandboxV2SeasonType,
    pub fixedDungeonTypeName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub randomDungeonTypeName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub preyDungeonTypeName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub noTeamDescription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub noTeamName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub noTeamBackgroundId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub noTeamSmallIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub noTeamBigIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub messengerEnemyId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub riftRushEnemyGroupLimit: i32,
    pub riftRushSpawnCd: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2RiftConstArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RiftConstArgs {
            refreshRate: 0,
            randomDungeonId: None,
            huntDungeonId: None,
            subTargetRewardId: None,
            preyQuestRewardId: None,
            dungeonSeasonId: enum__Torappu_SandboxV2SeasonType::NONE,
            fixedDungeonTypeName: None,
            randomDungeonTypeName: None,
            preyDungeonTypeName: None,
            noTeamDescription: None,
            noTeamName: None,
            noTeamBackgroundId: None,
            noTeamSmallIconId: None,
            noTeamBigIconId: None,
            messengerEnemyId: None,
            riftRushEnemyGroupLimit: 0,
            riftRushSpawnCd: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2RiftConstBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2RiftConstBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_refreshRate(&mut self, refreshRate: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2RiftConst::VT_REFRESHRATE,
            refreshRate,
            0,
        );
    }
    #[inline]
    pub fn add_randomDungeonId(&mut self, randomDungeonId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_RANDOMDUNGEONID,
            randomDungeonId,
        );
    }
    #[inline]
    pub fn add_huntDungeonId(&mut self, huntDungeonId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_HUNTDUNGEONID,
            huntDungeonId,
        );
    }
    #[inline]
    pub fn add_subTargetRewardId(&mut self, subTargetRewardId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_SUBTARGETREWARDID,
            subTargetRewardId,
        );
    }
    #[inline]
    pub fn add_preyQuestRewardId(&mut self, preyQuestRewardId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_PREYQUESTREWARDID,
            preyQuestRewardId,
        );
    }
    #[inline]
    pub fn add_dungeonSeasonId(&mut self, dungeonSeasonId: enum__Torappu_SandboxV2SeasonType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2SeasonType>(
            clz_Torappu_SandboxV2RiftConst::VT_DUNGEONSEASONID,
            dungeonSeasonId,
            enum__Torappu_SandboxV2SeasonType::NONE,
        );
    }
    #[inline]
    pub fn add_fixedDungeonTypeName(
        &mut self,
        fixedDungeonTypeName: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_FIXEDDUNGEONTYPENAME,
            fixedDungeonTypeName,
        );
    }
    #[inline]
    pub fn add_randomDungeonTypeName(
        &mut self,
        randomDungeonTypeName: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_RANDOMDUNGEONTYPENAME,
            randomDungeonTypeName,
        );
    }
    #[inline]
    pub fn add_preyDungeonTypeName(
        &mut self,
        preyDungeonTypeName: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_PREYDUNGEONTYPENAME,
            preyDungeonTypeName,
        );
    }
    #[inline]
    pub fn add_noTeamDescription(&mut self, noTeamDescription: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_NOTEAMDESCRIPTION,
            noTeamDescription,
        );
    }
    #[inline]
    pub fn add_noTeamName(&mut self, noTeamName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_NOTEAMNAME,
            noTeamName,
        );
    }
    #[inline]
    pub fn add_noTeamBackgroundId(&mut self, noTeamBackgroundId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_NOTEAMBACKGROUNDID,
            noTeamBackgroundId,
        );
    }
    #[inline]
    pub fn add_noTeamSmallIconId(&mut self, noTeamSmallIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_NOTEAMSMALLICONID,
            noTeamSmallIconId,
        );
    }
    #[inline]
    pub fn add_noTeamBigIconId(&mut self, noTeamBigIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_NOTEAMBIGICONID,
            noTeamBigIconId,
        );
    }
    #[inline]
    pub fn add_messengerEnemyId(&mut self, messengerEnemyId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_MESSENGERENEMYID,
            messengerEnemyId,
        );
    }
    #[inline]
    pub fn add_riftRushEnemyGroupLimit(&mut self, riftRushEnemyGroupLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2RiftConst::VT_RIFTRUSHENEMYGROUPLIMIT,
            riftRushEnemyGroupLimit,
            0,
        );
    }
    #[inline]
    pub fn add_riftRushSpawnCd(&mut self, riftRushSpawnCd: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2RiftConst::VT_RIFTRUSHSPAWNCD,
            riftRushSpawnCd,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RiftConstBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RiftConstBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftConst<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RiftConst<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RiftConst");
        ds.field("refreshRate", &self.refreshRate());
        ds.field("randomDungeonId", &self.randomDungeonId());
        ds.field("huntDungeonId", &self.huntDungeonId());
        ds.field("subTargetRewardId", &self.subTargetRewardId());
        ds.field("preyQuestRewardId", &self.preyQuestRewardId());
        ds.field("dungeonSeasonId", &self.dungeonSeasonId());
        ds.field("fixedDungeonTypeName", &self.fixedDungeonTypeName());
        ds.field("randomDungeonTypeName", &self.randomDungeonTypeName());
        ds.field("preyDungeonTypeName", &self.preyDungeonTypeName());
        ds.field("noTeamDescription", &self.noTeamDescription());
        ds.field("noTeamName", &self.noTeamName());
        ds.field("noTeamBackgroundId", &self.noTeamBackgroundId());
        ds.field("noTeamSmallIconId", &self.noTeamSmallIconId());
        ds.field("noTeamBigIconId", &self.noTeamBigIconId());
        ds.field("messengerEnemyId", &self.messengerEnemyId());
        ds.field("riftRushEnemyGroupLimit", &self.riftRushEnemyGroupLimit());
        ds.field("riftRushSpawnCd", &self.riftRushSpawnCd());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2DevelopmentConstOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2DevelopmentConst<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2DevelopmentConst<'a> {
    type Inner = clz_Torappu_SandboxV2DevelopmentConst<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2DevelopmentConst<'a> {
    pub const VT_TECHPOINTSTOTAL: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2DevelopmentConst { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2DevelopmentConstArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentConst<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2DevelopmentConstBuilder::new(_fbb);
        builder.add_techPointsTotal(args.techPointsTotal);
        builder.finish()
    }

    #[inline]
    pub fn techPointsTotal(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2DevelopmentConst::VT_TECHPOINTSTOTAL,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2DevelopmentConst<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("techPointsTotal", Self::VT_TECHPOINTSTOTAL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2DevelopmentConstArgs {
    pub techPointsTotal: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2DevelopmentConstArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2DevelopmentConstArgs { techPointsTotal: 0 }
    }
}

pub struct clz_Torappu_SandboxV2DevelopmentConstBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2DevelopmentConstBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_techPointsTotal(&mut self, techPointsTotal: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2DevelopmentConst::VT_TECHPOINTSTOTAL,
            techPointsTotal,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2DevelopmentConstBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2DevelopmentConstBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentConst<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2DevelopmentConst<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2DevelopmentConst");
        ds.field("techPointsTotal", &self.techPointsTotal());
        ds.finish()
    }
}
pub enum clz_Torappu_TipDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_TipData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_TipData<'a> {
    type Inner = clz_Torappu_TipData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_TipData<'a> {
    pub const VT_TIP: flatbuffers::VOffsetT = 4;
    pub const VT_WEIGHT: flatbuffers::VOffsetT = 6;
    pub const VT_CATEGORY: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_TipData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_TipDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TipData<'bldr>> {
        let mut builder = clz_Torappu_TipDataBuilder::new(_fbb);
        builder.add_category(args.category);
        builder.add_weight(args.weight);
        if let Some(x) = args.tip {
            builder.add_tip(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn tip(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_TipData::VT_TIP, None)
        }
    }
    #[inline]
    pub fn weight(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_TipData::VT_WEIGHT, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn category(&self) -> enum__Torappu_TipData_Category {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_TipData_Category>(
                    clz_Torappu_TipData::VT_CATEGORY,
                    Some(enum__Torappu_TipData_Category::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_TipData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tip", Self::VT_TIP, false)?
            .visit_field::<f32>("weight", Self::VT_WEIGHT, false)?
            .visit_field::<enum__Torappu_TipData_Category>("category", Self::VT_CATEGORY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_TipDataArgs<'a> {
    pub tip: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weight: f32,
    pub category: enum__Torappu_TipData_Category,
}
impl<'a> Default for clz_Torappu_TipDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_TipDataArgs {
            tip: None,
            weight: 0.0,
            category: enum__Torappu_TipData_Category::NONE,
        }
    }
}

pub struct clz_Torappu_TipDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_TipDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_tip(&mut self, tip: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_TipData::VT_TIP, tip);
    }
    #[inline]
    pub fn add_weight(&mut self, weight: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_TipData::VT_WEIGHT, weight, 0.0);
    }
    #[inline]
    pub fn add_category(&mut self, category: enum__Torappu_TipData_Category) {
        self.fbb_.push_slot::<enum__Torappu_TipData_Category>(
            clz_Torappu_TipData::VT_CATEGORY,
            category,
            enum__Torappu_TipData_Category::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_TipDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_TipDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_TipData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_TipData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_TipData");
        ds.field("tip", &self.tip());
        ds.field("weight", &self.weight());
        ds.field("category", &self.category());
        ds.finish()
    }
}
pub enum clz_Torappu_RuneData_SelectorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RuneData_Selector<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RuneData_Selector<'a> {
    type Inner = clz_Torappu_RuneData_Selector<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_RuneData_Selector<'a> {
    pub const VT_PROFESSIONMASK: flatbuffers::VOffsetT = 4;
    pub const VT_BUILDABLEMASK: flatbuffers::VOffsetT = 6;
    pub const VT_PLAYERSIDEMASK: flatbuffers::VOffsetT = 8;
    pub const VT_SIDETYPE: flatbuffers::VOffsetT = 10;
    pub const VT_CHARIDFILTER: flatbuffers::VOffsetT = 12;
    pub const VT_ENEMYIDFILTER: flatbuffers::VOffsetT = 14;
    pub const VT_ENEMYIDEXCLUDEFILTER: flatbuffers::VOffsetT = 16;
    pub const VT_ENEMYLEVELTYPEFILTER: flatbuffers::VOffsetT = 18;
    pub const VT_ENEMYACTIONHIDDENGROUPFILTER: flatbuffers::VOffsetT = 20;
    pub const VT_SKILLIDFILTER: flatbuffers::VOffsetT = 22;
    pub const VT_TILEKEYFILTER: flatbuffers::VOffsetT = 24;
    pub const VT_GROUPTAGFILTER: flatbuffers::VOffsetT = 26;
    pub const VT_FILTERTAGFILTER: flatbuffers::VOffsetT = 28;
    pub const VT_FILTERTAGEXCLUDEFILTER: flatbuffers::VOffsetT = 30;
    pub const VT_SUBPROFESSIONEXCLUDEFILTER: flatbuffers::VOffsetT = 32;
    pub const VT_MAPTAGFILTER: flatbuffers::VOffsetT = 34;
    pub const VT_HEIGHTTYPEMASK: flatbuffers::VOffsetT = 36;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RuneData_Selector { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RuneData_SelectorArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'bldr>> {
        let mut builder = clz_Torappu_RuneData_SelectorBuilder::new(_fbb);
        builder.add_heightTypeMask(args.heightTypeMask);
        if let Some(x) = args.mapTagFilter {
            builder.add_mapTagFilter(x);
        }
        if let Some(x) = args.subProfessionExcludeFilter {
            builder.add_subProfessionExcludeFilter(x);
        }
        if let Some(x) = args.filterTagExcludeFilter {
            builder.add_filterTagExcludeFilter(x);
        }
        if let Some(x) = args.filterTagFilter {
            builder.add_filterTagFilter(x);
        }
        if let Some(x) = args.groupTagFilter {
            builder.add_groupTagFilter(x);
        }
        if let Some(x) = args.tileKeyFilter {
            builder.add_tileKeyFilter(x);
        }
        if let Some(x) = args.skillIdFilter {
            builder.add_skillIdFilter(x);
        }
        if let Some(x) = args.enemyActionHiddenGroupFilter {
            builder.add_enemyActionHiddenGroupFilter(x);
        }
        if let Some(x) = args.enemyLevelTypeFilter {
            builder.add_enemyLevelTypeFilter(x);
        }
        if let Some(x) = args.enemyIdExcludeFilter {
            builder.add_enemyIdExcludeFilter(x);
        }
        if let Some(x) = args.enemyIdFilter {
            builder.add_enemyIdFilter(x);
        }
        if let Some(x) = args.charIdFilter {
            builder.add_charIdFilter(x);
        }
        builder.add_sideType(args.sideType);
        builder.add_buildableMask(args.buildableMask);
        builder.add_professionMask(args.professionMask);
        builder.add_playerSideMask(args.playerSideMask);
        builder.finish()
    }

    #[inline]
    pub fn professionMask(&self) -> enum__Torappu_ProfessionCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ProfessionCategory>(
                    clz_Torappu_RuneData_Selector::VT_PROFESSIONMASK,
                    Some(enum__Torappu_ProfessionCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn buildableMask(&self) -> enum__Torappu_BuildableType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildableType>(
                    clz_Torappu_RuneData_Selector::VT_BUILDABLEMASK,
                    Some(enum__Torappu_BuildableType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn playerSideMask(&self) -> enum__Torappu_PlayerSideMask {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_PlayerSideMask>(
                    clz_Torappu_RuneData_Selector::VT_PLAYERSIDEMASK,
                    Some(enum__Torappu_PlayerSideMask::ALL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sideType(&self) -> enum__Torappu_Battle_SideType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_Battle_SideType>(
                    clz_Torappu_RuneData_Selector::VT_SIDETYPE,
                    Some(enum__Torappu_Battle_SideType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn charIdFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_CHARIDFILTER, None)
        }
    }
    #[inline]
    pub fn enemyIdFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_ENEMYIDFILTER, None)
        }
    }
    #[inline]
    pub fn enemyIdExcludeFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_ENEMYIDEXCLUDEFILTER, None)
        }
    }
    #[inline]
    pub fn enemyLevelTypeFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_ENEMYLEVELTYPEFILTER, None)
        }
    }
    #[inline]
    pub fn enemyActionHiddenGroupFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RuneData_Selector::VT_ENEMYACTIONHIDDENGROUPFILTER,
                None,
            )
        }
    }
    #[inline]
    pub fn skillIdFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_SKILLIDFILTER, None)
        }
    }
    #[inline]
    pub fn tileKeyFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_TILEKEYFILTER, None)
        }
    }
    #[inline]
    pub fn groupTagFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_GROUPTAGFILTER, None)
        }
    }
    #[inline]
    pub fn filterTagFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_FILTERTAGFILTER, None)
        }
    }
    #[inline]
    pub fn filterTagExcludeFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RuneData_Selector::VT_FILTERTAGEXCLUDEFILTER,
                None,
            )
        }
    }
    #[inline]
    pub fn subProfessionExcludeFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RuneData_Selector::VT_SUBPROFESSIONEXCLUDEFILTER,
                None,
            )
        }
    }
    #[inline]
    pub fn mapTagFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_MAPTAGFILTER, None)
        }
    }
    #[inline]
    pub fn heightTypeMask(&self) -> enum__Torappu_TileData_HeightTypeMask {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_TileData_HeightTypeMask>(
                    clz_Torappu_RuneData_Selector::VT_HEIGHTTYPEMASK,
                    Some(enum__Torappu_TileData_HeightTypeMask::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RuneData_Selector<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_ProfessionCategory>(
                "professionMask",
                Self::VT_PROFESSIONMASK,
                false,
            )?
            .visit_field::<enum__Torappu_BuildableType>(
                "buildableMask",
                Self::VT_BUILDABLEMASK,
                false,
            )?
            .visit_field::<enum__Torappu_PlayerSideMask>(
                "playerSideMask",
                Self::VT_PLAYERSIDEMASK,
                false,
            )?
            .visit_field::<enum__Torappu_Battle_SideType>("sideType", Self::VT_SIDETYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("charIdFilter", Self::VT_CHARIDFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("enemyIdFilter", Self::VT_ENEMYIDFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("enemyIdExcludeFilter", Self::VT_ENEMYIDEXCLUDEFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("enemyLevelTypeFilter", Self::VT_ENEMYLEVELTYPEFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "enemyActionHiddenGroupFilter",
                Self::VT_ENEMYACTIONHIDDENGROUPFILTER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("skillIdFilter", Self::VT_SKILLIDFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("tileKeyFilter", Self::VT_TILEKEYFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("groupTagFilter", Self::VT_GROUPTAGFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("filterTagFilter", Self::VT_FILTERTAGFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "filterTagExcludeFilter",
                Self::VT_FILTERTAGEXCLUDEFILTER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "subProfessionExcludeFilter",
                Self::VT_SUBPROFESSIONEXCLUDEFILTER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("mapTagFilter", Self::VT_MAPTAGFILTER, false)?
            .visit_field::<enum__Torappu_TileData_HeightTypeMask>(
                "heightTypeMask",
                Self::VT_HEIGHTTYPEMASK,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RuneData_SelectorArgs<'a> {
    pub professionMask: enum__Torappu_ProfessionCategory,
    pub buildableMask: enum__Torappu_BuildableType,
    pub playerSideMask: enum__Torappu_PlayerSideMask,
    pub sideType: enum__Torappu_Battle_SideType,
    pub charIdFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub enemyIdFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub enemyIdExcludeFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub enemyLevelTypeFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub enemyActionHiddenGroupFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub skillIdFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub tileKeyFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub groupTagFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub filterTagFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub filterTagExcludeFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub subProfessionExcludeFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub mapTagFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub heightTypeMask: enum__Torappu_TileData_HeightTypeMask,
}
impl<'a> Default for clz_Torappu_RuneData_SelectorArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RuneData_SelectorArgs {
            professionMask: enum__Torappu_ProfessionCategory::NONE,
            buildableMask: enum__Torappu_BuildableType::NONE,
            playerSideMask: enum__Torappu_PlayerSideMask::ALL,
            sideType: enum__Torappu_Battle_SideType::NONE,
            charIdFilter: None,
            enemyIdFilter: None,
            enemyIdExcludeFilter: None,
            enemyLevelTypeFilter: None,
            enemyActionHiddenGroupFilter: None,
            skillIdFilter: None,
            tileKeyFilter: None,
            groupTagFilter: None,
            filterTagFilter: None,
            filterTagExcludeFilter: None,
            subProfessionExcludeFilter: None,
            mapTagFilter: None,
            heightTypeMask: enum__Torappu_TileData_HeightTypeMask::NONE,
        }
    }
}

pub struct clz_Torappu_RuneData_SelectorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RuneData_SelectorBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_professionMask(&mut self, professionMask: enum__Torappu_ProfessionCategory) {
        self.fbb_.push_slot::<enum__Torappu_ProfessionCategory>(
            clz_Torappu_RuneData_Selector::VT_PROFESSIONMASK,
            professionMask,
            enum__Torappu_ProfessionCategory::NONE,
        );
    }
    #[inline]
    pub fn add_buildableMask(&mut self, buildableMask: enum__Torappu_BuildableType) {
        self.fbb_.push_slot::<enum__Torappu_BuildableType>(
            clz_Torappu_RuneData_Selector::VT_BUILDABLEMASK,
            buildableMask,
            enum__Torappu_BuildableType::NONE,
        );
    }
    #[inline]
    pub fn add_playerSideMask(&mut self, playerSideMask: enum__Torappu_PlayerSideMask) {
        self.fbb_.push_slot::<enum__Torappu_PlayerSideMask>(
            clz_Torappu_RuneData_Selector::VT_PLAYERSIDEMASK,
            playerSideMask,
            enum__Torappu_PlayerSideMask::ALL,
        );
    }
    #[inline]
    pub fn add_sideType(&mut self, sideType: enum__Torappu_Battle_SideType) {
        self.fbb_.push_slot::<enum__Torappu_Battle_SideType>(
            clz_Torappu_RuneData_Selector::VT_SIDETYPE,
            sideType,
            enum__Torappu_Battle_SideType::NONE,
        );
    }
    #[inline]
    pub fn add_charIdFilter(
        &mut self,
        charIdFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_CHARIDFILTER,
            charIdFilter,
        );
    }
    #[inline]
    pub fn add_enemyIdFilter(
        &mut self,
        enemyIdFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_ENEMYIDFILTER,
            enemyIdFilter,
        );
    }
    #[inline]
    pub fn add_enemyIdExcludeFilter(
        &mut self,
        enemyIdExcludeFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_ENEMYIDEXCLUDEFILTER,
            enemyIdExcludeFilter,
        );
    }
    #[inline]
    pub fn add_enemyLevelTypeFilter(
        &mut self,
        enemyLevelTypeFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_ENEMYLEVELTYPEFILTER,
            enemyLevelTypeFilter,
        );
    }
    #[inline]
    pub fn add_enemyActionHiddenGroupFilter(
        &mut self,
        enemyActionHiddenGroupFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_ENEMYACTIONHIDDENGROUPFILTER,
            enemyActionHiddenGroupFilter,
        );
    }
    #[inline]
    pub fn add_skillIdFilter(
        &mut self,
        skillIdFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_SKILLIDFILTER,
            skillIdFilter,
        );
    }
    #[inline]
    pub fn add_tileKeyFilter(
        &mut self,
        tileKeyFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_TILEKEYFILTER,
            tileKeyFilter,
        );
    }
    #[inline]
    pub fn add_groupTagFilter(
        &mut self,
        groupTagFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_GROUPTAGFILTER,
            groupTagFilter,
        );
    }
    #[inline]
    pub fn add_filterTagFilter(
        &mut self,
        filterTagFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_FILTERTAGFILTER,
            filterTagFilter,
        );
    }
    #[inline]
    pub fn add_filterTagExcludeFilter(
        &mut self,
        filterTagExcludeFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_FILTERTAGEXCLUDEFILTER,
            filterTagExcludeFilter,
        );
    }
    #[inline]
    pub fn add_subProfessionExcludeFilter(
        &mut self,
        subProfessionExcludeFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_SUBPROFESSIONEXCLUDEFILTER,
            subProfessionExcludeFilter,
        );
    }
    #[inline]
    pub fn add_mapTagFilter(
        &mut self,
        mapTagFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_MAPTAGFILTER,
            mapTagFilter,
        );
    }
    #[inline]
    pub fn add_heightTypeMask(&mut self, heightTypeMask: enum__Torappu_TileData_HeightTypeMask) {
        self.fbb_
            .push_slot::<enum__Torappu_TileData_HeightTypeMask>(
                clz_Torappu_RuneData_Selector::VT_HEIGHTTYPEMASK,
                heightTypeMask,
                enum__Torappu_TileData_HeightTypeMask::NONE,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RuneData_SelectorBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RuneData_SelectorBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RuneData_Selector<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RuneData_Selector");
        ds.field("professionMask", &self.professionMask());
        ds.field("buildableMask", &self.buildableMask());
        ds.field("playerSideMask", &self.playerSideMask());
        ds.field("sideType", &self.sideType());
        ds.field("charIdFilter", &self.charIdFilter());
        ds.field("enemyIdFilter", &self.enemyIdFilter());
        ds.field("enemyIdExcludeFilter", &self.enemyIdExcludeFilter());
        ds.field("enemyLevelTypeFilter", &self.enemyLevelTypeFilter());
        ds.field(
            "enemyActionHiddenGroupFilter",
            &self.enemyActionHiddenGroupFilter(),
        );
        ds.field("skillIdFilter", &self.skillIdFilter());
        ds.field("tileKeyFilter", &self.tileKeyFilter());
        ds.field("groupTagFilter", &self.groupTagFilter());
        ds.field("filterTagFilter", &self.filterTagFilter());
        ds.field("filterTagExcludeFilter", &self.filterTagExcludeFilter());
        ds.field(
            "subProfessionExcludeFilter",
            &self.subProfessionExcludeFilter(),
        );
        ds.field("mapTagFilter", &self.mapTagFilter());
        ds.field("heightTypeMask", &self.heightTypeMask());
        ds.finish()
    }
}
pub enum clz_Torappu_Blackboard_DataPairOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Blackboard_DataPair<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Blackboard_DataPair<'a> {
    type Inner = clz_Torappu_Blackboard_DataPair<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_Blackboard_DataPair<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;
    pub const VT_VALUESTR: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Blackboard_DataPair { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Blackboard_DataPairArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'bldr>> {
        let mut builder = clz_Torappu_Blackboard_DataPairBuilder::new(_fbb);
        if let Some(x) = args.valueStr {
            builder.add_valueStr(x);
        }
        builder.add_value(args.value);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_KEY,
                None,
            )
        }
    }
    #[inline]
    pub fn value(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn valueStr(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Blackboard_DataPair<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<f32>("value", Self::VT_VALUE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "valueStr",
                Self::VT_VALUESTR,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Blackboard_DataPairArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: f32,
    pub valueStr: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Blackboard_DataPairArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Blackboard_DataPairArgs {
            key: None,
            value: 0.0,
            valueStr: None,
        }
    }
}

pub struct clz_Torappu_Blackboard_DataPairBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, value, 0.0);
    }
    #[inline]
    pub fn add_valueStr(&mut self, valueStr: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
            valueStr,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Blackboard_DataPairBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Blackboard_DataPair<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Blackboard_DataPair");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.field("valueStr", &self.valueStr());
        ds.finish()
    }
}
pub enum clz_Torappu_RuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RuneData<'a> {
    type Inner = clz_Torappu_RuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_RuneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_SELECTOR: flatbuffers::VOffsetT = 6;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneData<'bldr>> {
        let mut builder = clz_Torappu_RuneDataBuilder::new(_fbb);
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        if let Some(x) = args.selector {
            builder.add_selector(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_RuneData::VT_KEY, None)
        }
    }
    #[inline]
    pub fn selector(&self) -> Option<clz_Torappu_RuneData_Selector<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneData_Selector>>(
                    clz_Torappu_RuneData::VT_SELECTOR,
                    None,
                )
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(clz_Torappu_RuneData::VT_BLACKBOARD, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneData_Selector>>(
                "selector",
                Self::VT_SELECTOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RuneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub selector: Option<flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'a>>>,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RuneDataArgs {
            key: None,
            selector: None,
            blackboard: None,
        }
    }
}

pub struct clz_Torappu_RuneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RuneDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_RuneData::VT_KEY, key);
    }
    #[inline]
    pub fn add_selector(
        &mut self,
        selector: flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector>>(
                clz_Torappu_RuneData::VT_SELECTOR,
                selector,
            );
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RuneData");
        ds.field("key", &self.key());
        ds.field("selector", &self.selector());
        ds.field("blackboard", &self.blackboard());
        ds.finish()
    }
}
pub enum clz_Torappu_RuneTable_PackedRuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RuneTable_PackedRuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RuneTable_PackedRuneData<'a> {
    type Inner = clz_Torappu_RuneTable_PackedRuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_RuneTable_PackedRuneData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_POINTS: flatbuffers::VOffsetT = 6;
    pub const VT_MUTEXGROUPKEY: flatbuffers::VOffsetT = 8;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
    pub const VT_RUNES: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RuneTable_PackedRuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RuneTable_PackedRuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'bldr>> {
        let mut builder = clz_Torappu_RuneTable_PackedRuneDataBuilder::new(_fbb);
        if let Some(x) = args.runes {
            builder.add_runes(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.mutexGroupKey {
            builder.add_mutexGroupKey(x);
        }
        builder.add_points(args.points);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RuneTable_PackedRuneData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn points(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_RuneTable_PackedRuneData::VT_POINTS, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn mutexGroupKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RuneTable_PackedRuneData::VT_MUTEXGROUPKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RuneTable_PackedRuneData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn runes(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData>>,
            >>(clz_Torappu_RuneTable_PackedRuneData::VT_RUNES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RuneTable_PackedRuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<f32>("points", Self::VT_POINTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "mutexGroupKey",
                Self::VT_MUTEXGROUPKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData>>,
            >>("runes", Self::VT_RUNES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RuneTable_PackedRuneDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub points: f32,
    pub mutexGroupKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub runes: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RuneTable_PackedRuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RuneTable_PackedRuneDataArgs {
            id: None,
            points: 0.0,
            mutexGroupKey: None,
            description: None,
            runes: None,
        }
    }
}

pub struct clz_Torappu_RuneTable_PackedRuneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RuneTable_PackedRuneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneTable_PackedRuneData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_points(&mut self, points: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_RuneTable_PackedRuneData::VT_POINTS, points, 0.0);
    }
    #[inline]
    pub fn add_mutexGroupKey(&mut self, mutexGroupKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneTable_PackedRuneData::VT_MUTEXGROUPKEY,
            mutexGroupKey,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneTable_PackedRuneData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_runes(
        &mut self,
        runes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneTable_PackedRuneData::VT_RUNES,
            runes,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RuneTable_PackedRuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RuneTable_PackedRuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RuneTable_PackedRuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RuneTable_PackedRuneData");
        ds.field("id", &self.id());
        ds.field("points", &self.points());
        ds.field("mutexGroupKey", &self.mutexGroupKey());
        ds.field("description", &self.description());
        ds.field("runes", &self.runes());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_RuneTable_PackedRuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RuneTable_PackedRuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RuneTable_PackedRuneData<'a> {
    type Inner = dict__string__clz_Torappu_RuneTable_PackedRuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_RuneTable_PackedRuneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RuneTable_PackedRuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RuneTable_PackedRuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RuneTable_PackedRuneData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RuneTable_PackedRuneDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RuneTable_PackedRuneData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RuneTable_PackedRuneData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RuneTable_PackedRuneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneTable_PackedRuneData>>(
                    dict__string__clz_Torappu_RuneTable_PackedRuneData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RuneTable_PackedRuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneTable_PackedRuneData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RuneTable_PackedRuneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RuneTable_PackedRuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RuneTable_PackedRuneDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_RuneTable_PackedRuneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RuneTable_PackedRuneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RuneTable_PackedRuneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData>>(
                dict__string__clz_Torappu_RuneTable_PackedRuneData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RuneTable_PackedRuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RuneTable_PackedRuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RuneTable_PackedRuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RuneTable_PackedRuneData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RuneTable_PackedRuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RuneTable_PackedRuneData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_LegacyInLevelRuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LegacyInLevelRuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LegacyInLevelRuneData<'a> {
    type Inner = clz_Torappu_LegacyInLevelRuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_LegacyInLevelRuneData<'a> {
    pub const VT_DIFFICULTYMASK: flatbuffers::VOffsetT = 4;
    pub const VT_KEY: flatbuffers::VOffsetT = 6;
    pub const VT_PROFESSIONMASK: flatbuffers::VOffsetT = 8;
    pub const VT_BUILDABLEMASK: flatbuffers::VOffsetT = 10;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LegacyInLevelRuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LegacyInLevelRuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LegacyInLevelRuneData<'bldr>> {
        let mut builder = clz_Torappu_LegacyInLevelRuneDataBuilder::new(_fbb);
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        builder.add_buildableMask(args.buildableMask);
        builder.add_professionMask(args.professionMask);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.add_difficultyMask(args.difficultyMask);
        builder.finish()
    }

    #[inline]
    pub fn difficultyMask(&self) -> enum__Torappu_LevelData_Difficulty {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_LevelData_Difficulty>(
                    clz_Torappu_LegacyInLevelRuneData::VT_DIFFICULTYMASK,
                    Some(enum__Torappu_LevelData_Difficulty::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LegacyInLevelRuneData::VT_KEY,
                None,
            )
        }
    }
    #[inline]
    pub fn professionMask(&self) -> enum__Torappu_ProfessionCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ProfessionCategory>(
                    clz_Torappu_LegacyInLevelRuneData::VT_PROFESSIONMASK,
                    Some(enum__Torappu_ProfessionCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn buildableMask(&self) -> enum__Torappu_BuildableType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildableType>(
                    clz_Torappu_LegacyInLevelRuneData::VT_BUILDABLEMASK,
                    Some(enum__Torappu_BuildableType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(clz_Torappu_LegacyInLevelRuneData::VT_BLACKBOARD, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LegacyInLevelRuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_LevelData_Difficulty>(
                "difficultyMask",
                Self::VT_DIFFICULTYMASK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<enum__Torappu_ProfessionCategory>(
                "professionMask",
                Self::VT_PROFESSIONMASK,
                false,
            )?
            .visit_field::<enum__Torappu_BuildableType>(
                "buildableMask",
                Self::VT_BUILDABLEMASK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LegacyInLevelRuneDataArgs<'a> {
    pub difficultyMask: enum__Torappu_LevelData_Difficulty,
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub professionMask: enum__Torappu_ProfessionCategory,
    pub buildableMask: enum__Torappu_BuildableType,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_LegacyInLevelRuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LegacyInLevelRuneDataArgs {
            difficultyMask: enum__Torappu_LevelData_Difficulty::NONE,
            key: None,
            professionMask: enum__Torappu_ProfessionCategory::NONE,
            buildableMask: enum__Torappu_BuildableType::NONE,
            blackboard: None,
        }
    }
}

pub struct clz_Torappu_LegacyInLevelRuneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_LegacyInLevelRuneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_difficultyMask(&mut self, difficultyMask: enum__Torappu_LevelData_Difficulty) {
        self.fbb_.push_slot::<enum__Torappu_LevelData_Difficulty>(
            clz_Torappu_LegacyInLevelRuneData::VT_DIFFICULTYMASK,
            difficultyMask,
            enum__Torappu_LevelData_Difficulty::NONE,
        );
    }
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LegacyInLevelRuneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_professionMask(&mut self, professionMask: enum__Torappu_ProfessionCategory) {
        self.fbb_.push_slot::<enum__Torappu_ProfessionCategory>(
            clz_Torappu_LegacyInLevelRuneData::VT_PROFESSIONMASK,
            professionMask,
            enum__Torappu_ProfessionCategory::NONE,
        );
    }
    #[inline]
    pub fn add_buildableMask(&mut self, buildableMask: enum__Torappu_BuildableType) {
        self.fbb_.push_slot::<enum__Torappu_BuildableType>(
            clz_Torappu_LegacyInLevelRuneData::VT_BUILDABLEMASK,
            buildableMask,
            enum__Torappu_BuildableType::NONE,
        );
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LegacyInLevelRuneData::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LegacyInLevelRuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LegacyInLevelRuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_LegacyInLevelRuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LegacyInLevelRuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LegacyInLevelRuneData");
        ds.field("difficultyMask", &self.difficultyMask());
        ds.field("key", &self.key());
        ds.field("professionMask", &self.professionMask());
        ds.field("buildableMask", &self.buildableMask());
        ds.field("blackboard", &self.blackboard());
        ds.finish()
    }
}
pub enum dict__string__list_clz_Torappu_LegacyInLevelRuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a> {
    type Inner = dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_clz_Torappu_LegacyInLevelRuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_clz_Torappu_LegacyInLevelRuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_LegacyInLevelRuneData<'bldr>> {
        let mut builder = dict__string__list_clz_Torappu_LegacyInLevelRuneDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__list_clz_Torappu_LegacyInLevelRuneData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__list_clz_Torappu_LegacyInLevelRuneData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData>,
                >,
            >>(
                dict__string__list_clz_Torappu_LegacyInLevelRuneData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__list_clz_Torappu_LegacyInLevelRuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData>,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_clz_Torappu_LegacyInLevelRuneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for dict__string__list_clz_Torappu_LegacyInLevelRuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__list_clz_Torappu_LegacyInLevelRuneDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__list_clz_Torappu_LegacyInLevelRuneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__list_clz_Torappu_LegacyInLevelRuneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_clz_Torappu_LegacyInLevelRuneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_clz_Torappu_LegacyInLevelRuneData::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__list_clz_Torappu_LegacyInLevelRuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__list_clz_Torappu_LegacyInLevelRuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__list_clz_Torappu_LegacyInLevelRuneData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__list_clz_Torappu_LegacyInLevelRuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__list_clz_Torappu_LegacyInLevelRuneData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2QuestDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2QuestData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2QuestData<'a> {
    type Inner = clz_Torappu_SandboxV2QuestData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2QuestData<'a> {
    pub const VT_QUESTID: flatbuffers::VOffsetT = 4;
    pub const VT_QUESTLINE: flatbuffers::VOffsetT = 6;
    pub const VT_QUESTTITLE: flatbuffers::VOffsetT = 8;
    pub const VT_QUESTDESC: flatbuffers::VOffsetT = 10;
    pub const VT_QUESTTARGETDESC: flatbuffers::VOffsetT = 12;
    pub const VT_ISDISPLAY: flatbuffers::VOffsetT = 14;
    pub const VT_QUESTROUTETYPE: flatbuffers::VOffsetT = 16;
    pub const VT_QUESTLINETYPE: flatbuffers::VOffsetT = 18;
    pub const VT_QUESTROUTEPARAM: flatbuffers::VOffsetT = 20;
    pub const VT_SHOWPROGRESSINDEX: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2QuestData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2QuestDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2QuestData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2QuestDataBuilder::new(_fbb);
        builder.add_showProgressIndex(args.showProgressIndex);
        if let Some(x) = args.questRouteParam {
            builder.add_questRouteParam(x);
        }
        builder.add_questLineType(args.questLineType);
        builder.add_questRouteType(args.questRouteType);
        if let Some(x) = args.questTargetDesc {
            builder.add_questTargetDesc(x);
        }
        if let Some(x) = args.questDesc {
            builder.add_questDesc(x);
        }
        if let Some(x) = args.questTitle {
            builder.add_questTitle(x);
        }
        if let Some(x) = args.questLine {
            builder.add_questLine(x);
        }
        if let Some(x) = args.questId {
            builder.add_questId(x);
        }
        builder.add_isDisplay(args.isDisplay);
        builder.finish()
    }

    #[inline]
    pub fn questId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2QuestData::VT_QUESTID,
                None,
            )
        }
    }
    #[inline]
    pub fn questLine(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2QuestData::VT_QUESTLINE,
                None,
            )
        }
    }
    #[inline]
    pub fn questTitle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2QuestData::VT_QUESTTITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn questDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2QuestData::VT_QUESTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn questTargetDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2QuestData::VT_QUESTTARGETDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn isDisplay(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_SandboxV2QuestData::VT_ISDISPLAY, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn questRouteType(&self) -> enum__Torappu_SandboxV2QuestRouteType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2QuestRouteType>(
                    clz_Torappu_SandboxV2QuestData::VT_QUESTROUTETYPE,
                    Some(enum__Torappu_SandboxV2QuestRouteType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn questLineType(&self) -> enum__Torappu_SandboxV2QuestLineType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2QuestLineType>(
                    clz_Torappu_SandboxV2QuestData::VT_QUESTLINETYPE,
                    Some(enum__Torappu_SandboxV2QuestLineType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn questRouteParam(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2QuestData::VT_QUESTROUTEPARAM,
                None,
            )
        }
    }
    #[inline]
    pub fn showProgressIndex(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2QuestData::VT_SHOWPROGRESSINDEX,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2QuestData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("questId", Self::VT_QUESTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "questLine",
                Self::VT_QUESTLINE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "questTitle",
                Self::VT_QUESTTITLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "questDesc",
                Self::VT_QUESTDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "questTargetDesc",
                Self::VT_QUESTTARGETDESC,
                false,
            )?
            .visit_field::<bool>("isDisplay", Self::VT_ISDISPLAY, false)?
            .visit_field::<enum__Torappu_SandboxV2QuestRouteType>(
                "questRouteType",
                Self::VT_QUESTROUTETYPE,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxV2QuestLineType>(
                "questLineType",
                Self::VT_QUESTLINETYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "questRouteParam",
                Self::VT_QUESTROUTEPARAM,
                false,
            )?
            .visit_field::<i32>("showProgressIndex", Self::VT_SHOWPROGRESSINDEX, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2QuestDataArgs<'a> {
    pub questId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub questLine: Option<flatbuffers::WIPOffset<&'a str>>,
    pub questTitle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub questDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub questTargetDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isDisplay: bool,
    pub questRouteType: enum__Torappu_SandboxV2QuestRouteType,
    pub questLineType: enum__Torappu_SandboxV2QuestLineType,
    pub questRouteParam: Option<flatbuffers::WIPOffset<&'a str>>,
    pub showProgressIndex: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2QuestDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2QuestDataArgs {
            questId: None,
            questLine: None,
            questTitle: None,
            questDesc: None,
            questTargetDesc: None,
            isDisplay: false,
            questRouteType: enum__Torappu_SandboxV2QuestRouteType::NONE,
            questLineType: enum__Torappu_SandboxV2QuestLineType::NONE,
            questRouteParam: None,
            showProgressIndex: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2QuestDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2QuestDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_questId(&mut self, questId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2QuestData::VT_QUESTID,
            questId,
        );
    }
    #[inline]
    pub fn add_questLine(&mut self, questLine: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2QuestData::VT_QUESTLINE,
            questLine,
        );
    }
    #[inline]
    pub fn add_questTitle(&mut self, questTitle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2QuestData::VT_QUESTTITLE,
            questTitle,
        );
    }
    #[inline]
    pub fn add_questDesc(&mut self, questDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2QuestData::VT_QUESTDESC,
            questDesc,
        );
    }
    #[inline]
    pub fn add_questTargetDesc(&mut self, questTargetDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2QuestData::VT_QUESTTARGETDESC,
            questTargetDesc,
        );
    }
    #[inline]
    pub fn add_isDisplay(&mut self, isDisplay: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SandboxV2QuestData::VT_ISDISPLAY,
            isDisplay,
            false,
        );
    }
    #[inline]
    pub fn add_questRouteType(&mut self, questRouteType: enum__Torappu_SandboxV2QuestRouteType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2QuestRouteType>(
                clz_Torappu_SandboxV2QuestData::VT_QUESTROUTETYPE,
                questRouteType,
                enum__Torappu_SandboxV2QuestRouteType::NONE,
            );
    }
    #[inline]
    pub fn add_questLineType(&mut self, questLineType: enum__Torappu_SandboxV2QuestLineType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2QuestLineType>(
            clz_Torappu_SandboxV2QuestData::VT_QUESTLINETYPE,
            questLineType,
            enum__Torappu_SandboxV2QuestLineType::NONE,
        );
    }
    #[inline]
    pub fn add_questRouteParam(&mut self, questRouteParam: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2QuestData::VT_QUESTROUTEPARAM,
            questRouteParam,
        );
    }
    #[inline]
    pub fn add_showProgressIndex(&mut self, showProgressIndex: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2QuestData::VT_SHOWPROGRESSINDEX,
            showProgressIndex,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2QuestDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2QuestDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2QuestData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2QuestData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2QuestData");
        ds.field("questId", &self.questId());
        ds.field("questLine", &self.questLine());
        ds.field("questTitle", &self.questTitle());
        ds.field("questDesc", &self.questDesc());
        ds.field("questTargetDesc", &self.questTargetDesc());
        ds.field("isDisplay", &self.isDisplay());
        ds.field("questRouteType", &self.questRouteType());
        ds.field("questLineType", &self.questLineType());
        ds.field("questRouteParam", &self.questRouteParam());
        ds.field("showProgressIndex", &self.showProgressIndex());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2QuestDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2QuestData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2QuestData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2QuestData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2QuestData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2QuestData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2QuestDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2QuestData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2QuestDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2QuestData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2QuestData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2QuestData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2QuestData>>(
                    dict__string__clz_Torappu_SandboxV2QuestData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2QuestData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2QuestData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2QuestDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2QuestData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2QuestDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2QuestDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2QuestDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2QuestDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2QuestData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2QuestData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2QuestData>>(
                dict__string__clz_Torappu_SandboxV2QuestData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2QuestDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2QuestDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2QuestData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2QuestData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2QuestData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2QuestData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum dict__enum__Torappu_BattleDialogType__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_BattleDialogType__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__enum__Torappu_BattleDialogType__string<'a> {
    type Inner = dict__enum__Torappu_BattleDialogType__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__enum__Torappu_BattleDialogType__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_BattleDialogType__string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__enum__Torappu_BattleDialogType__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_BattleDialogType__string<'bldr>> {
        let mut builder = dict__enum__Torappu_BattleDialogType__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_BattleDialogType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BattleDialogType>(
                    dict__enum__Torappu_BattleDialogType__string::VT_KEY,
                    Some(enum__Torappu_BattleDialogType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__enum__Torappu_BattleDialogType__string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_BattleDialogType,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                dict__enum__Torappu_BattleDialogType__string::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for dict__enum__Torappu_BattleDialogType__string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_BattleDialogType>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__enum__Torappu_BattleDialogType__stringArgs<'a> {
    pub key: enum__Torappu_BattleDialogType,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for dict__enum__Torappu_BattleDialogType__stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__enum__Torappu_BattleDialogType__stringArgs {
            key: enum__Torappu_BattleDialogType::NONE,
            value: None,
        }
    }
}

pub struct dict__enum__Torappu_BattleDialogType__stringBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__enum__Torappu_BattleDialogType__stringBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: enum__Torappu_BattleDialogType) {
        self.fbb_.push_slot::<enum__Torappu_BattleDialogType>(
            dict__enum__Torappu_BattleDialogType__string::VT_KEY,
            key,
            enum__Torappu_BattleDialogType::NONE,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__enum__Torappu_BattleDialogType__string::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__enum__Torappu_BattleDialogType__stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__enum__Torappu_BattleDialogType__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_BattleDialogType__string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__enum__Torappu_BattleDialogType__string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__enum__Torappu_BattleDialogType__string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2NpcDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2NpcData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2NpcData<'a> {
    type Inner = clz_Torappu_SandboxV2NpcData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2NpcData<'a> {
    pub const VT_NPCID: flatbuffers::VOffsetT = 4;
    pub const VT_TRAPID: flatbuffers::VOffsetT = 6;
    pub const VT_NPCTYPE: flatbuffers::VOffsetT = 8;
    pub const VT_DIALOGIDS: flatbuffers::VOffsetT = 10;
    pub const VT_NPCLOCATION: flatbuffers::VOffsetT = 12;
    pub const VT_NPCORIENTATION: flatbuffers::VOffsetT = 14;
    pub const VT_PICID: flatbuffers::VOffsetT = 16;
    pub const VT_PICNAME: flatbuffers::VOffsetT = 18;
    pub const VT_SHOWPIC: flatbuffers::VOffsetT = 20;
    pub const VT_REACTSKILLINDEX: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2NpcData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2NpcDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NpcData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2NpcDataBuilder::new(_fbb);
        builder.add_reactSkillIndex(args.reactSkillIndex);
        if let Some(x) = args.picName {
            builder.add_picName(x);
        }
        if let Some(x) = args.picId {
            builder.add_picId(x);
        }
        builder.add_npcOrientation(args.npcOrientation);
        if let Some(x) = args.npcLocation {
            builder.add_npcLocation(x);
        }
        if let Some(x) = args.dialogIds {
            builder.add_dialogIds(x);
        }
        builder.add_npcType(args.npcType);
        if let Some(x) = args.trapId {
            builder.add_trapId(x);
        }
        if let Some(x) = args.npcId {
            builder.add_npcId(x);
        }
        builder.add_showPic(args.showPic);
        builder.finish()
    }

    #[inline]
    pub fn npcId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NpcData::VT_NPCID,
                None,
            )
        }
    }
    #[inline]
    pub fn trapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NpcData::VT_TRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn npcType(&self) -> enum__Torappu_SandboxV2NpcType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2NpcType>(
                    clz_Torappu_SandboxV2NpcData::VT_NPCTYPE,
                    Some(enum__Torappu_SandboxV2NpcType::NORMAL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn dialogIds(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__enum__Torappu_BattleDialogType__string<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__enum__Torappu_BattleDialogType__string>,
                >,
            >>(clz_Torappu_SandboxV2NpcData::VT_DIALOGIDS, None)
        }
    }
    #[inline]
    pub fn npcLocation(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    clz_Torappu_SandboxV2NpcData::VT_NPCLOCATION,
                    None,
                )
        }
    }
    #[inline]
    pub fn npcOrientation(&self) -> enum__Torappu_SharedConsts_Direction {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SharedConsts_Direction>(
                    clz_Torappu_SandboxV2NpcData::VT_NPCORIENTATION,
                    Some(enum__Torappu_SharedConsts_Direction::UP),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn picId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NpcData::VT_PICID,
                None,
            )
        }
    }
    #[inline]
    pub fn picName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NpcData::VT_PICNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn showPic(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_SandboxV2NpcData::VT_SHOWPIC, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn reactSkillIndex(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2NpcData::VT_REACTSKILLINDEX, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2NpcData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("npcId", Self::VT_NPCID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("trapId", Self::VT_TRAPID, false)?
            .visit_field::<enum__Torappu_SandboxV2NpcType>("npcType", Self::VT_NPCTYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__enum__Torappu_BattleDialogType__string>,
                >,
            >>("dialogIds", Self::VT_DIALOGIDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "npcLocation",
                Self::VT_NPCLOCATION,
                false,
            )?
            .visit_field::<enum__Torappu_SharedConsts_Direction>(
                "npcOrientation",
                Self::VT_NPCORIENTATION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("picId", Self::VT_PICID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("picName", Self::VT_PICNAME, false)?
            .visit_field::<bool>("showPic", Self::VT_SHOWPIC, false)?
            .visit_field::<i32>("reactSkillIndex", Self::VT_REACTSKILLINDEX, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2NpcDataArgs<'a> {
    pub npcId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub npcType: enum__Torappu_SandboxV2NpcType,
    pub dialogIds: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__enum__Torappu_BattleDialogType__string<'a>>,
            >,
        >,
    >,
    pub npcLocation: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub npcOrientation: enum__Torappu_SharedConsts_Direction,
    pub picId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub picName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub showPic: bool,
    pub reactSkillIndex: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2NpcDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2NpcDataArgs {
            npcId: None,
            trapId: None,
            npcType: enum__Torappu_SandboxV2NpcType::NORMAL,
            dialogIds: None,
            npcLocation: None,
            npcOrientation: enum__Torappu_SharedConsts_Direction::UP,
            picId: None,
            picName: None,
            showPic: false,
            reactSkillIndex: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2NpcDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2NpcDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_npcId(&mut self, npcId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NpcData::VT_NPCID,
            npcId,
        );
    }
    #[inline]
    pub fn add_trapId(&mut self, trapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NpcData::VT_TRAPID,
            trapId,
        );
    }
    #[inline]
    pub fn add_npcType(&mut self, npcType: enum__Torappu_SandboxV2NpcType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2NpcType>(
            clz_Torappu_SandboxV2NpcData::VT_NPCTYPE,
            npcType,
            enum__Torappu_SandboxV2NpcType::NORMAL,
        );
    }
    #[inline]
    pub fn add_dialogIds(
        &mut self,
        dialogIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__enum__Torappu_BattleDialogType__string<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NpcData::VT_DIALOGIDS,
            dialogIds,
        );
    }
    #[inline]
    pub fn add_npcLocation(
        &mut self,
        npcLocation: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NpcData::VT_NPCLOCATION,
            npcLocation,
        );
    }
    #[inline]
    pub fn add_npcOrientation(&mut self, npcOrientation: enum__Torappu_SharedConsts_Direction) {
        self.fbb_.push_slot::<enum__Torappu_SharedConsts_Direction>(
            clz_Torappu_SandboxV2NpcData::VT_NPCORIENTATION,
            npcOrientation,
            enum__Torappu_SharedConsts_Direction::UP,
        );
    }
    #[inline]
    pub fn add_picId(&mut self, picId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NpcData::VT_PICID,
            picId,
        );
    }
    #[inline]
    pub fn add_picName(&mut self, picName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NpcData::VT_PICNAME,
            picName,
        );
    }
    #[inline]
    pub fn add_showPic(&mut self, showPic: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_SandboxV2NpcData::VT_SHOWPIC, showPic, false);
    }
    #[inline]
    pub fn add_reactSkillIndex(&mut self, reactSkillIndex: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2NpcData::VT_REACTSKILLINDEX,
            reactSkillIndex,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2NpcDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2NpcDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NpcData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2NpcData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2NpcData");
        ds.field("npcId", &self.npcId());
        ds.field("trapId", &self.trapId());
        ds.field("npcType", &self.npcType());
        ds.field("dialogIds", &self.dialogIds());
        ds.field("npcLocation", &self.npcLocation());
        ds.field("npcOrientation", &self.npcOrientation());
        ds.field("picId", &self.picId());
        ds.field("picName", &self.picName());
        ds.field("showPic", &self.showPic());
        ds.field("reactSkillIndex", &self.reactSkillIndex());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2NpcDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2NpcData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2NpcData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2NpcData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2NpcData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2NpcData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2NpcDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NpcData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2NpcDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2NpcData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2NpcData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2NpcData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2NpcData>>(
                    dict__string__clz_Torappu_SandboxV2NpcData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2NpcData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2NpcData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2NpcDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2NpcData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2NpcDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2NpcDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2NpcDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2NpcDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2NpcData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2NpcData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2NpcData>>(
                dict__string__clz_Torappu_SandboxV2NpcData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2NpcDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2NpcDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NpcData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_SandboxV2NpcData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2NpcData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2NpcData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2DialogDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2DialogData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2DialogData<'a> {
    type Inner = clz_Torappu_SandboxV2DialogData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2DialogData<'a> {
    pub const VT_DIALOGID: flatbuffers::VOffsetT = 4;
    pub const VT_AVGID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2DialogData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2DialogDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DialogData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2DialogDataBuilder::new(_fbb);
        if let Some(x) = args.avgId {
            builder.add_avgId(x);
        }
        if let Some(x) = args.dialogId {
            builder.add_dialogId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn dialogId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DialogData::VT_DIALOGID,
                None,
            )
        }
    }
    #[inline]
    pub fn avgId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DialogData::VT_AVGID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2DialogData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dialogId",
                Self::VT_DIALOGID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("avgId", Self::VT_AVGID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2DialogDataArgs<'a> {
    pub dialogId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub avgId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2DialogDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2DialogDataArgs {
            dialogId: None,
            avgId: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2DialogDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2DialogDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_dialogId(&mut self, dialogId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DialogData::VT_DIALOGID,
            dialogId,
        );
    }
    #[inline]
    pub fn add_avgId(&mut self, avgId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DialogData::VT_AVGID,
            avgId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2DialogDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2DialogDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DialogData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2DialogData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2DialogData");
        ds.field("dialogId", &self.dialogId());
        ds.field("avgId", &self.avgId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2DialogDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2DialogData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2DialogData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2DialogData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2DialogData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2DialogData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2DialogDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2DialogData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2DialogDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2DialogData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2DialogData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2DialogData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DialogData>>(
                    dict__string__clz_Torappu_SandboxV2DialogData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2DialogData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DialogData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2DialogDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2DialogData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2DialogDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2DialogDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2DialogDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2DialogDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2DialogData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2DialogData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2DialogData>>(
                dict__string__clz_Torappu_SandboxV2DialogData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2DialogDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2DialogDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2DialogData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2DialogData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2DialogData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2DialogData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2QuestLineDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2QuestLineData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2QuestLineData<'a> {
    type Inner = clz_Torappu_SandboxV2QuestLineData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2QuestLineData<'a> {
    pub const VT_QUESTLINEID: flatbuffers::VOffsetT = 4;
    pub const VT_QUESTLINETITLE: flatbuffers::VOffsetT = 6;
    pub const VT_QUESTLINETYPE: flatbuffers::VOffsetT = 8;
    pub const VT_QUESTLINEBADGETYPE: flatbuffers::VOffsetT = 10;
    pub const VT_QUESTLINESCOPETYPE: flatbuffers::VOffsetT = 12;
    pub const VT_QUESTLINEDESC: flatbuffers::VOffsetT = 14;
    pub const VT_SORTID: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2QuestLineData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2QuestLineDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2QuestLineData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2QuestLineDataBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.questLineDesc {
            builder.add_questLineDesc(x);
        }
        builder.add_questLineScopeType(args.questLineScopeType);
        builder.add_questLineBadgeType(args.questLineBadgeType);
        builder.add_questLineType(args.questLineType);
        if let Some(x) = args.questLineTitle {
            builder.add_questLineTitle(x);
        }
        if let Some(x) = args.questLineId {
            builder.add_questLineId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn questLineId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINEID,
                None,
            )
        }
    }
    #[inline]
    pub fn questLineTitle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINETITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn questLineType(&self) -> enum__Torappu_SandboxV2QuestLineType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2QuestLineType>(
                    clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINETYPE,
                    Some(enum__Torappu_SandboxV2QuestLineType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn questLineBadgeType(&self) -> enum__Torappu_SandboxV2QuestLineBadgeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2QuestLineBadgeType>(
                    clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINEBADGETYPE,
                    Some(enum__Torappu_SandboxV2QuestLineBadgeType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn questLineScopeType(&self) -> enum__Torappu_SandboxV2QuestLineScopeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2QuestLineScopeType>(
                    clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINESCOPETYPE,
                    Some(enum__Torappu_SandboxV2QuestLineScopeType::MAIN),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn questLineDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2QuestLineData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2QuestLineData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "questLineId",
                Self::VT_QUESTLINEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "questLineTitle",
                Self::VT_QUESTLINETITLE,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxV2QuestLineType>(
                "questLineType",
                Self::VT_QUESTLINETYPE,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxV2QuestLineBadgeType>(
                "questLineBadgeType",
                Self::VT_QUESTLINEBADGETYPE,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxV2QuestLineScopeType>(
                "questLineScopeType",
                Self::VT_QUESTLINESCOPETYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "questLineDesc",
                Self::VT_QUESTLINEDESC,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2QuestLineDataArgs<'a> {
    pub questLineId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub questLineTitle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub questLineType: enum__Torappu_SandboxV2QuestLineType,
    pub questLineBadgeType: enum__Torappu_SandboxV2QuestLineBadgeType,
    pub questLineScopeType: enum__Torappu_SandboxV2QuestLineScopeType,
    pub questLineDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2QuestLineDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2QuestLineDataArgs {
            questLineId: None,
            questLineTitle: None,
            questLineType: enum__Torappu_SandboxV2QuestLineType::NONE,
            questLineBadgeType: enum__Torappu_SandboxV2QuestLineBadgeType::NONE,
            questLineScopeType: enum__Torappu_SandboxV2QuestLineScopeType::MAIN,
            questLineDesc: None,
            sortId: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2QuestLineDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2QuestLineDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_questLineId(&mut self, questLineId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINEID,
            questLineId,
        );
    }
    #[inline]
    pub fn add_questLineTitle(&mut self, questLineTitle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINETITLE,
            questLineTitle,
        );
    }
    #[inline]
    pub fn add_questLineType(&mut self, questLineType: enum__Torappu_SandboxV2QuestLineType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2QuestLineType>(
            clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINETYPE,
            questLineType,
            enum__Torappu_SandboxV2QuestLineType::NONE,
        );
    }
    #[inline]
    pub fn add_questLineBadgeType(
        &mut self,
        questLineBadgeType: enum__Torappu_SandboxV2QuestLineBadgeType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2QuestLineBadgeType>(
                clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINEBADGETYPE,
                questLineBadgeType,
                enum__Torappu_SandboxV2QuestLineBadgeType::NONE,
            );
    }
    #[inline]
    pub fn add_questLineScopeType(
        &mut self,
        questLineScopeType: enum__Torappu_SandboxV2QuestLineScopeType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2QuestLineScopeType>(
                clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINESCOPETYPE,
                questLineScopeType,
                enum__Torappu_SandboxV2QuestLineScopeType::MAIN,
            );
    }
    #[inline]
    pub fn add_questLineDesc(&mut self, questLineDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINEDESC,
            questLineDesc,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2QuestLineData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2QuestLineDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2QuestLineDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2QuestLineData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2QuestLineData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2QuestLineData");
        ds.field("questLineId", &self.questLineId());
        ds.field("questLineTitle", &self.questLineTitle());
        ds.field("questLineType", &self.questLineType());
        ds.field("questLineBadgeType", &self.questLineBadgeType());
        ds.field("questLineScopeType", &self.questLineScopeType());
        ds.field("questLineDesc", &self.questLineDesc());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2QuestLineDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2QuestLineData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2QuestLineData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2QuestLineData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2QuestLineData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2QuestLineData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2QuestLineDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2QuestLineData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2QuestLineDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2QuestLineData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2QuestLineData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2QuestLineData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2QuestLineData>>(
                    dict__string__clz_Torappu_SandboxV2QuestLineData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2QuestLineData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2QuestLineData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2QuestLineDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2QuestLineData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2QuestLineDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2QuestLineDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2QuestLineDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2QuestLineDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2QuestLineData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2QuestLineData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2QuestLineData>>(
                dict__string__clz_Torappu_SandboxV2QuestLineData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2QuestLineDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2QuestLineDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2QuestLineData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2QuestLineData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2QuestLineData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2QuestLineData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2GuideQuestDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2GuideQuestData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2GuideQuestData<'a> {
    type Inner = clz_Torappu_SandboxV2GuideQuestData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2GuideQuestData<'a> {
    pub const VT_QUESTID: flatbuffers::VOffsetT = 4;
    pub const VT_STORYID: flatbuffers::VOffsetT = 6;
    pub const VT_TRIGGERKEY: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2GuideQuestData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2GuideQuestDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2GuideQuestData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2GuideQuestDataBuilder::new(_fbb);
        if let Some(x) = args.triggerKey {
            builder.add_triggerKey(x);
        }
        if let Some(x) = args.storyId {
            builder.add_storyId(x);
        }
        if let Some(x) = args.questId {
            builder.add_questId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn questId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GuideQuestData::VT_QUESTID,
                None,
            )
        }
    }
    #[inline]
    pub fn storyId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GuideQuestData::VT_STORYID,
                None,
            )
        }
    }
    #[inline]
    pub fn triggerKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GuideQuestData::VT_TRIGGERKEY,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2GuideQuestData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("questId", Self::VT_QUESTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("storyId", Self::VT_STORYID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "triggerKey",
                Self::VT_TRIGGERKEY,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2GuideQuestDataArgs<'a> {
    pub questId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub storyId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub triggerKey: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2GuideQuestDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2GuideQuestDataArgs {
            questId: None,
            storyId: None,
            triggerKey: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2GuideQuestDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2GuideQuestDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_questId(&mut self, questId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GuideQuestData::VT_QUESTID,
            questId,
        );
    }
    #[inline]
    pub fn add_storyId(&mut self, storyId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GuideQuestData::VT_STORYID,
            storyId,
        );
    }
    #[inline]
    pub fn add_triggerKey(&mut self, triggerKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GuideQuestData::VT_TRIGGERKEY,
            triggerKey,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2GuideQuestDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2GuideQuestDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2GuideQuestData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2GuideQuestData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2GuideQuestData");
        ds.field("questId", &self.questId());
        ds.field("storyId", &self.storyId());
        ds.field("triggerKey", &self.triggerKey());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2GuideQuestDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2GuideQuestData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2GuideQuestData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2GuideQuestData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2GuideQuestData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2GuideQuestData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2GuideQuestDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2GuideQuestDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2GuideQuestData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2GuideQuestData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2GuideQuestData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2GuideQuestData>>(
                    dict__string__clz_Torappu_SandboxV2GuideQuestData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2GuideQuestData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2GuideQuestData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2GuideQuestDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2GuideQuestData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2GuideQuestDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2GuideQuestDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2GuideQuestDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2GuideQuestDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2GuideQuestData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2GuideQuestData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2GuideQuestData>>(
                dict__string__clz_Torappu_SandboxV2GuideQuestData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2GuideQuestDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2GuideQuestDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2GuideQuestData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2GuideQuestData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2GuideQuestData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2DevelopmentDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2DevelopmentData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2DevelopmentData<'a> {
    type Inner = clz_Torappu_SandboxV2DevelopmentData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2DevelopmentData<'a> {
    pub const VT_TECHID: flatbuffers::VOffsetT = 4;
    pub const VT_TECHTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_POSITIONX: flatbuffers::VOffsetT = 8;
    pub const VT_POSITIONY: flatbuffers::VOffsetT = 10;
    pub const VT_FRONTNODEID: flatbuffers::VOffsetT = 12;
    pub const VT_NEXTNODEIDS: flatbuffers::VOffsetT = 14;
    pub const VT_LIMITBASELEVEL: flatbuffers::VOffsetT = 16;
    pub const VT_TOKENCOST: flatbuffers::VOffsetT = 18;
    pub const VT_TECHNAME: flatbuffers::VOffsetT = 20;
    pub const VT_TECHICONID: flatbuffers::VOffsetT = 22;
    pub const VT_NODETITLE: flatbuffers::VOffsetT = 24;
    pub const VT_RAWDESC: flatbuffers::VOffsetT = 26;
    pub const VT_CANBUFFRESERCH: flatbuffers::VOffsetT = 28;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2DevelopmentData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2DevelopmentDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2DevelopmentDataBuilder::new(_fbb);
        if let Some(x) = args.rawDesc {
            builder.add_rawDesc(x);
        }
        if let Some(x) = args.nodeTitle {
            builder.add_nodeTitle(x);
        }
        if let Some(x) = args.techIconId {
            builder.add_techIconId(x);
        }
        if let Some(x) = args.techName {
            builder.add_techName(x);
        }
        builder.add_tokenCost(args.tokenCost);
        builder.add_limitBaseLevel(args.limitBaseLevel);
        if let Some(x) = args.nextNodeIds {
            builder.add_nextNodeIds(x);
        }
        if let Some(x) = args.frontNodeId {
            builder.add_frontNodeId(x);
        }
        builder.add_positionY(args.positionY);
        builder.add_positionX(args.positionX);
        builder.add_techType(args.techType);
        if let Some(x) = args.techId {
            builder.add_techId(x);
        }
        builder.add_canBuffReserch(args.canBuffReserch);
        builder.finish()
    }

    #[inline]
    pub fn techId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DevelopmentData::VT_TECHID,
                None,
            )
        }
    }
    #[inline]
    pub fn techType(&self) -> enum__Torappu_SandboxV2DevelopmentType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2DevelopmentType>(
                    clz_Torappu_SandboxV2DevelopmentData::VT_TECHTYPE,
                    Some(enum__Torappu_SandboxV2DevelopmentType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn positionX(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2DevelopmentData::VT_POSITIONX, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn positionY(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2DevelopmentData::VT_POSITIONY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn frontNodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DevelopmentData::VT_FRONTNODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn nextNodeIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxV2DevelopmentData::VT_NEXTNODEIDS, None)
        }
    }
    #[inline]
    pub fn limitBaseLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2DevelopmentData::VT_LIMITBASELEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn tokenCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2DevelopmentData::VT_TOKENCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn techName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DevelopmentData::VT_TECHNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn techIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DevelopmentData::VT_TECHICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeTitle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DevelopmentData::VT_NODETITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn rawDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DevelopmentData::VT_RAWDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn canBuffReserch(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_SandboxV2DevelopmentData::VT_CANBUFFRESERCH,
                    Some(false),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2DevelopmentData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("techId", Self::VT_TECHID, false)?
            .visit_field::<enum__Torappu_SandboxV2DevelopmentType>(
                "techType",
                Self::VT_TECHTYPE,
                false,
            )?
            .visit_field::<i32>("positionX", Self::VT_POSITIONX, false)?
            .visit_field::<i32>("positionY", Self::VT_POSITIONY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "frontNodeId",
                Self::VT_FRONTNODEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("nextNodeIds", Self::VT_NEXTNODEIDS, false)?
            .visit_field::<i32>("limitBaseLevel", Self::VT_LIMITBASELEVEL, false)?
            .visit_field::<i32>("tokenCost", Self::VT_TOKENCOST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "techName",
                Self::VT_TECHNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "techIconId",
                Self::VT_TECHICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nodeTitle",
                Self::VT_NODETITLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rawDesc", Self::VT_RAWDESC, false)?
            .visit_field::<bool>("canBuffReserch", Self::VT_CANBUFFRESERCH, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2DevelopmentDataArgs<'a> {
    pub techId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub techType: enum__Torappu_SandboxV2DevelopmentType,
    pub positionX: i32,
    pub positionY: i32,
    pub frontNodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nextNodeIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub limitBaseLevel: i32,
    pub tokenCost: i32,
    pub techName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub techIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nodeTitle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rawDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub canBuffReserch: bool,
}
impl<'a> Default for clz_Torappu_SandboxV2DevelopmentDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2DevelopmentDataArgs {
            techId: None,
            techType: enum__Torappu_SandboxV2DevelopmentType::NONE,
            positionX: 0,
            positionY: 0,
            frontNodeId: None,
            nextNodeIds: None,
            limitBaseLevel: 0,
            tokenCost: 0,
            techName: None,
            techIconId: None,
            nodeTitle: None,
            rawDesc: None,
            canBuffReserch: false,
        }
    }
}

pub struct clz_Torappu_SandboxV2DevelopmentDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2DevelopmentDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_techId(&mut self, techId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DevelopmentData::VT_TECHID,
            techId,
        );
    }
    #[inline]
    pub fn add_techType(&mut self, techType: enum__Torappu_SandboxV2DevelopmentType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2DevelopmentType>(
                clz_Torappu_SandboxV2DevelopmentData::VT_TECHTYPE,
                techType,
                enum__Torappu_SandboxV2DevelopmentType::NONE,
            );
    }
    #[inline]
    pub fn add_positionX(&mut self, positionX: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2DevelopmentData::VT_POSITIONX,
            positionX,
            0,
        );
    }
    #[inline]
    pub fn add_positionY(&mut self, positionY: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2DevelopmentData::VT_POSITIONY,
            positionY,
            0,
        );
    }
    #[inline]
    pub fn add_frontNodeId(&mut self, frontNodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DevelopmentData::VT_FRONTNODEID,
            frontNodeId,
        );
    }
    #[inline]
    pub fn add_nextNodeIds(
        &mut self,
        nextNodeIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DevelopmentData::VT_NEXTNODEIDS,
            nextNodeIds,
        );
    }
    #[inline]
    pub fn add_limitBaseLevel(&mut self, limitBaseLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2DevelopmentData::VT_LIMITBASELEVEL,
            limitBaseLevel,
            0,
        );
    }
    #[inline]
    pub fn add_tokenCost(&mut self, tokenCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2DevelopmentData::VT_TOKENCOST,
            tokenCost,
            0,
        );
    }
    #[inline]
    pub fn add_techName(&mut self, techName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DevelopmentData::VT_TECHNAME,
            techName,
        );
    }
    #[inline]
    pub fn add_techIconId(&mut self, techIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DevelopmentData::VT_TECHICONID,
            techIconId,
        );
    }
    #[inline]
    pub fn add_nodeTitle(&mut self, nodeTitle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DevelopmentData::VT_NODETITLE,
            nodeTitle,
        );
    }
    #[inline]
    pub fn add_rawDesc(&mut self, rawDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DevelopmentData::VT_RAWDESC,
            rawDesc,
        );
    }
    #[inline]
    pub fn add_canBuffReserch(&mut self, canBuffReserch: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SandboxV2DevelopmentData::VT_CANBUFFRESERCH,
            canBuffReserch,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2DevelopmentDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2DevelopmentDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2DevelopmentData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2DevelopmentData");
        ds.field("techId", &self.techId());
        ds.field("techType", &self.techType());
        ds.field("positionX", &self.positionX());
        ds.field("positionY", &self.positionY());
        ds.field("frontNodeId", &self.frontNodeId());
        ds.field("nextNodeIds", &self.nextNodeIds());
        ds.field("limitBaseLevel", &self.limitBaseLevel());
        ds.field("tokenCost", &self.tokenCost());
        ds.field("techName", &self.techName());
        ds.field("techIconId", &self.techIconId());
        ds.field("nodeTitle", &self.nodeTitle());
        ds.field("rawDesc", &self.rawDesc());
        ds.field("canBuffReserch", &self.canBuffReserch());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2DevelopmentDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2DevelopmentData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2DevelopmentData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2DevelopmentData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2DevelopmentData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2DevelopmentData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2DevelopmentDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2DevelopmentData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2DevelopmentDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2DevelopmentData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2DevelopmentData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2DevelopmentData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DevelopmentData>>(
                    dict__string__clz_Torappu_SandboxV2DevelopmentData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2DevelopmentData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DevelopmentData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2DevelopmentDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2DevelopmentDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2DevelopmentDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2DevelopmentDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2DevelopmentDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2DevelopmentData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentData>>(
                dict__string__clz_Torappu_SandboxV2DevelopmentData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2DevelopmentDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2DevelopmentDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2DevelopmentData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2DevelopmentData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2DevelopmentData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2DevelopmentData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2EventDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2EventData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2EventData<'a> {
    type Inner = clz_Torappu_SandboxV2EventData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2EventData<'a> {
    pub const VT_EVENTID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_ICONID: flatbuffers::VOffsetT = 8;
    pub const VT_ICONNAME: flatbuffers::VOffsetT = 10;
    pub const VT_ENTERSCENEID: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2EventData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2EventDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2EventDataBuilder::new(_fbb);
        if let Some(x) = args.enterSceneId {
            builder.add_enterSceneId(x);
        }
        if let Some(x) = args.iconName {
            builder.add_iconName(x);
        }
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        builder.add_type_(args.type_);
        if let Some(x) = args.eventId {
            builder.add_eventId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn eventId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventData::VT_EVENTID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_SandboxV2EventType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2EventType>(
                    clz_Torappu_SandboxV2EventData::VT_TYPE_,
                    Some(enum__Torappu_SandboxV2EventType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventData::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn iconName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventData::VT_ICONNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn enterSceneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventData::VT_ENTERSCENEID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2EventData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("eventId", Self::VT_EVENTID, false)?
            .visit_field::<enum__Torappu_SandboxV2EventType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "iconName",
                Self::VT_ICONNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enterSceneId",
                Self::VT_ENTERSCENEID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2EventDataArgs<'a> {
    pub eventId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_SandboxV2EventType,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub enterSceneId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2EventDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2EventDataArgs {
            eventId: None,
            type_: enum__Torappu_SandboxV2EventType::NONE,
            iconId: None,
            iconName: None,
            enterSceneId: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2EventDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2EventDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_eventId(&mut self, eventId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventData::VT_EVENTID,
            eventId,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_SandboxV2EventType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2EventType>(
            clz_Torappu_SandboxV2EventData::VT_TYPE_,
            type_,
            enum__Torappu_SandboxV2EventType::NONE,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_iconName(&mut self, iconName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventData::VT_ICONNAME,
            iconName,
        );
    }
    #[inline]
    pub fn add_enterSceneId(&mut self, enterSceneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventData::VT_ENTERSCENEID,
            enterSceneId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2EventDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2EventDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2EventData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2EventData");
        ds.field("eventId", &self.eventId());
        ds.field("type_", &self.type_());
        ds.field("iconId", &self.iconId());
        ds.field("iconName", &self.iconName());
        ds.field("enterSceneId", &self.enterSceneId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2EventDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2EventData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2EventData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2EventData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2EventData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2EventData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2EventDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EventData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2EventDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2EventData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2EventData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2EventData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2EventData>>(
                    dict__string__clz_Torappu_SandboxV2EventData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2EventData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2EventData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2EventDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2EventDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2EventDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2EventDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2EventDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2EventData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventData>>(
                dict__string__clz_Torappu_SandboxV2EventData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2EventDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2EventDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EventData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2EventData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2EventData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2EventData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2EventSceneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2EventSceneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2EventSceneData<'a> {
    type Inner = clz_Torappu_SandboxV2EventSceneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2EventSceneData<'a> {
    pub const VT_EVENTSCENEID: flatbuffers::VOffsetT = 4;
    pub const VT_TITLE: flatbuffers::VOffsetT = 6;
    pub const VT_DESC: flatbuffers::VOffsetT = 8;
    pub const VT_CHOICEIDS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2EventSceneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2EventSceneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventSceneData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2EventSceneDataBuilder::new(_fbb);
        if let Some(x) = args.choiceIds {
            builder.add_choiceIds(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.title {
            builder.add_title(x);
        }
        if let Some(x) = args.eventSceneId {
            builder.add_eventSceneId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn eventSceneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventSceneData::VT_EVENTSCENEID,
                None,
            )
        }
    }
    #[inline]
    pub fn title(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventSceneData::VT_TITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventSceneData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn choiceIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxV2EventSceneData::VT_CHOICEIDS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2EventSceneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "eventSceneId",
                Self::VT_EVENTSCENEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("choiceIds", Self::VT_CHOICEIDS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2EventSceneDataArgs<'a> {
    pub eventSceneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub choiceIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2EventSceneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2EventSceneDataArgs {
            eventSceneId: None,
            title: None,
            desc: None,
            choiceIds: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2EventSceneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2EventSceneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_eventSceneId(&mut self, eventSceneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventSceneData::VT_EVENTSCENEID,
            eventSceneId,
        );
    }
    #[inline]
    pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventSceneData::VT_TITLE,
            title,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventSceneData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_choiceIds(
        &mut self,
        choiceIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventSceneData::VT_CHOICEIDS,
            choiceIds,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2EventSceneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2EventSceneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventSceneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2EventSceneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2EventSceneData");
        ds.field("eventSceneId", &self.eventSceneId());
        ds.field("title", &self.title());
        ds.field("desc", &self.desc());
        ds.field("choiceIds", &self.choiceIds());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2EventSceneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2EventSceneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2EventSceneData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2EventSceneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2EventSceneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2EventSceneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2EventSceneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EventSceneData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2EventSceneDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2EventSceneData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2EventSceneData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2EventSceneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2EventSceneData>>(
                    dict__string__clz_Torappu_SandboxV2EventSceneData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2EventSceneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2EventSceneData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2EventSceneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventSceneData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2EventSceneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2EventSceneDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2EventSceneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2EventSceneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2EventSceneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventSceneData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventSceneData>>(
                dict__string__clz_Torappu_SandboxV2EventSceneData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2EventSceneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2EventSceneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EventSceneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2EventSceneData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2EventSceneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2EventSceneData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2EventChoiceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2EventChoiceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2EventChoiceData<'a> {
    type Inner = clz_Torappu_SandboxV2EventChoiceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2EventChoiceData<'a> {
    pub const VT_CHOICEID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_COSTACTION: flatbuffers::VOffsetT = 8;
    pub const VT_TITLE: flatbuffers::VOffsetT = 10;
    pub const VT_DESC: flatbuffers::VOffsetT = 12;
    pub const VT_EXPEDITIONID: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2EventChoiceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2EventChoiceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventChoiceData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2EventChoiceDataBuilder::new(_fbb);
        if let Some(x) = args.expeditionId {
            builder.add_expeditionId(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.title {
            builder.add_title(x);
        }
        builder.add_costAction(args.costAction);
        builder.add_type_(args.type_);
        if let Some(x) = args.choiceId {
            builder.add_choiceId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn choiceId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventChoiceData::VT_CHOICEID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_SandboxV2EventChoiceType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2EventChoiceType>(
                    clz_Torappu_SandboxV2EventChoiceData::VT_TYPE_,
                    Some(enum__Torappu_SandboxV2EventChoiceType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn costAction(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2EventChoiceData::VT_COSTACTION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn title(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventChoiceData::VT_TITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventChoiceData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn expeditionId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventChoiceData::VT_EXPEDITIONID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2EventChoiceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "choiceId",
                Self::VT_CHOICEID,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxV2EventChoiceType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<i32>("costAction", Self::VT_COSTACTION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "expeditionId",
                Self::VT_EXPEDITIONID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2EventChoiceDataArgs<'a> {
    pub choiceId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_SandboxV2EventChoiceType,
    pub costAction: i32,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub expeditionId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2EventChoiceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2EventChoiceDataArgs {
            choiceId: None,
            type_: enum__Torappu_SandboxV2EventChoiceType::NONE,
            costAction: 0,
            title: None,
            desc: None,
            expeditionId: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2EventChoiceDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2EventChoiceDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_choiceId(&mut self, choiceId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventChoiceData::VT_CHOICEID,
            choiceId,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_SandboxV2EventChoiceType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2EventChoiceType>(
                clz_Torappu_SandboxV2EventChoiceData::VT_TYPE_,
                type_,
                enum__Torappu_SandboxV2EventChoiceType::NONE,
            );
    }
    #[inline]
    pub fn add_costAction(&mut self, costAction: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2EventChoiceData::VT_COSTACTION,
            costAction,
            0,
        );
    }
    #[inline]
    pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventChoiceData::VT_TITLE,
            title,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventChoiceData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_expeditionId(&mut self, expeditionId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventChoiceData::VT_EXPEDITIONID,
            expeditionId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2EventChoiceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2EventChoiceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventChoiceData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2EventChoiceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2EventChoiceData");
        ds.field("choiceId", &self.choiceId());
        ds.field("type_", &self.type_());
        ds.field("costAction", &self.costAction());
        ds.field("title", &self.title());
        ds.field("desc", &self.desc());
        ds.field("expeditionId", &self.expeditionId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2EventChoiceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2EventChoiceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2EventChoiceData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2EventChoiceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2EventChoiceData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2EventChoiceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2EventChoiceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EventChoiceData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2EventChoiceDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2EventChoiceData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2EventChoiceData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2EventChoiceData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2EventChoiceData>>(
                    dict__string__clz_Torappu_SandboxV2EventChoiceData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2EventChoiceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2EventChoiceData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2EventChoiceDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventChoiceData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2EventChoiceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2EventChoiceDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2EventChoiceDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2EventChoiceDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2EventChoiceData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventChoiceData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventChoiceData>>(
                dict__string__clz_Torappu_SandboxV2EventChoiceData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2EventChoiceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2EventChoiceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EventChoiceData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2EventChoiceData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2EventChoiceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2EventChoiceData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2ExpeditionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ExpeditionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ExpeditionData<'a> {
    type Inner = clz_Torappu_SandboxV2ExpeditionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ExpeditionData<'a> {
    pub const VT_EXPEDITIONID: flatbuffers::VOffsetT = 4;
    pub const VT_DESC: flatbuffers::VOffsetT = 6;
    pub const VT_EFFECTDESC: flatbuffers::VOffsetT = 8;
    pub const VT_COSTACTION: flatbuffers::VOffsetT = 10;
    pub const VT_COSTDRINK: flatbuffers::VOffsetT = 12;
    pub const VT_CHARCNT: flatbuffers::VOffsetT = 14;
    pub const VT_PROFESSION: flatbuffers::VOffsetT = 16;
    pub const VT_PROFESSIONS: flatbuffers::VOffsetT = 18;
    pub const VT_MINELITERANK: flatbuffers::VOffsetT = 20;
    pub const VT_DURATION: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ExpeditionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ExpeditionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ExpeditionData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ExpeditionDataBuilder::new(_fbb);
        builder.add_duration(args.duration);
        builder.add_minEliteRank(args.minEliteRank);
        if let Some(x) = args.professions {
            builder.add_professions(x);
        }
        builder.add_profession(args.profession);
        builder.add_charCnt(args.charCnt);
        builder.add_costDrink(args.costDrink);
        builder.add_costAction(args.costAction);
        if let Some(x) = args.effectDesc {
            builder.add_effectDesc(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.expeditionId {
            builder.add_expeditionId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn expeditionId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ExpeditionData::VT_EXPEDITIONID,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ExpeditionData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn effectDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ExpeditionData::VT_EFFECTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn costAction(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ExpeditionData::VT_COSTACTION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn costDrink(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ExpeditionData::VT_COSTDRINK, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn charCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ExpeditionData::VT_CHARCNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn profession(&self) -> enum__Torappu_ProfessionCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ProfessionCategory>(
                    clz_Torappu_SandboxV2ExpeditionData::VT_PROFESSION,
                    Some(enum__Torappu_ProfessionCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn professions(&self) -> Option<flatbuffers::Vector<'a, enum__Torappu_ProfessionID>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_ProfessionID>,
            >>(clz_Torappu_SandboxV2ExpeditionData::VT_PROFESSIONS, None)
        }
    }
    #[inline]
    pub fn minEliteRank(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2ExpeditionData::VT_MINELITERANK,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn duration(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ExpeditionData::VT_DURATION, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ExpeditionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("expeditionId", Self::VT_EXPEDITIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("effectDesc", Self::VT_EFFECTDESC, false)?
     .visit_field::<i32>("costAction", Self::VT_COSTACTION, false)?
     .visit_field::<i32>("costDrink", Self::VT_COSTDRINK, false)?
     .visit_field::<i32>("charCnt", Self::VT_CHARCNT, false)?
     .visit_field::<enum__Torappu_ProfessionCategory>("profession", Self::VT_PROFESSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_ProfessionID>>>("professions", Self::VT_PROFESSIONS, false)?
     .visit_field::<i32>("minEliteRank", Self::VT_MINELITERANK, false)?
     .visit_field::<i32>("duration", Self::VT_DURATION, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ExpeditionDataArgs<'a> {
    pub expeditionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub effectDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub costAction: i32,
    pub costDrink: i32,
    pub charCnt: i32,
    pub profession: enum__Torappu_ProfessionCategory,
    pub professions:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_ProfessionID>>>,
    pub minEliteRank: i32,
    pub duration: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2ExpeditionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ExpeditionDataArgs {
            expeditionId: None,
            desc: None,
            effectDesc: None,
            costAction: 0,
            costDrink: 0,
            charCnt: 0,
            profession: enum__Torappu_ProfessionCategory::NONE,
            professions: None,
            minEliteRank: 0,
            duration: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2ExpeditionDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ExpeditionDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_expeditionId(&mut self, expeditionId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ExpeditionData::VT_EXPEDITIONID,
            expeditionId,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ExpeditionData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_effectDesc(&mut self, effectDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ExpeditionData::VT_EFFECTDESC,
            effectDesc,
        );
    }
    #[inline]
    pub fn add_costAction(&mut self, costAction: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ExpeditionData::VT_COSTACTION,
            costAction,
            0,
        );
    }
    #[inline]
    pub fn add_costDrink(&mut self, costDrink: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ExpeditionData::VT_COSTDRINK,
            costDrink,
            0,
        );
    }
    #[inline]
    pub fn add_charCnt(&mut self, charCnt: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2ExpeditionData::VT_CHARCNT, charCnt, 0);
    }
    #[inline]
    pub fn add_profession(&mut self, profession: enum__Torappu_ProfessionCategory) {
        self.fbb_.push_slot::<enum__Torappu_ProfessionCategory>(
            clz_Torappu_SandboxV2ExpeditionData::VT_PROFESSION,
            profession,
            enum__Torappu_ProfessionCategory::NONE,
        );
    }
    #[inline]
    pub fn add_professions(
        &mut self,
        professions: flatbuffers::WIPOffset<flatbuffers::Vector<'b, enum__Torappu_ProfessionID>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ExpeditionData::VT_PROFESSIONS,
            professions,
        );
    }
    #[inline]
    pub fn add_minEliteRank(&mut self, minEliteRank: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ExpeditionData::VT_MINELITERANK,
            minEliteRank,
            0,
        );
    }
    #[inline]
    pub fn add_duration(&mut self, duration: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ExpeditionData::VT_DURATION,
            duration,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ExpeditionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ExpeditionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ExpeditionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ExpeditionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ExpeditionData");
        ds.field("expeditionId", &self.expeditionId());
        ds.field("desc", &self.desc());
        ds.field("effectDesc", &self.effectDesc());
        ds.field("costAction", &self.costAction());
        ds.field("costDrink", &self.costDrink());
        ds.field("charCnt", &self.charCnt());
        ds.field("profession", &self.profession());
        ds.field("professions", &self.professions());
        ds.field("minEliteRank", &self.minEliteRank());
        ds.field("duration", &self.duration());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ExpeditionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ExpeditionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2ExpeditionData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2ExpeditionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ExpeditionData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ExpeditionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ExpeditionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ExpeditionData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2ExpeditionDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ExpeditionData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2ExpeditionData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ExpeditionData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ExpeditionData>>(
                    dict__string__clz_Torappu_SandboxV2ExpeditionData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ExpeditionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ExpeditionData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ExpeditionDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ExpeditionData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ExpeditionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ExpeditionDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ExpeditionDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ExpeditionDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ExpeditionData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ExpeditionData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ExpeditionData>>(
                dict__string__clz_Torappu_SandboxV2ExpeditionData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ExpeditionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ExpeditionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ExpeditionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ExpeditionData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ExpeditionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2ExpeditionData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2EventEffectDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2EventEffectData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2EventEffectData<'a> {
    type Inner = clz_Torappu_SandboxV2EventEffectData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2EventEffectData<'a> {
    pub const VT_EVENTEFFECTID: flatbuffers::VOffsetT = 4;
    pub const VT_BUFFID: flatbuffers::VOffsetT = 6;
    pub const VT_DURATION: flatbuffers::VOffsetT = 8;
    pub const VT_DESC: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2EventEffectData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2EventEffectDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventEffectData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2EventEffectDataBuilder::new(_fbb);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        builder.add_duration(args.duration);
        if let Some(x) = args.buffId {
            builder.add_buffId(x);
        }
        if let Some(x) = args.eventEffectId {
            builder.add_eventEffectId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn eventEffectId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventEffectData::VT_EVENTEFFECTID,
                None,
            )
        }
    }
    #[inline]
    pub fn buffId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventEffectData::VT_BUFFID,
                None,
            )
        }
    }
    #[inline]
    pub fn duration(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2EventEffectData::VT_DURATION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventEffectData::VT_DESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2EventEffectData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "eventEffectId",
                Self::VT_EVENTEFFECTID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buffId", Self::VT_BUFFID, false)?
            .visit_field::<i32>("duration", Self::VT_DURATION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2EventEffectDataArgs<'a> {
    pub eventEffectId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub duration: i32,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2EventEffectDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2EventEffectDataArgs {
            eventEffectId: None,
            buffId: None,
            duration: 0,
            desc: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2EventEffectDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2EventEffectDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_eventEffectId(&mut self, eventEffectId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventEffectData::VT_EVENTEFFECTID,
            eventEffectId,
        );
    }
    #[inline]
    pub fn add_buffId(&mut self, buffId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventEffectData::VT_BUFFID,
            buffId,
        );
    }
    #[inline]
    pub fn add_duration(&mut self, duration: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2EventEffectData::VT_DURATION,
            duration,
            0,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventEffectData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2EventEffectDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2EventEffectDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventEffectData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2EventEffectData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2EventEffectData");
        ds.field("eventEffectId", &self.eventEffectId());
        ds.field("buffId", &self.buffId());
        ds.field("duration", &self.duration());
        ds.field("desc", &self.desc());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2EventEffectDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2EventEffectData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2EventEffectData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2EventEffectData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2EventEffectData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2EventEffectData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2EventEffectDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EventEffectData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2EventEffectDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2EventEffectData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2EventEffectData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2EventEffectData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2EventEffectData>>(
                    dict__string__clz_Torappu_SandboxV2EventEffectData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2EventEffectData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2EventEffectData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2EventEffectDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventEffectData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2EventEffectDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2EventEffectDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2EventEffectDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2EventEffectDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2EventEffectData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventEffectData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventEffectData>>(
                dict__string__clz_Torappu_SandboxV2EventEffectData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2EventEffectDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2EventEffectDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EventEffectData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2EventEffectData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2EventEffectData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2EventEffectData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2ShopGoodDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ShopGoodData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ShopGoodData<'a> {
    type Inner = clz_Torappu_SandboxV2ShopGoodData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ShopGoodData<'a> {
    pub const VT_GOODID: flatbuffers::VOffsetT = 4;
    pub const VT_ITEMID: flatbuffers::VOffsetT = 6;
    pub const VT_COUNT: flatbuffers::VOffsetT = 8;
    pub const VT_COINTYPE: flatbuffers::VOffsetT = 10;
    pub const VT_VALUE: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ShopGoodData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ShopGoodDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ShopGoodData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ShopGoodDataBuilder::new(_fbb);
        builder.add_value(args.value);
        builder.add_coinType(args.coinType);
        builder.add_count(args.count);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        if let Some(x) = args.goodId {
            builder.add_goodId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn goodId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ShopGoodData::VT_GOODID,
                None,
            )
        }
    }
    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ShopGoodData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ShopGoodData::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn coinType(&self) -> enum__Torappu_SandboxV2CoinType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2CoinType>(
                    clz_Torappu_SandboxV2ShopGoodData::VT_COINTYPE,
                    Some(enum__Torappu_SandboxV2CoinType::DIMENSION_COIN),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn value(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ShopGoodData::VT_VALUE, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ShopGoodData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("goodId", Self::VT_GOODID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<enum__Torappu_SandboxV2CoinType>("coinType", Self::VT_COINTYPE, false)?
            .visit_field::<i32>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ShopGoodDataArgs<'a> {
    pub goodId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
    pub coinType: enum__Torappu_SandboxV2CoinType,
    pub value: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2ShopGoodDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ShopGoodDataArgs {
            goodId: None,
            itemId: None,
            count: 0,
            coinType: enum__Torappu_SandboxV2CoinType::DIMENSION_COIN,
            value: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2ShopGoodDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ShopGoodDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_goodId(&mut self, goodId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ShopGoodData::VT_GOODID,
            goodId,
        );
    }
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ShopGoodData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2ShopGoodData::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_coinType(&mut self, coinType: enum__Torappu_SandboxV2CoinType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2CoinType>(
            clz_Torappu_SandboxV2ShopGoodData::VT_COINTYPE,
            coinType,
            enum__Torappu_SandboxV2CoinType::DIMENSION_COIN,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2ShopGoodData::VT_VALUE, value, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ShopGoodDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ShopGoodDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ShopGoodData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ShopGoodData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ShopGoodData");
        ds.field("goodId", &self.goodId());
        ds.field("itemId", &self.itemId());
        ds.field("count", &self.count());
        ds.field("coinType", &self.coinType());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ShopGoodDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ShopGoodData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2ShopGoodData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2ShopGoodData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ShopGoodData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ShopGoodData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ShopGoodDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ShopGoodData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2ShopGoodDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ShopGoodData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2ShopGoodData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ShopGoodData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ShopGoodData>>(
                    dict__string__clz_Torappu_SandboxV2ShopGoodData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ShopGoodData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ShopGoodData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ShopGoodDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ShopGoodData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ShopGoodDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ShopGoodDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ShopGoodDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ShopGoodDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ShopGoodData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ShopGoodData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ShopGoodData>>(
                dict__string__clz_Torappu_SandboxV2ShopGoodData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ShopGoodDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ShopGoodDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ShopGoodData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ShopGoodData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ShopGoodData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2ShopGoodData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum dict__string__list_stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__list_string<'a> {
    type Inner = dict__string__list_string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__list_string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__list_string<'bldr>> {
        let mut builder = dict__string__list_stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__list_string::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__list_string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(dict__string__list_string::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__list_string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_stringArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for dict__string__list_stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__list_stringArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__list_stringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__list_stringBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__list_string::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_string::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__list_stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__list_stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__list_string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__list_string::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__list_string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__list_string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2ShopDialogDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ShopDialogData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ShopDialogData<'a> {
    type Inner = clz_Torappu_SandboxV2ShopDialogData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ShopDialogData<'a> {
    pub const VT_SEASONDIALOGS: flatbuffers::VOffsetT = 4;
    pub const VT_AFTERBUYDIALOGS: flatbuffers::VOffsetT = 6;
    pub const VT_SHOPEMPTYDIALOGS: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ShopDialogData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ShopDialogDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ShopDialogData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ShopDialogDataBuilder::new(_fbb);
        if let Some(x) = args.shopEmptyDialogs {
            builder.add_shopEmptyDialogs(x);
        }
        if let Some(x) = args.afterBuyDialogs {
            builder.add_afterBuyDialogs(x);
        }
        if let Some(x) = args.seasonDialogs {
            builder.add_seasonDialogs(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn seasonDialogs(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string>>,
            >>(clz_Torappu_SandboxV2ShopDialogData::VT_SEASONDIALOGS, None)
        }
    }
    #[inline]
    pub fn afterBuyDialogs(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2ShopDialogData::VT_AFTERBUYDIALOGS,
                None,
            )
        }
    }
    #[inline]
    pub fn shopEmptyDialogs(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2ShopDialogData::VT_SHOPEMPTYDIALOGS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ShopDialogData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__list_string>>,
            >>("seasonDialogs", Self::VT_SEASONDIALOGS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("afterBuyDialogs", Self::VT_AFTERBUYDIALOGS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("shopEmptyDialogs", Self::VT_SHOPEMPTYDIALOGS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ShopDialogDataArgs<'a> {
    pub seasonDialogs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string<'a>>>,
        >,
    >,
    pub afterBuyDialogs: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub shopEmptyDialogs: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2ShopDialogDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ShopDialogDataArgs {
            seasonDialogs: None,
            afterBuyDialogs: None,
            shopEmptyDialogs: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2ShopDialogDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ShopDialogDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_seasonDialogs(
        &mut self,
        seasonDialogs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__list_string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ShopDialogData::VT_SEASONDIALOGS,
            seasonDialogs,
        );
    }
    #[inline]
    pub fn add_afterBuyDialogs(
        &mut self,
        afterBuyDialogs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ShopDialogData::VT_AFTERBUYDIALOGS,
            afterBuyDialogs,
        );
    }
    #[inline]
    pub fn add_shopEmptyDialogs(
        &mut self,
        shopEmptyDialogs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ShopDialogData::VT_SHOPEMPTYDIALOGS,
            shopEmptyDialogs,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ShopDialogDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ShopDialogDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ShopDialogData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ShopDialogData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ShopDialogData");
        ds.field("seasonDialogs", &self.seasonDialogs());
        ds.field("afterBuyDialogs", &self.afterBuyDialogs());
        ds.field("shopEmptyDialogs", &self.shopEmptyDialogs());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2LogisticsDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2LogisticsData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2LogisticsData<'a> {
    type Inner = clz_Torappu_SandboxV2LogisticsData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2LogisticsData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DESC: flatbuffers::VOffsetT = 6;
    pub const VT_NOBUFFDESC: flatbuffers::VOffsetT = 8;
    pub const VT_ICONID: flatbuffers::VOffsetT = 10;
    pub const VT_PROFESSION: flatbuffers::VOffsetT = 12;
    pub const VT_SORTID: flatbuffers::VOffsetT = 14;
    pub const VT_LEVELPARAMS: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2LogisticsData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2LogisticsDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2LogisticsData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2LogisticsDataBuilder::new(_fbb);
        if let Some(x) = args.levelParams {
            builder.add_levelParams(x);
        }
        builder.add_sortId(args.sortId);
        builder.add_profession(args.profession);
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.noBuffDesc {
            builder.add_noBuffDesc(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2LogisticsData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2LogisticsData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn noBuffDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2LogisticsData::VT_NOBUFFDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2LogisticsData::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn profession(&self) -> enum__Torappu_ProfessionCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ProfessionCategory>(
                    clz_Torappu_SandboxV2LogisticsData::VT_PROFESSION,
                    Some(enum__Torappu_ProfessionCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2LogisticsData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn levelParams(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxV2LogisticsData::VT_LEVELPARAMS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2LogisticsData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "noBuffDesc",
                Self::VT_NOBUFFDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<enum__Torappu_ProfessionCategory>(
                "profession",
                Self::VT_PROFESSION,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("levelParams", Self::VT_LEVELPARAMS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2LogisticsDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub noBuffDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub profession: enum__Torappu_ProfessionCategory,
    pub sortId: i32,
    pub levelParams: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2LogisticsDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2LogisticsDataArgs {
            id: None,
            desc: None,
            noBuffDesc: None,
            iconId: None,
            profession: enum__Torappu_ProfessionCategory::NONE,
            sortId: 0,
            levelParams: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2LogisticsDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2LogisticsDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2LogisticsData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2LogisticsData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_noBuffDesc(&mut self, noBuffDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2LogisticsData::VT_NOBUFFDESC,
            noBuffDesc,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2LogisticsData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_profession(&mut self, profession: enum__Torappu_ProfessionCategory) {
        self.fbb_.push_slot::<enum__Torappu_ProfessionCategory>(
            clz_Torappu_SandboxV2LogisticsData::VT_PROFESSION,
            profession,
            enum__Torappu_ProfessionCategory::NONE,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2LogisticsData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_levelParams(
        &mut self,
        levelParams: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2LogisticsData::VT_LEVELPARAMS,
            levelParams,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2LogisticsDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2LogisticsDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2LogisticsData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2LogisticsData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2LogisticsData");
        ds.field("id", &self.id());
        ds.field("desc", &self.desc());
        ds.field("noBuffDesc", &self.noBuffDesc());
        ds.field("iconId", &self.iconId());
        ds.field("profession", &self.profession());
        ds.field("sortId", &self.sortId());
        ds.field("levelParams", &self.levelParams());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2LogisticsCharDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2LogisticsCharData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2LogisticsCharData<'a> {
    type Inner = clz_Torappu_SandboxV2LogisticsCharData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2LogisticsCharData<'a> {
    pub const VT_LEVELUPPERLIMIT: flatbuffers::VOffsetT = 4;
    pub const VT_CHARUPPERLIMIT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2LogisticsCharData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2LogisticsCharDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2LogisticsCharData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2LogisticsCharDataBuilder::new(_fbb);
        builder.add_charUpperLimit(args.charUpperLimit);
        builder.add_levelUpperLimit(args.levelUpperLimit);
        builder.finish()
    }

    #[inline]
    pub fn levelUpperLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2LogisticsCharData::VT_LEVELUPPERLIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn charUpperLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2LogisticsCharData::VT_CHARUPPERLIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2LogisticsCharData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("levelUpperLimit", Self::VT_LEVELUPPERLIMIT, false)?
            .visit_field::<i32>("charUpperLimit", Self::VT_CHARUPPERLIMIT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2LogisticsCharDataArgs {
    pub levelUpperLimit: i32,
    pub charUpperLimit: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2LogisticsCharDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2LogisticsCharDataArgs {
            levelUpperLimit: 0,
            charUpperLimit: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2LogisticsCharDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2LogisticsCharDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_levelUpperLimit(&mut self, levelUpperLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2LogisticsCharData::VT_LEVELUPPERLIMIT,
            levelUpperLimit,
            0,
        );
    }
    #[inline]
    pub fn add_charUpperLimit(&mut self, charUpperLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2LogisticsCharData::VT_CHARUPPERLIMIT,
            charUpperLimit,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2LogisticsCharDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2LogisticsCharDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2LogisticsCharData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2LogisticsCharData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2LogisticsCharData");
        ds.field("levelUpperLimit", &self.levelUpperLimit());
        ds.field("charUpperLimit", &self.charUpperLimit());
        ds.finish()
    }
}
pub enum dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a> {
    type Inner = dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__list_clz_Torappu_SandboxV2LogisticsCharData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'bldr>> {
        let mut builder = dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    dict__int__list_clz_Torappu_SandboxV2LogisticsCharData::VT_KEY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__int__list_clz_Torappu_SandboxV2LogisticsCharData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LogisticsCharData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LogisticsCharData>,
                >,
            >>(
                dict__int__list_clz_Torappu_SandboxV2LogisticsCharData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LogisticsCharData>,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataArgs<'a> {
    pub key: i32,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LogisticsCharData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataArgs {
            key: 0,
            value: None,
        }
    }
}

pub struct dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_.push_slot::<i32>(
            dict__int__list_clz_Torappu_SandboxV2LogisticsCharData::VT_KEY,
            key,
            0,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LogisticsCharData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__int__list_clz_Torappu_SandboxV2LogisticsCharData::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__int__list_clz_Torappu_SandboxV2LogisticsCharData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a>
{
    type Inner = dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataArgs<
            'args,
        >,
    ) -> flatbuffers::WIPOffset<
        dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'bldr>,
    > {
        let mut builder =
            dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataBuilder::new(
                _fbb,
            );
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData::VT_KEY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__int__list_clz_Torappu_SandboxV2LogisticsCharData,
                    >,
                >,
            >>(
                dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__int__list_clz_Torappu_SandboxV2LogisticsCharData,
                    >,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataArgs<'a> {
    pub key: i32,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default
    for dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataArgs<'a>
{
    #[inline]
    fn default() -> Self {
        dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataArgs {
            key: 0,
            value: None,
        }
    }
}

pub struct dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_.push_slot::<i32>(
            dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData::VT_KEY,
            key,
            0,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataBuilder<'a, 'b, A>
    {
        let start = _fbb.start_table();
        dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f
            .debug_struct("dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2MonthRushDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2MonthRushData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2MonthRushData<'a> {
    type Inner = clz_Torappu_SandboxV2MonthRushData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2MonthRushData<'a> {
    pub const VT_MONTHLYRUSHID: flatbuffers::VOffsetT = 4;
    pub const VT_STARTTIME: flatbuffers::VOffsetT = 6;
    pub const VT_ENDTIME: flatbuffers::VOffsetT = 8;
    pub const VT_ISLAST: flatbuffers::VOffsetT = 10;
    pub const VT_SORTID: flatbuffers::VOffsetT = 12;
    pub const VT_RUSHGROUPKEY: flatbuffers::VOffsetT = 14;
    pub const VT_MONTHLYRUSHNAME: flatbuffers::VOffsetT = 16;
    pub const VT_MONTHLYRUSHDES: flatbuffers::VOffsetT = 18;
    pub const VT_WEATHERID: flatbuffers::VOffsetT = 20;
    pub const VT_NODEID: flatbuffers::VOffsetT = 22;
    pub const VT_CONDITIONGROUP: flatbuffers::VOffsetT = 24;
    pub const VT_CONDITIONDESC: flatbuffers::VOffsetT = 26;
    pub const VT_REWARDITEMLIST: flatbuffers::VOffsetT = 28;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2MonthRushData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2MonthRushDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2MonthRushData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2MonthRushDataBuilder::new(_fbb);
        builder.add_endTime(args.endTime);
        builder.add_startTime(args.startTime);
        if let Some(x) = args.rewardItemList {
            builder.add_rewardItemList(x);
        }
        if let Some(x) = args.conditionDesc {
            builder.add_conditionDesc(x);
        }
        if let Some(x) = args.conditionGroup {
            builder.add_conditionGroup(x);
        }
        if let Some(x) = args.nodeId {
            builder.add_nodeId(x);
        }
        if let Some(x) = args.weatherId {
            builder.add_weatherId(x);
        }
        if let Some(x) = args.monthlyRushDes {
            builder.add_monthlyRushDes(x);
        }
        if let Some(x) = args.monthlyRushName {
            builder.add_monthlyRushName(x);
        }
        if let Some(x) = args.rushGroupKey {
            builder.add_rushGroupKey(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.monthlyRushId {
            builder.add_monthlyRushId(x);
        }
        builder.add_isLast(args.isLast);
        builder.finish()
    }

    #[inline]
    pub fn monthlyRushId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MonthRushData::VT_MONTHLYRUSHID,
                None,
            )
        }
    }
    #[inline]
    pub fn startTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_SandboxV2MonthRushData::VT_STARTTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_SandboxV2MonthRushData::VT_ENDTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn isLast(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_SandboxV2MonthRushData::VT_ISLAST, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2MonthRushData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn rushGroupKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MonthRushData::VT_RUSHGROUPKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn monthlyRushName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MonthRushData::VT_MONTHLYRUSHNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn monthlyRushDes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MonthRushData::VT_MONTHLYRUSHDES,
                None,
            )
        }
    }
    #[inline]
    pub fn weatherId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MonthRushData::VT_WEATHERID,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MonthRushData::VT_NODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn conditionGroup(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MonthRushData::VT_CONDITIONGROUP,
                None,
            )
        }
    }
    #[inline]
    pub fn conditionDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MonthRushData::VT_CONDITIONDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn rewardItemList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(clz_Torappu_SandboxV2MonthRushData::VT_REWARDITEMLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2MonthRushData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "monthlyRushId",
                Self::VT_MONTHLYRUSHID,
                false,
            )?
            .visit_field::<i64>("startTime", Self::VT_STARTTIME, false)?
            .visit_field::<i64>("endTime", Self::VT_ENDTIME, false)?
            .visit_field::<bool>("isLast", Self::VT_ISLAST, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rushGroupKey",
                Self::VT_RUSHGROUPKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "monthlyRushName",
                Self::VT_MONTHLYRUSHNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "monthlyRushDes",
                Self::VT_MONTHLYRUSHDES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "weatherId",
                Self::VT_WEATHERID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nodeId", Self::VT_NODEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "conditionGroup",
                Self::VT_CONDITIONGROUP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "conditionDesc",
                Self::VT_CONDITIONDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("rewardItemList", Self::VT_REWARDITEMLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2MonthRushDataArgs<'a> {
    pub monthlyRushId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub startTime: i64,
    pub endTime: i64,
    pub isLast: bool,
    pub sortId: i32,
    pub rushGroupKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub monthlyRushName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub monthlyRushDes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weatherId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub conditionGroup: Option<flatbuffers::WIPOffset<&'a str>>,
    pub conditionDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewardItemList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2MonthRushDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2MonthRushDataArgs {
            monthlyRushId: None,
            startTime: 0,
            endTime: 0,
            isLast: false,
            sortId: 0,
            rushGroupKey: None,
            monthlyRushName: None,
            monthlyRushDes: None,
            weatherId: None,
            nodeId: None,
            conditionGroup: None,
            conditionDesc: None,
            rewardItemList: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2MonthRushDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2MonthRushDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_monthlyRushId(&mut self, monthlyRushId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MonthRushData::VT_MONTHLYRUSHID,
            monthlyRushId,
        );
    }
    #[inline]
    pub fn add_startTime(&mut self, startTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_SandboxV2MonthRushData::VT_STARTTIME,
            startTime,
            0,
        );
    }
    #[inline]
    pub fn add_endTime(&mut self, endTime: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_SandboxV2MonthRushData::VT_ENDTIME, endTime, 0);
    }
    #[inline]
    pub fn add_isLast(&mut self, isLast: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_SandboxV2MonthRushData::VT_ISLAST, isLast, false);
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2MonthRushData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_rushGroupKey(&mut self, rushGroupKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MonthRushData::VT_RUSHGROUPKEY,
            rushGroupKey,
        );
    }
    #[inline]
    pub fn add_monthlyRushName(&mut self, monthlyRushName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MonthRushData::VT_MONTHLYRUSHNAME,
            monthlyRushName,
        );
    }
    #[inline]
    pub fn add_monthlyRushDes(&mut self, monthlyRushDes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MonthRushData::VT_MONTHLYRUSHDES,
            monthlyRushDes,
        );
    }
    #[inline]
    pub fn add_weatherId(&mut self, weatherId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MonthRushData::VT_WEATHERID,
            weatherId,
        );
    }
    #[inline]
    pub fn add_nodeId(&mut self, nodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MonthRushData::VT_NODEID,
            nodeId,
        );
    }
    #[inline]
    pub fn add_conditionGroup(&mut self, conditionGroup: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MonthRushData::VT_CONDITIONGROUP,
            conditionGroup,
        );
    }
    #[inline]
    pub fn add_conditionDesc(&mut self, conditionDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MonthRushData::VT_CONDITIONDESC,
            conditionDesc,
        );
    }
    #[inline]
    pub fn add_rewardItemList(
        &mut self,
        rewardItemList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MonthRushData::VT_REWARDITEMLIST,
            rewardItemList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2MonthRushDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2MonthRushDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2MonthRushData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2MonthRushData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2MonthRushData");
        ds.field("monthlyRushId", &self.monthlyRushId());
        ds.field("startTime", &self.startTime());
        ds.field("endTime", &self.endTime());
        ds.field("isLast", &self.isLast());
        ds.field("sortId", &self.sortId());
        ds.field("rushGroupKey", &self.rushGroupKey());
        ds.field("monthlyRushName", &self.monthlyRushName());
        ds.field("monthlyRushDes", &self.monthlyRushDes());
        ds.field("weatherId", &self.weatherId());
        ds.field("nodeId", &self.nodeId());
        ds.field("conditionGroup", &self.conditionGroup());
        ds.field("conditionDesc", &self.conditionDesc());
        ds.field("rewardItemList", &self.rewardItemList());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2RiftParamDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RiftParamData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RiftParamData<'a> {
    type Inner = clz_Torappu_SandboxV2RiftParamData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RiftParamData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DESC: flatbuffers::VOffsetT = 6;
    pub const VT_ICONID: flatbuffers::VOffsetT = 8;
    pub const VT_BKCOLOR: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RiftParamData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RiftParamDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftParamData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RiftParamDataBuilder::new(_fbb);
        if let Some(x) = args.bkColor {
            builder.add_bkColor(x);
        }
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftParamData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftParamData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftParamData::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn bkColor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftParamData::VT_BKCOLOR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RiftParamData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bkColor", Self::VT_BKCOLOR, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RiftParamDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bkColor: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2RiftParamDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RiftParamDataArgs {
            id: None,
            desc: None,
            iconId: None,
            bkColor: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2RiftParamDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RiftParamDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftParamData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftParamData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftParamData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_bkColor(&mut self, bkColor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftParamData::VT_BKCOLOR,
            bkColor,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RiftParamDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RiftParamDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftParamData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RiftParamData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RiftParamData");
        ds.field("id", &self.id());
        ds.field("desc", &self.desc());
        ds.field("iconId", &self.iconId());
        ds.field("bkColor", &self.bkColor());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RiftParamDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RiftParamData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RiftParamData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RiftParamData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RiftParamData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RiftParamData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RiftParamDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2RiftParamDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RiftParamData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2RiftParamData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RiftParamData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftParamData>>(
                    dict__string__clz_Torappu_SandboxV2RiftParamData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RiftParamData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftParamData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RiftParamDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftParamData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RiftParamDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RiftParamDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RiftParamDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RiftParamDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RiftParamData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftParamData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftParamData>>(
                dict__string__clz_Torappu_SandboxV2RiftParamData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RiftParamDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RiftParamDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RiftParamData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RiftParamData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RiftParamData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2RiftSubTargetDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RiftSubTargetData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RiftSubTargetData<'a> {
    type Inner = clz_Torappu_SandboxV2RiftSubTargetData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RiftSubTargetData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_DESC: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RiftSubTargetData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RiftSubTargetDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftSubTargetData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RiftSubTargetDataBuilder::new(_fbb);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftSubTargetData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftSubTargetData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftSubTargetData::VT_DESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RiftSubTargetData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RiftSubTargetDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2RiftSubTargetDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RiftSubTargetDataArgs {
            id: None,
            name: None,
            desc: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2RiftSubTargetDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RiftSubTargetDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftSubTargetData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftSubTargetData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftSubTargetData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RiftSubTargetDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RiftSubTargetDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftSubTargetData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RiftSubTargetData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RiftSubTargetData");
        ds.field("id", &self.id());
        ds.field("name", &self.name());
        ds.field("desc", &self.desc());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RiftSubTargetDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RiftSubTargetData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RiftSubTargetDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2RiftSubTargetDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RiftSubTargetData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2RiftSubTargetData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RiftSubTargetData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftSubTargetData>>(
                    dict__string__clz_Torappu_SandboxV2RiftSubTargetData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftSubTargetData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RiftSubTargetDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftSubTargetData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RiftSubTargetDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RiftSubTargetDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RiftSubTargetDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RiftSubTargetDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RiftSubTargetData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftSubTargetData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftSubTargetData>>(
                dict__string__clz_Torappu_SandboxV2RiftSubTargetData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RiftSubTargetDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RiftSubTargetDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RiftSubTargetData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RiftSubTargetData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2RiftMainTargetDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RiftMainTargetData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RiftMainTargetData<'a> {
    type Inner = clz_Torappu_SandboxV2RiftMainTargetData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RiftMainTargetData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TITLE: flatbuffers::VOffsetT = 6;
    pub const VT_DESC: flatbuffers::VOffsetT = 8;
    pub const VT_STORYDESC: flatbuffers::VOffsetT = 10;
    pub const VT_TARGETDAYCOUNT: flatbuffers::VOffsetT = 12;
    pub const VT_TARGETTYPE: flatbuffers::VOffsetT = 14;
    pub const VT_QUESTICONID: flatbuffers::VOffsetT = 16;
    pub const VT_QUESTICONNAME: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RiftMainTargetData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RiftMainTargetDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftMainTargetData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RiftMainTargetDataBuilder::new(_fbb);
        if let Some(x) = args.questIconName {
            builder.add_questIconName(x);
        }
        if let Some(x) = args.questIconId {
            builder.add_questIconId(x);
        }
        builder.add_targetType(args.targetType);
        builder.add_targetDayCount(args.targetDayCount);
        if let Some(x) = args.storyDesc {
            builder.add_storyDesc(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.title {
            builder.add_title(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftMainTargetData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn title(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftMainTargetData::VT_TITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftMainTargetData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn storyDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftMainTargetData::VT_STORYDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn targetDayCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2RiftMainTargetData::VT_TARGETDAYCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn targetType(&self) -> enum__Torappu_SandboxV2RiftMainTargetType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2RiftMainTargetType>(
                    clz_Torappu_SandboxV2RiftMainTargetData::VT_TARGETTYPE,
                    Some(enum__Torappu_SandboxV2RiftMainTargetType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn questIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftMainTargetData::VT_QUESTICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn questIconName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftMainTargetData::VT_QUESTICONNAME,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RiftMainTargetData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "storyDesc",
                Self::VT_STORYDESC,
                false,
            )?
            .visit_field::<i32>("targetDayCount", Self::VT_TARGETDAYCOUNT, false)?
            .visit_field::<enum__Torappu_SandboxV2RiftMainTargetType>(
                "targetType",
                Self::VT_TARGETTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "questIconId",
                Self::VT_QUESTICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "questIconName",
                Self::VT_QUESTICONNAME,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RiftMainTargetDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub storyDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub targetDayCount: i32,
    pub targetType: enum__Torappu_SandboxV2RiftMainTargetType,
    pub questIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub questIconName: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2RiftMainTargetDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RiftMainTargetDataArgs {
            id: None,
            title: None,
            desc: None,
            storyDesc: None,
            targetDayCount: 0,
            targetType: enum__Torappu_SandboxV2RiftMainTargetType::NONE,
            questIconId: None,
            questIconName: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2RiftMainTargetDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RiftMainTargetDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftMainTargetData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftMainTargetData::VT_TITLE,
            title,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftMainTargetData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_storyDesc(&mut self, storyDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftMainTargetData::VT_STORYDESC,
            storyDesc,
        );
    }
    #[inline]
    pub fn add_targetDayCount(&mut self, targetDayCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2RiftMainTargetData::VT_TARGETDAYCOUNT,
            targetDayCount,
            0,
        );
    }
    #[inline]
    pub fn add_targetType(&mut self, targetType: enum__Torappu_SandboxV2RiftMainTargetType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2RiftMainTargetType>(
                clz_Torappu_SandboxV2RiftMainTargetData::VT_TARGETTYPE,
                targetType,
                enum__Torappu_SandboxV2RiftMainTargetType::NONE,
            );
    }
    #[inline]
    pub fn add_questIconId(&mut self, questIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftMainTargetData::VT_QUESTICONID,
            questIconId,
        );
    }
    #[inline]
    pub fn add_questIconName(&mut self, questIconName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftMainTargetData::VT_QUESTICONNAME,
            questIconName,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RiftMainTargetDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RiftMainTargetDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftMainTargetData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RiftMainTargetData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RiftMainTargetData");
        ds.field("id", &self.id());
        ds.field("title", &self.title());
        ds.field("desc", &self.desc());
        ds.field("storyDesc", &self.storyDesc());
        ds.field("targetDayCount", &self.targetDayCount());
        ds.field("targetType", &self.targetType());
        ds.field("questIconId", &self.questIconId());
        ds.field("questIconName", &self.questIconName());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RiftMainTargetDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RiftMainTargetData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RiftMainTargetDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2RiftMainTargetDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RiftMainTargetData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2RiftMainTargetData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RiftMainTargetData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftMainTargetData>>(
                    dict__string__clz_Torappu_SandboxV2RiftMainTargetData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftMainTargetData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RiftMainTargetDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftMainTargetData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RiftMainTargetDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RiftMainTargetDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RiftMainTargetDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RiftMainTargetDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RiftMainTargetData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftMainTargetData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftMainTargetData>>(
                dict__string__clz_Torappu_SandboxV2RiftMainTargetData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RiftMainTargetDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RiftMainTargetDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RiftMainTargetData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RiftMainTargetData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2RiftGlobalEffectDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RiftGlobalEffectData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RiftGlobalEffectData<'a> {
    type Inner = clz_Torappu_SandboxV2RiftGlobalEffectData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RiftGlobalEffectData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DESC: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RiftGlobalEffectData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RiftGlobalEffectDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftGlobalEffectData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RiftGlobalEffectDataBuilder::new(_fbb);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftGlobalEffectData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftGlobalEffectData::VT_DESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RiftGlobalEffectData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RiftGlobalEffectDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2RiftGlobalEffectDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RiftGlobalEffectDataArgs {
            id: None,
            desc: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2RiftGlobalEffectDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RiftGlobalEffectDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftGlobalEffectData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftGlobalEffectData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RiftGlobalEffectDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RiftGlobalEffectDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftGlobalEffectData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RiftGlobalEffectData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RiftGlobalEffectData");
        ds.field("id", &self.id());
        ds.field("desc", &self.desc());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'bldr>>
    {
        let mut builder = dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RiftGlobalEffectData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftGlobalEffectData>>(
                    dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftGlobalEffectData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftGlobalEffectData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftGlobalEffectData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftGlobalEffectData>>(
                dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2FixedRiftDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2FixedRiftData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2FixedRiftData<'a> {
    type Inner = clz_Torappu_SandboxV2FixedRiftData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2FixedRiftData<'a> {
    pub const VT_RIFTID: flatbuffers::VOffsetT = 4;
    pub const VT_RIFTNAME: flatbuffers::VOffsetT = 6;
    pub const VT_REWARDGROUPID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2FixedRiftData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2FixedRiftDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FixedRiftData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2FixedRiftDataBuilder::new(_fbb);
        if let Some(x) = args.rewardGroupId {
            builder.add_rewardGroupId(x);
        }
        if let Some(x) = args.riftName {
            builder.add_riftName(x);
        }
        if let Some(x) = args.riftId {
            builder.add_riftId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn riftId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2FixedRiftData::VT_RIFTID,
                None,
            )
        }
    }
    #[inline]
    pub fn riftName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2FixedRiftData::VT_RIFTNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn rewardGroupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2FixedRiftData::VT_REWARDGROUPID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2FixedRiftData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("riftId", Self::VT_RIFTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "riftName",
                Self::VT_RIFTNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rewardGroupId",
                Self::VT_REWARDGROUPID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2FixedRiftDataArgs<'a> {
    pub riftId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub riftName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewardGroupId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2FixedRiftDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2FixedRiftDataArgs {
            riftId: None,
            riftName: None,
            rewardGroupId: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2FixedRiftDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2FixedRiftDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_riftId(&mut self, riftId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FixedRiftData::VT_RIFTID,
            riftId,
        );
    }
    #[inline]
    pub fn add_riftName(&mut self, riftName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FixedRiftData::VT_RIFTNAME,
            riftName,
        );
    }
    #[inline]
    pub fn add_rewardGroupId(&mut self, rewardGroupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FixedRiftData::VT_REWARDGROUPID,
            rewardGroupId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2FixedRiftDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2FixedRiftDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FixedRiftData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2FixedRiftData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2FixedRiftData");
        ds.field("riftId", &self.riftId());
        ds.field("riftName", &self.riftName());
        ds.field("rewardGroupId", &self.rewardGroupId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2FixedRiftDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2FixedRiftData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2FixedRiftData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2FixedRiftData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2FixedRiftData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2FixedRiftData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2FixedRiftDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2FixedRiftData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2FixedRiftDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2FixedRiftData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2FixedRiftData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2FixedRiftData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FixedRiftData>>(
                    dict__string__clz_Torappu_SandboxV2FixedRiftData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2FixedRiftData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FixedRiftData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2FixedRiftDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2FixedRiftData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2FixedRiftDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2FixedRiftDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2FixedRiftDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2FixedRiftDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2FixedRiftData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2FixedRiftData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2FixedRiftData>>(
                dict__string__clz_Torappu_SandboxV2FixedRiftData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2FixedRiftDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2FixedRiftDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2FixedRiftData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2FixedRiftData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2FixedRiftData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2FixedRiftData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2RiftTeamBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RiftTeamBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RiftTeamBuffData<'a> {
    type Inner = clz_Torappu_SandboxV2RiftTeamBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RiftTeamBuffData<'a> {
    pub const VT_TEAMID: flatbuffers::VOffsetT = 4;
    pub const VT_TEAMNAME: flatbuffers::VOffsetT = 6;
    pub const VT_BUFFLEVEL: flatbuffers::VOffsetT = 8;
    pub const VT_BUFFDESC: flatbuffers::VOffsetT = 10;
    pub const VT_TEAMSMALLICONID: flatbuffers::VOffsetT = 12;
    pub const VT_TEAMBIGICONID: flatbuffers::VOffsetT = 14;
    pub const VT_TEAMDESC: flatbuffers::VOffsetT = 16;
    pub const VT_TEAMBGID: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RiftTeamBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RiftTeamBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftTeamBuffData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RiftTeamBuffDataBuilder::new(_fbb);
        if let Some(x) = args.teamBgId {
            builder.add_teamBgId(x);
        }
        if let Some(x) = args.teamDesc {
            builder.add_teamDesc(x);
        }
        if let Some(x) = args.teamBigIconId {
            builder.add_teamBigIconId(x);
        }
        if let Some(x) = args.teamSmallIconId {
            builder.add_teamSmallIconId(x);
        }
        if let Some(x) = args.buffDesc {
            builder.add_buffDesc(x);
        }
        builder.add_buffLevel(args.buffLevel);
        if let Some(x) = args.teamName {
            builder.add_teamName(x);
        }
        if let Some(x) = args.teamId {
            builder.add_teamId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn teamId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMID,
                None,
            )
        }
    }
    #[inline]
    pub fn teamName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn buffLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2RiftTeamBuffData::VT_BUFFLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn buffDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftTeamBuffData::VT_BUFFDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn teamSmallIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMSMALLICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn teamBigIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMBIGICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn teamDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn teamBgId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMBGID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RiftTeamBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("teamId", Self::VT_TEAMID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "teamName",
                Self::VT_TEAMNAME,
                false,
            )?
            .visit_field::<i32>("buffLevel", Self::VT_BUFFLEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffDesc",
                Self::VT_BUFFDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "teamSmallIconId",
                Self::VT_TEAMSMALLICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "teamBigIconId",
                Self::VT_TEAMBIGICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "teamDesc",
                Self::VT_TEAMDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "teamBgId",
                Self::VT_TEAMBGID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RiftTeamBuffDataArgs<'a> {
    pub teamId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teamName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffLevel: i32,
    pub buffDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teamSmallIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teamBigIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teamDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teamBgId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2RiftTeamBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RiftTeamBuffDataArgs {
            teamId: None,
            teamName: None,
            buffLevel: 0,
            buffDesc: None,
            teamSmallIconId: None,
            teamBigIconId: None,
            teamDesc: None,
            teamBgId: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2RiftTeamBuffDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RiftTeamBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_teamId(&mut self, teamId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMID,
            teamId,
        );
    }
    #[inline]
    pub fn add_teamName(&mut self, teamName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMNAME,
            teamName,
        );
    }
    #[inline]
    pub fn add_buffLevel(&mut self, buffLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2RiftTeamBuffData::VT_BUFFLEVEL,
            buffLevel,
            0,
        );
    }
    #[inline]
    pub fn add_buffDesc(&mut self, buffDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftTeamBuffData::VT_BUFFDESC,
            buffDesc,
        );
    }
    #[inline]
    pub fn add_teamSmallIconId(&mut self, teamSmallIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMSMALLICONID,
            teamSmallIconId,
        );
    }
    #[inline]
    pub fn add_teamBigIconId(&mut self, teamBigIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMBIGICONID,
            teamBigIconId,
        );
    }
    #[inline]
    pub fn add_teamDesc(&mut self, teamDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMDESC,
            teamDesc,
        );
    }
    #[inline]
    pub fn add_teamBgId(&mut self, teamBgId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMBGID,
            teamBgId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RiftTeamBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RiftTeamBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftTeamBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RiftTeamBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RiftTeamBuffData");
        ds.field("teamId", &self.teamId());
        ds.field("teamName", &self.teamName());
        ds.field("buffLevel", &self.buffLevel());
        ds.field("buffDesc", &self.buffDesc());
        ds.field("teamSmallIconId", &self.teamSmallIconId());
        ds.field("teamBigIconId", &self.teamBigIconId());
        ds.field("teamDesc", &self.teamDesc());
        ds.field("teamBgId", &self.teamBgId());
        ds.finish()
    }
}
pub enum dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'a> {
    type Inner = dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'bldr>>
    {
        let mut builder =
            dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftTeamBuffData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftTeamBuffData>,
                >,
            >>(
                dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftTeamBuffData>,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftTeamBuffData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftTeamBuffData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2RiftDifficultyDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RiftDifficultyData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RiftDifficultyData<'a> {
    type Inner = clz_Torappu_SandboxV2RiftDifficultyData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RiftDifficultyData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_RIFTID: flatbuffers::VOffsetT = 6;
    pub const VT_DESC: flatbuffers::VOffsetT = 8;
    pub const VT_DIFFICULTYLEVEL: flatbuffers::VOffsetT = 10;
    pub const VT_REWARDGROUPID: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RiftDifficultyData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RiftDifficultyDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftDifficultyData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RiftDifficultyDataBuilder::new(_fbb);
        if let Some(x) = args.rewardGroupId {
            builder.add_rewardGroupId(x);
        }
        builder.add_difficultyLevel(args.difficultyLevel);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.riftId {
            builder.add_riftId(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftDifficultyData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn riftId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftDifficultyData::VT_RIFTID,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftDifficultyData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn difficultyLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2RiftDifficultyData::VT_DIFFICULTYLEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rewardGroupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftDifficultyData::VT_REWARDGROUPID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RiftDifficultyData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("riftId", Self::VT_RIFTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<i32>("difficultyLevel", Self::VT_DIFFICULTYLEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rewardGroupId",
                Self::VT_REWARDGROUPID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RiftDifficultyDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub riftId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub difficultyLevel: i32,
    pub rewardGroupId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2RiftDifficultyDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RiftDifficultyDataArgs {
            id: None,
            riftId: None,
            desc: None,
            difficultyLevel: 0,
            rewardGroupId: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2RiftDifficultyDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RiftDifficultyDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftDifficultyData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_riftId(&mut self, riftId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftDifficultyData::VT_RIFTID,
            riftId,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftDifficultyData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_difficultyLevel(&mut self, difficultyLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2RiftDifficultyData::VT_DIFFICULTYLEVEL,
            difficultyLevel,
            0,
        );
    }
    #[inline]
    pub fn add_rewardGroupId(&mut self, rewardGroupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftDifficultyData::VT_REWARDGROUPID,
            rewardGroupId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RiftDifficultyDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RiftDifficultyDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftDifficultyData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RiftDifficultyData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RiftDifficultyData");
        ds.field("id", &self.id());
        ds.field("riftId", &self.riftId());
        ds.field("desc", &self.desc());
        ds.field("difficultyLevel", &self.difficultyLevel());
        ds.field("rewardGroupId", &self.rewardGroupId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RiftDifficultyDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RiftDifficultyData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RiftDifficultyDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2RiftDifficultyDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RiftDifficultyData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2RiftDifficultyData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RiftDifficultyData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftDifficultyData>>(
                    dict__string__clz_Torappu_SandboxV2RiftDifficultyData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftDifficultyData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RiftDifficultyDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftDifficultyData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RiftDifficultyDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RiftDifficultyDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RiftDifficultyDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RiftDifficultyDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RiftDifficultyData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftDifficultyData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftDifficultyData>>(
                dict__string__clz_Torappu_SandboxV2RiftDifficultyData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RiftDifficultyDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RiftDifficultyDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RiftDifficultyData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RiftDifficultyData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum dict__string__list_dict__string__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_dict__string__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__list_dict__string__string<'a> {
    type Inner = dict__string__list_dict__string__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__list_dict__string__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_dict__string__string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_dict__string__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__list_dict__string__string<'bldr>> {
        let mut builder = dict__string__list_dict__string__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__list_dict__string__string::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__list_dict__string__string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(dict__string__list_dict__string__string::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__list_dict__string__string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_dict__string__stringArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>,
        >,
    >,
}
impl<'a> Default for dict__string__list_dict__string__stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__list_dict__string__stringArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__list_dict__string__stringBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__list_dict__string__stringBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_dict__string__string::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_dict__string__string::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__list_dict__string__stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__list_dict__string__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__list_dict__string__string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__list_dict__string__string::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__list_dict__string__string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__list_dict__string__string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2ArchiveQuestAvgDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ArchiveQuestAvgData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ArchiveQuestAvgData<'a> {
    type Inner = clz_Torappu_SandboxV2ArchiveQuestAvgData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ArchiveQuestAvgData<'a> {
    pub const VT_AVGID: flatbuffers::VOffsetT = 4;
    pub const VT_AVGNAME: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ArchiveQuestAvgData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ArchiveQuestAvgDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestAvgData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ArchiveQuestAvgDataBuilder::new(_fbb);
        if let Some(x) = args.avgName {
            builder.add_avgName(x);
        }
        if let Some(x) = args.avgId {
            builder.add_avgId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn avgId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestAvgData::VT_AVGID,
                None,
            )
        }
    }
    #[inline]
    pub fn avgName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestAvgData::VT_AVGNAME,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ArchiveQuestAvgData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("avgId", Self::VT_AVGID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("avgName", Self::VT_AVGNAME, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ArchiveQuestAvgDataArgs<'a> {
    pub avgId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub avgName: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ArchiveQuestAvgDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ArchiveQuestAvgDataArgs {
            avgId: None,
            avgName: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2ArchiveQuestAvgDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ArchiveQuestAvgDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_avgId(&mut self, avgId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestAvgData::VT_AVGID,
            avgId,
        );
    }
    #[inline]
    pub fn add_avgName(&mut self, avgName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestAvgData::VT_AVGNAME,
            avgName,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ArchiveQuestAvgDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ArchiveQuestAvgDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestAvgData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ArchiveQuestAvgData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ArchiveQuestAvgData");
        ds.field("avgId", &self.avgId());
        ds.field("avgName", &self.avgName());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2ArchiveQuestCgDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ArchiveQuestCgData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ArchiveQuestCgData<'a> {
    type Inner = clz_Torappu_SandboxV2ArchiveQuestCgData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ArchiveQuestCgData<'a> {
    pub const VT_CGID: flatbuffers::VOffsetT = 4;
    pub const VT_CGTITLE: flatbuffers::VOffsetT = 6;
    pub const VT_CGDESC: flatbuffers::VOffsetT = 8;
    pub const VT_CGPATH: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ArchiveQuestCgData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ArchiveQuestCgDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestCgData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ArchiveQuestCgDataBuilder::new(_fbb);
        if let Some(x) = args.cgPath {
            builder.add_cgPath(x);
        }
        if let Some(x) = args.cgDesc {
            builder.add_cgDesc(x);
        }
        if let Some(x) = args.cgTitle {
            builder.add_cgTitle(x);
        }
        if let Some(x) = args.cgId {
            builder.add_cgId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn cgId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestCgData::VT_CGID,
                None,
            )
        }
    }
    #[inline]
    pub fn cgTitle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestCgData::VT_CGTITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn cgDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestCgData::VT_CGDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn cgPath(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestCgData::VT_CGPATH,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ArchiveQuestCgData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cgId", Self::VT_CGID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cgTitle", Self::VT_CGTITLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cgDesc", Self::VT_CGDESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cgPath", Self::VT_CGPATH, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ArchiveQuestCgDataArgs<'a> {
    pub cgId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cgTitle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cgDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cgPath: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ArchiveQuestCgDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ArchiveQuestCgDataArgs {
            cgId: None,
            cgTitle: None,
            cgDesc: None,
            cgPath: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2ArchiveQuestCgDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ArchiveQuestCgDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_cgId(&mut self, cgId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestCgData::VT_CGID,
            cgId,
        );
    }
    #[inline]
    pub fn add_cgTitle(&mut self, cgTitle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestCgData::VT_CGTITLE,
            cgTitle,
        );
    }
    #[inline]
    pub fn add_cgDesc(&mut self, cgDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestCgData::VT_CGDESC,
            cgDesc,
        );
    }
    #[inline]
    pub fn add_cgPath(&mut self, cgPath: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestCgData::VT_CGPATH,
            cgPath,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ArchiveQuestCgDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ArchiveQuestCgDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestCgData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ArchiveQuestCgData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ArchiveQuestCgData");
        ds.field("cgId", &self.cgId());
        ds.field("cgTitle", &self.cgTitle());
        ds.field("cgDesc", &self.cgDesc());
        ds.field("cgPath", &self.cgPath());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2ArchiveQuestZoneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ArchiveQuestZoneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ArchiveQuestZoneData<'a> {
    type Inner = clz_Torappu_SandboxV2ArchiveQuestZoneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ArchiveQuestZoneData<'a> {
    pub const VT_ZONEID: flatbuffers::VOffsetT = 4;
    pub const VT_ZONENAME: flatbuffers::VOffsetT = 6;
    pub const VT_ZONEBGPICID: flatbuffers::VOffsetT = 8;
    pub const VT_ZONENAMEIDEN: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ArchiveQuestZoneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ArchiveQuestZoneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestZoneData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ArchiveQuestZoneDataBuilder::new(_fbb);
        if let Some(x) = args.zoneNameIdEn {
            builder.add_zoneNameIdEn(x);
        }
        if let Some(x) = args.zoneBgPicId {
            builder.add_zoneBgPicId(x);
        }
        if let Some(x) = args.zoneName {
            builder.add_zoneName(x);
        }
        if let Some(x) = args.zoneId {
            builder.add_zoneId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn zoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestZoneData::VT_ZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn zoneName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestZoneData::VT_ZONENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn zoneBgPicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestZoneData::VT_ZONEBGPICID,
                None,
            )
        }
    }
    #[inline]
    pub fn zoneNameIdEn(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestZoneData::VT_ZONENAMEIDEN,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ArchiveQuestZoneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zoneId", Self::VT_ZONEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "zoneName",
                Self::VT_ZONENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "zoneBgPicId",
                Self::VT_ZONEBGPICID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "zoneNameIdEn",
                Self::VT_ZONENAMEIDEN,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ArchiveQuestZoneDataArgs<'a> {
    pub zoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneBgPicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneNameIdEn: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ArchiveQuestZoneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ArchiveQuestZoneDataArgs {
            zoneId: None,
            zoneName: None,
            zoneBgPicId: None,
            zoneNameIdEn: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2ArchiveQuestZoneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ArchiveQuestZoneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_zoneId(&mut self, zoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestZoneData::VT_ZONEID,
            zoneId,
        );
    }
    #[inline]
    pub fn add_zoneName(&mut self, zoneName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestZoneData::VT_ZONENAME,
            zoneName,
        );
    }
    #[inline]
    pub fn add_zoneBgPicId(&mut self, zoneBgPicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestZoneData::VT_ZONEBGPICID,
            zoneBgPicId,
        );
    }
    #[inline]
    pub fn add_zoneNameIdEn(&mut self, zoneNameIdEn: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestZoneData::VT_ZONENAMEIDEN,
            zoneNameIdEn,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ArchiveQuestZoneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ArchiveQuestZoneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestZoneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ArchiveQuestZoneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ArchiveQuestZoneData");
        ds.field("zoneId", &self.zoneId());
        ds.field("zoneName", &self.zoneName());
        ds.field("zoneBgPicId", &self.zoneBgPicId());
        ds.field("zoneNameIdEn", &self.zoneNameIdEn());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2ArchiveQuestDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ArchiveQuestData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ArchiveQuestData<'a> {
    type Inner = clz_Torappu_SandboxV2ArchiveQuestData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ArchiveQuestData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_QUESTTYPE: flatbuffers::VOffsetT = 8;
    pub const VT_NAME: flatbuffers::VOffsetT = 10;
    pub const VT_DESC: flatbuffers::VOffsetT = 12;
    pub const VT_AVGDATALIST: flatbuffers::VOffsetT = 14;
    pub const VT_CGDATALIST: flatbuffers::VOffsetT = 16;
    pub const VT_NPCPICIDLIST: flatbuffers::VOffsetT = 18;
    pub const VT_ZONEDATA: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ArchiveQuestData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ArchiveQuestDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ArchiveQuestDataBuilder::new(_fbb);
        if let Some(x) = args.zoneData {
            builder.add_zoneData(x);
        }
        if let Some(x) = args.npcPicIdList {
            builder.add_npcPicIdList(x);
        }
        if let Some(x) = args.cgDataList {
            builder.add_cgDataList(x);
        }
        if let Some(x) = args.avgDataList {
            builder.add_avgDataList(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_questType(args.questType);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ArchiveQuestData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn questType(&self) -> enum__Torappu_SandboxV2ArchiveQuestType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2ArchiveQuestType>(
                    clz_Torappu_SandboxV2ArchiveQuestData::VT_QUESTTYPE,
                    Some(enum__Torappu_SandboxV2ArchiveQuestType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn avgDataList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestAvgData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestAvgData>,
                >,
            >>(clz_Torappu_SandboxV2ArchiveQuestData::VT_AVGDATALIST, None)
        }
    }
    #[inline]
    pub fn cgDataList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestCgData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestCgData>,
                >,
            >>(clz_Torappu_SandboxV2ArchiveQuestData::VT_CGDATALIST, None)
        }
    }
    #[inline]
    pub fn npcPicIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxV2ArchiveQuestData::VT_NPCPICIDLIST, None)
        }
    }
    #[inline]
    pub fn zoneData(&self) -> Option<clz_Torappu_SandboxV2ArchiveQuestZoneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestZoneData>>(
                    clz_Torappu_SandboxV2ArchiveQuestData::VT_ZONEDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ArchiveQuestData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<enum__Torappu_SandboxV2ArchiveQuestType>(
                "questType",
                Self::VT_QUESTTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestAvgData>,
                >,
            >>("avgDataList", Self::VT_AVGDATALIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestCgData>,
                >,
            >>("cgDataList", Self::VT_CGDATALIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("npcPicIdList", Self::VT_NPCPICIDLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestZoneData>>(
                "zoneData",
                Self::VT_ZONEDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ArchiveQuestDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub questType: enum__Torappu_SandboxV2ArchiveQuestType,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub avgDataList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestAvgData<'a>>,
            >,
        >,
    >,
    pub cgDataList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestCgData<'a>>,
            >,
        >,
    >,
    pub npcPicIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub zoneData: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestZoneData<'a>>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ArchiveQuestDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ArchiveQuestDataArgs {
            id: None,
            sortId: 0,
            questType: enum__Torappu_SandboxV2ArchiveQuestType::NONE,
            name: None,
            desc: None,
            avgDataList: None,
            cgDataList: None,
            npcPicIdList: None,
            zoneData: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2ArchiveQuestDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ArchiveQuestDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2ArchiveQuestData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_questType(&mut self, questType: enum__Torappu_SandboxV2ArchiveQuestType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2ArchiveQuestType>(
                clz_Torappu_SandboxV2ArchiveQuestData::VT_QUESTTYPE,
                questType,
                enum__Torappu_SandboxV2ArchiveQuestType::NONE,
            );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_avgDataList(
        &mut self,
        avgDataList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestAvgData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestData::VT_AVGDATALIST,
            avgDataList,
        );
    }
    #[inline]
    pub fn add_cgDataList(
        &mut self,
        cgDataList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestCgData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestData::VT_CGDATALIST,
            cgDataList,
        );
    }
    #[inline]
    pub fn add_npcPicIdList(
        &mut self,
        npcPicIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestData::VT_NPCPICIDLIST,
            npcPicIdList,
        );
    }
    #[inline]
    pub fn add_zoneData(
        &mut self,
        zoneData: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestZoneData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestZoneData>>(
                clz_Torappu_SandboxV2ArchiveQuestData::VT_ZONEDATA,
                zoneData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ArchiveQuestDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ArchiveQuestDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ArchiveQuestData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ArchiveQuestData");
        ds.field("id", &self.id());
        ds.field("sortId", &self.sortId());
        ds.field("questType", &self.questType());
        ds.field("name", &self.name());
        ds.field("desc", &self.desc());
        ds.field("avgDataList", &self.avgDataList());
        ds.field("cgDataList", &self.cgDataList());
        ds.field("npcPicIdList", &self.npcPicIdList());
        ds.field("zoneData", &self.zoneData());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ArchiveQuestDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ArchiveQuestData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ArchiveQuestDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2ArchiveQuestDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ArchiveQuestData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2ArchiveQuestData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ArchiveQuestData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestData>>(
                    dict__string__clz_Torappu_SandboxV2ArchiveQuestData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ArchiveQuestDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ArchiveQuestDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ArchiveQuestDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ArchiveQuestDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ArchiveQuestDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ArchiveQuestData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestData>>(
                dict__string__clz_Torappu_SandboxV2ArchiveQuestData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ArchiveQuestDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ArchiveQuestDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ArchiveQuestData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2ArchiveQuestData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2ArchiveAchievementDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ArchiveAchievementData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ArchiveAchievementData<'a> {
    type Inner = clz_Torappu_SandboxV2ArchiveAchievementData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ArchiveAchievementData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_ACHIEVEMENTTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_RARITYSORTID: flatbuffers::VOffsetT = 8;
    pub const VT_SORTID: flatbuffers::VOffsetT = 10;
    pub const VT_NAME: flatbuffers::VOffsetT = 12;
    pub const VT_DESC: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ArchiveAchievementData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ArchiveAchievementDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveAchievementData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ArchiveAchievementDataBuilder::new(_fbb);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_sortId(args.sortId);
        builder.add_raritySortId(args.raritySortId);
        if let Some(x) = args.achievementType {
            builder.add_achievementType(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveAchievementData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn achievementType(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2ArchiveAchievementData::VT_ACHIEVEMENTTYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn raritySortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2ArchiveAchievementData::VT_RARITYSORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2ArchiveAchievementData::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveAchievementData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveAchievementData::VT_DESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ArchiveAchievementData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("achievementType", Self::VT_ACHIEVEMENTTYPE, false)?
            .visit_field::<i32>("raritySortId", Self::VT_RARITYSORTID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ArchiveAchievementDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub achievementType: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub raritySortId: i32,
    pub sortId: i32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ArchiveAchievementDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ArchiveAchievementDataArgs {
            id: None,
            achievementType: None,
            raritySortId: 0,
            sortId: 0,
            name: None,
            desc: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2ArchiveAchievementDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ArchiveAchievementDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveAchievementData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_achievementType(
        &mut self,
        achievementType: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveAchievementData::VT_ACHIEVEMENTTYPE,
            achievementType,
        );
    }
    #[inline]
    pub fn add_raritySortId(&mut self, raritySortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ArchiveAchievementData::VT_RARITYSORTID,
            raritySortId,
            0,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ArchiveAchievementData::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveAchievementData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveAchievementData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ArchiveAchievementDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ArchiveAchievementDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveAchievementData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ArchiveAchievementData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ArchiveAchievementData");
        ds.field("id", &self.id());
        ds.field("achievementType", &self.achievementType());
        ds.field("raritySortId", &self.raritySortId());
        ds.field("sortId", &self.sortId());
        ds.field("name", &self.name());
        ds.field("desc", &self.desc());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ArchiveAchievementData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ArchiveAchievementData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2ArchiveAchievementData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ArchiveAchievementData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveAchievementData>>(
                    dict__string__clz_Torappu_SandboxV2ArchiveAchievementData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveAchievementData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveAchievementData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ArchiveAchievementData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveAchievementData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveAchievementData>>(dict__string__clz_Torappu_SandboxV2ArchiveAchievementData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ArchiveAchievementData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2ArchiveAchievementData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2ArchiveAchievementTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a> {
    type Inner = clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a> {
    pub const VT_ACHIEVEMENTTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_SORTID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ArchiveAchievementTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ArchiveAchievementTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveAchievementTypeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ArchiveAchievementTypeDataBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.achievementType {
            builder.add_achievementType(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn achievementType(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveAchievementTypeData::VT_ACHIEVEMENTTYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveAchievementTypeData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2ArchiveAchievementTypeData::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ArchiveAchievementTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "achievementType",
                Self::VT_ACHIEVEMENTTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ArchiveAchievementTypeDataArgs<'a> {
    pub achievementType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2ArchiveAchievementTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ArchiveAchievementTypeDataArgs {
            achievementType: None,
            name: None,
            sortId: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2ArchiveAchievementTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ArchiveAchievementTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_achievementType(&mut self, achievementType: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveAchievementTypeData::VT_ACHIEVEMENTTYPE,
            achievementType,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveAchievementTypeData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ArchiveAchievementTypeData::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ArchiveAchievementTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ArchiveAchievementTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ArchiveAchievementTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ArchiveAchievementTypeData");
        ds.field("achievementType", &self.achievementType());
        ds.field("name", &self.name());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a>
{
    type Inner = dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveAchievementTypeData>>(dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveAchievementTypeData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveAchievementTypeData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveAchievementTypeData>>(dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2ArchiveQuestTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ArchiveQuestTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ArchiveQuestTypeData<'a> {
    type Inner = clz_Torappu_SandboxV2ArchiveQuestTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ArchiveQuestTypeData<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_ICONID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ArchiveQuestTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ArchiveQuestTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestTypeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ArchiveQuestTypeDataBuilder::new(_fbb);
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    #[inline]
    pub fn type_(&self) -> enum__Torappu_SandboxV2ArchiveQuestType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2ArchiveQuestType>(
                    clz_Torappu_SandboxV2ArchiveQuestTypeData::VT_TYPE_,
                    Some(enum__Torappu_SandboxV2ArchiveQuestType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestTypeData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestTypeData::VT_ICONID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ArchiveQuestTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxV2ArchiveQuestType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ArchiveQuestTypeDataArgs<'a> {
    pub type_: enum__Torappu_SandboxV2ArchiveQuestType,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ArchiveQuestTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ArchiveQuestTypeDataArgs {
            type_: enum__Torappu_SandboxV2ArchiveQuestType::NONE,
            name: None,
            iconId: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2ArchiveQuestTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ArchiveQuestTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_SandboxV2ArchiveQuestType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2ArchiveQuestType>(
                clz_Torappu_SandboxV2ArchiveQuestTypeData::VT_TYPE_,
                type_,
                enum__Torappu_SandboxV2ArchiveQuestType::NONE,
            );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestTypeData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestTypeData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ArchiveQuestTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ArchiveQuestTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ArchiveQuestTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ArchiveQuestTypeData");
        ds.field("type_", &self.type_());
        ds.field("name", &self.name());
        ds.field("iconId", &self.iconId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'bldr>>
    {
        let mut builder = dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ArchiveQuestTypeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestTypeData>>(
                    dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestTypeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestTypeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestTypeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestTypeData>>(
                dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2ArchiveMusicUnlockDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a> {
    type Inner = clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a> {
    pub const VT_MUSICID: flatbuffers::VOffsetT = 4;
    pub const VT_UNLOCKCONDDESC: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ArchiveMusicUnlockData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ArchiveMusicUnlockDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveMusicUnlockData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ArchiveMusicUnlockDataBuilder::new(_fbb);
        if let Some(x) = args.unlockCondDesc {
            builder.add_unlockCondDesc(x);
        }
        if let Some(x) = args.musicId {
            builder.add_musicId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn musicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveMusicUnlockData::VT_MUSICID,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockCondDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveMusicUnlockData::VT_UNLOCKCONDDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ArchiveMusicUnlockData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("musicId", Self::VT_MUSICID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockCondDesc",
                Self::VT_UNLOCKCONDDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ArchiveMusicUnlockDataArgs<'a> {
    pub musicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockCondDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ArchiveMusicUnlockDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ArchiveMusicUnlockDataArgs {
            musicId: None,
            unlockCondDesc: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2ArchiveMusicUnlockDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ArchiveMusicUnlockDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_musicId(&mut self, musicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveMusicUnlockData::VT_MUSICID,
            musicId,
        );
    }
    #[inline]
    pub fn add_unlockCondDesc(&mut self, unlockCondDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveMusicUnlockData::VT_UNLOCKCONDDESC,
            unlockCondDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ArchiveMusicUnlockDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ArchiveMusicUnlockDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ArchiveMusicUnlockData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ArchiveMusicUnlockData");
        ds.field("musicId", &self.musicId());
        ds.field("unlockCondDesc", &self.unlockCondDesc());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveMusicUnlockData>>(
                    dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveMusicUnlockData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveMusicUnlockData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveMusicUnlockData>>(dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2BaseUpdateConditionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2BaseUpdateCondition<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2BaseUpdateCondition<'a> {
    type Inner = clz_Torappu_SandboxV2BaseUpdateCondition<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2BaseUpdateCondition<'a> {
    pub const VT_DESC: flatbuffers::VOffsetT = 4;
    pub const VT_LIMITCOND: flatbuffers::VOffsetT = 6;
    pub const VT_PARAM: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2BaseUpdateCondition { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2BaseUpdateConditionArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseUpdateCondition<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2BaseUpdateConditionBuilder::new(_fbb);
        if let Some(x) = args.param {
            builder.add_param(x);
        }
        if let Some(x) = args.limitCond {
            builder.add_limitCond(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BaseUpdateCondition::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn limitCond(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BaseUpdateCondition::VT_LIMITCOND,
                None,
            )
        }
    }
    #[inline]
    pub fn param(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxV2BaseUpdateCondition::VT_PARAM, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2BaseUpdateCondition<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "limitCond",
                Self::VT_LIMITCOND,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("param", Self::VT_PARAM, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2BaseUpdateConditionArgs<'a> {
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub limitCond: Option<flatbuffers::WIPOffset<&'a str>>,
    pub param: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2BaseUpdateConditionArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2BaseUpdateConditionArgs {
            desc: None,
            limitCond: None,
            param: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2BaseUpdateConditionBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2BaseUpdateConditionBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateCondition::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_limitCond(&mut self, limitCond: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateCondition::VT_LIMITCOND,
            limitCond,
        );
    }
    #[inline]
    pub fn add_param(
        &mut self,
        param: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateCondition::VT_PARAM,
            param,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2BaseUpdateConditionBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2BaseUpdateConditionBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseUpdateCondition<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2BaseUpdateCondition<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2BaseUpdateCondition");
        ds.field("desc", &self.desc());
        ds.field("limitCond", &self.limitCond());
        ds.field("param", &self.param());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'a> {
    type Inner = clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'a> {
    pub const VT_FUNCID: flatbuffers::VOffsetT = 4;
    pub const VT_UNLOCKTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_TYPETITLE: flatbuffers::VOffsetT = 8;
    pub const VT_DESC: flatbuffers::VOffsetT = 10;
    pub const VT_ICON: flatbuffers::VOffsetT = 12;
    pub const VT_DARKMODE: flatbuffers::VOffsetT = 14;
    pub const VT_SORTID: flatbuffers::VOffsetT = 16;
    pub const VT_DISPLAYTYPE: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'bldr>>
    {
        let mut builder =
            clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataBuilder::new(_fbb);
        builder.add_displayType(args.displayType);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.icon {
            builder.add_icon(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.typeTitle {
            builder.add_typeTitle(x);
        }
        builder.add_unlockType(args.unlockType);
        if let Some(x) = args.funcId {
            builder.add_funcId(x);
        }
        builder.add_darkMode(args.darkMode);
        builder.finish()
    }

    #[inline]
    pub fn funcId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_FUNCID,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockType(&self) -> enum__Torappu_SandboxV2BaseUnlockFuncType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2BaseUnlockFuncType>(
                    clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_UNLOCKTYPE,
                    Some(enum__Torappu_SandboxV2BaseUnlockFuncType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn typeTitle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_TYPETITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn icon(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_ICON,
                None,
            )
        }
    }
    #[inline]
    pub fn darkMode(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_DARKMODE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn displayType(&self) -> enum__Torappu_SandboxV2BaseUnlockFuncDisplayType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2BaseUnlockFuncDisplayType>(
                    clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_DISPLAYTYPE,
                    Some(enum__Torappu_SandboxV2BaseUnlockFuncDisplayType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("funcId", Self::VT_FUNCID, false)?
            .visit_field::<enum__Torappu_SandboxV2BaseUnlockFuncType>(
                "unlockType",
                Self::VT_UNLOCKTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "typeTitle",
                Self::VT_TYPETITLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("icon", Self::VT_ICON, false)?
            .visit_field::<bool>("darkMode", Self::VT_DARKMODE, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<enum__Torappu_SandboxV2BaseUnlockFuncDisplayType>(
                "displayType",
                Self::VT_DISPLAYTYPE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataArgs<'a> {
    pub funcId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockType: enum__Torappu_SandboxV2BaseUnlockFuncType,
    pub typeTitle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub icon: Option<flatbuffers::WIPOffset<&'a str>>,
    pub darkMode: bool,
    pub sortId: i32,
    pub displayType: enum__Torappu_SandboxV2BaseUnlockFuncDisplayType,
}
impl<'a> Default for clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataArgs {
            funcId: None,
            unlockType: enum__Torappu_SandboxV2BaseUnlockFuncType::NONE,
            typeTitle: None,
            desc: None,
            icon: None,
            darkMode: false,
            sortId: 0,
            displayType: enum__Torappu_SandboxV2BaseUnlockFuncDisplayType::NONE,
        }
    }
}

pub struct clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_funcId(&mut self, funcId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_FUNCID,
            funcId,
        );
    }
    #[inline]
    pub fn add_unlockType(&mut self, unlockType: enum__Torappu_SandboxV2BaseUnlockFuncType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2BaseUnlockFuncType>(
                clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_UNLOCKTYPE,
                unlockType,
                enum__Torappu_SandboxV2BaseUnlockFuncType::NONE,
            );
    }
    #[inline]
    pub fn add_typeTitle(&mut self, typeTitle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_TYPETITLE,
            typeTitle,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_icon(&mut self, icon: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_ICON,
            icon,
        );
    }
    #[inline]
    pub fn add_darkMode(&mut self, darkMode: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_DARKMODE,
            darkMode,
            false,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn add_displayType(
        &mut self,
        displayType: enum__Torappu_SandboxV2BaseUnlockFuncDisplayType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2BaseUnlockFuncDisplayType>(
                clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_DISPLAYTYPE,
                displayType,
                enum__Torappu_SandboxV2BaseUnlockFuncDisplayType::NONE,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData");
        ds.field("funcId", &self.funcId());
        ds.field("unlockType", &self.unlockType());
        ds.field("typeTitle", &self.typeTitle());
        ds.field("desc", &self.desc());
        ds.field("icon", &self.icon());
        ds.field("darkMode", &self.darkMode());
        ds.field("sortId", &self.sortId());
        ds.field("displayType", &self.displayType());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2BaseFunctionPreviewDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2BaseFunctionPreviewData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2BaseFunctionPreviewData<'a> {
    type Inner = clz_Torappu_SandboxV2BaseFunctionPreviewData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2BaseFunctionPreviewData<'a> {
    pub const VT_PREVIEWID: flatbuffers::VOffsetT = 4;
    pub const VT_PREVIEWVALUE: flatbuffers::VOffsetT = 6;
    pub const VT_DETAILDATA: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2BaseFunctionPreviewData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2BaseFunctionPreviewDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseFunctionPreviewData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2BaseFunctionPreviewDataBuilder::new(_fbb);
        if let Some(x) = args.detailData {
            builder.add_detailData(x);
        }
        builder.add_previewValue(args.previewValue);
        if let Some(x) = args.previewId {
            builder.add_previewId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn previewId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BaseFunctionPreviewData::VT_PREVIEWID,
                None,
            )
        }
    }
    #[inline]
    pub fn previewValue(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BaseFunctionPreviewData::VT_PREVIEWVALUE,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn detailData(
        &self,
    ) -> Option<clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData,
            >>(
                clz_Torappu_SandboxV2BaseFunctionPreviewData::VT_DETAILDATA,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2BaseFunctionPreviewData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("previewId", Self::VT_PREVIEWID, false)?
     .visit_field::<i32>("previewValue", Self::VT_PREVIEWVALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData>>("detailData", Self::VT_DETAILDATA, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2BaseFunctionPreviewDataArgs<'a> {
    pub previewId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub previewValue: i32,
    pub detailData: Option<
        flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'a>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2BaseFunctionPreviewDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2BaseFunctionPreviewDataArgs {
            previewId: None,
            previewValue: 0,
            detailData: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2BaseFunctionPreviewDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2BaseFunctionPreviewDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_previewId(&mut self, previewId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseFunctionPreviewData::VT_PREVIEWID,
            previewId,
        );
    }
    #[inline]
    pub fn add_previewValue(&mut self, previewValue: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BaseFunctionPreviewData::VT_PREVIEWVALUE,
            previewValue,
            0,
        );
    }
    #[inline]
    pub fn add_detailData(
        &mut self,
        detailData: flatbuffers::WIPOffset<
            clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData>>(clz_Torappu_SandboxV2BaseFunctionPreviewData::VT_DETAILDATA, detailData);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2BaseFunctionPreviewDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2BaseFunctionPreviewDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseFunctionPreviewData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2BaseFunctionPreviewData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2BaseFunctionPreviewData");
        ds.field("previewId", &self.previewId());
        ds.field("previewValue", &self.previewValue());
        ds.field("detailData", &self.detailData());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2BaseUpdateDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2BaseUpdateData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2BaseUpdateData<'a> {
    type Inner = clz_Torappu_SandboxV2BaseUpdateData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2BaseUpdateData<'a> {
    pub const VT_BASELEVELID: flatbuffers::VOffsetT = 4;
    pub const VT_BASELEVEL: flatbuffers::VOffsetT = 6;
    pub const VT_CONDITIONS: flatbuffers::VOffsetT = 8;
    pub const VT_ITEMS: flatbuffers::VOffsetT = 10;
    pub const VT_PREVIEWDATAS: flatbuffers::VOffsetT = 12;
    pub const VT_SCOREFACTOR: flatbuffers::VOffsetT = 14;
    pub const VT_PORTABLEREPAIRCOST: flatbuffers::VOffsetT = 16;
    pub const VT_ENTRYCOUNT: flatbuffers::VOffsetT = 18;
    pub const VT_REPAIRCOST: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2BaseUpdateData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2BaseUpdateDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseUpdateData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2BaseUpdateDataBuilder::new(_fbb);
        builder.add_repairCost(args.repairCost);
        builder.add_entryCount(args.entryCount);
        builder.add_portableRepairCost(args.portableRepairCost);
        if let Some(x) = args.scoreFactor {
            builder.add_scoreFactor(x);
        }
        if let Some(x) = args.previewDatas {
            builder.add_previewDatas(x);
        }
        if let Some(x) = args.items {
            builder.add_items(x);
        }
        if let Some(x) = args.conditions {
            builder.add_conditions(x);
        }
        builder.add_baseLevel(args.baseLevel);
        if let Some(x) = args.baseLevelId {
            builder.add_baseLevelId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn baseLevelId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BaseUpdateData::VT_BASELEVELID,
                None,
            )
        }
    }
    #[inline]
    pub fn baseLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2BaseUpdateData::VT_BASELEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn conditions(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseUpdateCondition<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseUpdateCondition>,
                >,
            >>(clz_Torappu_SandboxV2BaseUpdateData::VT_CONDITIONS, None)
        }
    }
    #[inline]
    pub fn items(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>(clz_Torappu_SandboxV2BaseUpdateData::VT_ITEMS, None)
        }
    }
    #[inline]
    pub fn previewDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseFunctionPreviewData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseFunctionPreviewData>,
                >,
            >>(clz_Torappu_SandboxV2BaseUpdateData::VT_PREVIEWDATAS, None)
        }
    }
    #[inline]
    pub fn scoreFactor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BaseUpdateData::VT_SCOREFACTOR,
                None,
            )
        }
    }
    #[inline]
    pub fn portableRepairCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BaseUpdateData::VT_PORTABLEREPAIRCOST,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn entryCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2BaseUpdateData::VT_ENTRYCOUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn repairCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2BaseUpdateData::VT_REPAIRCOST, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2BaseUpdateData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "baseLevelId",
                Self::VT_BASELEVELID,
                false,
            )?
            .visit_field::<i32>("baseLevel", Self::VT_BASELEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseUpdateCondition>,
                >,
            >>("conditions", Self::VT_CONDITIONS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>("items", Self::VT_ITEMS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseFunctionPreviewData>,
                >,
            >>("previewDatas", Self::VT_PREVIEWDATAS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "scoreFactor",
                Self::VT_SCOREFACTOR,
                false,
            )?
            .visit_field::<i32>("portableRepairCost", Self::VT_PORTABLEREPAIRCOST, false)?
            .visit_field::<i32>("entryCount", Self::VT_ENTRYCOUNT, false)?
            .visit_field::<i32>("repairCost", Self::VT_REPAIRCOST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2BaseUpdateDataArgs<'a> {
    pub baseLevelId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub baseLevel: i32,
    pub conditions: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseUpdateCondition<'a>>,
            >,
        >,
    >,
    pub items: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>,
        >,
    >,
    pub previewDatas: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseFunctionPreviewData<'a>>,
            >,
        >,
    >,
    pub scoreFactor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub portableRepairCost: i32,
    pub entryCount: i32,
    pub repairCost: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2BaseUpdateDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2BaseUpdateDataArgs {
            baseLevelId: None,
            baseLevel: 0,
            conditions: None,
            items: None,
            previewDatas: None,
            scoreFactor: None,
            portableRepairCost: 0,
            entryCount: 0,
            repairCost: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2BaseUpdateDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2BaseUpdateDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_baseLevelId(&mut self, baseLevelId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateData::VT_BASELEVELID,
            baseLevelId,
        );
    }
    #[inline]
    pub fn add_baseLevel(&mut self, baseLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BaseUpdateData::VT_BASELEVEL,
            baseLevel,
            0,
        );
    }
    #[inline]
    pub fn add_conditions(
        &mut self,
        conditions: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseUpdateCondition<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateData::VT_CONDITIONS,
            conditions,
        );
    }
    #[inline]
    pub fn add_items(
        &mut self,
        items: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__int<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateData::VT_ITEMS,
            items,
        );
    }
    #[inline]
    pub fn add_previewDatas(
        &mut self,
        previewDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseFunctionPreviewData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateData::VT_PREVIEWDATAS,
            previewDatas,
        );
    }
    #[inline]
    pub fn add_scoreFactor(&mut self, scoreFactor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateData::VT_SCOREFACTOR,
            scoreFactor,
        );
    }
    #[inline]
    pub fn add_portableRepairCost(&mut self, portableRepairCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BaseUpdateData::VT_PORTABLEREPAIRCOST,
            portableRepairCost,
            0,
        );
    }
    #[inline]
    pub fn add_entryCount(&mut self, entryCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BaseUpdateData::VT_ENTRYCOUNT,
            entryCount,
            0,
        );
    }
    #[inline]
    pub fn add_repairCost(&mut self, repairCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BaseUpdateData::VT_REPAIRCOST,
            repairCost,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2BaseUpdateDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2BaseUpdateDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseUpdateData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2BaseUpdateData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2BaseUpdateData");
        ds.field("baseLevelId", &self.baseLevelId());
        ds.field("baseLevel", &self.baseLevel());
        ds.field("conditions", &self.conditions());
        ds.field("items", &self.items());
        ds.field("previewDatas", &self.previewDatas());
        ds.field("scoreFactor", &self.scoreFactor());
        ds.field("portableRepairCost", &self.portableRepairCost());
        ds.field("entryCount", &self.entryCount());
        ds.field("repairCost", &self.repairCost());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2DevelopmentLineSegmentDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2DevelopmentLineSegmentData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2DevelopmentLineSegmentData<'a> {
    type Inner = clz_Torappu_SandboxV2DevelopmentLineSegmentData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2DevelopmentLineSegmentData<'a> {
    pub const VT_FROMNODEID: flatbuffers::VOffsetT = 4;
    pub const VT_PASSINGNODEIDS: flatbuffers::VOffsetT = 6;
    pub const VT_FROMAXISPOSX: flatbuffers::VOffsetT = 8;
    pub const VT_FROMAXISPOSY: flatbuffers::VOffsetT = 10;
    pub const VT_TOAXISPOSX: flatbuffers::VOffsetT = 12;
    pub const VT_TOAXISPOSY: flatbuffers::VOffsetT = 14;
    pub const VT_LINESTYLE: flatbuffers::VOffsetT = 16;
    pub const VT_UNLOCKBASEMENTLEVEL: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2DevelopmentLineSegmentData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2DevelopmentLineSegmentDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentLineSegmentData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2DevelopmentLineSegmentDataBuilder::new(_fbb);
        builder.add_unlockBasementLevel(args.unlockBasementLevel);
        builder.add_lineStyle(args.lineStyle);
        builder.add_toAxisPosY(args.toAxisPosY);
        builder.add_toAxisPosX(args.toAxisPosX);
        builder.add_fromAxisPosY(args.fromAxisPosY);
        builder.add_fromAxisPosX(args.fromAxisPosX);
        if let Some(x) = args.passingNodeIds {
            builder.add_passingNodeIds(x);
        }
        if let Some(x) = args.fromNodeId {
            builder.add_fromNodeId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn fromNodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_FROMNODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn passingNodeIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_PASSINGNODEIDS,
                None,
            )
        }
    }
    #[inline]
    pub fn fromAxisPosX(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_FROMAXISPOSX,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn fromAxisPosY(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_FROMAXISPOSY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn toAxisPosX(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_TOAXISPOSX,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn toAxisPosY(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_TOAXISPOSY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn lineStyle(&self) -> enum__Torappu_SandboxV2DevelopmentLineStyle {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2DevelopmentLineStyle>(
                    clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_LINESTYLE,
                    Some(enum__Torappu_SandboxV2DevelopmentLineStyle::EMPTY),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockBasementLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_UNLOCKBASEMENTLEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2DevelopmentLineSegmentData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "fromNodeId",
                Self::VT_FROMNODEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("passingNodeIds", Self::VT_PASSINGNODEIDS, false)?
            .visit_field::<i32>("fromAxisPosX", Self::VT_FROMAXISPOSX, false)?
            .visit_field::<i32>("fromAxisPosY", Self::VT_FROMAXISPOSY, false)?
            .visit_field::<i32>("toAxisPosX", Self::VT_TOAXISPOSX, false)?
            .visit_field::<i32>("toAxisPosY", Self::VT_TOAXISPOSY, false)?
            .visit_field::<enum__Torappu_SandboxV2DevelopmentLineStyle>(
                "lineStyle",
                Self::VT_LINESTYLE,
                false,
            )?
            .visit_field::<i32>("unlockBasementLevel", Self::VT_UNLOCKBASEMENTLEVEL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2DevelopmentLineSegmentDataArgs<'a> {
    pub fromNodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub passingNodeIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub fromAxisPosX: i32,
    pub fromAxisPosY: i32,
    pub toAxisPosX: i32,
    pub toAxisPosY: i32,
    pub lineStyle: enum__Torappu_SandboxV2DevelopmentLineStyle,
    pub unlockBasementLevel: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2DevelopmentLineSegmentDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2DevelopmentLineSegmentDataArgs {
            fromNodeId: None,
            passingNodeIds: None,
            fromAxisPosX: 0,
            fromAxisPosY: 0,
            toAxisPosX: 0,
            toAxisPosY: 0,
            lineStyle: enum__Torappu_SandboxV2DevelopmentLineStyle::EMPTY,
            unlockBasementLevel: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2DevelopmentLineSegmentDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2DevelopmentLineSegmentDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_fromNodeId(&mut self, fromNodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_FROMNODEID,
            fromNodeId,
        );
    }
    #[inline]
    pub fn add_passingNodeIds(
        &mut self,
        passingNodeIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_PASSINGNODEIDS,
            passingNodeIds,
        );
    }
    #[inline]
    pub fn add_fromAxisPosX(&mut self, fromAxisPosX: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_FROMAXISPOSX,
            fromAxisPosX,
            0,
        );
    }
    #[inline]
    pub fn add_fromAxisPosY(&mut self, fromAxisPosY: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_FROMAXISPOSY,
            fromAxisPosY,
            0,
        );
    }
    #[inline]
    pub fn add_toAxisPosX(&mut self, toAxisPosX: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_TOAXISPOSX,
            toAxisPosX,
            0,
        );
    }
    #[inline]
    pub fn add_toAxisPosY(&mut self, toAxisPosY: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_TOAXISPOSY,
            toAxisPosY,
            0,
        );
    }
    #[inline]
    pub fn add_lineStyle(&mut self, lineStyle: enum__Torappu_SandboxV2DevelopmentLineStyle) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2DevelopmentLineStyle>(
                clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_LINESTYLE,
                lineStyle,
                enum__Torappu_SandboxV2DevelopmentLineStyle::EMPTY,
            );
    }
    #[inline]
    pub fn add_unlockBasementLevel(&mut self, unlockBasementLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_UNLOCKBASEMENTLEVEL,
            unlockBasementLevel,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2DevelopmentLineSegmentDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2DevelopmentLineSegmentDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentLineSegmentData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2DevelopmentLineSegmentData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2DevelopmentLineSegmentData");
        ds.field("fromNodeId", &self.fromNodeId());
        ds.field("passingNodeIds", &self.passingNodeIds());
        ds.field("fromAxisPosX", &self.fromAxisPosX());
        ds.field("fromAxisPosY", &self.fromAxisPosY());
        ds.field("toAxisPosX", &self.toAxisPosX());
        ds.field("toAxisPosY", &self.toAxisPosY());
        ds.field("lineStyle", &self.lineStyle());
        ds.field("unlockBasementLevel", &self.unlockBasementLevel());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2BuildingNodeScoreDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2BuildingNodeScoreData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2BuildingNodeScoreData<'a> {
    type Inner = clz_Torappu_SandboxV2BuildingNodeScoreData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2BuildingNodeScoreData<'a> {
    pub const VT_NODEID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_LIMITSCORE: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2BuildingNodeScoreData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2BuildingNodeScoreDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BuildingNodeScoreData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2BuildingNodeScoreDataBuilder::new(_fbb);
        builder.add_limitScore(args.limitScore);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.nodeId {
            builder.add_nodeId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn nodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BuildingNodeScoreData::VT_NODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BuildingNodeScoreData::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn limitScore(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BuildingNodeScoreData::VT_LIMITSCORE,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2BuildingNodeScoreData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nodeId", Self::VT_NODEID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<i32>("limitScore", Self::VT_LIMITSCORE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2BuildingNodeScoreDataArgs<'a> {
    pub nodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub limitScore: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2BuildingNodeScoreDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2BuildingNodeScoreDataArgs {
            nodeId: None,
            sortId: 0,
            limitScore: 0,
        }
    }
}

pub struct clz_Torappu_SandboxV2BuildingNodeScoreDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2BuildingNodeScoreDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeId(&mut self, nodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BuildingNodeScoreData::VT_NODEID,
            nodeId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BuildingNodeScoreData::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn add_limitScore(&mut self, limitScore: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BuildingNodeScoreData::VT_LIMITSCORE,
            limitScore,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2BuildingNodeScoreDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2BuildingNodeScoreDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BuildingNodeScoreData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2BuildingNodeScoreData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2BuildingNodeScoreData");
        ds.field("nodeId", &self.nodeId());
        ds.field("sortId", &self.sortId());
        ds.field("limitScore", &self.limitScore());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2BuildingNodeScoreData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BuildingNodeScoreData>>(
                    dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BuildingNodeScoreData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2BuildingNodeScoreData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2BuildingNodeScoreData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2BuildingNodeScoreData>>(
                dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2SeasonDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2SeasonData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2SeasonData<'a> {
    type Inner = clz_Torappu_SandboxV2SeasonData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2SeasonData<'a> {
    pub const VT_SEASONTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_FUNCTIONDESC: flatbuffers::VOffsetT = 8;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
    pub const VT_COLOR: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2SeasonData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2SeasonDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2SeasonData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2SeasonDataBuilder::new(_fbb);
        if let Some(x) = args.color {
            builder.add_color(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.functionDesc {
            builder.add_functionDesc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_seasonType(args.seasonType);
        builder.finish()
    }

    #[inline]
    pub fn seasonType(&self) -> enum__Torappu_SandboxV2SeasonType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2SeasonType>(
                    clz_Torappu_SandboxV2SeasonData::VT_SEASONTYPE,
                    Some(enum__Torappu_SandboxV2SeasonType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2SeasonData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn functionDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2SeasonData::VT_FUNCTIONDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2SeasonData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn color(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2SeasonData::VT_COLOR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2SeasonData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxV2SeasonType>(
                "seasonType",
                Self::VT_SEASONTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "functionDesc",
                Self::VT_FUNCTIONDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("color", Self::VT_COLOR, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2SeasonDataArgs<'a> {
    pub seasonType: enum__Torappu_SandboxV2SeasonType,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub functionDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub color: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2SeasonDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2SeasonDataArgs {
            seasonType: enum__Torappu_SandboxV2SeasonType::NONE,
            name: None,
            functionDesc: None,
            description: None,
            color: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2SeasonDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2SeasonDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_seasonType(&mut self, seasonType: enum__Torappu_SandboxV2SeasonType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2SeasonType>(
            clz_Torappu_SandboxV2SeasonData::VT_SEASONTYPE,
            seasonType,
            enum__Torappu_SandboxV2SeasonType::NONE,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2SeasonData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_functionDesc(&mut self, functionDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2SeasonData::VT_FUNCTIONDESC,
            functionDesc,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2SeasonData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_color(&mut self, color: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2SeasonData::VT_COLOR,
            color,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2SeasonDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2SeasonDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2SeasonData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2SeasonData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2SeasonData");
        ds.field("seasonType", &self.seasonType());
        ds.field("name", &self.name());
        ds.field("functionDesc", &self.functionDesc());
        ds.field("description", &self.description());
        ds.field("color", &self.color());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2SeasonDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2SeasonData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2SeasonData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2SeasonData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2SeasonData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2SeasonData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2SeasonDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2SeasonData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2SeasonDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2SeasonData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2SeasonData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2SeasonData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2SeasonData>>(
                    dict__string__clz_Torappu_SandboxV2SeasonData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2SeasonData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2SeasonData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2SeasonDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2SeasonData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2SeasonDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2SeasonDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2SeasonDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2SeasonDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2SeasonData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2SeasonData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2SeasonData>>(
                dict__string__clz_Torappu_SandboxV2SeasonData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2SeasonDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2SeasonDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2SeasonData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2SeasonData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2SeasonData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2SeasonData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2ConfirmIconDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ConfirmIconData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ConfirmIconData<'a> {
    type Inner = clz_Torappu_SandboxV2ConfirmIconData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ConfirmIconData<'a> {
    pub const VT_ICONTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_ICONPICID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ConfirmIconData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ConfirmIconDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ConfirmIconData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ConfirmIconDataBuilder::new(_fbb);
        if let Some(x) = args.iconPicId {
            builder.add_iconPicId(x);
        }
        builder.add_iconType(args.iconType);
        builder.finish()
    }

    #[inline]
    pub fn iconType(&self) -> enum__Torappu_SandboxV2ConfirmIconType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2ConfirmIconType>(
                    clz_Torappu_SandboxV2ConfirmIconData::VT_ICONTYPE,
                    Some(enum__Torappu_SandboxV2ConfirmIconType::COMMON),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn iconPicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ConfirmIconData::VT_ICONPICID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ConfirmIconData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxV2ConfirmIconType>(
                "iconType",
                Self::VT_ICONTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "iconPicId",
                Self::VT_ICONPICID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ConfirmIconDataArgs<'a> {
    pub iconType: enum__Torappu_SandboxV2ConfirmIconType,
    pub iconPicId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ConfirmIconDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ConfirmIconDataArgs {
            iconType: enum__Torappu_SandboxV2ConfirmIconType::COMMON,
            iconPicId: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2ConfirmIconDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ConfirmIconDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_iconType(&mut self, iconType: enum__Torappu_SandboxV2ConfirmIconType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2ConfirmIconType>(
                clz_Torappu_SandboxV2ConfirmIconData::VT_ICONTYPE,
                iconType,
                enum__Torappu_SandboxV2ConfirmIconType::COMMON,
            );
    }
    #[inline]
    pub fn add_iconPicId(&mut self, iconPicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ConfirmIconData::VT_ICONPICID,
            iconPicId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ConfirmIconDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ConfirmIconDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ConfirmIconData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ConfirmIconData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ConfirmIconData");
        ds.field("iconType", &self.iconType());
        ds.field("iconPicId", &self.iconPicId());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2TutorialRepoCharDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2TutorialRepoCharData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2TutorialRepoCharData<'a> {
    type Inner = clz_Torappu_SandboxV2TutorialRepoCharData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2TutorialRepoCharData<'a> {
    pub const VT_INSTID: flatbuffers::VOffsetT = 4;
    pub const VT_CHARID: flatbuffers::VOffsetT = 6;
    pub const VT_EVOLVEPHASE: flatbuffers::VOffsetT = 8;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 10;
    pub const VT_FAVORPOINT: flatbuffers::VOffsetT = 12;
    pub const VT_POTENTIALRANK: flatbuffers::VOffsetT = 14;
    pub const VT_MAINSKILLLV: flatbuffers::VOffsetT = 16;
    pub const VT_SPECSKILLLIST: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2TutorialRepoCharData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2TutorialRepoCharDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialRepoCharData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2TutorialRepoCharDataBuilder::new(_fbb);
        if let Some(x) = args.specSkillList {
            builder.add_specSkillList(x);
        }
        builder.add_mainSkillLv(args.mainSkillLv);
        builder.add_potentialRank(args.potentialRank);
        builder.add_favorPoint(args.favorPoint);
        builder.add_level(args.level);
        builder.add_evolvePhase(args.evolvePhase);
        if let Some(x) = args.charId {
            builder.add_charId(x);
        }
        builder.add_instId(args.instId);
        builder.finish()
    }

    #[inline]
    pub fn instId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2TutorialRepoCharData::VT_INSTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn charId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2TutorialRepoCharData::VT_CHARID,
                None,
            )
        }
    }
    #[inline]
    pub fn evolvePhase(&self) -> enum__Torappu_EvolvePhase {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_EvolvePhase>(
                    clz_Torappu_SandboxV2TutorialRepoCharData::VT_EVOLVEPHASE,
                    Some(enum__Torappu_EvolvePhase::PHASE_0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2TutorialRepoCharData::VT_LEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn favorPoint(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2TutorialRepoCharData::VT_FAVORPOINT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn potentialRank(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2TutorialRepoCharData::VT_POTENTIALRANK,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn mainSkillLv(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2TutorialRepoCharData::VT_MAINSKILLLV,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn specSkillList(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    clz_Torappu_SandboxV2TutorialRepoCharData::VT_SPECSKILLLIST,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2TutorialRepoCharData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("instId", Self::VT_INSTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("charId", Self::VT_CHARID, false)?
            .visit_field::<enum__Torappu_EvolvePhase>("evolvePhase", Self::VT_EVOLVEPHASE, false)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .visit_field::<i32>("favorPoint", Self::VT_FAVORPOINT, false)?
            .visit_field::<i32>("potentialRank", Self::VT_POTENTIALRANK, false)?
            .visit_field::<i32>("mainSkillLv", Self::VT_MAINSKILLLV, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "specSkillList",
                Self::VT_SPECSKILLLIST,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2TutorialRepoCharDataArgs<'a> {
    pub instId: i32,
    pub charId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub evolvePhase: enum__Torappu_EvolvePhase,
    pub level: i32,
    pub favorPoint: i32,
    pub potentialRank: i32,
    pub mainSkillLv: i32,
    pub specSkillList: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for clz_Torappu_SandboxV2TutorialRepoCharDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2TutorialRepoCharDataArgs {
            instId: 0,
            charId: None,
            evolvePhase: enum__Torappu_EvolvePhase::PHASE_0,
            level: 0,
            favorPoint: 0,
            potentialRank: 0,
            mainSkillLv: 0,
            specSkillList: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2TutorialRepoCharDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2TutorialRepoCharDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_instId(&mut self, instId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2TutorialRepoCharData::VT_INSTID,
            instId,
            0,
        );
    }
    #[inline]
    pub fn add_charId(&mut self, charId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2TutorialRepoCharData::VT_CHARID,
            charId,
        );
    }
    #[inline]
    pub fn add_evolvePhase(&mut self, evolvePhase: enum__Torappu_EvolvePhase) {
        self.fbb_.push_slot::<enum__Torappu_EvolvePhase>(
            clz_Torappu_SandboxV2TutorialRepoCharData::VT_EVOLVEPHASE,
            evolvePhase,
            enum__Torappu_EvolvePhase::PHASE_0,
        );
    }
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2TutorialRepoCharData::VT_LEVEL,
            level,
            0,
        );
    }
    #[inline]
    pub fn add_favorPoint(&mut self, favorPoint: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2TutorialRepoCharData::VT_FAVORPOINT,
            favorPoint,
            0,
        );
    }
    #[inline]
    pub fn add_potentialRank(&mut self, potentialRank: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2TutorialRepoCharData::VT_POTENTIALRANK,
            potentialRank,
            0,
        );
    }
    #[inline]
    pub fn add_mainSkillLv(&mut self, mainSkillLv: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2TutorialRepoCharData::VT_MAINSKILLLV,
            mainSkillLv,
            0,
        );
    }
    #[inline]
    pub fn add_specSkillList(
        &mut self,
        specSkillList: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2TutorialRepoCharData::VT_SPECSKILLLIST,
            specSkillList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2TutorialRepoCharDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2TutorialRepoCharDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialRepoCharData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2TutorialRepoCharData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2TutorialRepoCharData");
        ds.field("instId", &self.instId());
        ds.field("charId", &self.charId());
        ds.field("evolvePhase", &self.evolvePhase());
        ds.field("level", &self.level());
        ds.field("favorPoint", &self.favorPoint());
        ds.field("potentialRank", &self.potentialRank());
        ds.field("mainSkillLv", &self.mainSkillLv());
        ds.field("specSkillList", &self.specSkillList());
        ds.finish()
    }
}
pub enum dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'a> {
    type Inner = dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__clz_Torappu_SandboxV2TutorialRepoCharData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'bldr>> {
        let mut builder = dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    dict__int__clz_Torappu_SandboxV2TutorialRepoCharData::VT_KEY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__int__clz_Torappu_SandboxV2TutorialRepoCharData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2TutorialRepoCharData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2TutorialRepoCharData>>(
                    dict__int__clz_Torappu_SandboxV2TutorialRepoCharData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2TutorialRepoCharData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataArgs<'a> {
    pub key: i32,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialRepoCharData<'a>>>,
}
impl<'a> Default for dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataArgs {
            key: 0,
            value: None,
        }
    }
}

pub struct dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_.push_slot::<i32>(
            dict__int__clz_Torappu_SandboxV2TutorialRepoCharData::VT_KEY,
            key,
            0,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialRepoCharData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialRepoCharData>>(
                dict__int__clz_Torappu_SandboxV2TutorialRepoCharData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__int__clz_Torappu_SandboxV2TutorialRepoCharData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2TutorialBasicConstOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2TutorialBasicConst<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2TutorialBasicConst<'a> {
    type Inner = clz_Torappu_SandboxV2TutorialBasicConst<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2TutorialBasicConst<'a> {
    pub const VT_TRAININGQUESTLIST: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2TutorialBasicConst { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2TutorialBasicConstArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialBasicConst<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2TutorialBasicConstBuilder::new(_fbb);
        if let Some(x) = args.trainingQuestList {
            builder.add_trainingQuestList(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn trainingQuestList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2TutorialBasicConst::VT_TRAININGQUESTLIST,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2TutorialBasicConst<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("trainingQuestList", Self::VT_TRAININGQUESTLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2TutorialBasicConstArgs<'a> {
    pub trainingQuestList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2TutorialBasicConstArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2TutorialBasicConstArgs {
            trainingQuestList: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2TutorialBasicConstBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2TutorialBasicConstBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_trainingQuestList(
        &mut self,
        trainingQuestList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2TutorialBasicConst::VT_TRAININGQUESTLIST,
            trainingQuestList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2TutorialBasicConstBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2TutorialBasicConstBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialBasicConst<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2TutorialBasicConst<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2TutorialBasicConst");
        ds.field("trainingQuestList", &self.trainingQuestList());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2TutorialDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2TutorialData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2TutorialData<'a> {
    type Inner = clz_Torappu_SandboxV2TutorialData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2TutorialData<'a> {
    pub const VT_CHARREPODATA: flatbuffers::VOffsetT = 4;
    pub const VT_QUESTDATA: flatbuffers::VOffsetT = 6;
    pub const VT_GUIDEQUESTDATA: flatbuffers::VOffsetT = 8;
    pub const VT_QUESTLINEDATA: flatbuffers::VOffsetT = 10;
    pub const VT_BASICCONST: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2TutorialData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2TutorialDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2TutorialDataBuilder::new(_fbb);
        if let Some(x) = args.basicConst {
            builder.add_basicConst(x);
        }
        if let Some(x) = args.questLineData {
            builder.add_questLineData(x);
        }
        if let Some(x) = args.guideQuestData {
            builder.add_guideQuestData(x);
        }
        if let Some(x) = args.questData {
            builder.add_questData(x);
        }
        if let Some(x) = args.charRepoData {
            builder.add_charRepoData(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn charRepoData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__int__clz_Torappu_SandboxV2TutorialRepoCharData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2TutorialData::VT_CHARREPODATA, None)
        }
    }
    #[inline]
    pub fn questData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestData>,
                >,
            >>(clz_Torappu_SandboxV2TutorialData::VT_QUESTDATA, None)
        }
    }
    #[inline]
    pub fn guideQuestData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData>,
                >,
            >>(clz_Torappu_SandboxV2TutorialData::VT_GUIDEQUESTDATA, None)
        }
    }
    #[inline]
    pub fn questLineData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestLineData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestLineData>,
                >,
            >>(clz_Torappu_SandboxV2TutorialData::VT_QUESTLINEDATA, None)
        }
    }
    #[inline]
    pub fn basicConst(&self) -> Option<clz_Torappu_SandboxV2TutorialBasicConst<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2TutorialBasicConst>>(
                    clz_Torappu_SandboxV2TutorialData::VT_BASICCONST,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2TutorialData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__int__clz_Torappu_SandboxV2TutorialRepoCharData,
                    >,
                >,
            >>("charRepoData", Self::VT_CHARREPODATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestData>,
                >,
            >>("questData", Self::VT_QUESTDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData>,
                >,
            >>("guideQuestData", Self::VT_GUIDEQUESTDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestLineData>,
                >,
            >>("questLineData", Self::VT_QUESTLINEDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2TutorialBasicConst>>(
                "basicConst",
                Self::VT_BASICCONST,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2TutorialDataArgs<'a> {
    pub charRepoData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'a>,
                >,
            >,
        >,
    >,
    pub questData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestData<'a>>,
            >,
        >,
    >,
    pub guideQuestData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData<'a>>,
            >,
        >,
    >,
    pub questLineData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestLineData<'a>>,
            >,
        >,
    >,
    pub basicConst: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialBasicConst<'a>>>,
}
impl<'a> Default for clz_Torappu_SandboxV2TutorialDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2TutorialDataArgs {
            charRepoData: None,
            questData: None,
            guideQuestData: None,
            questLineData: None,
            basicConst: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2TutorialDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2TutorialDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_charRepoData(
        &mut self,
        charRepoData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2TutorialData::VT_CHARREPODATA,
            charRepoData,
        );
    }
    #[inline]
    pub fn add_questData(
        &mut self,
        questData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2TutorialData::VT_QUESTDATA,
            questData,
        );
    }
    #[inline]
    pub fn add_guideQuestData(
        &mut self,
        guideQuestData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2TutorialData::VT_GUIDEQUESTDATA,
            guideQuestData,
        );
    }
    #[inline]
    pub fn add_questLineData(
        &mut self,
        questLineData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestLineData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2TutorialData::VT_QUESTLINEDATA,
            questLineData,
        );
    }
    #[inline]
    pub fn add_basicConst(
        &mut self,
        basicConst: flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialBasicConst<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialBasicConst>>(
                clz_Torappu_SandboxV2TutorialData::VT_BASICCONST,
                basicConst,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2TutorialDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2TutorialDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2TutorialData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2TutorialData");
        ds.field("charRepoData", &self.charRepoData());
        ds.field("questData", &self.questData());
        ds.field("guideQuestData", &self.guideQuestData());
        ds.field("questLineData", &self.questLineData());
        ds.field("basicConst", &self.basicConst());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2RacerBasicInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RacerBasicInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RacerBasicInfo<'a> {
    type Inner = clz_Torappu_SandboxV2RacerBasicInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RacerBasicInfo<'a> {
    pub const VT_RACERID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_RACERNAME: flatbuffers::VOffsetT = 8;
    pub const VT_ITEMID: flatbuffers::VOffsetT = 10;
    pub const VT_ATTRIBUTEMAXVALUE: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RacerBasicInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RacerBasicInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerBasicInfo<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RacerBasicInfoBuilder::new(_fbb);
        if let Some(x) = args.attributeMaxValue {
            builder.add_attributeMaxValue(x);
        }
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        if let Some(x) = args.racerName {
            builder.add_racerName(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.racerId {
            builder.add_racerId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn racerId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerBasicInfo::VT_RACERID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2RacerBasicInfo::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn racerName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerBasicInfo::VT_RACERNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerBasicInfo::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn attributeMaxValue(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    clz_Torappu_SandboxV2RacerBasicInfo::VT_ATTRIBUTEMAXVALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RacerBasicInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("racerId", Self::VT_RACERID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "racerName",
                Self::VT_RACERNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "attributeMaxValue",
                Self::VT_ATTRIBUTEMAXVALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RacerBasicInfoArgs<'a> {
    pub racerId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub racerName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub attributeMaxValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for clz_Torappu_SandboxV2RacerBasicInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RacerBasicInfoArgs {
            racerId: None,
            sortId: 0,
            racerName: None,
            itemId: None,
            attributeMaxValue: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2RacerBasicInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RacerBasicInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_racerId(&mut self, racerId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerBasicInfo::VT_RACERID,
            racerId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2RacerBasicInfo::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_racerName(&mut self, racerName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerBasicInfo::VT_RACERNAME,
            racerName,
        );
    }
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerBasicInfo::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_attributeMaxValue(
        &mut self,
        attributeMaxValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerBasicInfo::VT_ATTRIBUTEMAXVALUE,
            attributeMaxValue,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RacerBasicInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RacerBasicInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerBasicInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RacerBasicInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RacerBasicInfo");
        ds.field("racerId", &self.racerId());
        ds.field("sortId", &self.sortId());
        ds.field("racerName", &self.racerName());
        ds.field("itemId", &self.itemId());
        ds.field("attributeMaxValue", &self.attributeMaxValue());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RacerBasicInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RacerBasicInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RacerBasicInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2RacerBasicInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RacerBasicInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2RacerBasicInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RacerBasicInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacerBasicInfo>>(
                    dict__string__clz_Torappu_SandboxV2RacerBasicInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacerBasicInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RacerBasicInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerBasicInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RacerBasicInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RacerBasicInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RacerBasicInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RacerBasicInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RacerBasicInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerBasicInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerBasicInfo>>(
                dict__string__clz_Torappu_SandboxV2RacerBasicInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RacerBasicInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RacerBasicInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RacerBasicInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RacerBasicInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2RacerTalentInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RacerTalentInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RacerTalentInfo<'a> {
    type Inner = clz_Torappu_SandboxV2RacerTalentInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RacerTalentInfo<'a> {
    pub const VT_TALENTID: flatbuffers::VOffsetT = 4;
    pub const VT_TALENTTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_TALENTICONID: flatbuffers::VOffsetT = 8;
    pub const VT_DESC: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RacerTalentInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RacerTalentInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerTalentInfo<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RacerTalentInfoBuilder::new(_fbb);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.talentIconId {
            builder.add_talentIconId(x);
        }
        builder.add_talentType(args.talentType);
        if let Some(x) = args.talentId {
            builder.add_talentId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn talentId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerTalentInfo::VT_TALENTID,
                None,
            )
        }
    }
    #[inline]
    pub fn talentType(&self) -> enum__Torappu_SandboxV2RacerTalentType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2RacerTalentType>(
                    clz_Torappu_SandboxV2RacerTalentInfo::VT_TALENTTYPE,
                    Some(enum__Torappu_SandboxV2RacerTalentType::BORN),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn talentIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerTalentInfo::VT_TALENTICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerTalentInfo::VT_DESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RacerTalentInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "talentId",
                Self::VT_TALENTID,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxV2RacerTalentType>(
                "talentType",
                Self::VT_TALENTTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "talentIconId",
                Self::VT_TALENTICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RacerTalentInfoArgs<'a> {
    pub talentId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub talentType: enum__Torappu_SandboxV2RacerTalentType,
    pub talentIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2RacerTalentInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RacerTalentInfoArgs {
            talentId: None,
            talentType: enum__Torappu_SandboxV2RacerTalentType::BORN,
            talentIconId: None,
            desc: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2RacerTalentInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RacerTalentInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_talentId(&mut self, talentId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerTalentInfo::VT_TALENTID,
            talentId,
        );
    }
    #[inline]
    pub fn add_talentType(&mut self, talentType: enum__Torappu_SandboxV2RacerTalentType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2RacerTalentType>(
                clz_Torappu_SandboxV2RacerTalentInfo::VT_TALENTTYPE,
                talentType,
                enum__Torappu_SandboxV2RacerTalentType::BORN,
            );
    }
    #[inline]
    pub fn add_talentIconId(&mut self, talentIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerTalentInfo::VT_TALENTICONID,
            talentIconId,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerTalentInfo::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RacerTalentInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RacerTalentInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerTalentInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RacerTalentInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RacerTalentInfo");
        ds.field("talentId", &self.talentId());
        ds.field("talentType", &self.talentType());
        ds.field("talentIconId", &self.talentIconId());
        ds.field("desc", &self.desc());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RacerTalentInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RacerTalentInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RacerTalentInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2RacerTalentInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RacerTalentInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2RacerTalentInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RacerTalentInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacerTalentInfo>>(
                    dict__string__clz_Torappu_SandboxV2RacerTalentInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacerTalentInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RacerTalentInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerTalentInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RacerTalentInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RacerTalentInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RacerTalentInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RacerTalentInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RacerTalentInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerTalentInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerTalentInfo>>(
                dict__string__clz_Torappu_SandboxV2RacerTalentInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RacerTalentInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RacerTalentInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RacerTalentInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RacerTalentInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2RacerNameInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RacerNameInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RacerNameInfo<'a> {
    type Inner = clz_Torappu_SandboxV2RacerNameInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RacerNameInfo<'a> {
    pub const VT_NAMEID: flatbuffers::VOffsetT = 4;
    pub const VT_NAMETYPE: flatbuffers::VOffsetT = 6;
    pub const VT_NAMEDESC: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RacerNameInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RacerNameInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerNameInfo<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RacerNameInfoBuilder::new(_fbb);
        if let Some(x) = args.nameDesc {
            builder.add_nameDesc(x);
        }
        builder.add_nameType(args.nameType);
        if let Some(x) = args.nameId {
            builder.add_nameId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn nameId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerNameInfo::VT_NAMEID,
                None,
            )
        }
    }
    #[inline]
    pub fn nameType(&self) -> enum__Torappu_SandboxV2RacerNameType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2RacerNameType>(
                    clz_Torappu_SandboxV2RacerNameInfo::VT_NAMETYPE,
                    Some(enum__Torappu_SandboxV2RacerNameType::PREFIX),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn nameDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerNameInfo::VT_NAMEDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RacerNameInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nameId", Self::VT_NAMEID, false)?
            .visit_field::<enum__Torappu_SandboxV2RacerNameType>(
                "nameType",
                Self::VT_NAMETYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nameDesc",
                Self::VT_NAMEDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RacerNameInfoArgs<'a> {
    pub nameId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nameType: enum__Torappu_SandboxV2RacerNameType,
    pub nameDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2RacerNameInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RacerNameInfoArgs {
            nameId: None,
            nameType: enum__Torappu_SandboxV2RacerNameType::PREFIX,
            nameDesc: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2RacerNameInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RacerNameInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nameId(&mut self, nameId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerNameInfo::VT_NAMEID,
            nameId,
        );
    }
    #[inline]
    pub fn add_nameType(&mut self, nameType: enum__Torappu_SandboxV2RacerNameType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2RacerNameType>(
            clz_Torappu_SandboxV2RacerNameInfo::VT_NAMETYPE,
            nameType,
            enum__Torappu_SandboxV2RacerNameType::PREFIX,
        );
    }
    #[inline]
    pub fn add_nameDesc(&mut self, nameDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerNameInfo::VT_NAMEDESC,
            nameDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RacerNameInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RacerNameInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerNameInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RacerNameInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RacerNameInfo");
        ds.field("nameId", &self.nameId());
        ds.field("nameType", &self.nameType());
        ds.field("nameDesc", &self.nameDesc());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RacerNameInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RacerNameInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RacerNameInfo<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RacerNameInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RacerNameInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RacerNameInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RacerNameInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacerNameInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2RacerNameInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RacerNameInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2RacerNameInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RacerNameInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacerNameInfo>>(
                    dict__string__clz_Torappu_SandboxV2RacerNameInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RacerNameInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacerNameInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RacerNameInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerNameInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RacerNameInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RacerNameInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RacerNameInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RacerNameInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RacerNameInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerNameInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerNameInfo>>(
                dict__string__clz_Torappu_SandboxV2RacerNameInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RacerNameInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RacerNameInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacerNameInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RacerNameInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RacerNameInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RacerNameInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2RacerMedalInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RacerMedalInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RacerMedalInfo<'a> {
    type Inner = clz_Torappu_SandboxV2RacerMedalInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RacerMedalInfo<'a> {
    pub const VT_MEDALID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_NAME: flatbuffers::VOffsetT = 8;
    pub const VT_DESC: flatbuffers::VOffsetT = 10;
    pub const VT_ICONID: flatbuffers::VOffsetT = 12;
    pub const VT_SMALLICONID: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RacerMedalInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RacerMedalInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerMedalInfo<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RacerMedalInfoBuilder::new(_fbb);
        if let Some(x) = args.smallIconId {
            builder.add_smallIconId(x);
        }
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.medalId {
            builder.add_medalId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn medalId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerMedalInfo::VT_MEDALID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2RacerMedalInfo::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerMedalInfo::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerMedalInfo::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerMedalInfo::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn smallIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerMedalInfo::VT_SMALLICONID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RacerMedalInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("medalId", Self::VT_MEDALID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "smallIconId",
                Self::VT_SMALLICONID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RacerMedalInfoArgs<'a> {
    pub medalId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub smallIconId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2RacerMedalInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RacerMedalInfoArgs {
            medalId: None,
            sortId: 0,
            name: None,
            desc: None,
            iconId: None,
            smallIconId: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2RacerMedalInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RacerMedalInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_medalId(&mut self, medalId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerMedalInfo::VT_MEDALID,
            medalId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2RacerMedalInfo::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerMedalInfo::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerMedalInfo::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerMedalInfo::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_smallIconId(&mut self, smallIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerMedalInfo::VT_SMALLICONID,
            smallIconId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RacerMedalInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RacerMedalInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerMedalInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RacerMedalInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RacerMedalInfo");
        ds.field("medalId", &self.medalId());
        ds.field("sortId", &self.sortId());
        ds.field("name", &self.name());
        ds.field("desc", &self.desc());
        ds.field("iconId", &self.iconId());
        ds.field("smallIconId", &self.smallIconId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RacerMedalInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RacerMedalInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RacerMedalInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2RacerMedalInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RacerMedalInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2RacerMedalInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RacerMedalInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacerMedalInfo>>(
                    dict__string__clz_Torappu_SandboxV2RacerMedalInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacerMedalInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RacerMedalInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerMedalInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RacerMedalInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RacerMedalInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RacerMedalInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RacerMedalInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RacerMedalInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerMedalInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerMedalInfo>>(
                dict__string__clz_Torappu_SandboxV2RacerMedalInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RacerMedalInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RacerMedalInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RacerMedalInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RacerMedalInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2RacingItemInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RacingItemInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RacingItemInfo<'a> {
    type Inner = clz_Torappu_SandboxV2RacingItemInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RacingItemInfo<'a> {
    pub const VT_RACERITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_ICONID: flatbuffers::VOffsetT = 8;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RacingItemInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RacingItemInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingItemInfo<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RacingItemInfoBuilder::new(_fbb);
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.racerItemId {
            builder.add_racerItemId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn racerItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingItemInfo::VT_RACERITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingItemInfo::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingItemInfo::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(clz_Torappu_SandboxV2RacingItemInfo::VT_BLACKBOARD, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RacingItemInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "racerItemId",
                Self::VT_RACERITEMID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RacingItemInfoArgs<'a> {
    pub racerItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2RacingItemInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RacingItemInfoArgs {
            racerItemId: None,
            name: None,
            iconId: None,
            blackboard: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2RacingItemInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RacingItemInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_racerItemId(&mut self, racerItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingItemInfo::VT_RACERITEMID,
            racerItemId,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingItemInfo::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingItemInfo::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingItemInfo::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RacingItemInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RacingItemInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingItemInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RacingItemInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RacingItemInfo");
        ds.field("racerItemId", &self.racerItemId());
        ds.field("name", &self.name());
        ds.field("iconId", &self.iconId());
        ds.field("blackboard", &self.blackboard());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RacingItemInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RacingItemInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RacingItemInfo<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RacingItemInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RacingItemInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RacingItemInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RacingItemInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacingItemInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2RacingItemInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RacingItemInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2RacingItemInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RacingItemInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacingItemInfo>>(
                    dict__string__clz_Torappu_SandboxV2RacingItemInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RacingItemInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacingItemInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RacingItemInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingItemInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RacingItemInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RacingItemInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RacingItemInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RacingItemInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RacingItemInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingItemInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingItemInfo>>(
                dict__string__clz_Torappu_SandboxV2RacingItemInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RacingItemInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RacingItemInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacingItemInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RacingItemInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RacingItemInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RacingItemInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2RacingConstDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RacingConstData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RacingConstData<'a> {
    type Inner = clz_Torappu_SandboxV2RacingConstData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RacingConstData<'a> {
    pub const VT_ATTRIBUTENAMELIST: flatbuffers::VOffsetT = 4;
    pub const VT_RACERMAXVALUE: flatbuffers::VOffsetT = 6;
    pub const VT_BAGFULLHINTPERCENT: flatbuffers::VOffsetT = 8;
    pub const VT_TEMPBAGFULLHINTPERCENT: flatbuffers::VOffsetT = 10;
    pub const VT_BAGNAME: flatbuffers::VOffsetT = 12;
    pub const VT_TEMPBAGNAME: flatbuffers::VOffsetT = 14;
    pub const VT_BAGEMPTYLEFTDESC: flatbuffers::VOffsetT = 16;
    pub const VT_BAGEMPTYRIGHTDESC: flatbuffers::VOffsetT = 18;
    pub const VT_TEMPBAGEMPTYLEFTDESC: flatbuffers::VOffsetT = 20;
    pub const VT_TEMPBAGEMPTYRIGHTDESC: flatbuffers::VOffsetT = 22;
    pub const VT_BORNTALENTICONID: flatbuffers::VOffsetT = 24;
    pub const VT_BORNTALENTTITLE: flatbuffers::VOffsetT = 26;
    pub const VT_LEARNEDTALENTICONID: flatbuffers::VOffsetT = 28;
    pub const VT_LEARNEDTALENTTITLE: flatbuffers::VOffsetT = 30;
    pub const VT_TALENTEMPTYDESC: flatbuffers::VOffsetT = 32;
    pub const VT_SLUGITEMID: flatbuffers::VOffsetT = 34;
    pub const VT_RACINGHPFACTOR: flatbuffers::VOffsetT = 36;
    pub const VT_RACINGSPEEDFACTOR: flatbuffers::VOffsetT = 38;
    pub const VT_RACINGACCELERATIONFACTOR: flatbuffers::VOffsetT = 40;
    pub const VT_RECOVERMOVESPEED: flatbuffers::VOffsetT = 42;
    pub const VT_RECOVERHPFACTOR: flatbuffers::VOffsetT = 44;
    pub const VT_BLEEDINGFACTOR: flatbuffers::VOffsetT = 46;
    pub const VT_MAXSTEERINGFACTOR: flatbuffers::VOffsetT = 48;
    pub const VT_STEERINGMASSLEVELFACTOR: flatbuffers::VOffsetT = 50;
    pub const VT_STEERINGMOVESPEEDFACTOR: flatbuffers::VOffsetT = 52;
    pub const VT_SAFEANGLECOS: flatbuffers::VOffsetT = 54;
    pub const VT_SAFECOLLISIONFORCELEVEL: flatbuffers::VOffsetT = 56;
    pub const VT_TILECOLLISIONFACTOR: flatbuffers::VOffsetT = 58;
    pub const VT_COLLISIONFORCESECTOR: flatbuffers::VOffsetT = 60;
    pub const VT_COLLISIONFORCELEVEL: flatbuffers::VOffsetT = 62;
    pub const VT_COLLISIONSPEEDLOSS: flatbuffers::VOffsetT = 64;
    pub const VT_COLLISIONHPLOSS: flatbuffers::VOffsetT = 66;
    pub const VT_TILECOLLISIONSPEEDLOSS: flatbuffers::VOffsetT = 68;
    pub const VT_TILECOLLISIONHPLOSS: flatbuffers::VOffsetT = 70;
    pub const VT_AUTOUSEITEMTIMERANGE: flatbuffers::VOffsetT = 72;
    pub const VT_RECOVERACCELERATION: flatbuffers::VOffsetT = 74;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RacingConstData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RacingConstDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingConstData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RacingConstDataBuilder::new(_fbb);
        builder.add_recoverAcceleration(args.recoverAcceleration);
        if let Some(x) = args.autoUseItemTimeRange {
            builder.add_autoUseItemTimeRange(x);
        }
        if let Some(x) = args.tileCollisionHpLoss {
            builder.add_tileCollisionHpLoss(x);
        }
        if let Some(x) = args.tileCollisionSpeedLoss {
            builder.add_tileCollisionSpeedLoss(x);
        }
        if let Some(x) = args.collisionHpLoss {
            builder.add_collisionHpLoss(x);
        }
        if let Some(x) = args.collisionSpeedLoss {
            builder.add_collisionSpeedLoss(x);
        }
        if let Some(x) = args.collisionForceLevel {
            builder.add_collisionForceLevel(x);
        }
        if let Some(x) = args.collisionForceSector {
            builder.add_collisionForceSector(x);
        }
        builder.add_tileCollisionFactor(args.tileCollisionFactor);
        builder.add_safeCollisionForceLevel(args.safeCollisionForceLevel);
        builder.add_safeAngleCos(args.safeAngleCos);
        builder.add_steeringMoveSpeedFactor(args.steeringMoveSpeedFactor);
        builder.add_steeringMassLevelFactor(args.steeringMassLevelFactor);
        builder.add_maxSteeringFactor(args.maxSteeringFactor);
        builder.add_bleedingFactor(args.bleedingFactor);
        builder.add_recoverHpFactor(args.recoverHpFactor);
        builder.add_recoverMoveSpeed(args.recoverMoveSpeed);
        builder.add_racingAccelerationFactor(args.racingAccelerationFactor);
        builder.add_racingSpeedFactor(args.racingSpeedFactor);
        builder.add_racingHpFactor(args.racingHpFactor);
        if let Some(x) = args.slugItemId {
            builder.add_slugItemId(x);
        }
        if let Some(x) = args.talentEmptyDesc {
            builder.add_talentEmptyDesc(x);
        }
        if let Some(x) = args.learnedTalentTitle {
            builder.add_learnedTalentTitle(x);
        }
        if let Some(x) = args.learnedTalentIconId {
            builder.add_learnedTalentIconId(x);
        }
        if let Some(x) = args.bornTalentTitle {
            builder.add_bornTalentTitle(x);
        }
        if let Some(x) = args.bornTalentIconId {
            builder.add_bornTalentIconId(x);
        }
        if let Some(x) = args.tempBagEmptyRightDesc {
            builder.add_tempBagEmptyRightDesc(x);
        }
        if let Some(x) = args.tempBagEmptyLeftDesc {
            builder.add_tempBagEmptyLeftDesc(x);
        }
        if let Some(x) = args.bagEmptyRightDesc {
            builder.add_bagEmptyRightDesc(x);
        }
        if let Some(x) = args.bagEmptyLeftDesc {
            builder.add_bagEmptyLeftDesc(x);
        }
        if let Some(x) = args.tempBagName {
            builder.add_tempBagName(x);
        }
        if let Some(x) = args.bagName {
            builder.add_bagName(x);
        }
        builder.add_tempBagFullHintPercent(args.tempBagFullHintPercent);
        builder.add_bagFullHintPercent(args.bagFullHintPercent);
        if let Some(x) = args.racerMaxValue {
            builder.add_racerMaxValue(x);
        }
        if let Some(x) = args.attributeNameList {
            builder.add_attributeNameList(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn attributeNameList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2RacingConstData::VT_ATTRIBUTENAMELIST,
                None,
            )
        }
    }
    #[inline]
    pub fn racerMaxValue(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    clz_Torappu_SandboxV2RacingConstData::VT_RACERMAXVALUE,
                    None,
                )
        }
    }
    #[inline]
    pub fn bagFullHintPercent(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_BAGFULLHINTPERCENT,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn tempBagFullHintPercent(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_TEMPBAGFULLHINTPERCENT,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn bagName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_BAGNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn tempBagName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_TEMPBAGNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn bagEmptyLeftDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_BAGEMPTYLEFTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn bagEmptyRightDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_BAGEMPTYRIGHTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn tempBagEmptyLeftDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_TEMPBAGEMPTYLEFTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn tempBagEmptyRightDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_TEMPBAGEMPTYRIGHTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn bornTalentIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_BORNTALENTICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn bornTalentTitle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_BORNTALENTTITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn learnedTalentIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_LEARNEDTALENTICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn learnedTalentTitle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_LEARNEDTALENTTITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn talentEmptyDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_TALENTEMPTYDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn slugItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_SLUGITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn racingHpFactor(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_RACINGHPFACTOR,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn racingSpeedFactor(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_RACINGSPEEDFACTOR,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn racingAccelerationFactor(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_RACINGACCELERATIONFACTOR,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn recoverMoveSpeed(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_RECOVERMOVESPEED,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn recoverHpFactor(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_RECOVERHPFACTOR,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn bleedingFactor(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_BLEEDINGFACTOR,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxSteeringFactor(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_MAXSTEERINGFACTOR,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn steeringMassLevelFactor(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_STEERINGMASSLEVELFACTOR,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn steeringMoveSpeedFactor(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_STEERINGMOVESPEEDFACTOR,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn safeAngleCos(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_SAFEANGLECOS,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn safeCollisionForceLevel(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_SAFECOLLISIONFORCELEVEL,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn tileCollisionFactor(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_TILECOLLISIONFACTOR,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn collisionForceSector(&self) -> Option<flatbuffers::Vector<'a, f32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    clz_Torappu_SandboxV2RacingConstData::VT_COLLISIONFORCESECTOR,
                    None,
                )
        }
    }
    #[inline]
    pub fn collisionForceLevel(&self) -> Option<flatbuffers::Vector<'a, f32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    clz_Torappu_SandboxV2RacingConstData::VT_COLLISIONFORCELEVEL,
                    None,
                )
        }
    }
    #[inline]
    pub fn collisionSpeedLoss(&self) -> Option<flatbuffers::Vector<'a, f32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    clz_Torappu_SandboxV2RacingConstData::VT_COLLISIONSPEEDLOSS,
                    None,
                )
        }
    }
    #[inline]
    pub fn collisionHpLoss(&self) -> Option<flatbuffers::Vector<'a, f32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    clz_Torappu_SandboxV2RacingConstData::VT_COLLISIONHPLOSS,
                    None,
                )
        }
    }
    #[inline]
    pub fn tileCollisionSpeedLoss(&self) -> Option<flatbuffers::Vector<'a, f32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    clz_Torappu_SandboxV2RacingConstData::VT_TILECOLLISIONSPEEDLOSS,
                    None,
                )
        }
    }
    #[inline]
    pub fn tileCollisionHpLoss(&self) -> Option<flatbuffers::Vector<'a, f32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    clz_Torappu_SandboxV2RacingConstData::VT_TILECOLLISIONHPLOSS,
                    None,
                )
        }
    }
    #[inline]
    pub fn autoUseItemTimeRange(&self) -> Option<flatbuffers::Vector<'a, f32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    clz_Torappu_SandboxV2RacingConstData::VT_AUTOUSEITEMTIMERANGE,
                    None,
                )
        }
    }
    #[inline]
    pub fn recoverAcceleration(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_RECOVERACCELERATION,
                    Some(0.0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RacingConstData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("attributeNameList", Self::VT_ATTRIBUTENAMELIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "racerMaxValue",
                Self::VT_RACERMAXVALUE,
                false,
            )?
            .visit_field::<f32>("bagFullHintPercent", Self::VT_BAGFULLHINTPERCENT, false)?
            .visit_field::<f32>(
                "tempBagFullHintPercent",
                Self::VT_TEMPBAGFULLHINTPERCENT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bagName", Self::VT_BAGNAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "tempBagName",
                Self::VT_TEMPBAGNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bagEmptyLeftDesc",
                Self::VT_BAGEMPTYLEFTDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bagEmptyRightDesc",
                Self::VT_BAGEMPTYRIGHTDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "tempBagEmptyLeftDesc",
                Self::VT_TEMPBAGEMPTYLEFTDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "tempBagEmptyRightDesc",
                Self::VT_TEMPBAGEMPTYRIGHTDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bornTalentIconId",
                Self::VT_BORNTALENTICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bornTalentTitle",
                Self::VT_BORNTALENTTITLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "learnedTalentIconId",
                Self::VT_LEARNEDTALENTICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "learnedTalentTitle",
                Self::VT_LEARNEDTALENTTITLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "talentEmptyDesc",
                Self::VT_TALENTEMPTYDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "slugItemId",
                Self::VT_SLUGITEMID,
                false,
            )?
            .visit_field::<f32>("racingHpFactor", Self::VT_RACINGHPFACTOR, false)?
            .visit_field::<f32>("racingSpeedFactor", Self::VT_RACINGSPEEDFACTOR, false)?
            .visit_field::<f32>(
                "racingAccelerationFactor",
                Self::VT_RACINGACCELERATIONFACTOR,
                false,
            )?
            .visit_field::<f32>("recoverMoveSpeed", Self::VT_RECOVERMOVESPEED, false)?
            .visit_field::<f32>("recoverHpFactor", Self::VT_RECOVERHPFACTOR, false)?
            .visit_field::<f32>("bleedingFactor", Self::VT_BLEEDINGFACTOR, false)?
            .visit_field::<f32>("maxSteeringFactor", Self::VT_MAXSTEERINGFACTOR, false)?
            .visit_field::<f32>(
                "steeringMassLevelFactor",
                Self::VT_STEERINGMASSLEVELFACTOR,
                false,
            )?
            .visit_field::<f32>(
                "steeringMoveSpeedFactor",
                Self::VT_STEERINGMOVESPEEDFACTOR,
                false,
            )?
            .visit_field::<f32>("safeAngleCos", Self::VT_SAFEANGLECOS, false)?
            .visit_field::<f32>(
                "safeCollisionForceLevel",
                Self::VT_SAFECOLLISIONFORCELEVEL,
                false,
            )?
            .visit_field::<f32>("tileCollisionFactor", Self::VT_TILECOLLISIONFACTOR, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "collisionForceSector",
                Self::VT_COLLISIONFORCESECTOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "collisionForceLevel",
                Self::VT_COLLISIONFORCELEVEL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "collisionSpeedLoss",
                Self::VT_COLLISIONSPEEDLOSS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "collisionHpLoss",
                Self::VT_COLLISIONHPLOSS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "tileCollisionSpeedLoss",
                Self::VT_TILECOLLISIONSPEEDLOSS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "tileCollisionHpLoss",
                Self::VT_TILECOLLISIONHPLOSS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "autoUseItemTimeRange",
                Self::VT_AUTOUSEITEMTIMERANGE,
                false,
            )?
            .visit_field::<f32>("recoverAcceleration", Self::VT_RECOVERACCELERATION, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RacingConstDataArgs<'a> {
    pub attributeNameList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub racerMaxValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub bagFullHintPercent: f32,
    pub tempBagFullHintPercent: f32,
    pub bagName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tempBagName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bagEmptyLeftDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bagEmptyRightDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tempBagEmptyLeftDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tempBagEmptyRightDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bornTalentIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bornTalentTitle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub learnedTalentIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub learnedTalentTitle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub talentEmptyDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub slugItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub racingHpFactor: f32,
    pub racingSpeedFactor: f32,
    pub racingAccelerationFactor: f32,
    pub recoverMoveSpeed: f32,
    pub recoverHpFactor: f32,
    pub bleedingFactor: f32,
    pub maxSteeringFactor: f32,
    pub steeringMassLevelFactor: f32,
    pub steeringMoveSpeedFactor: f32,
    pub safeAngleCos: f32,
    pub safeCollisionForceLevel: f32,
    pub tileCollisionFactor: f32,
    pub collisionForceSector: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub collisionForceLevel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub collisionSpeedLoss: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub collisionHpLoss: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub tileCollisionSpeedLoss: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub tileCollisionHpLoss: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub autoUseItemTimeRange: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub recoverAcceleration: f32,
}
impl<'a> Default for clz_Torappu_SandboxV2RacingConstDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RacingConstDataArgs {
            attributeNameList: None,
            racerMaxValue: None,
            bagFullHintPercent: 0.0,
            tempBagFullHintPercent: 0.0,
            bagName: None,
            tempBagName: None,
            bagEmptyLeftDesc: None,
            bagEmptyRightDesc: None,
            tempBagEmptyLeftDesc: None,
            tempBagEmptyRightDesc: None,
            bornTalentIconId: None,
            bornTalentTitle: None,
            learnedTalentIconId: None,
            learnedTalentTitle: None,
            talentEmptyDesc: None,
            slugItemId: None,
            racingHpFactor: 0.0,
            racingSpeedFactor: 0.0,
            racingAccelerationFactor: 0.0,
            recoverMoveSpeed: 0.0,
            recoverHpFactor: 0.0,
            bleedingFactor: 0.0,
            maxSteeringFactor: 0.0,
            steeringMassLevelFactor: 0.0,
            steeringMoveSpeedFactor: 0.0,
            safeAngleCos: 0.0,
            safeCollisionForceLevel: 0.0,
            tileCollisionFactor: 0.0,
            collisionForceSector: None,
            collisionForceLevel: None,
            collisionSpeedLoss: None,
            collisionHpLoss: None,
            tileCollisionSpeedLoss: None,
            tileCollisionHpLoss: None,
            autoUseItemTimeRange: None,
            recoverAcceleration: 0.0,
        }
    }
}

pub struct clz_Torappu_SandboxV2RacingConstDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RacingConstDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_attributeNameList(
        &mut self,
        attributeNameList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_ATTRIBUTENAMELIST,
            attributeNameList,
        );
    }
    #[inline]
    pub fn add_racerMaxValue(
        &mut self,
        racerMaxValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_RACERMAXVALUE,
            racerMaxValue,
        );
    }
    #[inline]
    pub fn add_bagFullHintPercent(&mut self, bagFullHintPercent: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_BAGFULLHINTPERCENT,
            bagFullHintPercent,
            0.0,
        );
    }
    #[inline]
    pub fn add_tempBagFullHintPercent(&mut self, tempBagFullHintPercent: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_TEMPBAGFULLHINTPERCENT,
            tempBagFullHintPercent,
            0.0,
        );
    }
    #[inline]
    pub fn add_bagName(&mut self, bagName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_BAGNAME,
            bagName,
        );
    }
    #[inline]
    pub fn add_tempBagName(&mut self, tempBagName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_TEMPBAGNAME,
            tempBagName,
        );
    }
    #[inline]
    pub fn add_bagEmptyLeftDesc(&mut self, bagEmptyLeftDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_BAGEMPTYLEFTDESC,
            bagEmptyLeftDesc,
        );
    }
    #[inline]
    pub fn add_bagEmptyRightDesc(&mut self, bagEmptyRightDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_BAGEMPTYRIGHTDESC,
            bagEmptyRightDesc,
        );
    }
    #[inline]
    pub fn add_tempBagEmptyLeftDesc(
        &mut self,
        tempBagEmptyLeftDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_TEMPBAGEMPTYLEFTDESC,
            tempBagEmptyLeftDesc,
        );
    }
    #[inline]
    pub fn add_tempBagEmptyRightDesc(
        &mut self,
        tempBagEmptyRightDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_TEMPBAGEMPTYRIGHTDESC,
            tempBagEmptyRightDesc,
        );
    }
    #[inline]
    pub fn add_bornTalentIconId(&mut self, bornTalentIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_BORNTALENTICONID,
            bornTalentIconId,
        );
    }
    #[inline]
    pub fn add_bornTalentTitle(&mut self, bornTalentTitle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_BORNTALENTTITLE,
            bornTalentTitle,
        );
    }
    #[inline]
    pub fn add_learnedTalentIconId(
        &mut self,
        learnedTalentIconId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_LEARNEDTALENTICONID,
            learnedTalentIconId,
        );
    }
    #[inline]
    pub fn add_learnedTalentTitle(&mut self, learnedTalentTitle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_LEARNEDTALENTTITLE,
            learnedTalentTitle,
        );
    }
    #[inline]
    pub fn add_talentEmptyDesc(&mut self, talentEmptyDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_TALENTEMPTYDESC,
            talentEmptyDesc,
        );
    }
    #[inline]
    pub fn add_slugItemId(&mut self, slugItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_SLUGITEMID,
            slugItemId,
        );
    }
    #[inline]
    pub fn add_racingHpFactor(&mut self, racingHpFactor: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_RACINGHPFACTOR,
            racingHpFactor,
            0.0,
        );
    }
    #[inline]
    pub fn add_racingSpeedFactor(&mut self, racingSpeedFactor: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_RACINGSPEEDFACTOR,
            racingSpeedFactor,
            0.0,
        );
    }
    #[inline]
    pub fn add_racingAccelerationFactor(&mut self, racingAccelerationFactor: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_RACINGACCELERATIONFACTOR,
            racingAccelerationFactor,
            0.0,
        );
    }
    #[inline]
    pub fn add_recoverMoveSpeed(&mut self, recoverMoveSpeed: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_RECOVERMOVESPEED,
            recoverMoveSpeed,
            0.0,
        );
    }
    #[inline]
    pub fn add_recoverHpFactor(&mut self, recoverHpFactor: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_RECOVERHPFACTOR,
            recoverHpFactor,
            0.0,
        );
    }
    #[inline]
    pub fn add_bleedingFactor(&mut self, bleedingFactor: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_BLEEDINGFACTOR,
            bleedingFactor,
            0.0,
        );
    }
    #[inline]
    pub fn add_maxSteeringFactor(&mut self, maxSteeringFactor: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_MAXSTEERINGFACTOR,
            maxSteeringFactor,
            0.0,
        );
    }
    #[inline]
    pub fn add_steeringMassLevelFactor(&mut self, steeringMassLevelFactor: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_STEERINGMASSLEVELFACTOR,
            steeringMassLevelFactor,
            0.0,
        );
    }
    #[inline]
    pub fn add_steeringMoveSpeedFactor(&mut self, steeringMoveSpeedFactor: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_STEERINGMOVESPEEDFACTOR,
            steeringMoveSpeedFactor,
            0.0,
        );
    }
    #[inline]
    pub fn add_safeAngleCos(&mut self, safeAngleCos: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_SAFEANGLECOS,
            safeAngleCos,
            0.0,
        );
    }
    #[inline]
    pub fn add_safeCollisionForceLevel(&mut self, safeCollisionForceLevel: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_SAFECOLLISIONFORCELEVEL,
            safeCollisionForceLevel,
            0.0,
        );
    }
    #[inline]
    pub fn add_tileCollisionFactor(&mut self, tileCollisionFactor: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_TILECOLLISIONFACTOR,
            tileCollisionFactor,
            0.0,
        );
    }
    #[inline]
    pub fn add_collisionForceSector(
        &mut self,
        collisionForceSector: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_COLLISIONFORCESECTOR,
            collisionForceSector,
        );
    }
    #[inline]
    pub fn add_collisionForceLevel(
        &mut self,
        collisionForceLevel: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_COLLISIONFORCELEVEL,
            collisionForceLevel,
        );
    }
    #[inline]
    pub fn add_collisionSpeedLoss(
        &mut self,
        collisionSpeedLoss: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_COLLISIONSPEEDLOSS,
            collisionSpeedLoss,
        );
    }
    #[inline]
    pub fn add_collisionHpLoss(
        &mut self,
        collisionHpLoss: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_COLLISIONHPLOSS,
            collisionHpLoss,
        );
    }
    #[inline]
    pub fn add_tileCollisionSpeedLoss(
        &mut self,
        tileCollisionSpeedLoss: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_TILECOLLISIONSPEEDLOSS,
            tileCollisionSpeedLoss,
        );
    }
    #[inline]
    pub fn add_tileCollisionHpLoss(
        &mut self,
        tileCollisionHpLoss: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_TILECOLLISIONHPLOSS,
            tileCollisionHpLoss,
        );
    }
    #[inline]
    pub fn add_autoUseItemTimeRange(
        &mut self,
        autoUseItemTimeRange: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_AUTOUSEITEMTIMERANGE,
            autoUseItemTimeRange,
        );
    }
    #[inline]
    pub fn add_recoverAcceleration(&mut self, recoverAcceleration: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_RECOVERACCELERATION,
            recoverAcceleration,
            0.0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RacingConstDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RacingConstDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingConstData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RacingConstData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RacingConstData");
        ds.field("attributeNameList", &self.attributeNameList());
        ds.field("racerMaxValue", &self.racerMaxValue());
        ds.field("bagFullHintPercent", &self.bagFullHintPercent());
        ds.field("tempBagFullHintPercent", &self.tempBagFullHintPercent());
        ds.field("bagName", &self.bagName());
        ds.field("tempBagName", &self.tempBagName());
        ds.field("bagEmptyLeftDesc", &self.bagEmptyLeftDesc());
        ds.field("bagEmptyRightDesc", &self.bagEmptyRightDesc());
        ds.field("tempBagEmptyLeftDesc", &self.tempBagEmptyLeftDesc());
        ds.field("tempBagEmptyRightDesc", &self.tempBagEmptyRightDesc());
        ds.field("bornTalentIconId", &self.bornTalentIconId());
        ds.field("bornTalentTitle", &self.bornTalentTitle());
        ds.field("learnedTalentIconId", &self.learnedTalentIconId());
        ds.field("learnedTalentTitle", &self.learnedTalentTitle());
        ds.field("talentEmptyDesc", &self.talentEmptyDesc());
        ds.field("slugItemId", &self.slugItemId());
        ds.field("racingHpFactor", &self.racingHpFactor());
        ds.field("racingSpeedFactor", &self.racingSpeedFactor());
        ds.field("racingAccelerationFactor", &self.racingAccelerationFactor());
        ds.field("recoverMoveSpeed", &self.recoverMoveSpeed());
        ds.field("recoverHpFactor", &self.recoverHpFactor());
        ds.field("bleedingFactor", &self.bleedingFactor());
        ds.field("maxSteeringFactor", &self.maxSteeringFactor());
        ds.field("steeringMassLevelFactor", &self.steeringMassLevelFactor());
        ds.field("steeringMoveSpeedFactor", &self.steeringMoveSpeedFactor());
        ds.field("safeAngleCos", &self.safeAngleCos());
        ds.field("safeCollisionForceLevel", &self.safeCollisionForceLevel());
        ds.field("tileCollisionFactor", &self.tileCollisionFactor());
        ds.field("collisionForceSector", &self.collisionForceSector());
        ds.field("collisionForceLevel", &self.collisionForceLevel());
        ds.field("collisionSpeedLoss", &self.collisionSpeedLoss());
        ds.field("collisionHpLoss", &self.collisionHpLoss());
        ds.field("tileCollisionSpeedLoss", &self.tileCollisionSpeedLoss());
        ds.field("tileCollisionHpLoss", &self.tileCollisionHpLoss());
        ds.field("autoUseItemTimeRange", &self.autoUseItemTimeRange());
        ds.field("recoverAcceleration", &self.recoverAcceleration());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2RacingDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RacingData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RacingData<'a> {
    type Inner = clz_Torappu_SandboxV2RacingData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RacingData<'a> {
    pub const VT_RACERBASICINFO: flatbuffers::VOffsetT = 4;
    pub const VT_RACERTALENTINFO: flatbuffers::VOffsetT = 6;
    pub const VT_RACERNAMEINFO: flatbuffers::VOffsetT = 8;
    pub const VT_RACERMEDALINFO: flatbuffers::VOffsetT = 10;
    pub const VT_ENEMYITEMMAP: flatbuffers::VOffsetT = 12;
    pub const VT_RACINGITEMINFO: flatbuffers::VOffsetT = 14;
    pub const VT_CONSTDATA: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RacingData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RacingDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RacingDataBuilder::new(_fbb);
        if let Some(x) = args.constData {
            builder.add_constData(x);
        }
        if let Some(x) = args.racingItemInfo {
            builder.add_racingItemInfo(x);
        }
        if let Some(x) = args.enemyItemMap {
            builder.add_enemyItemMap(x);
        }
        if let Some(x) = args.racerMedalInfo {
            builder.add_racerMedalInfo(x);
        }
        if let Some(x) = args.racerNameInfo {
            builder.add_racerNameInfo(x);
        }
        if let Some(x) = args.racerTalentInfo {
            builder.add_racerTalentInfo(x);
        }
        if let Some(x) = args.racerBasicInfo {
            builder.add_racerBasicInfo(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn racerBasicInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerBasicInfo>,
                >,
            >>(clz_Torappu_SandboxV2RacingData::VT_RACERBASICINFO, None)
        }
    }
    #[inline]
    pub fn racerTalentInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2RacerTalentInfo,
                    >,
                >,
            >>(clz_Torappu_SandboxV2RacingData::VT_RACERTALENTINFO, None)
        }
    }
    #[inline]
    pub fn racerNameInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerNameInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerNameInfo>,
                >,
            >>(clz_Torappu_SandboxV2RacingData::VT_RACERNAMEINFO, None)
        }
    }
    #[inline]
    pub fn racerMedalInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerMedalInfo>,
                >,
            >>(clz_Torappu_SandboxV2RacingData::VT_RACERMEDALINFO, None)
        }
    }
    #[inline]
    pub fn enemyItemMap(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(clz_Torappu_SandboxV2RacingData::VT_ENEMYITEMMAP, None)
        }
    }
    #[inline]
    pub fn racingItemInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacingItemInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacingItemInfo>,
                >,
            >>(clz_Torappu_SandboxV2RacingData::VT_RACINGITEMINFO, None)
        }
    }
    #[inline]
    pub fn constData(&self) -> Option<clz_Torappu_SandboxV2RacingConstData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacingConstData>>(
                    clz_Torappu_SandboxV2RacingData::VT_CONSTDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RacingData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerBasicInfo>,
                >,
            >>("racerBasicInfo", Self::VT_RACERBASICINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2RacerTalentInfo,
                    >,
                >,
            >>("racerTalentInfo", Self::VT_RACERTALENTINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerNameInfo>,
                >,
            >>("racerNameInfo", Self::VT_RACERNAMEINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerMedalInfo>,
                >,
            >>("racerMedalInfo", Self::VT_RACERMEDALINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>("enemyItemMap", Self::VT_ENEMYITEMMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacingItemInfo>,
                >,
            >>("racingItemInfo", Self::VT_RACINGITEMINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacingConstData>>(
                "constData",
                Self::VT_CONSTDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RacingDataArgs<'a> {
    pub racerBasicInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'a>>,
            >,
        >,
    >,
    pub racerTalentInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'a>,
                >,
            >,
        >,
    >,
    pub racerNameInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerNameInfo<'a>>,
            >,
        >,
    >,
    pub racerMedalInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'a>>,
            >,
        >,
    >,
    pub enemyItemMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>,
        >,
    >,
    pub racingItemInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacingItemInfo<'a>>,
            >,
        >,
    >,
    pub constData: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingConstData<'a>>>,
}
impl<'a> Default for clz_Torappu_SandboxV2RacingDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RacingDataArgs {
            racerBasicInfo: None,
            racerTalentInfo: None,
            racerNameInfo: None,
            racerMedalInfo: None,
            enemyItemMap: None,
            racingItemInfo: None,
            constData: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2RacingDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2RacingDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_racerBasicInfo(
        &mut self,
        racerBasicInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingData::VT_RACERBASICINFO,
            racerBasicInfo,
        );
    }
    #[inline]
    pub fn add_racerTalentInfo(
        &mut self,
        racerTalentInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingData::VT_RACERTALENTINFO,
            racerTalentInfo,
        );
    }
    #[inline]
    pub fn add_racerNameInfo(
        &mut self,
        racerNameInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerNameInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingData::VT_RACERNAMEINFO,
            racerNameInfo,
        );
    }
    #[inline]
    pub fn add_racerMedalInfo(
        &mut self,
        racerMedalInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingData::VT_RACERMEDALINFO,
            racerMedalInfo,
        );
    }
    #[inline]
    pub fn add_enemyItemMap(
        &mut self,
        enemyItemMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingData::VT_ENEMYITEMMAP,
            enemyItemMap,
        );
    }
    #[inline]
    pub fn add_racingItemInfo(
        &mut self,
        racingItemInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacingItemInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingData::VT_RACINGITEMINFO,
            racingItemInfo,
        );
    }
    #[inline]
    pub fn add_constData(
        &mut self,
        constData: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingConstData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingConstData>>(
                clz_Torappu_SandboxV2RacingData::VT_CONSTDATA,
                constData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RacingDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RacingDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RacingData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RacingData");
        ds.field("racerBasicInfo", &self.racerBasicInfo());
        ds.field("racerTalentInfo", &self.racerTalentInfo());
        ds.field("racerNameInfo", &self.racerNameInfo());
        ds.field("racerMedalInfo", &self.racerMedalInfo());
        ds.field("enemyItemMap", &self.enemyItemMap());
        ds.field("racingItemInfo", &self.racingItemInfo());
        ds.field("constData", &self.constData());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2ChallengeConstOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ChallengeConst<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ChallengeConst<'a> {
    type Inner = clz_Torappu_SandboxV2ChallengeConst<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ChallengeConst<'a> {
    pub const VT_CHALLENGEMODEDESC: flatbuffers::VOffsetT = 4;
    pub const VT_DAILYTITLEDESC: flatbuffers::VOffsetT = 6;
    pub const VT_DEBUFFCOUNTDOWNDESC: flatbuffers::VOffsetT = 8;
    pub const VT_GAINALLDEBUFFDESC: flatbuffers::VOffsetT = 10;
    pub const VT_DAILYUPATTRIBUTEDESC: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ChallengeConst { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ChallengeConstArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeConst<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ChallengeConstBuilder::new(_fbb);
        if let Some(x) = args.dailyUpAttributeDesc {
            builder.add_dailyUpAttributeDesc(x);
        }
        if let Some(x) = args.gainAllDebuffDesc {
            builder.add_gainAllDebuffDesc(x);
        }
        if let Some(x) = args.debuffCountdownDesc {
            builder.add_debuffCountdownDesc(x);
        }
        if let Some(x) = args.dailyTitleDesc {
            builder.add_dailyTitleDesc(x);
        }
        if let Some(x) = args.challengeModeDesc {
            builder.add_challengeModeDesc(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn challengeModeDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ChallengeConst::VT_CHALLENGEMODEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn dailyTitleDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ChallengeConst::VT_DAILYTITLEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn debuffCountdownDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ChallengeConst::VT_DEBUFFCOUNTDOWNDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn gainAllDebuffDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ChallengeConst::VT_GAINALLDEBUFFDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn dailyUpAttributeDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ChallengeConst::VT_DAILYUPATTRIBUTEDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ChallengeConst<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "challengeModeDesc",
                Self::VT_CHALLENGEMODEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dailyTitleDesc",
                Self::VT_DAILYTITLEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "debuffCountdownDesc",
                Self::VT_DEBUFFCOUNTDOWNDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "gainAllDebuffDesc",
                Self::VT_GAINALLDEBUFFDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dailyUpAttributeDesc",
                Self::VT_DAILYUPATTRIBUTEDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ChallengeConstArgs<'a> {
    pub challengeModeDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dailyTitleDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub debuffCountdownDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gainAllDebuffDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dailyUpAttributeDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ChallengeConstArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ChallengeConstArgs {
            challengeModeDesc: None,
            dailyTitleDesc: None,
            debuffCountdownDesc: None,
            gainAllDebuffDesc: None,
            dailyUpAttributeDesc: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2ChallengeConstBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ChallengeConstBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_challengeModeDesc(&mut self, challengeModeDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeConst::VT_CHALLENGEMODEDESC,
            challengeModeDesc,
        );
    }
    #[inline]
    pub fn add_dailyTitleDesc(&mut self, dailyTitleDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeConst::VT_DAILYTITLEDESC,
            dailyTitleDesc,
        );
    }
    #[inline]
    pub fn add_debuffCountdownDesc(
        &mut self,
        debuffCountdownDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeConst::VT_DEBUFFCOUNTDOWNDESC,
            debuffCountdownDesc,
        );
    }
    #[inline]
    pub fn add_gainAllDebuffDesc(&mut self, gainAllDebuffDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeConst::VT_GAINALLDEBUFFDESC,
            gainAllDebuffDesc,
        );
    }
    #[inline]
    pub fn add_dailyUpAttributeDesc(
        &mut self,
        dailyUpAttributeDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeConst::VT_DAILYUPATTRIBUTEDESC,
            dailyUpAttributeDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ChallengeConstBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ChallengeConstBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeConst<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ChallengeConst<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ChallengeConst");
        ds.field("challengeModeDesc", &self.challengeModeDesc());
        ds.field("dailyTitleDesc", &self.dailyTitleDesc());
        ds.field("debuffCountdownDesc", &self.debuffCountdownDesc());
        ds.field("gainAllDebuffDesc", &self.gainAllDebuffDesc());
        ds.field("dailyUpAttributeDesc", &self.dailyUpAttributeDesc());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2ChallengeModeUnlockDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ChallengeModeUnlockData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ChallengeModeUnlockData<'a> {
    type Inner = clz_Torappu_SandboxV2ChallengeModeUnlockData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ChallengeModeUnlockData<'a> {
    pub const VT_UNLOCKID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_CONDITIONDESC: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ChallengeModeUnlockData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ChallengeModeUnlockDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeUnlockData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ChallengeModeUnlockDataBuilder::new(_fbb);
        if let Some(x) = args.conditionDesc {
            builder.add_conditionDesc(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.unlockId {
            builder.add_unlockId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn unlockId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ChallengeModeUnlockData::VT_UNLOCKID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2ChallengeModeUnlockData::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn conditionDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ChallengeModeUnlockData::VT_CONDITIONDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ChallengeModeUnlockData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockId",
                Self::VT_UNLOCKID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "conditionDesc",
                Self::VT_CONDITIONDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ChallengeModeUnlockDataArgs<'a> {
    pub unlockId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub conditionDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ChallengeModeUnlockDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ChallengeModeUnlockDataArgs {
            unlockId: None,
            sortId: 0,
            conditionDesc: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2ChallengeModeUnlockDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ChallengeModeUnlockDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_unlockId(&mut self, unlockId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeModeUnlockData::VT_UNLOCKID,
            unlockId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ChallengeModeUnlockData::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn add_conditionDesc(&mut self, conditionDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeModeUnlockData::VT_CONDITIONDESC,
            conditionDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ChallengeModeUnlockDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ChallengeModeUnlockDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeUnlockData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ChallengeModeUnlockData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ChallengeModeUnlockData");
        ds.field("unlockId", &self.unlockId());
        ds.field("sortId", &self.sortId());
        ds.field("conditionDesc", &self.conditionDesc());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'a>
{
    type Inner = dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ChallengeModeUnlockData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeModeUnlockData>>(
                    dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeModeUnlockData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeUnlockData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeUnlockData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeUnlockData>>(dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2ChallengeModeRewardDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ChallengeModeRewardData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ChallengeModeRewardData<'a> {
    type Inner = clz_Torappu_SandboxV2ChallengeModeRewardData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ChallengeModeRewardData<'a> {
    pub const VT_REWARDID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_REWARDDAY: flatbuffers::VOffsetT = 8;
    pub const VT_REWARDITEMLIST: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ChallengeModeRewardData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ChallengeModeRewardDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeRewardData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ChallengeModeRewardDataBuilder::new(_fbb);
        if let Some(x) = args.rewardItemList {
            builder.add_rewardItemList(x);
        }
        builder.add_rewardDay(args.rewardDay);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.rewardId {
            builder.add_rewardId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn rewardId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ChallengeModeRewardData::VT_REWARDID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2ChallengeModeRewardData::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rewardDay(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2ChallengeModeRewardData::VT_REWARDDAY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rewardItemList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(
                clz_Torappu_SandboxV2ChallengeModeRewardData::VT_REWARDITEMLIST,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ChallengeModeRewardData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rewardId",
                Self::VT_REWARDID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<i32>("rewardDay", Self::VT_REWARDDAY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("rewardItemList", Self::VT_REWARDITEMLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ChallengeModeRewardDataArgs<'a> {
    pub rewardId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub rewardDay: i32,
    pub rewardItemList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2ChallengeModeRewardDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ChallengeModeRewardDataArgs {
            rewardId: None,
            sortId: 0,
            rewardDay: 0,
            rewardItemList: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2ChallengeModeRewardDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ChallengeModeRewardDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_rewardId(&mut self, rewardId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeModeRewardData::VT_REWARDID,
            rewardId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ChallengeModeRewardData::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn add_rewardDay(&mut self, rewardDay: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ChallengeModeRewardData::VT_REWARDDAY,
            rewardDay,
            0,
        );
    }
    #[inline]
    pub fn add_rewardItemList(
        &mut self,
        rewardItemList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeModeRewardData::VT_REWARDITEMLIST,
            rewardItemList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ChallengeModeRewardDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ChallengeModeRewardDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeRewardData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ChallengeModeRewardData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ChallengeModeRewardData");
        ds.field("rewardId", &self.rewardId());
        ds.field("sortId", &self.sortId());
        ds.field("rewardDay", &self.rewardDay());
        ds.field("rewardItemList", &self.rewardItemList());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'a>
{
    type Inner = dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ChallengeModeRewardData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeModeRewardData>>(
                    dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeModeRewardData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeRewardData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeRewardData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeRewardData>>(dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2ChallengeModeDifficultyDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ChallengeModeDifficultyData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ChallengeModeDifficultyData<'a> {
    type Inner = clz_Torappu_SandboxV2ChallengeModeDifficultyData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ChallengeModeDifficultyData<'a> {
    pub const VT_CHALLENGEDAY: flatbuffers::VOffsetT = 4;
    pub const VT_DIFFDESC: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ChallengeModeDifficultyData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ChallengeModeDifficultyDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeDifficultyData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ChallengeModeDifficultyDataBuilder::new(_fbb);
        if let Some(x) = args.diffDesc {
            builder.add_diffDesc(x);
        }
        builder.add_challengeDay(args.challengeDay);
        builder.finish()
    }

    #[inline]
    pub fn challengeDay(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2ChallengeModeDifficultyData::VT_CHALLENGEDAY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn diffDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ChallengeModeDifficultyData::VT_DIFFDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ChallengeModeDifficultyData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("challengeDay", Self::VT_CHALLENGEDAY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "diffDesc",
                Self::VT_DIFFDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ChallengeModeDifficultyDataArgs<'a> {
    pub challengeDay: i32,
    pub diffDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ChallengeModeDifficultyDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ChallengeModeDifficultyDataArgs {
            challengeDay: 0,
            diffDesc: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2ChallengeModeDifficultyDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ChallengeModeDifficultyDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_challengeDay(&mut self, challengeDay: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ChallengeModeDifficultyData::VT_CHALLENGEDAY,
            challengeDay,
            0,
        );
    }
    #[inline]
    pub fn add_diffDesc(&mut self, diffDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeModeDifficultyData::VT_DIFFDESC,
            diffDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ChallengeModeDifficultyDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ChallengeModeDifficultyDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeDifficultyData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ChallengeModeDifficultyData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ChallengeModeDifficultyData");
        ds.field("challengeDay", &self.challengeDay());
        ds.field("diffDesc", &self.diffDesc());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2ChallengeModeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ChallengeModeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ChallengeModeData<'a> {
    type Inner = clz_Torappu_SandboxV2ChallengeModeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ChallengeModeData<'a> {
    pub const VT_CHALLENGECONST: flatbuffers::VOffsetT = 4;
    pub const VT_CHALLENGEMODEUNLOCKDATA: flatbuffers::VOffsetT = 6;
    pub const VT_CHALLENGEMODEREWARDDATA: flatbuffers::VOffsetT = 8;
    pub const VT_CHALLENGEMODEDIFFICULTYDATA: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ChallengeModeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ChallengeModeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ChallengeModeDataBuilder::new(_fbb);
        if let Some(x) = args.challengeModeDifficultyData {
            builder.add_challengeModeDifficultyData(x);
        }
        if let Some(x) = args.challengeModeRewardData {
            builder.add_challengeModeRewardData(x);
        }
        if let Some(x) = args.challengeModeUnlockData {
            builder.add_challengeModeUnlockData(x);
        }
        if let Some(x) = args.challengeConst {
            builder.add_challengeConst(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn challengeConst(&self) -> Option<clz_Torappu_SandboxV2ChallengeConst<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeConst>>(
                    clz_Torappu_SandboxV2ChallengeModeData::VT_CHALLENGECONST,
                    None,
                )
        }
    }
    #[inline]
    pub fn challengeModeUnlockData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData,
                    >,
                >,
            >>(
                clz_Torappu_SandboxV2ChallengeModeData::VT_CHALLENGEMODEUNLOCKDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn challengeModeRewardData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData,
                    >,
                >,
            >>(
                clz_Torappu_SandboxV2ChallengeModeData::VT_CHALLENGEMODEREWARDDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn challengeModeDifficultyData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeModeDifficultyData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeModeDifficultyData>,
                >,
            >>(
                clz_Torappu_SandboxV2ChallengeModeData::VT_CHALLENGEMODEDIFFICULTYDATA,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ChallengeModeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeConst>>(
                "challengeConst",
                Self::VT_CHALLENGECONST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData,
                    >,
                >,
            >>(
                "challengeModeUnlockData",
                Self::VT_CHALLENGEMODEUNLOCKDATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData,
                    >,
                >,
            >>(
                "challengeModeRewardData",
                Self::VT_CHALLENGEMODEREWARDDATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeModeDifficultyData>,
                >,
            >>(
                "challengeModeDifficultyData",
                Self::VT_CHALLENGEMODEDIFFICULTYDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ChallengeModeDataArgs<'a> {
    pub challengeConst: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeConst<'a>>>,
    pub challengeModeUnlockData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'a>,
                >,
            >,
        >,
    >,
    pub challengeModeRewardData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'a>,
                >,
            >,
        >,
    >,
    pub challengeModeDifficultyData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeModeDifficultyData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2ChallengeModeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ChallengeModeDataArgs {
            challengeConst: None,
            challengeModeUnlockData: None,
            challengeModeRewardData: None,
            challengeModeDifficultyData: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2ChallengeModeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ChallengeModeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_challengeConst(
        &mut self,
        challengeConst: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeConst<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeConst>>(
                clz_Torappu_SandboxV2ChallengeModeData::VT_CHALLENGECONST,
                challengeConst,
            );
    }
    #[inline]
    pub fn add_challengeModeUnlockData(
        &mut self,
        challengeModeUnlockData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeModeData::VT_CHALLENGEMODEUNLOCKDATA,
            challengeModeUnlockData,
        );
    }
    #[inline]
    pub fn add_challengeModeRewardData(
        &mut self,
        challengeModeRewardData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeModeData::VT_CHALLENGEMODEREWARDDATA,
            challengeModeRewardData,
        );
    }
    #[inline]
    pub fn add_challengeModeDifficultyData(
        &mut self,
        challengeModeDifficultyData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeModeDifficultyData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeModeData::VT_CHALLENGEMODEDIFFICULTYDATA,
            challengeModeDifficultyData,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ChallengeModeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ChallengeModeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ChallengeModeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ChallengeModeData");
        ds.field("challengeConst", &self.challengeConst());
        ds.field("challengeModeUnlockData", &self.challengeModeUnlockData());
        ds.field("challengeModeRewardData", &self.challengeModeRewardData());
        ds.field(
            "challengeModeDifficultyData",
            &self.challengeModeDifficultyData(),
        );
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxV2DataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2Data<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2Data<'a> {
    type Inner = clz_Torappu_SandboxV2Data<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxV2Data<'a> {
    pub const VT_MAPDATA: flatbuffers::VOffsetT = 4;
    pub const VT_ITEMTRAPDATA: flatbuffers::VOffsetT = 6;
    pub const VT_ITEMTRAPTAGDATA: flatbuffers::VOffsetT = 8;
    pub const VT_BUILDINGITEMDATA: flatbuffers::VOffsetT = 10;
    pub const VT_CRAFTITEMDATA: flatbuffers::VOffsetT = 12;
    pub const VT_LIVESTOCKPRODUCEDATA: flatbuffers::VOffsetT = 14;
    pub const VT_CRAFTGROUPDATA: flatbuffers::VOffsetT = 16;
    pub const VT_ALCHEMYRECIPEDATA: flatbuffers::VOffsetT = 18;
    pub const VT_DRINKMATDATA: flatbuffers::VOffsetT = 20;
    pub const VT_FOODMATDATA: flatbuffers::VOffsetT = 22;
    pub const VT_FOODDATA: flatbuffers::VOffsetT = 24;
    pub const VT_NODETYPEDATA: flatbuffers::VOffsetT = 26;
    pub const VT_NODEUPGRADEDATA: flatbuffers::VOffsetT = 28;
    pub const VT_WEATHERDATA: flatbuffers::VOffsetT = 30;
    pub const VT_STAGEDATA: flatbuffers::VOffsetT = 32;
    pub const VT_ZONEDATA: flatbuffers::VOffsetT = 34;
    pub const VT_NODEBUFFDATA: flatbuffers::VOffsetT = 36;
    pub const VT_REWARDCONFIGDATA: flatbuffers::VOffsetT = 38;
    pub const VT_FLOATICONDATA: flatbuffers::VOffsetT = 40;
    pub const VT_ENEMYRUSHTYPEDATA: flatbuffers::VOffsetT = 42;
    pub const VT_RUSHENEMYDATA: flatbuffers::VOffsetT = 44;
    pub const VT_GAMECONST: flatbuffers::VOffsetT = 46;
    pub const VT_BASICCONST: flatbuffers::VOffsetT = 48;
    pub const VT_RIFTCONST: flatbuffers::VOffsetT = 50;
    pub const VT_DEVELOPMENTCONST: flatbuffers::VOffsetT = 52;
    pub const VT_BATTLELOADINGTIPS: flatbuffers::VOffsetT = 54;
    pub const VT_RUNEDATAS: flatbuffers::VOffsetT = 56;
    pub const VT_ITEMRUNELIST: flatbuffers::VOffsetT = 58;
    pub const VT_QUESTDATA: flatbuffers::VOffsetT = 60;
    pub const VT_NPCDATA: flatbuffers::VOffsetT = 62;
    pub const VT_DIALOGDATA: flatbuffers::VOffsetT = 64;
    pub const VT_QUESTLINEDATA: flatbuffers::VOffsetT = 66;
    pub const VT_QUESTLINESTORYDATA: flatbuffers::VOffsetT = 68;
    pub const VT_GUIDEQUESTDATA: flatbuffers::VOffsetT = 70;
    pub const VT_DEVELOPMENTDATA: flatbuffers::VOffsetT = 72;
    pub const VT_EVENTDATA: flatbuffers::VOffsetT = 74;
    pub const VT_EVENTSCENEDATA: flatbuffers::VOffsetT = 76;
    pub const VT_EVENTCHOICEDATA: flatbuffers::VOffsetT = 78;
    pub const VT_EXPEDITIONDATA: flatbuffers::VOffsetT = 80;
    pub const VT_EVENTEFFECTDATA: flatbuffers::VOffsetT = 82;
    pub const VT_SHOPGOODDATA: flatbuffers::VOffsetT = 84;
    pub const VT_SHOPDIALOGDATA: flatbuffers::VOffsetT = 86;
    pub const VT_LOGISTICSDATA: flatbuffers::VOffsetT = 88;
    pub const VT_LOGISTICSCHARMAPPING: flatbuffers::VOffsetT = 90;
    pub const VT_MATERIALKEYWORDDATA: flatbuffers::VOffsetT = 92;
    pub const VT_MONTHRUSHDATA: flatbuffers::VOffsetT = 94;
    pub const VT_RIFTTERRAINPARAMDATA: flatbuffers::VOffsetT = 96;
    pub const VT_RIFTCLIMATEPARAMDATA: flatbuffers::VOffsetT = 98;
    pub const VT_RIFTENEMYPARAMDATA: flatbuffers::VOffsetT = 100;
    pub const VT_RIFTSUBTARGETDATA: flatbuffers::VOffsetT = 102;
    pub const VT_RIFTMAINTARGETDATA: flatbuffers::VOffsetT = 104;
    pub const VT_RIFTGLOBALEFFECTDATA: flatbuffers::VOffsetT = 106;
    pub const VT_FIXEDRIFTDATA: flatbuffers::VOffsetT = 108;
    pub const VT_RIFTTEAMBUFFDATA: flatbuffers::VOffsetT = 110;
    pub const VT_RIFTDIFFICULTYDATA: flatbuffers::VOffsetT = 112;
    pub const VT_RIFTREWARDDISPLAYDATA: flatbuffers::VOffsetT = 114;
    pub const VT_ENEMYREPLACEDATA: flatbuffers::VOffsetT = 116;
    pub const VT_ARCHIVEQUESTDATA: flatbuffers::VOffsetT = 118;
    pub const VT_ACHIEVEMENTDATA: flatbuffers::VOffsetT = 120;
    pub const VT_ACHIEVEMENTTYPEDATA: flatbuffers::VOffsetT = 122;
    pub const VT_ARCHIVEQUESTTYPEDATA: flatbuffers::VOffsetT = 124;
    pub const VT_ARCHIVEMUSICUNLOCKDATA: flatbuffers::VOffsetT = 126;
    pub const VT_BASEUPDATE: flatbuffers::VOffsetT = 128;
    pub const VT_DEVELOPMENTLINESEGMENTDATAS: flatbuffers::VOffsetT = 130;
    pub const VT_BUILDINGNODESCOREDATA: flatbuffers::VOffsetT = 132;
    pub const VT_SEASONDATA: flatbuffers::VOffsetT = 134;
    pub const VT_CONFIRMICONDATA: flatbuffers::VOffsetT = 136;
    pub const VT_SHOPUPDATETIMEDATA: flatbuffers::VOffsetT = 138;
    pub const VT_TUTORIALDATA: flatbuffers::VOffsetT = 140;
    pub const VT_RACINGDATA: flatbuffers::VOffsetT = 142;
    pub const VT_CHALLENGEMODEDATA: flatbuffers::VOffsetT = 144;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2Data { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2DataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2Data<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2DataBuilder::new(_fbb);
        if let Some(x) = args.challengeModeData {
            builder.add_challengeModeData(x);
        }
        if let Some(x) = args.racingData {
            builder.add_racingData(x);
        }
        if let Some(x) = args.tutorialData {
            builder.add_tutorialData(x);
        }
        if let Some(x) = args.shopUpdateTimeData {
            builder.add_shopUpdateTimeData(x);
        }
        if let Some(x) = args.confirmIconData {
            builder.add_confirmIconData(x);
        }
        if let Some(x) = args.seasonData {
            builder.add_seasonData(x);
        }
        if let Some(x) = args.buildingNodeScoreData {
            builder.add_buildingNodeScoreData(x);
        }
        if let Some(x) = args.developmentLineSegmentDatas {
            builder.add_developmentLineSegmentDatas(x);
        }
        if let Some(x) = args.baseUpdate {
            builder.add_baseUpdate(x);
        }
        if let Some(x) = args.archiveMusicUnlockData {
            builder.add_archiveMusicUnlockData(x);
        }
        if let Some(x) = args.archiveQuestTypeData {
            builder.add_archiveQuestTypeData(x);
        }
        if let Some(x) = args.achievementTypeData {
            builder.add_achievementTypeData(x);
        }
        if let Some(x) = args.achievementData {
            builder.add_achievementData(x);
        }
        if let Some(x) = args.archiveQuestData {
            builder.add_archiveQuestData(x);
        }
        if let Some(x) = args.enemyReplaceData {
            builder.add_enemyReplaceData(x);
        }
        if let Some(x) = args.riftRewardDisplayData {
            builder.add_riftRewardDisplayData(x);
        }
        if let Some(x) = args.riftDifficultyData {
            builder.add_riftDifficultyData(x);
        }
        if let Some(x) = args.riftTeamBuffData {
            builder.add_riftTeamBuffData(x);
        }
        if let Some(x) = args.fixedRiftData {
            builder.add_fixedRiftData(x);
        }
        if let Some(x) = args.riftGlobalEffectData {
            builder.add_riftGlobalEffectData(x);
        }
        if let Some(x) = args.riftMainTargetData {
            builder.add_riftMainTargetData(x);
        }
        if let Some(x) = args.riftSubTargetData {
            builder.add_riftSubTargetData(x);
        }
        if let Some(x) = args.riftEnemyParamData {
            builder.add_riftEnemyParamData(x);
        }
        if let Some(x) = args.riftClimateParamData {
            builder.add_riftClimateParamData(x);
        }
        if let Some(x) = args.riftTerrainParamData {
            builder.add_riftTerrainParamData(x);
        }
        if let Some(x) = args.monthRushData {
            builder.add_monthRushData(x);
        }
        if let Some(x) = args.materialKeywordData {
            builder.add_materialKeywordData(x);
        }
        if let Some(x) = args.logisticsCharMapping {
            builder.add_logisticsCharMapping(x);
        }
        if let Some(x) = args.logisticsData {
            builder.add_logisticsData(x);
        }
        if let Some(x) = args.shopDialogData {
            builder.add_shopDialogData(x);
        }
        if let Some(x) = args.shopGoodData {
            builder.add_shopGoodData(x);
        }
        if let Some(x) = args.eventEffectData {
            builder.add_eventEffectData(x);
        }
        if let Some(x) = args.expeditionData {
            builder.add_expeditionData(x);
        }
        if let Some(x) = args.eventChoiceData {
            builder.add_eventChoiceData(x);
        }
        if let Some(x) = args.eventSceneData {
            builder.add_eventSceneData(x);
        }
        if let Some(x) = args.eventData {
            builder.add_eventData(x);
        }
        if let Some(x) = args.developmentData {
            builder.add_developmentData(x);
        }
        if let Some(x) = args.guideQuestData {
            builder.add_guideQuestData(x);
        }
        if let Some(x) = args.questLineStoryData {
            builder.add_questLineStoryData(x);
        }
        if let Some(x) = args.questLineData {
            builder.add_questLineData(x);
        }
        if let Some(x) = args.dialogData {
            builder.add_dialogData(x);
        }
        if let Some(x) = args.npcData {
            builder.add_npcData(x);
        }
        if let Some(x) = args.questData {
            builder.add_questData(x);
        }
        if let Some(x) = args.itemRuneList {
            builder.add_itemRuneList(x);
        }
        if let Some(x) = args.runeDatas {
            builder.add_runeDatas(x);
        }
        if let Some(x) = args.battleLoadingTips {
            builder.add_battleLoadingTips(x);
        }
        if let Some(x) = args.developmentConst {
            builder.add_developmentConst(x);
        }
        if let Some(x) = args.riftConst {
            builder.add_riftConst(x);
        }
        if let Some(x) = args.basicConst {
            builder.add_basicConst(x);
        }
        if let Some(x) = args.gameConst {
            builder.add_gameConst(x);
        }
        if let Some(x) = args.rushEnemyData {
            builder.add_rushEnemyData(x);
        }
        if let Some(x) = args.enemyRushTypeData {
            builder.add_enemyRushTypeData(x);
        }
        if let Some(x) = args.floatIconData {
            builder.add_floatIconData(x);
        }
        if let Some(x) = args.rewardConfigData {
            builder.add_rewardConfigData(x);
        }
        if let Some(x) = args.nodeBuffData {
            builder.add_nodeBuffData(x);
        }
        if let Some(x) = args.zoneData {
            builder.add_zoneData(x);
        }
        if let Some(x) = args.stageData {
            builder.add_stageData(x);
        }
        if let Some(x) = args.weatherData {
            builder.add_weatherData(x);
        }
        if let Some(x) = args.nodeUpgradeData {
            builder.add_nodeUpgradeData(x);
        }
        if let Some(x) = args.nodeTypeData {
            builder.add_nodeTypeData(x);
        }
        if let Some(x) = args.foodData {
            builder.add_foodData(x);
        }
        if let Some(x) = args.foodMatData {
            builder.add_foodMatData(x);
        }
        if let Some(x) = args.drinkMatData {
            builder.add_drinkMatData(x);
        }
        if let Some(x) = args.alchemyRecipeData {
            builder.add_alchemyRecipeData(x);
        }
        if let Some(x) = args.craftGroupData {
            builder.add_craftGroupData(x);
        }
        if let Some(x) = args.livestockProduceData {
            builder.add_livestockProduceData(x);
        }
        if let Some(x) = args.craftItemData {
            builder.add_craftItemData(x);
        }
        if let Some(x) = args.buildingItemData {
            builder.add_buildingItemData(x);
        }
        if let Some(x) = args.itemTrapTagData {
            builder.add_itemTrapTagData(x);
        }
        if let Some(x) = args.itemTrapData {
            builder.add_itemTrapData(x);
        }
        if let Some(x) = args.mapData {
            builder.add_mapData(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn mapData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2MapData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2MapData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_MAPDATA, None)
        }
    }
    #[inline]
    pub fn itemTrapData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ItemTrapData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ItemTrapData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ITEMTRAPDATA, None)
        }
    }
    #[inline]
    pub fn itemTrapTagData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2ItemTrapTagData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ITEMTRAPTAGDATA, None)
        }
    }
    #[inline]
    pub fn buildingItemData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2BuildingItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2BuildingItemData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_BUILDINGITEMDATA, None)
        }
    }
    #[inline]
    pub fn craftItemData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2CraftItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2CraftItemData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_CRAFTITEMDATA, None)
        }
    }
    #[inline]
    pub fn livestockProduceData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2LivestockData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2LivestockData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_LIVESTOCKPRODUCEDATA, None)
        }
    }
    #[inline]
    pub fn craftGroupData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2CraftGroupData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2CraftGroupData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_CRAFTGROUPDATA, None)
        }
    }
    #[inline]
    pub fn alchemyRecipeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2AlchemyRecipeData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ALCHEMYRECIPEDATA, None)
        }
    }
    #[inline]
    pub fn drinkMatData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DrinkMatData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DrinkMatData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_DRINKMATDATA, None)
        }
    }
    #[inline]
    pub fn foodMatData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FoodMatData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FoodMatData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_FOODMATDATA, None)
        }
    }
    #[inline]
    pub fn foodData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FoodData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FoodData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_FOODDATA, None)
        }
    }
    #[inline]
    pub fn nodeTypeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeTypeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeTypeData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_NODETYPEDATA, None)
        }
    }
    #[inline]
    pub fn nodeUpgradeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2NodeUpgradeData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_NODEUPGRADEDATA, None)
        }
    }
    #[inline]
    pub fn weatherData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2WeatherData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2WeatherData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_WEATHERDATA, None)
        }
    }
    #[inline]
    pub fn stageData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2StageData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2StageData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_STAGEDATA, None)
        }
    }
    #[inline]
    pub fn zoneData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ZoneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ZoneData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ZONEDATA, None)
        }
    }
    #[inline]
    pub fn nodeBuffData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeBuffData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeBuffData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_NODEBUFFDATA, None)
        }
    }
    #[inline]
    pub fn rewardConfigData(&self) -> Option<clz_Torappu_SandboxV2RewardConfigGroupData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RewardConfigGroupData>>(
                    clz_Torappu_SandboxV2Data::VT_REWARDCONFIGDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn floatIconData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FloatIconData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FloatIconData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_FLOATICONDATA, None)
        }
    }
    #[inline]
    pub fn enemyRushTypeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2EnemyRushTypeData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ENEMYRUSHTYPEDATA, None)
        }
    }
    #[inline]
    pub fn rushEnemyData(&self) -> Option<clz_Torappu_SandboxV2BattleRushEnemyData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyData>>(
                    clz_Torappu_SandboxV2Data::VT_RUSHENEMYDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn gameConst(&self) -> Option<clz_Torappu_SandboxV2GameConst<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2GameConst>>(
                    clz_Torappu_SandboxV2Data::VT_GAMECONST,
                    None,
                )
        }
    }
    #[inline]
    pub fn basicConst(&self) -> Option<clz_Torappu_SandboxV2BasicConst<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BasicConst>>(
                    clz_Torappu_SandboxV2Data::VT_BASICCONST,
                    None,
                )
        }
    }
    #[inline]
    pub fn riftConst(&self) -> Option<clz_Torappu_SandboxV2RiftConst<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftConst>>(
                    clz_Torappu_SandboxV2Data::VT_RIFTCONST,
                    None,
                )
        }
    }
    #[inline]
    pub fn developmentConst(&self) -> Option<clz_Torappu_SandboxV2DevelopmentConst<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DevelopmentConst>>(
                    clz_Torappu_SandboxV2Data::VT_DEVELOPMENTCONST,
                    None,
                )
        }
    }
    #[inline]
    pub fn battleLoadingTips(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TipData<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TipData>>,
            >>(clz_Torappu_SandboxV2Data::VT_BATTLELOADINGTIPS, None)
        }
    }
    #[inline]
    pub fn runeDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RuneTable_PackedRuneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RuneTable_PackedRuneData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_RUNEDATAS, None)
        }
    }
    #[inline]
    pub fn itemRuneList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__list_clz_Torappu_LegacyInLevelRuneData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ITEMRUNELIST, None)
        }
    }
    #[inline]
    pub fn questData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_QUESTDATA, None)
        }
    }
    #[inline]
    pub fn npcData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NpcData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NpcData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_NPCDATA, None)
        }
    }
    #[inline]
    pub fn dialogData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DialogData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DialogData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_DIALOGDATA, None)
        }
    }
    #[inline]
    pub fn questLineData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestLineData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestLineData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_QUESTLINEDATA, None)
        }
    }
    #[inline]
    pub fn questLineStoryData(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(clz_Torappu_SandboxV2Data::VT_QUESTLINESTORYDATA, None)
        }
    }
    #[inline]
    pub fn guideQuestData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_GUIDEQUESTDATA, None)
        }
    }
    #[inline]
    pub fn developmentData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DevelopmentData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2DevelopmentData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_DEVELOPMENTDATA, None)
        }
    }
    #[inline]
    pub fn eventData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_EVENTDATA, None)
        }
    }
    #[inline]
    pub fn eventSceneData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventSceneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventSceneData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_EVENTSCENEDATA, None)
        }
    }
    #[inline]
    pub fn eventChoiceData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventChoiceData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2EventChoiceData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_EVENTCHOICEDATA, None)
        }
    }
    #[inline]
    pub fn expeditionData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ExpeditionData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ExpeditionData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_EXPEDITIONDATA, None)
        }
    }
    #[inline]
    pub fn eventEffectData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventEffectData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2EventEffectData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_EVENTEFFECTDATA, None)
        }
    }
    #[inline]
    pub fn shopGoodData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ShopGoodData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ShopGoodData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_SHOPGOODDATA, None)
        }
    }
    #[inline]
    pub fn shopDialogData(&self) -> Option<clz_Torappu_SandboxV2ShopDialogData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ShopDialogData>>(
                    clz_Torappu_SandboxV2Data::VT_SHOPDIALOGDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn logisticsData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LogisticsData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LogisticsData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_LOGISTICSDATA, None)
        }
    }
    #[inline]
    pub fn logisticsCharMapping(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_LOGISTICSCHARMAPPING, None)
        }
    }
    #[inline]
    pub fn materialKeywordData(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(clz_Torappu_SandboxV2Data::VT_MATERIALKEYWORDDATA, None)
        }
    }
    #[inline]
    pub fn monthRushData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2MonthRushData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2MonthRushData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_MONTHRUSHDATA, None)
        }
    }
    #[inline]
    pub fn riftTerrainParamData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_RIFTTERRAINPARAMDATA, None)
        }
    }
    #[inline]
    pub fn riftClimateParamData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_RIFTCLIMATEPARAMDATA, None)
        }
    }
    #[inline]
    pub fn riftEnemyParamData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_RIFTENEMYPARAMDATA, None)
        }
    }
    #[inline]
    pub fn riftSubTargetData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2RiftSubTargetData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_RIFTSUBTARGETDATA, None)
        }
    }
    #[inline]
    pub fn riftMainTargetData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2RiftMainTargetData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_RIFTMAINTARGETDATA, None)
        }
    }
    #[inline]
    pub fn riftGlobalEffectData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_RIFTGLOBALEFFECTDATA, None)
        }
    }
    #[inline]
    pub fn fixedRiftData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FixedRiftData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FixedRiftData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_FIXEDRIFTDATA, None)
        }
    }
    #[inline]
    pub fn riftTeamBuffData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_RIFTTEAMBUFFDATA, None)
        }
    }
    #[inline]
    pub fn riftDifficultyData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2RiftDifficultyData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_RIFTDIFFICULTYDATA, None)
        }
    }
    #[inline]
    pub fn riftRewardDisplayData(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string>>,
            >>(clz_Torappu_SandboxV2Data::VT_RIFTREWARDDISPLAYDATA, None)
        }
    }
    #[inline]
    pub fn enemyReplaceData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__list_dict__string__string<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__list_dict__string__string>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ENEMYREPLACEDATA, None)
        }
    }
    #[inline]
    pub fn archiveQuestData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2ArchiveQuestData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ARCHIVEQUESTDATA, None)
        }
    }
    #[inline]
    pub fn achievementData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2ArchiveAchievementData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ACHIEVEMENTDATA, None)
        }
    }
    #[inline]
    pub fn achievementTypeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ACHIEVEMENTTYPEDATA, None)
        }
    }
    #[inline]
    pub fn archiveQuestTypeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ARCHIVEQUESTTYPEDATA, None)
        }
    }
    #[inline]
    pub fn archiveMusicUnlockData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ARCHIVEMUSICUNLOCKDATA, None)
        }
    }
    #[inline]
    pub fn baseUpdate(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseUpdateData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseUpdateData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_BASEUPDATE, None)
        }
    }
    #[inline]
    pub fn developmentLineSegmentDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DevelopmentLineSegmentData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DevelopmentLineSegmentData>,
                >,
            >>(
                clz_Torappu_SandboxV2Data::VT_DEVELOPMENTLINESEGMENTDATAS,
                None,
            )
        }
    }
    #[inline]
    pub fn buildingNodeScoreData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_BUILDINGNODESCOREDATA, None)
        }
    }
    #[inline]
    pub fn seasonData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2SeasonData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2SeasonData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_SEASONDATA, None)
        }
    }
    #[inline]
    pub fn confirmIconData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ConfirmIconData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ConfirmIconData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_CONFIRMICONDATA, None)
        }
    }
    #[inline]
    pub fn shopUpdateTimeData(&self) -> Option<flatbuffers::Vector<'a, i64>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(
                    clz_Torappu_SandboxV2Data::VT_SHOPUPDATETIMEDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn tutorialData(&self) -> Option<clz_Torappu_SandboxV2TutorialData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2TutorialData>>(
                    clz_Torappu_SandboxV2Data::VT_TUTORIALDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn racingData(&self) -> Option<clz_Torappu_SandboxV2RacingData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacingData>>(
                    clz_Torappu_SandboxV2Data::VT_RACINGDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn challengeModeData(&self) -> Option<clz_Torappu_SandboxV2ChallengeModeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeModeData>>(
                    clz_Torappu_SandboxV2Data::VT_CHALLENGEMODEDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2Data<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2MapData>>>>("mapData", Self::VT_MAPDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ItemTrapData>>>>("itemTrapData", Self::VT_ITEMTRAPDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ItemTrapTagData>>>>("itemTrapTagData", Self::VT_ITEMTRAPTAGDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2BuildingItemData>>>>("buildingItemData", Self::VT_BUILDINGITEMDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2CraftItemData>>>>("craftItemData", Self::VT_CRAFTITEMDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2LivestockData>>>>("livestockProduceData", Self::VT_LIVESTOCKPRODUCEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2CraftGroupData>>>>("craftGroupData", Self::VT_CRAFTGROUPDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2AlchemyRecipeData>>>>("alchemyRecipeData", Self::VT_ALCHEMYRECIPEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DrinkMatData>>>>("drinkMatData", Self::VT_DRINKMATDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FoodMatData>>>>("foodMatData", Self::VT_FOODMATDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FoodData>>>>("foodData", Self::VT_FOODDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeTypeData>>>>("nodeTypeData", Self::VT_NODETYPEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeUpgradeData>>>>("nodeUpgradeData", Self::VT_NODEUPGRADEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2WeatherData>>>>("weatherData", Self::VT_WEATHERDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2StageData>>>>("stageData", Self::VT_STAGEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ZoneData>>>>("zoneData", Self::VT_ZONEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeBuffData>>>>("nodeBuffData", Self::VT_NODEBUFFDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RewardConfigGroupData>>("rewardConfigData", Self::VT_REWARDCONFIGDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FloatIconData>>>>("floatIconData", Self::VT_FLOATICONDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EnemyRushTypeData>>>>("enemyRushTypeData", Self::VT_ENEMYRUSHTYPEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyData>>("rushEnemyData", Self::VT_RUSHENEMYDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2GameConst>>("gameConst", Self::VT_GAMECONST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BasicConst>>("basicConst", Self::VT_BASICCONST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftConst>>("riftConst", Self::VT_RIFTCONST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DevelopmentConst>>("developmentConst", Self::VT_DEVELOPMENTCONST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_TipData>>>>("battleLoadingTips", Self::VT_BATTLELOADINGTIPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RuneTable_PackedRuneData>>>>("runeDatas", Self::VT_RUNEDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__list_clz_Torappu_LegacyInLevelRuneData>>>>("itemRuneList", Self::VT_ITEMRUNELIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestData>>>>("questData", Self::VT_QUESTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NpcData>>>>("npcData", Self::VT_NPCDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DialogData>>>>("dialogData", Self::VT_DIALOGDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestLineData>>>>("questLineData", Self::VT_QUESTLINEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>>>("questLineStoryData", Self::VT_QUESTLINESTORYDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData>>>>("guideQuestData", Self::VT_GUIDEQUESTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DevelopmentData>>>>("developmentData", Self::VT_DEVELOPMENTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventData>>>>("eventData", Self::VT_EVENTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventSceneData>>>>("eventSceneData", Self::VT_EVENTSCENEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventChoiceData>>>>("eventChoiceData", Self::VT_EVENTCHOICEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ExpeditionData>>>>("expeditionData", Self::VT_EXPEDITIONDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventEffectData>>>>("eventEffectData", Self::VT_EVENTEFFECTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ShopGoodData>>>>("shopGoodData", Self::VT_SHOPGOODDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ShopDialogData>>("shopDialogData", Self::VT_SHOPDIALOGDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LogisticsData>>>>("logisticsData", Self::VT_LOGISTICSDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData>>>>("logisticsCharMapping", Self::VT_LOGISTICSCHARMAPPING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>>>("materialKeywordData", Self::VT_MATERIALKEYWORDDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2MonthRushData>>>>("monthRushData", Self::VT_MONTHRUSHDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData>>>>("riftTerrainParamData", Self::VT_RIFTTERRAINPARAMDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData>>>>("riftClimateParamData", Self::VT_RIFTCLIMATEPARAMDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData>>>>("riftEnemyParamData", Self::VT_RIFTENEMYPARAMDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftSubTargetData>>>>("riftSubTargetData", Self::VT_RIFTSUBTARGETDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftMainTargetData>>>>("riftMainTargetData", Self::VT_RIFTMAINTARGETDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData>>>>("riftGlobalEffectData", Self::VT_RIFTGLOBALEFFECTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FixedRiftData>>>>("fixedRiftData", Self::VT_FIXEDRIFTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData>>>>("riftTeamBuffData", Self::VT_RIFTTEAMBUFFDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftDifficultyData>>>>("riftDifficultyData", Self::VT_RIFTDIFFICULTYDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__list_string>>>>("riftRewardDisplayData", Self::VT_RIFTREWARDDISPLAYDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__list_dict__string__string>>>>("enemyReplaceData", Self::VT_ENEMYREPLACEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ArchiveQuestData>>>>("archiveQuestData", Self::VT_ARCHIVEQUESTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ArchiveAchievementData>>>>("achievementData", Self::VT_ACHIEVEMENTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData>>>>("achievementTypeData", Self::VT_ACHIEVEMENTTYPEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData>>>>("archiveQuestTypeData", Self::VT_ARCHIVEQUESTTYPEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData>>>>("archiveMusicUnlockData", Self::VT_ARCHIVEMUSICUNLOCKDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseUpdateData>>>>("baseUpdate", Self::VT_BASEUPDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DevelopmentLineSegmentData>>>>("developmentLineSegmentDatas", Self::VT_DEVELOPMENTLINESEGMENTDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData>>>>("buildingNodeScoreData", Self::VT_BUILDINGNODESCOREDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2SeasonData>>>>("seasonData", Self::VT_SEASONDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ConfirmIconData>>>>("confirmIconData", Self::VT_CONFIRMICONDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("shopUpdateTimeData", Self::VT_SHOPUPDATETIMEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2TutorialData>>("tutorialData", Self::VT_TUTORIALDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacingData>>("racingData", Self::VT_RACINGDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeModeData>>("challengeModeData", Self::VT_CHALLENGEMODEDATA, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2DataArgs<'a> {
    pub mapData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2MapData<'a>>,
            >,
        >,
    >,
    pub itemTrapData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ItemTrapData<'a>>,
            >,
        >,
    >,
    pub itemTrapTagData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'a>,
                >,
            >,
        >,
    >,
    pub buildingItemData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2BuildingItemData<'a>,
                >,
            >,
        >,
    >,
    pub craftItemData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2CraftItemData<'a>>,
            >,
        >,
    >,
    pub livestockProduceData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2LivestockData<'a>>,
            >,
        >,
    >,
    pub craftGroupData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2CraftGroupData<'a>>,
            >,
        >,
    >,
    pub alchemyRecipeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'a>,
                >,
            >,
        >,
    >,
    pub drinkMatData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DrinkMatData<'a>>,
            >,
        >,
    >,
    pub foodMatData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FoodMatData<'a>>,
            >,
        >,
    >,
    pub foodData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FoodData<'a>>,
            >,
        >,
    >,
    pub nodeTypeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeTypeData<'a>>,
            >,
        >,
    >,
    pub nodeUpgradeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'a>,
                >,
            >,
        >,
    >,
    pub weatherData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2WeatherData<'a>>,
            >,
        >,
    >,
    pub stageData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2StageData<'a>>,
            >,
        >,
    >,
    pub zoneData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ZoneData<'a>>,
            >,
        >,
    >,
    pub nodeBuffData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeBuffData<'a>>,
            >,
        >,
    >,
    pub rewardConfigData:
        Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardConfigGroupData<'a>>>,
    pub floatIconData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FloatIconData<'a>>,
            >,
        >,
    >,
    pub enemyRushTypeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'a>,
                >,
            >,
        >,
    >,
    pub rushEnemyData: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyData<'a>>>,
    pub gameConst: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2GameConst<'a>>>,
    pub basicConst: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2BasicConst<'a>>>,
    pub riftConst: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftConst<'a>>>,
    pub developmentConst: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentConst<'a>>>,
    pub battleLoadingTips: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TipData<'a>>>,
        >,
    >,
    pub runeDatas: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RuneTable_PackedRuneData<'a>,
                >,
            >,
        >,
    >,
    pub itemRuneList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a>,
                >,
            >,
        >,
    >,
    pub questData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestData<'a>>,
            >,
        >,
    >,
    pub npcData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NpcData<'a>>,
            >,
        >,
    >,
    pub dialogData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DialogData<'a>>,
            >,
        >,
    >,
    pub questLineData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestLineData<'a>>,
            >,
        >,
    >,
    pub questLineStoryData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>,
        >,
    >,
    pub guideQuestData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData<'a>>,
            >,
        >,
    >,
    pub developmentData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2DevelopmentData<'a>,
                >,
            >,
        >,
    >,
    pub eventData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventData<'a>>,
            >,
        >,
    >,
    pub eventSceneData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventSceneData<'a>>,
            >,
        >,
    >,
    pub eventChoiceData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2EventChoiceData<'a>,
                >,
            >,
        >,
    >,
    pub expeditionData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ExpeditionData<'a>>,
            >,
        >,
    >,
    pub eventEffectData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2EventEffectData<'a>,
                >,
            >,
        >,
    >,
    pub shopGoodData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ShopGoodData<'a>>,
            >,
        >,
    >,
    pub shopDialogData: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ShopDialogData<'a>>>,
    pub logisticsData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LogisticsData<'a>>,
            >,
        >,
    >,
    pub logisticsCharMapping: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a>,
                >,
            >,
        >,
    >,
    pub materialKeywordData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>,
        >,
    >,
    pub monthRushData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2MonthRushData<'a>>,
            >,
        >,
    >,
    pub riftTerrainParamData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'a>>,
            >,
        >,
    >,
    pub riftClimateParamData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'a>>,
            >,
        >,
    >,
    pub riftEnemyParamData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'a>>,
            >,
        >,
    >,
    pub riftSubTargetData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'a>,
                >,
            >,
        >,
    >,
    pub riftMainTargetData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'a>,
                >,
            >,
        >,
    >,
    pub riftGlobalEffectData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'a>,
                >,
            >,
        >,
    >,
    pub fixedRiftData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FixedRiftData<'a>>,
            >,
        >,
    >,
    pub riftTeamBuffData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'a>,
                >,
            >,
        >,
    >,
    pub riftDifficultyData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'a>,
                >,
            >,
        >,
    >,
    pub riftRewardDisplayData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string<'a>>>,
        >,
    >,
    pub enemyReplaceData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__list_dict__string__string<'a>>,
            >,
        >,
    >,
    pub archiveQuestData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'a>,
                >,
            >,
        >,
    >,
    pub achievementData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'a>,
                >,
            >,
        >,
    >,
    pub achievementTypeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a>,
                >,
            >,
        >,
    >,
    pub archiveQuestTypeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'a>,
                >,
            >,
        >,
    >,
    pub archiveMusicUnlockData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a>,
                >,
            >,
        >,
    >,
    pub baseUpdate: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseUpdateData<'a>>,
            >,
        >,
    >,
    pub developmentLineSegmentDatas: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DevelopmentLineSegmentData<'a>>,
            >,
        >,
    >,
    pub buildingNodeScoreData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'a>,
                >,
            >,
        >,
    >,
    pub seasonData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2SeasonData<'a>>,
            >,
        >,
    >,
    pub confirmIconData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ConfirmIconData<'a>>,
            >,
        >,
    >,
    pub shopUpdateTimeData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub tutorialData: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialData<'a>>>,
    pub racingData: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingData<'a>>>,
    pub challengeModeData:
        Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeData<'a>>>,
}
impl<'a> Default for clz_Torappu_SandboxV2DataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2DataArgs {
            mapData: None,
            itemTrapData: None,
            itemTrapTagData: None,
            buildingItemData: None,
            craftItemData: None,
            livestockProduceData: None,
            craftGroupData: None,
            alchemyRecipeData: None,
            drinkMatData: None,
            foodMatData: None,
            foodData: None,
            nodeTypeData: None,
            nodeUpgradeData: None,
            weatherData: None,
            stageData: None,
            zoneData: None,
            nodeBuffData: None,
            rewardConfigData: None,
            floatIconData: None,
            enemyRushTypeData: None,
            rushEnemyData: None,
            gameConst: None,
            basicConst: None,
            riftConst: None,
            developmentConst: None,
            battleLoadingTips: None,
            runeDatas: None,
            itemRuneList: None,
            questData: None,
            npcData: None,
            dialogData: None,
            questLineData: None,
            questLineStoryData: None,
            guideQuestData: None,
            developmentData: None,
            eventData: None,
            eventSceneData: None,
            eventChoiceData: None,
            expeditionData: None,
            eventEffectData: None,
            shopGoodData: None,
            shopDialogData: None,
            logisticsData: None,
            logisticsCharMapping: None,
            materialKeywordData: None,
            monthRushData: None,
            riftTerrainParamData: None,
            riftClimateParamData: None,
            riftEnemyParamData: None,
            riftSubTargetData: None,
            riftMainTargetData: None,
            riftGlobalEffectData: None,
            fixedRiftData: None,
            riftTeamBuffData: None,
            riftDifficultyData: None,
            riftRewardDisplayData: None,
            enemyReplaceData: None,
            archiveQuestData: None,
            achievementData: None,
            achievementTypeData: None,
            archiveQuestTypeData: None,
            archiveMusicUnlockData: None,
            baseUpdate: None,
            developmentLineSegmentDatas: None,
            buildingNodeScoreData: None,
            seasonData: None,
            confirmIconData: None,
            shopUpdateTimeData: None,
            tutorialData: None,
            racingData: None,
            challengeModeData: None,
        }
    }
}

pub struct clz_Torappu_SandboxV2DataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2DataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_mapData(
        &mut self,
        mapData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2MapData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_MAPDATA,
            mapData,
        );
    }
    #[inline]
    pub fn add_itemTrapData(
        &mut self,
        itemTrapData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ItemTrapData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ITEMTRAPDATA,
            itemTrapData,
        );
    }
    #[inline]
    pub fn add_itemTrapTagData(
        &mut self,
        itemTrapTagData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ITEMTRAPTAGDATA,
            itemTrapTagData,
        );
    }
    #[inline]
    pub fn add_buildingItemData(
        &mut self,
        buildingItemData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2BuildingItemData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_BUILDINGITEMDATA,
            buildingItemData,
        );
    }
    #[inline]
    pub fn add_craftItemData(
        &mut self,
        craftItemData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2CraftItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_CRAFTITEMDATA,
            craftItemData,
        );
    }
    #[inline]
    pub fn add_livestockProduceData(
        &mut self,
        livestockProduceData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2LivestockData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_LIVESTOCKPRODUCEDATA,
            livestockProduceData,
        );
    }
    #[inline]
    pub fn add_craftGroupData(
        &mut self,
        craftGroupData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2CraftGroupData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_CRAFTGROUPDATA,
            craftGroupData,
        );
    }
    #[inline]
    pub fn add_alchemyRecipeData(
        &mut self,
        alchemyRecipeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ALCHEMYRECIPEDATA,
            alchemyRecipeData,
        );
    }
    #[inline]
    pub fn add_drinkMatData(
        &mut self,
        drinkMatData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DrinkMatData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_DRINKMATDATA,
            drinkMatData,
        );
    }
    #[inline]
    pub fn add_foodMatData(
        &mut self,
        foodMatData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FoodMatData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_FOODMATDATA,
            foodMatData,
        );
    }
    #[inline]
    pub fn add_foodData(
        &mut self,
        foodData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FoodData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_FOODDATA,
            foodData,
        );
    }
    #[inline]
    pub fn add_nodeTypeData(
        &mut self,
        nodeTypeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeTypeData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_NODETYPEDATA,
            nodeTypeData,
        );
    }
    #[inline]
    pub fn add_nodeUpgradeData(
        &mut self,
        nodeUpgradeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_NODEUPGRADEDATA,
            nodeUpgradeData,
        );
    }
    #[inline]
    pub fn add_weatherData(
        &mut self,
        weatherData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2WeatherData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_WEATHERDATA,
            weatherData,
        );
    }
    #[inline]
    pub fn add_stageData(
        &mut self,
        stageData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2StageData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_STAGEDATA,
            stageData,
        );
    }
    #[inline]
    pub fn add_zoneData(
        &mut self,
        zoneData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ZoneData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ZONEDATA,
            zoneData,
        );
    }
    #[inline]
    pub fn add_nodeBuffData(
        &mut self,
        nodeBuffData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeBuffData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_NODEBUFFDATA,
            nodeBuffData,
        );
    }
    #[inline]
    pub fn add_rewardConfigData(
        &mut self,
        rewardConfigData: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardConfigGroupData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardConfigGroupData>>(
                clz_Torappu_SandboxV2Data::VT_REWARDCONFIGDATA,
                rewardConfigData,
            );
    }
    #[inline]
    pub fn add_floatIconData(
        &mut self,
        floatIconData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FloatIconData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_FLOATICONDATA,
            floatIconData,
        );
    }
    #[inline]
    pub fn add_enemyRushTypeData(
        &mut self,
        enemyRushTypeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ENEMYRUSHTYPEDATA,
            enemyRushTypeData,
        );
    }
    #[inline]
    pub fn add_rushEnemyData(
        &mut self,
        rushEnemyData: flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyData>>(
                clz_Torappu_SandboxV2Data::VT_RUSHENEMYDATA,
                rushEnemyData,
            );
    }
    #[inline]
    pub fn add_gameConst(
        &mut self,
        gameConst: flatbuffers::WIPOffset<clz_Torappu_SandboxV2GameConst<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2GameConst>>(
                clz_Torappu_SandboxV2Data::VT_GAMECONST,
                gameConst,
            );
    }
    #[inline]
    pub fn add_basicConst(
        &mut self,
        basicConst: flatbuffers::WIPOffset<clz_Torappu_SandboxV2BasicConst<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2BasicConst>>(
                clz_Torappu_SandboxV2Data::VT_BASICCONST,
                basicConst,
            );
    }
    #[inline]
    pub fn add_riftConst(
        &mut self,
        riftConst: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftConst<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftConst>>(
                clz_Torappu_SandboxV2Data::VT_RIFTCONST,
                riftConst,
            );
    }
    #[inline]
    pub fn add_developmentConst(
        &mut self,
        developmentConst: flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentConst<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentConst>>(
                clz_Torappu_SandboxV2Data::VT_DEVELOPMENTCONST,
                developmentConst,
            );
    }
    #[inline]
    pub fn add_battleLoadingTips(
        &mut self,
        battleLoadingTips: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_TipData<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_BATTLELOADINGTIPS,
            battleLoadingTips,
        );
    }
    #[inline]
    pub fn add_runeDatas(
        &mut self,
        runeDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RuneTable_PackedRuneData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_RUNEDATAS,
            runeDatas,
        );
    }
    #[inline]
    pub fn add_itemRuneList(
        &mut self,
        itemRuneList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_clz_Torappu_LegacyInLevelRuneData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ITEMRUNELIST,
            itemRuneList,
        );
    }
    #[inline]
    pub fn add_questData(
        &mut self,
        questData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_QUESTDATA,
            questData,
        );
    }
    #[inline]
    pub fn add_npcData(
        &mut self,
        npcData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NpcData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_NPCDATA,
            npcData,
        );
    }
    #[inline]
    pub fn add_dialogData(
        &mut self,
        dialogData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DialogData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_DIALOGDATA,
            dialogData,
        );
    }
    #[inline]
    pub fn add_questLineData(
        &mut self,
        questLineData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestLineData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_QUESTLINEDATA,
            questLineData,
        );
    }
    #[inline]
    pub fn add_questLineStoryData(
        &mut self,
        questLineStoryData: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_QUESTLINESTORYDATA,
            questLineStoryData,
        );
    }
    #[inline]
    pub fn add_guideQuestData(
        &mut self,
        guideQuestData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_GUIDEQUESTDATA,
            guideQuestData,
        );
    }
    #[inline]
    pub fn add_developmentData(
        &mut self,
        developmentData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2DevelopmentData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_DEVELOPMENTDATA,
            developmentData,
        );
    }
    #[inline]
    pub fn add_eventData(
        &mut self,
        eventData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_EVENTDATA,
            eventData,
        );
    }
    #[inline]
    pub fn add_eventSceneData(
        &mut self,
        eventSceneData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventSceneData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_EVENTSCENEDATA,
            eventSceneData,
        );
    }
    #[inline]
    pub fn add_eventChoiceData(
        &mut self,
        eventChoiceData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2EventChoiceData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_EVENTCHOICEDATA,
            eventChoiceData,
        );
    }
    #[inline]
    pub fn add_expeditionData(
        &mut self,
        expeditionData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ExpeditionData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_EXPEDITIONDATA,
            expeditionData,
        );
    }
    #[inline]
    pub fn add_eventEffectData(
        &mut self,
        eventEffectData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2EventEffectData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_EVENTEFFECTDATA,
            eventEffectData,
        );
    }
    #[inline]
    pub fn add_shopGoodData(
        &mut self,
        shopGoodData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ShopGoodData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_SHOPGOODDATA,
            shopGoodData,
        );
    }
    #[inline]
    pub fn add_shopDialogData(
        &mut self,
        shopDialogData: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ShopDialogData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ShopDialogData>>(
                clz_Torappu_SandboxV2Data::VT_SHOPDIALOGDATA,
                shopDialogData,
            );
    }
    #[inline]
    pub fn add_logisticsData(
        &mut self,
        logisticsData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LogisticsData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_LOGISTICSDATA,
            logisticsData,
        );
    }
    #[inline]
    pub fn add_logisticsCharMapping(
        &mut self,
        logisticsCharMapping: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_LOGISTICSCHARMAPPING,
            logisticsCharMapping,
        );
    }
    #[inline]
    pub fn add_materialKeywordData(
        &mut self,
        materialKeywordData: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_MATERIALKEYWORDDATA,
            materialKeywordData,
        );
    }
    #[inline]
    pub fn add_monthRushData(
        &mut self,
        monthRushData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2MonthRushData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_MONTHRUSHDATA,
            monthRushData,
        );
    }
    #[inline]
    pub fn add_riftTerrainParamData(
        &mut self,
        riftTerrainParamData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_RIFTTERRAINPARAMDATA,
            riftTerrainParamData,
        );
    }
    #[inline]
    pub fn add_riftClimateParamData(
        &mut self,
        riftClimateParamData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_RIFTCLIMATEPARAMDATA,
            riftClimateParamData,
        );
    }
    #[inline]
    pub fn add_riftEnemyParamData(
        &mut self,
        riftEnemyParamData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_RIFTENEMYPARAMDATA,
            riftEnemyParamData,
        );
    }
    #[inline]
    pub fn add_riftSubTargetData(
        &mut self,
        riftSubTargetData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_RIFTSUBTARGETDATA,
            riftSubTargetData,
        );
    }
    #[inline]
    pub fn add_riftMainTargetData(
        &mut self,
        riftMainTargetData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_RIFTMAINTARGETDATA,
            riftMainTargetData,
        );
    }
    #[inline]
    pub fn add_riftGlobalEffectData(
        &mut self,
        riftGlobalEffectData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_RIFTGLOBALEFFECTDATA,
            riftGlobalEffectData,
        );
    }
    #[inline]
    pub fn add_fixedRiftData(
        &mut self,
        fixedRiftData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FixedRiftData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_FIXEDRIFTDATA,
            fixedRiftData,
        );
    }
    #[inline]
    pub fn add_riftTeamBuffData(
        &mut self,
        riftTeamBuffData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_RIFTTEAMBUFFDATA,
            riftTeamBuffData,
        );
    }
    #[inline]
    pub fn add_riftDifficultyData(
        &mut self,
        riftDifficultyData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_RIFTDIFFICULTYDATA,
            riftDifficultyData,
        );
    }
    #[inline]
    pub fn add_riftRewardDisplayData(
        &mut self,
        riftRewardDisplayData: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__list_string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_RIFTREWARDDISPLAYDATA,
            riftRewardDisplayData,
        );
    }
    #[inline]
    pub fn add_enemyReplaceData(
        &mut self,
        enemyReplaceData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__list_dict__string__string<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ENEMYREPLACEDATA,
            enemyReplaceData,
        );
    }
    #[inline]
    pub fn add_archiveQuestData(
        &mut self,
        archiveQuestData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ARCHIVEQUESTDATA,
            archiveQuestData,
        );
    }
    #[inline]
    pub fn add_achievementData(
        &mut self,
        achievementData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ACHIEVEMENTDATA,
            achievementData,
        );
    }
    #[inline]
    pub fn add_achievementTypeData(
        &mut self,
        achievementTypeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ACHIEVEMENTTYPEDATA,
            achievementTypeData,
        );
    }
    #[inline]
    pub fn add_archiveQuestTypeData(
        &mut self,
        archiveQuestTypeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ARCHIVEQUESTTYPEDATA,
            archiveQuestTypeData,
        );
    }
    #[inline]
    pub fn add_archiveMusicUnlockData(
        &mut self,
        archiveMusicUnlockData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ARCHIVEMUSICUNLOCKDATA,
            archiveMusicUnlockData,
        );
    }
    #[inline]
    pub fn add_baseUpdate(
        &mut self,
        baseUpdate: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseUpdateData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_BASEUPDATE,
            baseUpdate,
        );
    }
    #[inline]
    pub fn add_developmentLineSegmentDatas(
        &mut self,
        developmentLineSegmentDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DevelopmentLineSegmentData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_DEVELOPMENTLINESEGMENTDATAS,
            developmentLineSegmentDatas,
        );
    }
    #[inline]
    pub fn add_buildingNodeScoreData(
        &mut self,
        buildingNodeScoreData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_BUILDINGNODESCOREDATA,
            buildingNodeScoreData,
        );
    }
    #[inline]
    pub fn add_seasonData(
        &mut self,
        seasonData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2SeasonData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_SEASONDATA,
            seasonData,
        );
    }
    #[inline]
    pub fn add_confirmIconData(
        &mut self,
        confirmIconData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ConfirmIconData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_CONFIRMICONDATA,
            confirmIconData,
        );
    }
    #[inline]
    pub fn add_shopUpdateTimeData(
        &mut self,
        shopUpdateTimeData: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i64>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_SHOPUPDATETIMEDATA,
            shopUpdateTimeData,
        );
    }
    #[inline]
    pub fn add_tutorialData(
        &mut self,
        tutorialData: flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialData>>(
                clz_Torappu_SandboxV2Data::VT_TUTORIALDATA,
                tutorialData,
            );
    }
    #[inline]
    pub fn add_racingData(
        &mut self,
        racingData: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingData>>(
                clz_Torappu_SandboxV2Data::VT_RACINGDATA,
                racingData,
            );
    }
    #[inline]
    pub fn add_challengeModeData(
        &mut self,
        challengeModeData: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeData>>(
                clz_Torappu_SandboxV2Data::VT_CHALLENGEMODEDATA,
                challengeModeData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2DataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2DataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2Data<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2Data<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2Data");
        ds.field("mapData", &self.mapData());
        ds.field("itemTrapData", &self.itemTrapData());
        ds.field("itemTrapTagData", &self.itemTrapTagData());
        ds.field("buildingItemData", &self.buildingItemData());
        ds.field("craftItemData", &self.craftItemData());
        ds.field("livestockProduceData", &self.livestockProduceData());
        ds.field("craftGroupData", &self.craftGroupData());
        ds.field("alchemyRecipeData", &self.alchemyRecipeData());
        ds.field("drinkMatData", &self.drinkMatData());
        ds.field("foodMatData", &self.foodMatData());
        ds.field("foodData", &self.foodData());
        ds.field("nodeTypeData", &self.nodeTypeData());
        ds.field("nodeUpgradeData", &self.nodeUpgradeData());
        ds.field("weatherData", &self.weatherData());
        ds.field("stageData", &self.stageData());
        ds.field("zoneData", &self.zoneData());
        ds.field("nodeBuffData", &self.nodeBuffData());
        ds.field("rewardConfigData", &self.rewardConfigData());
        ds.field("floatIconData", &self.floatIconData());
        ds.field("enemyRushTypeData", &self.enemyRushTypeData());
        ds.field("rushEnemyData", &self.rushEnemyData());
        ds.field("gameConst", &self.gameConst());
        ds.field("basicConst", &self.basicConst());
        ds.field("riftConst", &self.riftConst());
        ds.field("developmentConst", &self.developmentConst());
        ds.field("battleLoadingTips", &self.battleLoadingTips());
        ds.field("runeDatas", &self.runeDatas());
        ds.field("itemRuneList", &self.itemRuneList());
        ds.field("questData", &self.questData());
        ds.field("npcData", &self.npcData());
        ds.field("dialogData", &self.dialogData());
        ds.field("questLineData", &self.questLineData());
        ds.field("questLineStoryData", &self.questLineStoryData());
        ds.field("guideQuestData", &self.guideQuestData());
        ds.field("developmentData", &self.developmentData());
        ds.field("eventData", &self.eventData());
        ds.field("eventSceneData", &self.eventSceneData());
        ds.field("eventChoiceData", &self.eventChoiceData());
        ds.field("expeditionData", &self.expeditionData());
        ds.field("eventEffectData", &self.eventEffectData());
        ds.field("shopGoodData", &self.shopGoodData());
        ds.field("shopDialogData", &self.shopDialogData());
        ds.field("logisticsData", &self.logisticsData());
        ds.field("logisticsCharMapping", &self.logisticsCharMapping());
        ds.field("materialKeywordData", &self.materialKeywordData());
        ds.field("monthRushData", &self.monthRushData());
        ds.field("riftTerrainParamData", &self.riftTerrainParamData());
        ds.field("riftClimateParamData", &self.riftClimateParamData());
        ds.field("riftEnemyParamData", &self.riftEnemyParamData());
        ds.field("riftSubTargetData", &self.riftSubTargetData());
        ds.field("riftMainTargetData", &self.riftMainTargetData());
        ds.field("riftGlobalEffectData", &self.riftGlobalEffectData());
        ds.field("fixedRiftData", &self.fixedRiftData());
        ds.field("riftTeamBuffData", &self.riftTeamBuffData());
        ds.field("riftDifficultyData", &self.riftDifficultyData());
        ds.field("riftRewardDisplayData", &self.riftRewardDisplayData());
        ds.field("enemyReplaceData", &self.enemyReplaceData());
        ds.field("archiveQuestData", &self.archiveQuestData());
        ds.field("achievementData", &self.achievementData());
        ds.field("achievementTypeData", &self.achievementTypeData());
        ds.field("archiveQuestTypeData", &self.archiveQuestTypeData());
        ds.field("archiveMusicUnlockData", &self.archiveMusicUnlockData());
        ds.field("baseUpdate", &self.baseUpdate());
        ds.field(
            "developmentLineSegmentDatas",
            &self.developmentLineSegmentDatas(),
        );
        ds.field("buildingNodeScoreData", &self.buildingNodeScoreData());
        ds.field("seasonData", &self.seasonData());
        ds.field("confirmIconData", &self.confirmIconData());
        ds.field("shopUpdateTimeData", &self.shopUpdateTimeData());
        ds.field("tutorialData", &self.tutorialData());
        ds.field("racingData", &self.racingData());
        ds.field("challengeModeData", &self.challengeModeData());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxV2DataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2Data<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2Data<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2Data<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2Data<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2Data { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2DataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2Data<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2DataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2Data::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2Data) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2Data<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2Data>>(
                    dict__string__clz_Torappu_SandboxV2Data::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2Data<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2Data>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2DataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2Data<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2DataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2DataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxV2DataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2DataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2Data::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2Data<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2Data>>(
                dict__string__clz_Torappu_SandboxV2Data::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2DataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2DataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2Data<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_SandboxV2Data::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2Data<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2Data");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxPermDetailDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxPermDetailData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxPermDetailData<'a> {
    type Inner = clz_Torappu_SandboxPermDetailData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxPermDetailData<'a> {
    pub const VT_SANDBOX_V2: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxPermDetailData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxPermDetailDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermDetailData<'bldr>> {
        let mut builder = clz_Torappu_SandboxPermDetailDataBuilder::new(_fbb);
        if let Some(x) = args.SANDBOX_V2 {
            builder.add_SANDBOX_V2(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn SANDBOX_V2(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2Data<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2Data>,
                >,
            >>(clz_Torappu_SandboxPermDetailData::VT_SANDBOX_V2, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxPermDetailData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2Data>,
                >,
            >>("SANDBOX_V2", Self::VT_SANDBOX_V2, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxPermDetailDataArgs<'a> {
    pub SANDBOX_V2: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2Data<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SandboxPermDetailDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxPermDetailDataArgs { SANDBOX_V2: None }
    }
}

pub struct clz_Torappu_SandboxPermDetailDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxPermDetailDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_SANDBOX_V2(
        &mut self,
        SANDBOX_V2: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2Data<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermDetailData::VT_SANDBOX_V2,
            SANDBOX_V2,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxPermDetailDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxPermDetailDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermDetailData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxPermDetailData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxPermDetailData");
        ds.field("SANDBOX_V2", &self.SANDBOX_V2());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxPermItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxPermItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxPermItemData<'a> {
    type Inner = clz_Torappu_SandboxPermItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxPermItemData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_ITEMTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_ITEMNAME: flatbuffers::VOffsetT = 8;
    pub const VT_ITEMUSAGE: flatbuffers::VOffsetT = 10;
    pub const VT_ITEMDESC: flatbuffers::VOffsetT = 12;
    pub const VT_ITEMRARITY: flatbuffers::VOffsetT = 14;
    pub const VT_SORTID: flatbuffers::VOffsetT = 16;
    pub const VT_OBTAINAPPROACH: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxPermItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxPermItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermItemData<'bldr>> {
        let mut builder = clz_Torappu_SandboxPermItemDataBuilder::new(_fbb);
        if let Some(x) = args.obtainApproach {
            builder.add_obtainApproach(x);
        }
        builder.add_sortId(args.sortId);
        builder.add_itemRarity(args.itemRarity);
        if let Some(x) = args.itemDesc {
            builder.add_itemDesc(x);
        }
        if let Some(x) = args.itemUsage {
            builder.add_itemUsage(x);
        }
        if let Some(x) = args.itemName {
            builder.add_itemName(x);
        }
        builder.add_itemType(args.itemType);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermItemData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn itemType(&self) -> enum__Torappu_SandboxPermItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxPermItemType>(
                    clz_Torappu_SandboxPermItemData::VT_ITEMTYPE,
                    Some(enum__Torappu_SandboxPermItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn itemName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermItemData::VT_ITEMNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn itemUsage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermItemData::VT_ITEMUSAGE,
                None,
            )
        }
    }
    #[inline]
    pub fn itemDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermItemData::VT_ITEMDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn itemRarity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxPermItemData::VT_ITEMRARITY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxPermItemData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn obtainApproach(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermItemData::VT_OBTAINAPPROACH,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxPermItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<enum__Torappu_SandboxPermItemType>("itemType", Self::VT_ITEMTYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "itemName",
                Self::VT_ITEMNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "itemUsage",
                Self::VT_ITEMUSAGE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "itemDesc",
                Self::VT_ITEMDESC,
                false,
            )?
            .visit_field::<i32>("itemRarity", Self::VT_ITEMRARITY, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "obtainApproach",
                Self::VT_OBTAINAPPROACH,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxPermItemDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemType: enum__Torappu_SandboxPermItemType,
    pub itemName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemUsage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemRarity: i32,
    pub sortId: i32,
    pub obtainApproach: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxPermItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxPermItemDataArgs {
            itemId: None,
            itemType: enum__Torappu_SandboxPermItemType::NONE,
            itemName: None,
            itemUsage: None,
            itemDesc: None,
            itemRarity: 0,
            sortId: 0,
            obtainApproach: None,
        }
    }
}

pub struct clz_Torappu_SandboxPermItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxPermItemDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermItemData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_itemType(&mut self, itemType: enum__Torappu_SandboxPermItemType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxPermItemType>(
            clz_Torappu_SandboxPermItemData::VT_ITEMTYPE,
            itemType,
            enum__Torappu_SandboxPermItemType::NONE,
        );
    }
    #[inline]
    pub fn add_itemName(&mut self, itemName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermItemData::VT_ITEMNAME,
            itemName,
        );
    }
    #[inline]
    pub fn add_itemUsage(&mut self, itemUsage: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermItemData::VT_ITEMUSAGE,
            itemUsage,
        );
    }
    #[inline]
    pub fn add_itemDesc(&mut self, itemDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermItemData::VT_ITEMDESC,
            itemDesc,
        );
    }
    #[inline]
    pub fn add_itemRarity(&mut self, itemRarity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxPermItemData::VT_ITEMRARITY,
            itemRarity,
            0,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxPermItemData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_obtainApproach(&mut self, obtainApproach: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermItemData::VT_OBTAINAPPROACH,
            obtainApproach,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxPermItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxPermItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxPermItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxPermItemData");
        ds.field("itemId", &self.itemId());
        ds.field("itemType", &self.itemType());
        ds.field("itemName", &self.itemName());
        ds.field("itemUsage", &self.itemUsage());
        ds.field("itemDesc", &self.itemDesc());
        ds.field("itemRarity", &self.itemRarity());
        ds.field("sortId", &self.sortId());
        ds.field("obtainApproach", &self.obtainApproach());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxPermItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxPermItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxPermItemData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxPermItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxPermItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxPermItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxPermItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxPermItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxPermItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxPermItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxPermItemData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxPermItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxPermItemData>>(
                    dict__string__clz_Torappu_SandboxPermItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxPermItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxPermItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxPermItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxPermItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxPermItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxPermItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxPermItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxPermItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxPermItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxPermItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxPermItemData>>(
                dict__string__clz_Torappu_SandboxPermItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxPermItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxPermItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxPermItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxPermItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxPermItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxPermItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxPermTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxPermTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxPermTable<'a> {
    type Inner = clz_Torappu_SandboxPermTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxPermTable<'a> {
    pub const VT_BASICINFO: flatbuffers::VOffsetT = 4;
    pub const VT_DETAIL: flatbuffers::VOffsetT = 6;
    pub const VT_ITEMDATA: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxPermTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxPermTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermTable<'bldr>> {
        let mut builder = clz_Torappu_SandboxPermTableBuilder::new(_fbb);
        if let Some(x) = args.itemData {
            builder.add_itemData(x);
        }
        if let Some(x) = args.detail {
            builder.add_detail(x);
        }
        if let Some(x) = args.basicInfo {
            builder.add_basicInfo(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn basicInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxPermBasicData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxPermBasicData>,
                >,
            >>(clz_Torappu_SandboxPermTable::VT_BASICINFO, None)
        }
    }
    #[inline]
    pub fn detail(&self) -> Option<clz_Torappu_SandboxPermDetailData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxPermDetailData>>(
                    clz_Torappu_SandboxPermTable::VT_DETAIL,
                    None,
                )
        }
    }
    #[inline]
    pub fn itemData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxPermItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxPermItemData>,
                >,
            >>(clz_Torappu_SandboxPermTable::VT_ITEMDATA, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxPermTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxPermBasicData>,
                >,
            >>("basicInfo", Self::VT_BASICINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxPermDetailData>>(
                "detail",
                Self::VT_DETAIL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxPermItemData>,
                >,
            >>("itemData", Self::VT_ITEMDATA, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxPermTableArgs<'a> {
    pub basicInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxPermBasicData<'a>>,
            >,
        >,
    >,
    pub detail: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxPermDetailData<'a>>>,
    pub itemData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxPermItemData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SandboxPermTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxPermTableArgs {
            basicInfo: None,
            detail: None,
            itemData: None,
        }
    }
}

pub struct clz_Torappu_SandboxPermTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxPermTableBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_basicInfo(
        &mut self,
        basicInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxPermBasicData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermTable::VT_BASICINFO,
            basicInfo,
        );
    }
    #[inline]
    pub fn add_detail(
        &mut self,
        detail: flatbuffers::WIPOffset<clz_Torappu_SandboxPermDetailData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxPermDetailData>>(
                clz_Torappu_SandboxPermTable::VT_DETAIL,
                detail,
            );
    }
    #[inline]
    pub fn add_itemData(
        &mut self,
        itemData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxPermItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermTable::VT_ITEMDATA,
            itemData,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxPermTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxPermTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxPermTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxPermTable");
        ds.field("basicInfo", &self.basicInfo());
        ds.field("detail", &self.detail());
        ds.field("itemData", &self.itemData());
        ds.finish()
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_SandboxPermTable`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_sandbox_perm_table_unchecked`.
pub fn root_as_clz_torappu_sandbox_perm_table(
    buf: &[u8],
) -> Result<clz_Torappu_SandboxPermTable, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_SandboxPermTable>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_SandboxPermTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_sandbox_perm_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_sandbox_perm_table(
    buf: &[u8],
) -> Result<clz_Torappu_SandboxPermTable, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_SandboxPermTable>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_SandboxPermTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_sandbox_perm_table_unchecked`.
pub fn root_as_clz_torappu_sandbox_perm_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_SandboxPermTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_SandboxPermTable<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_SandboxPermTable` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_sandbox_perm_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_sandbox_perm_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_SandboxPermTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_SandboxPermTable<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_SandboxPermTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_SandboxPermTable`.
pub unsafe fn root_as_clz_torappu_sandbox_perm_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_SandboxPermTable {
    flatbuffers::root_unchecked::<clz_Torappu_SandboxPermTable>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_SandboxPermTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_SandboxPermTable`.
pub unsafe fn size_prefixed_root_as_clz_torappu_sandbox_perm_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_SandboxPermTable {
    flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_SandboxPermTable>(buf)
}
#[inline]
pub fn finish_clz_torappu_sandbox_perm_table_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_SandboxPermTable<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_sandbox_perm_table_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_SandboxPermTable<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
