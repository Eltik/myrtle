// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_PERM_TEMPLATE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_PERM_TEMPLATE_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_PERM_TEMPLATE_TYPE:
    [enum__Torappu_SandboxPermTemplateType; 2] = [
    enum__Torappu_SandboxPermTemplateType::NONE,
    enum__Torappu_SandboxPermTemplateType::SANDBOX_V2,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxPermTemplateType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxPermTemplateType {
    pub const NONE: Self = Self(0);
    pub const SANDBOX_V2: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::SANDBOX_V2];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::SANDBOX_V2 => Some("SANDBOX_V2"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxPermTemplateType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxPermTemplateType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxPermTemplateType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxPermTemplateType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxPermTemplateType {
    type Output = enum__Torappu_SandboxPermTemplateType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxPermTemplateType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxPermTemplateType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxPermTemplateType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_TRAP_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_TRAP_ITEM_TYPE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_TRAP_ITEM_TYPE:
    [enum__Torappu_SandboxV2TrapItemType; 5] = [
    enum__Torappu_SandboxV2TrapItemType::NONE,
    enum__Torappu_SandboxV2TrapItemType::BATTLE,
    enum__Torappu_SandboxV2TrapItemType::TACTICAL,
    enum__Torappu_SandboxV2TrapItemType::FUNCTION,
    enum__Torappu_SandboxV2TrapItemType::ANIMAL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2TrapItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2TrapItemType {
    pub const NONE: Self = Self(0);
    pub const BATTLE: Self = Self(1);
    pub const TACTICAL: Self = Self(2);
    pub const FUNCTION: Self = Self(3);
    pub const ANIMAL: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::BATTLE,
        Self::TACTICAL,
        Self::FUNCTION,
        Self::ANIMAL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::BATTLE => Some("BATTLE"),
            Self::TACTICAL => Some("TACTICAL"),
            Self::FUNCTION => Some("FUNCTION"),
            Self::ANIMAL => Some("ANIMAL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2TrapItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2TrapItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2TrapItemType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2TrapItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2TrapItemType {
    type Output = enum__Torappu_SandboxV2TrapItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2TrapItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2TrapItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2TrapItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_ITEM_TRAP_TAG: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_ITEM_TRAP_TAG: i32 = 8;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_ITEM_TRAP_TAG:
    [enum__Torappu_SandboxV2ItemTrapTag; 9] = [
    enum__Torappu_SandboxV2ItemTrapTag::OUTPUT,
    enum__Torappu_SandboxV2ItemTrapTag::COLLECTION,
    enum__Torappu_SandboxV2ItemTrapTag::IMPAIR,
    enum__Torappu_SandboxV2ItemTrapTag::ENHANCE,
    enum__Torappu_SandboxV2ItemTrapTag::EXPLORE,
    enum__Torappu_SandboxV2ItemTrapTag::SPECTACLE,
    enum__Torappu_SandboxV2ItemTrapTag::DECORATE,
    enum__Torappu_SandboxV2ItemTrapTag::DEFEND,
    enum__Torappu_SandboxV2ItemTrapTag::SCOUT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2ItemTrapTag(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2ItemTrapTag {
    pub const OUTPUT: Self = Self(0);
    pub const COLLECTION: Self = Self(1);
    pub const IMPAIR: Self = Self(2);
    pub const ENHANCE: Self = Self(3);
    pub const EXPLORE: Self = Self(4);
    pub const SPECTACLE: Self = Self(5);
    pub const DECORATE: Self = Self(6);
    pub const DEFEND: Self = Self(7);
    pub const SCOUT: Self = Self(8);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 8;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::OUTPUT,
        Self::COLLECTION,
        Self::IMPAIR,
        Self::ENHANCE,
        Self::EXPLORE,
        Self::SPECTACLE,
        Self::DECORATE,
        Self::DEFEND,
        Self::SCOUT,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::OUTPUT => Some("OUTPUT"),
            Self::COLLECTION => Some("COLLECTION"),
            Self::IMPAIR => Some("IMPAIR"),
            Self::ENHANCE => Some("ENHANCE"),
            Self::EXPLORE => Some("EXPLORE"),
            Self::SPECTACLE => Some("SPECTACLE"),
            Self::DECORATE => Some("DECORATE"),
            Self::DEFEND => Some("DEFEND"),
            Self::SCOUT => Some("SCOUT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2ItemTrapTag {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2ItemTrapTag {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2ItemTrapTag",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2ItemTrapTag {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2ItemTrapTag {
    type Output = enum__Torappu_SandboxV2ItemTrapTag;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2ItemTrapTag {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2ItemTrapTag {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2ItemTrapTag {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_CRAFT_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_CRAFT_ITEM_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_CRAFT_ITEM_TYPE:
    [enum__Torappu_SandboxV2CraftItemType; 3] = [
    enum__Torappu_SandboxV2CraftItemType::BASE_BUILDING,
    enum__Torappu_SandboxV2CraftItemType::TACTICAL,
    enum__Torappu_SandboxV2CraftItemType::COMBAT_BUILDING,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2CraftItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2CraftItemType {
    pub const BASE_BUILDING: Self = Self(0);
    pub const TACTICAL: Self = Self(1);
    pub const COMBAT_BUILDING: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::BASE_BUILDING, Self::TACTICAL, Self::COMBAT_BUILDING];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::BASE_BUILDING => Some("BASE_BUILDING"),
            Self::TACTICAL => Some("TACTICAL"),
            Self::COMBAT_BUILDING => Some("COMBAT_BUILDING"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2CraftItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2CraftItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2CraftItemType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2CraftItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2CraftItemType {
    type Output = enum__Torappu_SandboxV2CraftItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2CraftItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2CraftItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2CraftItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_PERM_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_PERM_ITEM_TYPE: i32 = 15;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_PERM_ITEM_TYPE: [enum__Torappu_SandboxPermItemType;
    14] = [
    enum__Torappu_SandboxPermItemType::NONE,
    enum__Torappu_SandboxPermItemType::TACTICAL,
    enum__Torappu_SandboxPermItemType::BUILDING,
    enum__Torappu_SandboxPermItemType::BUILDINGMAT,
    enum__Torappu_SandboxPermItemType::FOOD,
    enum__Torappu_SandboxPermItemType::FOODMAT,
    enum__Torappu_SandboxPermItemType::SPECIALMAT,
    enum__Torappu_SandboxPermItemType::COIN,
    enum__Torappu_SandboxPermItemType::CRAFT,
    enum__Torappu_SandboxPermItemType::PLACEHOLDER,
    enum__Torappu_SandboxPermItemType::STAMINAPOT,
    enum__Torappu_SandboxPermItemType::ANIMAL,
    enum__Torappu_SandboxPermItemType::INSECT,
    enum__Torappu_SandboxPermItemType::SLUGITEM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxPermItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxPermItemType {
    pub const NONE: Self = Self(0);
    pub const TACTICAL: Self = Self(1);
    pub const BUILDING: Self = Self(2);
    pub const BUILDINGMAT: Self = Self(3);
    pub const FOOD: Self = Self(4);
    pub const FOODMAT: Self = Self(5);
    pub const SPECIALMAT: Self = Self(6);
    pub const COIN: Self = Self(9);
    pub const CRAFT: Self = Self(10);
    pub const PLACEHOLDER: Self = Self(11);
    pub const STAMINAPOT: Self = Self(12);
    pub const ANIMAL: Self = Self(13);
    pub const INSECT: Self = Self(14);
    pub const SLUGITEM: Self = Self(15);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 15;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::TACTICAL,
        Self::BUILDING,
        Self::BUILDINGMAT,
        Self::FOOD,
        Self::FOODMAT,
        Self::SPECIALMAT,
        Self::COIN,
        Self::CRAFT,
        Self::PLACEHOLDER,
        Self::STAMINAPOT,
        Self::ANIMAL,
        Self::INSECT,
        Self::SLUGITEM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::TACTICAL => Some("TACTICAL"),
            Self::BUILDING => Some("BUILDING"),
            Self::BUILDINGMAT => Some("BUILDINGMAT"),
            Self::FOOD => Some("FOOD"),
            Self::FOODMAT => Some("FOODMAT"),
            Self::SPECIALMAT => Some("SPECIALMAT"),
            Self::COIN => Some("COIN"),
            Self::CRAFT => Some("CRAFT"),
            Self::PLACEHOLDER => Some("PLACEHOLDER"),
            Self::STAMINAPOT => Some("STAMINAPOT"),
            Self::ANIMAL => Some("ANIMAL"),
            Self::INSECT => Some("INSECT"),
            Self::SLUGITEM => Some("SLUGITEM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxPermItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxPermItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxPermItemType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxPermItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxPermItemType {
    type Output = enum__Torappu_SandboxPermItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxPermItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxPermItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxPermItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_FOOD_MAT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_FOOD_MAT_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_FOOD_MAT_TYPE:
    [enum__Torappu_SandboxV2FoodMatType; 2] = [
    enum__Torappu_SandboxV2FoodMatType::MAIN,
    enum__Torappu_SandboxV2FoodMatType::SUB,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2FoodMatType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2FoodMatType {
    pub const MAIN: Self = Self(0);
    pub const SUB: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::MAIN, Self::SUB];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::MAIN => Some("MAIN"),
            Self::SUB => Some("SUB"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2FoodMatType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2FoodMatType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2FoodMatType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2FoodMatType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2FoodMatType {
    type Output = enum__Torappu_SandboxV2FoodMatType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2FoodMatType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2FoodMatType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2FoodMatType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_FOOD_ATTRIBUTE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_FOOD_ATTRIBUTE: i32 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_FOOD_ATTRIBUTE:
    [enum__Torappu_SandboxV2FoodAttribute; 8] = [
    enum__Torappu_SandboxV2FoodAttribute::NONE,
    enum__Torappu_SandboxV2FoodAttribute::SURVIVE,
    enum__Torappu_SandboxV2FoodAttribute::COST,
    enum__Torappu_SandboxV2FoodAttribute::ATTACK,
    enum__Torappu_SandboxV2FoodAttribute::COOLDOWN,
    enum__Torappu_SandboxV2FoodAttribute::SKILL_POINT,
    enum__Torappu_SandboxV2FoodAttribute::SPECIAL,
    enum__Torappu_SandboxV2FoodAttribute::ENHANCED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2FoodAttribute(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2FoodAttribute {
    pub const NONE: Self = Self(0);
    pub const SURVIVE: Self = Self(1);
    pub const COST: Self = Self(2);
    pub const ATTACK: Self = Self(3);
    pub const COOLDOWN: Self = Self(4);
    pub const SKILL_POINT: Self = Self(5);
    pub const SPECIAL: Self = Self(6);
    pub const ENHANCED: Self = Self(7);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 7;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::SURVIVE,
        Self::COST,
        Self::ATTACK,
        Self::COOLDOWN,
        Self::SKILL_POINT,
        Self::SPECIAL,
        Self::ENHANCED,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::SURVIVE => Some("SURVIVE"),
            Self::COST => Some("COST"),
            Self::ATTACK => Some("ATTACK"),
            Self::COOLDOWN => Some("COOLDOWN"),
            Self::SKILL_POINT => Some("SKILL_POINT"),
            Self::SPECIAL => Some("SPECIAL"),
            Self::ENHANCED => Some("ENHANCED"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2FoodAttribute {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2FoodAttribute {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2FoodAttribute",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2FoodAttribute {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2FoodAttribute {
    type Output = enum__Torappu_SandboxV2FoodAttribute;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2FoodAttribute {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2FoodAttribute {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2FoodAttribute {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_FOOD_VARIANT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_FOOD_VARIANT_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_FOOD_VARIANT_TYPE:
    [enum__Torappu_SandboxV2FoodVariantType; 4] = [
    enum__Torappu_SandboxV2FoodVariantType::NONE,
    enum__Torappu_SandboxV2FoodVariantType::ALPHA,
    enum__Torappu_SandboxV2FoodVariantType::BETA,
    enum__Torappu_SandboxV2FoodVariantType::GAMMA,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2FoodVariantType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2FoodVariantType {
    pub const NONE: Self = Self(0);
    pub const ALPHA: Self = Self(1);
    pub const BETA: Self = Self(2);
    pub const GAMMA: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::ALPHA, Self::BETA, Self::GAMMA];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ALPHA => Some("ALPHA"),
            Self::BETA => Some("BETA"),
            Self::GAMMA => Some("GAMMA"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2FoodVariantType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2FoodVariantType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2FoodVariantType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2FoodVariantType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2FoodVariantType {
    type Output = enum__Torappu_SandboxV2FoodVariantType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2FoodVariantType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2FoodVariantType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2FoodVariantType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_NODE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_NODE_TYPE: i32 = 17;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_NODE_TYPE: [enum__Torappu_SandboxV2NodeType; 18] = [
    enum__Torappu_SandboxV2NodeType::NONE,
    enum__Torappu_SandboxV2NodeType::HOME,
    enum__Torappu_SandboxV2NodeType::HOME_OUTPOST,
    enum__Torappu_SandboxV2NodeType::BATTLE,
    enum__Torappu_SandboxV2NodeType::NEST,
    enum__Torappu_SandboxV2NodeType::COLLECT,
    enum__Torappu_SandboxV2NodeType::HUNT,
    enum__Torappu_SandboxV2NodeType::CAVE,
    enum__Torappu_SandboxV2NodeType::MINE,
    enum__Torappu_SandboxV2NodeType::ENCOUNTER,
    enum__Torappu_SandboxV2NodeType::EXPEDITION,
    enum__Torappu_SandboxV2NodeType::SHOP,
    enum__Torappu_SandboxV2NodeType::GATE,
    enum__Torappu_SandboxV2NodeType::MARKET,
    enum__Torappu_SandboxV2NodeType::HOME_PORTABLE,
    enum__Torappu_SandboxV2NodeType::HOME_PORTABLE_RIFT,
    enum__Torappu_SandboxV2NodeType::SELECTION,
    enum__Torappu_SandboxV2NodeType::RACING,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2NodeType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2NodeType {
    pub const NONE: Self = Self(0);
    pub const HOME: Self = Self(1);
    pub const HOME_OUTPOST: Self = Self(2);
    pub const BATTLE: Self = Self(3);
    pub const NEST: Self = Self(4);
    pub const COLLECT: Self = Self(5);
    pub const HUNT: Self = Self(6);
    pub const CAVE: Self = Self(7);
    pub const MINE: Self = Self(8);
    pub const ENCOUNTER: Self = Self(9);
    pub const EXPEDITION: Self = Self(10);
    pub const SHOP: Self = Self(11);
    pub const GATE: Self = Self(12);
    pub const MARKET: Self = Self(13);
    pub const HOME_PORTABLE: Self = Self(14);
    pub const HOME_PORTABLE_RIFT: Self = Self(15);
    pub const SELECTION: Self = Self(16);
    pub const RACING: Self = Self(17);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 17;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::HOME,
        Self::HOME_OUTPOST,
        Self::BATTLE,
        Self::NEST,
        Self::COLLECT,
        Self::HUNT,
        Self::CAVE,
        Self::MINE,
        Self::ENCOUNTER,
        Self::EXPEDITION,
        Self::SHOP,
        Self::GATE,
        Self::MARKET,
        Self::HOME_PORTABLE,
        Self::HOME_PORTABLE_RIFT,
        Self::SELECTION,
        Self::RACING,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::HOME => Some("HOME"),
            Self::HOME_OUTPOST => Some("HOME_OUTPOST"),
            Self::BATTLE => Some("BATTLE"),
            Self::NEST => Some("NEST"),
            Self::COLLECT => Some("COLLECT"),
            Self::HUNT => Some("HUNT"),
            Self::CAVE => Some("CAVE"),
            Self::MINE => Some("MINE"),
            Self::ENCOUNTER => Some("ENCOUNTER"),
            Self::EXPEDITION => Some("EXPEDITION"),
            Self::SHOP => Some("SHOP"),
            Self::GATE => Some("GATE"),
            Self::MARKET => Some("MARKET"),
            Self::HOME_PORTABLE => Some("HOME_PORTABLE"),
            Self::HOME_PORTABLE_RIFT => Some("HOME_PORTABLE_RIFT"),
            Self::SELECTION => Some("SELECTION"),
            Self::RACING => Some("RACING"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2NodeType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2NodeType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2NodeType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2NodeType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2NodeType {
    type Output = enum__Torappu_SandboxV2NodeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2NodeType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2NodeType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2NodeType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_WEATHER_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_WEATHER_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_WEATHER_TYPE: [enum__Torappu_SandboxV2WeatherType;
    4] = [
    enum__Torappu_SandboxV2WeatherType::NORMAL,
    enum__Torappu_SandboxV2WeatherType::RAINFOREST,
    enum__Torappu_SandboxV2WeatherType::VOLCANO,
    enum__Torappu_SandboxV2WeatherType::DESERT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2WeatherType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2WeatherType {
    pub const NORMAL: Self = Self(0);
    pub const RAINFOREST: Self = Self(1);
    pub const VOLCANO: Self = Self(2);
    pub const DESERT: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NORMAL, Self::RAINFOREST, Self::VOLCANO, Self::DESERT];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NORMAL => Some("NORMAL"),
            Self::RAINFOREST => Some("RAINFOREST"),
            Self::VOLCANO => Some("VOLCANO"),
            Self::DESERT => Some("DESERT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2WeatherType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2WeatherType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2WeatherType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2WeatherType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2WeatherType {
    type Output = enum__Torappu_SandboxV2WeatherType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2WeatherType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2WeatherType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2WeatherType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_ENEMY_RUSH_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_ENEMY_RUSH_TYPE: i32 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_ENEMY_RUSH_TYPE:
    [enum__Torappu_SandboxV2EnemyRushType; 8] = [
    enum__Torappu_SandboxV2EnemyRushType::NORMAL,
    enum__Torappu_SandboxV2EnemyRushType::ELITE,
    enum__Torappu_SandboxV2EnemyRushType::BOSS,
    enum__Torappu_SandboxV2EnemyRushType::BANDIT,
    enum__Torappu_SandboxV2EnemyRushType::RALLY,
    enum__Torappu_SandboxV2EnemyRushType::THIEF,
    enum__Torappu_SandboxV2EnemyRushType::MESSENGER,
    enum__Torappu_SandboxV2EnemyRushType::INSECT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2EnemyRushType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2EnemyRushType {
    pub const NORMAL: Self = Self(0);
    pub const ELITE: Self = Self(1);
    pub const BOSS: Self = Self(2);
    pub const BANDIT: Self = Self(3);
    pub const RALLY: Self = Self(4);
    pub const THIEF: Self = Self(5);
    pub const MESSENGER: Self = Self(6);
    pub const INSECT: Self = Self(7);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 7;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NORMAL,
        Self::ELITE,
        Self::BOSS,
        Self::BANDIT,
        Self::RALLY,
        Self::THIEF,
        Self::MESSENGER,
        Self::INSECT,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NORMAL => Some("NORMAL"),
            Self::ELITE => Some("ELITE"),
            Self::BOSS => Some("BOSS"),
            Self::BANDIT => Some("BANDIT"),
            Self::RALLY => Some("RALLY"),
            Self::THIEF => Some("THIEF"),
            Self::MESSENGER => Some("MESSENGER"),
            Self::INSECT => Some("INSECT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2EnemyRushType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2EnemyRushType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2EnemyRushType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2EnemyRushType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2EnemyRushType {
    type Output = enum__Torappu_SandboxV2EnemyRushType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2EnemyRushType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2EnemyRushType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2EnemyRushType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_SEASON_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_SEASON_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_SEASON_TYPE: [enum__Torappu_SandboxV2SeasonType;
    4] = [
    enum__Torappu_SandboxV2SeasonType::NONE,
    enum__Torappu_SandboxV2SeasonType::DRY,
    enum__Torappu_SandboxV2SeasonType::RAINY,
    enum__Torappu_SandboxV2SeasonType::CHALLENGE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2SeasonType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2SeasonType {
    pub const NONE: Self = Self(0);
    pub const DRY: Self = Self(1);
    pub const RAINY: Self = Self(2);
    pub const CHALLENGE: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::DRY, Self::RAINY, Self::CHALLENGE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::DRY => Some("DRY"),
            Self::RAINY => Some("RAINY"),
            Self::CHALLENGE => Some("CHALLENGE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2SeasonType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2SeasonType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2SeasonType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2SeasonType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2SeasonType {
    type Output = enum__Torappu_SandboxV2SeasonType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2SeasonType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2SeasonType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2SeasonType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ITEM_TYPE: i32 = 90;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ITEM_TYPE: [enum__Torappu_ItemType; 91] = [
    enum__Torappu_ItemType::NONE,
    enum__Torappu_ItemType::CHAR,
    enum__Torappu_ItemType::CARD_EXP,
    enum__Torappu_ItemType::MATERIAL,
    enum__Torappu_ItemType::GOLD,
    enum__Torappu_ItemType::EXP_PLAYER,
    enum__Torappu_ItemType::TKT_TRY,
    enum__Torappu_ItemType::TKT_RECRUIT,
    enum__Torappu_ItemType::TKT_INST_FIN,
    enum__Torappu_ItemType::TKT_GACHA,
    enum__Torappu_ItemType::ACTIVITY_COIN,
    enum__Torappu_ItemType::DIAMOND,
    enum__Torappu_ItemType::DIAMOND_SHD,
    enum__Torappu_ItemType::HGG_SHD,
    enum__Torappu_ItemType::LGG_SHD,
    enum__Torappu_ItemType::FURN,
    enum__Torappu_ItemType::AP_GAMEPLAY,
    enum__Torappu_ItemType::AP_BASE,
    enum__Torappu_ItemType::SOCIAL_PT,
    enum__Torappu_ItemType::CHAR_SKIN,
    enum__Torappu_ItemType::TKT_GACHA_10,
    enum__Torappu_ItemType::TKT_GACHA_PRSV,
    enum__Torappu_ItemType::AP_ITEM,
    enum__Torappu_ItemType::AP_SUPPLY,
    enum__Torappu_ItemType::RENAMING_CARD,
    enum__Torappu_ItemType::RENAMING_CARD_2,
    enum__Torappu_ItemType::ET_STAGE,
    enum__Torappu_ItemType::ACTIVITY_ITEM,
    enum__Torappu_ItemType::VOUCHER_PICK,
    enum__Torappu_ItemType::VOUCHER_CGACHA,
    enum__Torappu_ItemType::VOUCHER_MGACHA,
    enum__Torappu_ItemType::CRS_SHOP_COIN,
    enum__Torappu_ItemType::CRS_RUNE_COIN,
    enum__Torappu_ItemType::LMTGS_COIN,
    enum__Torappu_ItemType::EPGS_COIN,
    enum__Torappu_ItemType::LIMITED_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_FREE_GACHA,
    enum__Torappu_ItemType::REP_COIN,
    enum__Torappu_ItemType::ROGUELIKE,
    enum__Torappu_ItemType::LINKAGE_TKT_GACHA_10,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_4,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_5,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_6,
    enum__Torappu_ItemType::VOUCHER_SKIN,
    enum__Torappu_ItemType::RETRO_COIN,
    enum__Torappu_ItemType::PLAYER_AVATAR,
    enum__Torappu_ItemType::UNI_COLLECTION,
    enum__Torappu_ItemType::VOUCHER_FULL_POTENTIAL,
    enum__Torappu_ItemType::RL_COIN,
    enum__Torappu_ItemType::RETURN_CREDIT,
    enum__Torappu_ItemType::MEDAL,
    enum__Torappu_ItemType::CHARM,
    enum__Torappu_ItemType::HOME_BACKGROUND,
    enum__Torappu_ItemType::EXTERMINATION_AGENT,
    enum__Torappu_ItemType::OPTIONAL_VOUCHER_PICK,
    enum__Torappu_ItemType::ACT_CART_COMPONENT,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_4,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_4,
    enum__Torappu_ItemType::ACTIVITY_POTENTIAL,
    enum__Torappu_ItemType::ITEM_PACK,
    enum__Torappu_ItemType::SANDBOX,
    enum__Torappu_ItemType::FAVOR_ADD_ITEM,
    enum__Torappu_ItemType::CLASSIC_SHD,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_BUFF,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_5,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_6,
    enum__Torappu_ItemType::RETURN_PROGRESS,
    enum__Torappu_ItemType::NEW_PROGRESS,
    enum__Torappu_ItemType::MCARD_VOUCHER,
    enum__Torappu_ItemType::MATERIAL_ISSUE_VOUCHER,
    enum__Torappu_ItemType::CRS_SHOP_COIN_V2,
    enum__Torappu_ItemType::HOME_THEME,
    enum__Torappu_ItemType::SANDBOX_PERM,
    enum__Torappu_ItemType::SANDBOX_TOKEN,
    enum__Torappu_ItemType::TEMPLATE_TRAP,
    enum__Torappu_ItemType::NAME_CARD_SKIN,
    enum__Torappu_ItemType::EMOTICON_SET,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA_10,
    enum__Torappu_ItemType::SO_CHAR_EXP,
    enum__Torappu_ItemType::GIFTPACKAGE_TKT,
    enum__Torappu_ItemType::VOUCHER_SKIN_V2,
    enum__Torappu_ItemType::RANDOM_VOUCHER_SKIN,
    enum__Torappu_ItemType::ACT1VHALFIDLE_ITEM,
    enum__Torappu_ItemType::PLOT_ITEM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ItemType {
    pub const NONE: Self = Self(0);
    pub const CHAR: Self = Self(1);
    pub const CARD_EXP: Self = Self(2);
    pub const MATERIAL: Self = Self(3);
    pub const GOLD: Self = Self(4);
    pub const EXP_PLAYER: Self = Self(5);
    pub const TKT_TRY: Self = Self(6);
    pub const TKT_RECRUIT: Self = Self(7);
    pub const TKT_INST_FIN: Self = Self(8);
    pub const TKT_GACHA: Self = Self(9);
    pub const ACTIVITY_COIN: Self = Self(10);
    pub const DIAMOND: Self = Self(11);
    pub const DIAMOND_SHD: Self = Self(12);
    pub const HGG_SHD: Self = Self(13);
    pub const LGG_SHD: Self = Self(14);
    pub const FURN: Self = Self(15);
    pub const AP_GAMEPLAY: Self = Self(16);
    pub const AP_BASE: Self = Self(17);
    pub const SOCIAL_PT: Self = Self(18);
    pub const CHAR_SKIN: Self = Self(19);
    pub const TKT_GACHA_10: Self = Self(20);
    pub const TKT_GACHA_PRSV: Self = Self(21);
    pub const AP_ITEM: Self = Self(22);
    pub const AP_SUPPLY: Self = Self(23);
    pub const RENAMING_CARD: Self = Self(24);
    pub const RENAMING_CARD_2: Self = Self(25);
    pub const ET_STAGE: Self = Self(26);
    pub const ACTIVITY_ITEM: Self = Self(27);
    pub const VOUCHER_PICK: Self = Self(28);
    pub const VOUCHER_CGACHA: Self = Self(29);
    pub const VOUCHER_MGACHA: Self = Self(30);
    pub const CRS_SHOP_COIN: Self = Self(31);
    pub const CRS_RUNE_COIN: Self = Self(32);
    pub const LMTGS_COIN: Self = Self(33);
    pub const EPGS_COIN: Self = Self(34);
    pub const LIMITED_TKT_GACHA_10: Self = Self(35);
    pub const LIMITED_FREE_GACHA: Self = Self(36);
    pub const REP_COIN: Self = Self(37);
    pub const ROGUELIKE: Self = Self(38);
    pub const LINKAGE_TKT_GACHA_10: Self = Self(39);
    pub const VOUCHER_ELITE_II_4: Self = Self(40);
    pub const VOUCHER_ELITE_II_5: Self = Self(41);
    pub const VOUCHER_ELITE_II_6: Self = Self(42);
    pub const VOUCHER_SKIN: Self = Self(43);
    pub const RETRO_COIN: Self = Self(44);
    pub const PLAYER_AVATAR: Self = Self(45);
    pub const UNI_COLLECTION: Self = Self(46);
    pub const VOUCHER_FULL_POTENTIAL: Self = Self(47);
    pub const RL_COIN: Self = Self(48);
    pub const RETURN_CREDIT: Self = Self(49);
    pub const MEDAL: Self = Self(50);
    pub const CHARM: Self = Self(51);
    pub const HOME_BACKGROUND: Self = Self(52);
    pub const EXTERMINATION_AGENT: Self = Self(53);
    pub const OPTIONAL_VOUCHER_PICK: Self = Self(54);
    pub const ACT_CART_COMPONENT: Self = Self(55);
    pub const VOUCHER_LEVELMAX_6: Self = Self(56);
    pub const VOUCHER_LEVELMAX_5: Self = Self(57);
    pub const VOUCHER_LEVELMAX_4: Self = Self(58);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_6: Self = Self(59);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_5: Self = Self(60);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_4: Self = Self(61);
    pub const ACTIVITY_POTENTIAL: Self = Self(62);
    pub const ITEM_PACK: Self = Self(63);
    pub const SANDBOX: Self = Self(64);
    pub const FAVOR_ADD_ITEM: Self = Self(65);
    pub const CLASSIC_SHD: Self = Self(66);
    pub const CLASSIC_TKT_GACHA: Self = Self(67);
    pub const CLASSIC_TKT_GACHA_10: Self = Self(68);
    pub const LIMITED_BUFF: Self = Self(69);
    pub const CLASSIC_FES_PICK_TIER_5: Self = Self(70);
    pub const CLASSIC_FES_PICK_TIER_6: Self = Self(71);
    pub const RETURN_PROGRESS: Self = Self(72);
    pub const NEW_PROGRESS: Self = Self(73);
    pub const MCARD_VOUCHER: Self = Self(74);
    pub const MATERIAL_ISSUE_VOUCHER: Self = Self(75);
    pub const CRS_SHOP_COIN_V2: Self = Self(76);
    pub const HOME_THEME: Self = Self(77);
    pub const SANDBOX_PERM: Self = Self(78);
    pub const SANDBOX_TOKEN: Self = Self(79);
    pub const TEMPLATE_TRAP: Self = Self(80);
    pub const NAME_CARD_SKIN: Self = Self(81);
    pub const EMOTICON_SET: Self = Self(82);
    pub const EXCLUSIVE_TKT_GACHA: Self = Self(83);
    pub const EXCLUSIVE_TKT_GACHA_10: Self = Self(84);
    pub const SO_CHAR_EXP: Self = Self(85);
    pub const GIFTPACKAGE_TKT: Self = Self(86);
    pub const VOUCHER_SKIN_V2: Self = Self(87);
    pub const RANDOM_VOUCHER_SKIN: Self = Self(88);
    pub const ACT1VHALFIDLE_ITEM: Self = Self(89);
    pub const PLOT_ITEM: Self = Self(90);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 90;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::CHAR,
        Self::CARD_EXP,
        Self::MATERIAL,
        Self::GOLD,
        Self::EXP_PLAYER,
        Self::TKT_TRY,
        Self::TKT_RECRUIT,
        Self::TKT_INST_FIN,
        Self::TKT_GACHA,
        Self::ACTIVITY_COIN,
        Self::DIAMOND,
        Self::DIAMOND_SHD,
        Self::HGG_SHD,
        Self::LGG_SHD,
        Self::FURN,
        Self::AP_GAMEPLAY,
        Self::AP_BASE,
        Self::SOCIAL_PT,
        Self::CHAR_SKIN,
        Self::TKT_GACHA_10,
        Self::TKT_GACHA_PRSV,
        Self::AP_ITEM,
        Self::AP_SUPPLY,
        Self::RENAMING_CARD,
        Self::RENAMING_CARD_2,
        Self::ET_STAGE,
        Self::ACTIVITY_ITEM,
        Self::VOUCHER_PICK,
        Self::VOUCHER_CGACHA,
        Self::VOUCHER_MGACHA,
        Self::CRS_SHOP_COIN,
        Self::CRS_RUNE_COIN,
        Self::LMTGS_COIN,
        Self::EPGS_COIN,
        Self::LIMITED_TKT_GACHA_10,
        Self::LIMITED_FREE_GACHA,
        Self::REP_COIN,
        Self::ROGUELIKE,
        Self::LINKAGE_TKT_GACHA_10,
        Self::VOUCHER_ELITE_II_4,
        Self::VOUCHER_ELITE_II_5,
        Self::VOUCHER_ELITE_II_6,
        Self::VOUCHER_SKIN,
        Self::RETRO_COIN,
        Self::PLAYER_AVATAR,
        Self::UNI_COLLECTION,
        Self::VOUCHER_FULL_POTENTIAL,
        Self::RL_COIN,
        Self::RETURN_CREDIT,
        Self::MEDAL,
        Self::CHARM,
        Self::HOME_BACKGROUND,
        Self::EXTERMINATION_AGENT,
        Self::OPTIONAL_VOUCHER_PICK,
        Self::ACT_CART_COMPONENT,
        Self::VOUCHER_LEVELMAX_6,
        Self::VOUCHER_LEVELMAX_5,
        Self::VOUCHER_LEVELMAX_4,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_6,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_5,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_4,
        Self::ACTIVITY_POTENTIAL,
        Self::ITEM_PACK,
        Self::SANDBOX,
        Self::FAVOR_ADD_ITEM,
        Self::CLASSIC_SHD,
        Self::CLASSIC_TKT_GACHA,
        Self::CLASSIC_TKT_GACHA_10,
        Self::LIMITED_BUFF,
        Self::CLASSIC_FES_PICK_TIER_5,
        Self::CLASSIC_FES_PICK_TIER_6,
        Self::RETURN_PROGRESS,
        Self::NEW_PROGRESS,
        Self::MCARD_VOUCHER,
        Self::MATERIAL_ISSUE_VOUCHER,
        Self::CRS_SHOP_COIN_V2,
        Self::HOME_THEME,
        Self::SANDBOX_PERM,
        Self::SANDBOX_TOKEN,
        Self::TEMPLATE_TRAP,
        Self::NAME_CARD_SKIN,
        Self::EMOTICON_SET,
        Self::EXCLUSIVE_TKT_GACHA,
        Self::EXCLUSIVE_TKT_GACHA_10,
        Self::SO_CHAR_EXP,
        Self::GIFTPACKAGE_TKT,
        Self::VOUCHER_SKIN_V2,
        Self::RANDOM_VOUCHER_SKIN,
        Self::ACT1VHALFIDLE_ITEM,
        Self::PLOT_ITEM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::CHAR => Some("CHAR"),
            Self::CARD_EXP => Some("CARD_EXP"),
            Self::MATERIAL => Some("MATERIAL"),
            Self::GOLD => Some("GOLD"),
            Self::EXP_PLAYER => Some("EXP_PLAYER"),
            Self::TKT_TRY => Some("TKT_TRY"),
            Self::TKT_RECRUIT => Some("TKT_RECRUIT"),
            Self::TKT_INST_FIN => Some("TKT_INST_FIN"),
            Self::TKT_GACHA => Some("TKT_GACHA"),
            Self::ACTIVITY_COIN => Some("ACTIVITY_COIN"),
            Self::DIAMOND => Some("DIAMOND"),
            Self::DIAMOND_SHD => Some("DIAMOND_SHD"),
            Self::HGG_SHD => Some("HGG_SHD"),
            Self::LGG_SHD => Some("LGG_SHD"),
            Self::FURN => Some("FURN"),
            Self::AP_GAMEPLAY => Some("AP_GAMEPLAY"),
            Self::AP_BASE => Some("AP_BASE"),
            Self::SOCIAL_PT => Some("SOCIAL_PT"),
            Self::CHAR_SKIN => Some("CHAR_SKIN"),
            Self::TKT_GACHA_10 => Some("TKT_GACHA_10"),
            Self::TKT_GACHA_PRSV => Some("TKT_GACHA_PRSV"),
            Self::AP_ITEM => Some("AP_ITEM"),
            Self::AP_SUPPLY => Some("AP_SUPPLY"),
            Self::RENAMING_CARD => Some("RENAMING_CARD"),
            Self::RENAMING_CARD_2 => Some("RENAMING_CARD_2"),
            Self::ET_STAGE => Some("ET_STAGE"),
            Self::ACTIVITY_ITEM => Some("ACTIVITY_ITEM"),
            Self::VOUCHER_PICK => Some("VOUCHER_PICK"),
            Self::VOUCHER_CGACHA => Some("VOUCHER_CGACHA"),
            Self::VOUCHER_MGACHA => Some("VOUCHER_MGACHA"),
            Self::CRS_SHOP_COIN => Some("CRS_SHOP_COIN"),
            Self::CRS_RUNE_COIN => Some("CRS_RUNE_COIN"),
            Self::LMTGS_COIN => Some("LMTGS_COIN"),
            Self::EPGS_COIN => Some("EPGS_COIN"),
            Self::LIMITED_TKT_GACHA_10 => Some("LIMITED_TKT_GACHA_10"),
            Self::LIMITED_FREE_GACHA => Some("LIMITED_FREE_GACHA"),
            Self::REP_COIN => Some("REP_COIN"),
            Self::ROGUELIKE => Some("ROGUELIKE"),
            Self::LINKAGE_TKT_GACHA_10 => Some("LINKAGE_TKT_GACHA_10"),
            Self::VOUCHER_ELITE_II_4 => Some("VOUCHER_ELITE_II_4"),
            Self::VOUCHER_ELITE_II_5 => Some("VOUCHER_ELITE_II_5"),
            Self::VOUCHER_ELITE_II_6 => Some("VOUCHER_ELITE_II_6"),
            Self::VOUCHER_SKIN => Some("VOUCHER_SKIN"),
            Self::RETRO_COIN => Some("RETRO_COIN"),
            Self::PLAYER_AVATAR => Some("PLAYER_AVATAR"),
            Self::UNI_COLLECTION => Some("UNI_COLLECTION"),
            Self::VOUCHER_FULL_POTENTIAL => Some("VOUCHER_FULL_POTENTIAL"),
            Self::RL_COIN => Some("RL_COIN"),
            Self::RETURN_CREDIT => Some("RETURN_CREDIT"),
            Self::MEDAL => Some("MEDAL"),
            Self::CHARM => Some("CHARM"),
            Self::HOME_BACKGROUND => Some("HOME_BACKGROUND"),
            Self::EXTERMINATION_AGENT => Some("EXTERMINATION_AGENT"),
            Self::OPTIONAL_VOUCHER_PICK => Some("OPTIONAL_VOUCHER_PICK"),
            Self::ACT_CART_COMPONENT => Some("ACT_CART_COMPONENT"),
            Self::VOUCHER_LEVELMAX_6 => Some("VOUCHER_LEVELMAX_6"),
            Self::VOUCHER_LEVELMAX_5 => Some("VOUCHER_LEVELMAX_5"),
            Self::VOUCHER_LEVELMAX_4 => Some("VOUCHER_LEVELMAX_4"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_6 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_6"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_5 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_5"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_4 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_4"),
            Self::ACTIVITY_POTENTIAL => Some("ACTIVITY_POTENTIAL"),
            Self::ITEM_PACK => Some("ITEM_PACK"),
            Self::SANDBOX => Some("SANDBOX"),
            Self::FAVOR_ADD_ITEM => Some("FAVOR_ADD_ITEM"),
            Self::CLASSIC_SHD => Some("CLASSIC_SHD"),
            Self::CLASSIC_TKT_GACHA => Some("CLASSIC_TKT_GACHA"),
            Self::CLASSIC_TKT_GACHA_10 => Some("CLASSIC_TKT_GACHA_10"),
            Self::LIMITED_BUFF => Some("LIMITED_BUFF"),
            Self::CLASSIC_FES_PICK_TIER_5 => Some("CLASSIC_FES_PICK_TIER_5"),
            Self::CLASSIC_FES_PICK_TIER_6 => Some("CLASSIC_FES_PICK_TIER_6"),
            Self::RETURN_PROGRESS => Some("RETURN_PROGRESS"),
            Self::NEW_PROGRESS => Some("NEW_PROGRESS"),
            Self::MCARD_VOUCHER => Some("MCARD_VOUCHER"),
            Self::MATERIAL_ISSUE_VOUCHER => Some("MATERIAL_ISSUE_VOUCHER"),
            Self::CRS_SHOP_COIN_V2 => Some("CRS_SHOP_COIN_V2"),
            Self::HOME_THEME => Some("HOME_THEME"),
            Self::SANDBOX_PERM => Some("SANDBOX_PERM"),
            Self::SANDBOX_TOKEN => Some("SANDBOX_TOKEN"),
            Self::TEMPLATE_TRAP => Some("TEMPLATE_TRAP"),
            Self::NAME_CARD_SKIN => Some("NAME_CARD_SKIN"),
            Self::EMOTICON_SET => Some("EMOTICON_SET"),
            Self::EXCLUSIVE_TKT_GACHA => Some("EXCLUSIVE_TKT_GACHA"),
            Self::EXCLUSIVE_TKT_GACHA_10 => Some("EXCLUSIVE_TKT_GACHA_10"),
            Self::SO_CHAR_EXP => Some("SO_CHAR_EXP"),
            Self::GIFTPACKAGE_TKT => Some("GIFTPACKAGE_TKT"),
            Self::VOUCHER_SKIN_V2 => Some("VOUCHER_SKIN_V2"),
            Self::RANDOM_VOUCHER_SKIN => Some("RANDOM_VOUCHER_SKIN"),
            Self::ACT1VHALFIDLE_ITEM => Some("ACT1VHALFIDLE_ITEM"),
            Self::PLOT_ITEM => Some("PLOT_ITEM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ItemType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ItemType {
    type Output = enum__Torappu_ItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_TIP_DATA_CATEGORY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_TIP_DATA_CATEGORY: i32 = 31;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_TIP_DATA_CATEGORY: [enum__Torappu_TipData_Category; 7] = [
    enum__Torappu_TipData_Category::NONE,
    enum__Torappu_TipData_Category::BATTLE,
    enum__Torappu_TipData_Category::UI,
    enum__Torappu_TipData_Category::BUILDING,
    enum__Torappu_TipData_Category::GACHA,
    enum__Torappu_TipData_Category::MISC,
    enum__Torappu_TipData_Category::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_TipData_Category(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_TipData_Category {
    pub const NONE: Self = Self(0);
    pub const BATTLE: Self = Self(1);
    pub const UI: Self = Self(2);
    pub const BUILDING: Self = Self(4);
    pub const GACHA: Self = Self(8);
    pub const MISC: Self = Self(16);
    pub const ALL: Self = Self(31);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 31;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::BATTLE,
        Self::UI,
        Self::BUILDING,
        Self::GACHA,
        Self::MISC,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::BATTLE => Some("BATTLE"),
            Self::UI => Some("UI"),
            Self::BUILDING => Some("BUILDING"),
            Self::GACHA => Some("GACHA"),
            Self::MISC => Some("MISC"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_TipData_Category {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_TipData_Category {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_TipData_Category",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_TipData_Category {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_TipData_Category {
    type Output = enum__Torappu_TipData_Category;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_TipData_Category {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_TipData_Category {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_TipData_Category {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_PROFESSION_CATEGORY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_PROFESSION_CATEGORY: i32 = 512;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_PROFESSION_CATEGORY: [enum__Torappu_ProfessionCategory; 11] = [
    enum__Torappu_ProfessionCategory::NONE,
    enum__Torappu_ProfessionCategory::WARRIOR,
    enum__Torappu_ProfessionCategory::SNIPER,
    enum__Torappu_ProfessionCategory::TANK,
    enum__Torappu_ProfessionCategory::MEDIC,
    enum__Torappu_ProfessionCategory::SUPPORT,
    enum__Torappu_ProfessionCategory::CASTER,
    enum__Torappu_ProfessionCategory::SPECIAL,
    enum__Torappu_ProfessionCategory::TOKEN,
    enum__Torappu_ProfessionCategory::TRAP,
    enum__Torappu_ProfessionCategory::PIONEER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ProfessionCategory(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ProfessionCategory {
    pub const NONE: Self = Self(0);
    pub const WARRIOR: Self = Self(1);
    pub const SNIPER: Self = Self(2);
    pub const TANK: Self = Self(4);
    pub const MEDIC: Self = Self(8);
    pub const SUPPORT: Self = Self(16);
    pub const CASTER: Self = Self(32);
    pub const SPECIAL: Self = Self(64);
    pub const TOKEN: Self = Self(128);
    pub const TRAP: Self = Self(256);
    pub const PIONEER: Self = Self(512);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 512;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::WARRIOR,
        Self::SNIPER,
        Self::TANK,
        Self::MEDIC,
        Self::SUPPORT,
        Self::CASTER,
        Self::SPECIAL,
        Self::TOKEN,
        Self::TRAP,
        Self::PIONEER,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::WARRIOR => Some("WARRIOR"),
            Self::SNIPER => Some("SNIPER"),
            Self::TANK => Some("TANK"),
            Self::MEDIC => Some("MEDIC"),
            Self::SUPPORT => Some("SUPPORT"),
            Self::CASTER => Some("CASTER"),
            Self::SPECIAL => Some("SPECIAL"),
            Self::TOKEN => Some("TOKEN"),
            Self::TRAP => Some("TRAP"),
            Self::PIONEER => Some("PIONEER"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ProfessionCategory {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ProfessionCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ProfessionCategory",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ProfessionCategory {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ProfessionCategory {
    type Output = enum__Torappu_ProfessionCategory;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ProfessionCategory {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ProfessionCategory {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ProfessionCategory {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUILDABLE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUILDABLE_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUILDABLE_TYPE: [enum__Torappu_BuildableType; 4] = [
    enum__Torappu_BuildableType::NONE,
    enum__Torappu_BuildableType::MELEE,
    enum__Torappu_BuildableType::RANGED,
    enum__Torappu_BuildableType::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuildableType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuildableType {
    pub const NONE: Self = Self(0);
    pub const MELEE: Self = Self(1);
    pub const RANGED: Self = Self(2);
    pub const ALL: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::MELEE, Self::RANGED, Self::ALL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MELEE => Some("MELEE"),
            Self::RANGED => Some("RANGED"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuildableType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_BuildableType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_BuildableType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuildableType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuildableType {
    type Output = enum__Torappu_BuildableType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuildableType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuildableType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuildableType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_PLAYER_SIDE_MASK: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_PLAYER_SIDE_MASK: u8 = 255;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_PLAYER_SIDE_MASK: [enum__Torappu_PlayerSideMask; 4] = [
    enum__Torappu_PlayerSideMask::ALL,
    enum__Torappu_PlayerSideMask::SIDE_A,
    enum__Torappu_PlayerSideMask::SIDE_B,
    enum__Torappu_PlayerSideMask::NONE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_PlayerSideMask(pub u8);
#[allow(non_upper_case_globals)]
impl enum__Torappu_PlayerSideMask {
    pub const ALL: Self = Self(0);
    pub const SIDE_A: Self = Self(2);
    pub const SIDE_B: Self = Self(4);
    pub const NONE: Self = Self(255);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 255;
    pub const ENUM_VALUES: &'static [Self] = &[Self::ALL, Self::SIDE_A, Self::SIDE_B, Self::NONE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ALL => Some("ALL"),
            Self::SIDE_A => Some("SIDE_A"),
            Self::SIDE_B => Some("SIDE_B"),
            Self::NONE => Some("NONE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_PlayerSideMask {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_PlayerSideMask {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_PlayerSideMask",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_PlayerSideMask {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_PlayerSideMask {
    type Output = enum__Torappu_PlayerSideMask;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_PlayerSideMask {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_PlayerSideMask {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_PlayerSideMask {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BATTLE_SIDE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BATTLE_SIDE_TYPE: i32 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BATTLE_SIDE_TYPE: [enum__Torappu_Battle_SideType; 6] = [
    enum__Torappu_Battle_SideType::NONE,
    enum__Torappu_Battle_SideType::ALLY,
    enum__Torappu_Battle_SideType::ENEMY,
    enum__Torappu_Battle_SideType::BOTH_ALLY_AND_ENEMY,
    enum__Torappu_Battle_SideType::NEUTRAL,
    enum__Torappu_Battle_SideType::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_Battle_SideType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_Battle_SideType {
    pub const NONE: Self = Self(0);
    pub const ALLY: Self = Self(1);
    pub const ENEMY: Self = Self(2);
    pub const BOTH_ALLY_AND_ENEMY: Self = Self(3);
    pub const NEUTRAL: Self = Self(4);
    pub const ALL: Self = Self(7);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 7;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ALLY,
        Self::ENEMY,
        Self::BOTH_ALLY_AND_ENEMY,
        Self::NEUTRAL,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ALLY => Some("ALLY"),
            Self::ENEMY => Some("ENEMY"),
            Self::BOTH_ALLY_AND_ENEMY => Some("BOTH_ALLY_AND_ENEMY"),
            Self::NEUTRAL => Some("NEUTRAL"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_Battle_SideType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_Battle_SideType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_Battle_SideType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_Battle_SideType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_Battle_SideType {
    type Output = enum__Torappu_Battle_SideType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_Battle_SideType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_Battle_SideType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_Battle_SideType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_TILE_DATA_HEIGHT_TYPE_MASK: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_TILE_DATA_HEIGHT_TYPE_MASK: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_TILE_DATA_HEIGHT_TYPE_MASK:
    [enum__Torappu_TileData_HeightTypeMask; 4] = [
    enum__Torappu_TileData_HeightTypeMask::NONE,
    enum__Torappu_TileData_HeightTypeMask::LOWLAND,
    enum__Torappu_TileData_HeightTypeMask::HIGHLAND,
    enum__Torappu_TileData_HeightTypeMask::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_TileData_HeightTypeMask(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_TileData_HeightTypeMask {
    pub const NONE: Self = Self(0);
    pub const LOWLAND: Self = Self(1);
    pub const HIGHLAND: Self = Self(2);
    pub const ALL: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::LOWLAND, Self::HIGHLAND, Self::ALL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::LOWLAND => Some("LOWLAND"),
            Self::HIGHLAND => Some("HIGHLAND"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_TileData_HeightTypeMask {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_TileData_HeightTypeMask {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_TileData_HeightTypeMask",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_TileData_HeightTypeMask {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_TileData_HeightTypeMask {
    type Output = enum__Torappu_TileData_HeightTypeMask;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_TileData_HeightTypeMask {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_TileData_HeightTypeMask {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_TileData_HeightTypeMask {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_LEVEL_DATA_DIFFICULTY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_LEVEL_DATA_DIFFICULTY: i32 = 15;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_LEVEL_DATA_DIFFICULTY: [enum__Torappu_LevelData_Difficulty; 6] = [
    enum__Torappu_LevelData_Difficulty::NONE,
    enum__Torappu_LevelData_Difficulty::NORMAL,
    enum__Torappu_LevelData_Difficulty::FOUR_STAR,
    enum__Torappu_LevelData_Difficulty::EASY,
    enum__Torappu_LevelData_Difficulty::SIX_STAR,
    enum__Torappu_LevelData_Difficulty::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_LevelData_Difficulty(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_LevelData_Difficulty {
    pub const NONE: Self = Self(0);
    pub const NORMAL: Self = Self(1);
    pub const FOUR_STAR: Self = Self(2);
    pub const EASY: Self = Self(4);
    pub const SIX_STAR: Self = Self(8);
    pub const ALL: Self = Self(15);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 15;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::NORMAL,
        Self::FOUR_STAR,
        Self::EASY,
        Self::SIX_STAR,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::NORMAL => Some("NORMAL"),
            Self::FOUR_STAR => Some("FOUR_STAR"),
            Self::EASY => Some("EASY"),
            Self::SIX_STAR => Some("SIX_STAR"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_LevelData_Difficulty {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_LevelData_Difficulty {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_LevelData_Difficulty",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_LevelData_Difficulty {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_LevelData_Difficulty {
    type Output = enum__Torappu_LevelData_Difficulty;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_LevelData_Difficulty {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_LevelData_Difficulty {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_LevelData_Difficulty {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_QUEST_ROUTE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_QUEST_ROUTE_TYPE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_QUEST_ROUTE_TYPE:
    [enum__Torappu_SandboxV2QuestRouteType; 5] = [
    enum__Torappu_SandboxV2QuestRouteType::NONE,
    enum__Torappu_SandboxV2QuestRouteType::ENEMY_RUSH,
    enum__Torappu_SandboxV2QuestRouteType::EVENT,
    enum__Torappu_SandboxV2QuestRouteType::NODE,
    enum__Torappu_SandboxV2QuestRouteType::NPC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2QuestRouteType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2QuestRouteType {
    pub const NONE: Self = Self(0);
    pub const ENEMY_RUSH: Self = Self(1);
    pub const EVENT: Self = Self(2);
    pub const NODE: Self = Self(3);
    pub const NPC: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ENEMY_RUSH,
        Self::EVENT,
        Self::NODE,
        Self::NPC,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ENEMY_RUSH => Some("ENEMY_RUSH"),
            Self::EVENT => Some("EVENT"),
            Self::NODE => Some("NODE"),
            Self::NPC => Some("NPC"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2QuestRouteType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2QuestRouteType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2QuestRouteType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2QuestRouteType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2QuestRouteType {
    type Output = enum__Torappu_SandboxV2QuestRouteType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2QuestRouteType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2QuestRouteType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2QuestRouteType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_QUEST_LINE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_QUEST_LINE_TYPE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_QUEST_LINE_TYPE:
    [enum__Torappu_SandboxV2QuestLineType; 5] = [
    enum__Torappu_SandboxV2QuestLineType::NONE,
    enum__Torappu_SandboxV2QuestLineType::MAIN,
    enum__Torappu_SandboxV2QuestLineType::SIDE,
    enum__Torappu_SandboxV2QuestLineType::GUIDE,
    enum__Torappu_SandboxV2QuestLineType::TRAINING,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2QuestLineType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2QuestLineType {
    pub const NONE: Self = Self(0);
    pub const MAIN: Self = Self(1);
    pub const SIDE: Self = Self(2);
    pub const GUIDE: Self = Self(3);
    pub const TRAINING: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::MAIN,
        Self::SIDE,
        Self::GUIDE,
        Self::TRAINING,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MAIN => Some("MAIN"),
            Self::SIDE => Some("SIDE"),
            Self::GUIDE => Some("GUIDE"),
            Self::TRAINING => Some("TRAINING"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2QuestLineType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2QuestLineType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2QuestLineType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2QuestLineType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2QuestLineType {
    type Output = enum__Torappu_SandboxV2QuestLineType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2QuestLineType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2QuestLineType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2QuestLineType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_NPC_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_NPC_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_NPC_TYPE: [enum__Torappu_SandboxV2NpcType; 4] = [
    enum__Torappu_SandboxV2NpcType::NORMAL,
    enum__Torappu_SandboxV2NpcType::FIXED_RIFT,
    enum__Torappu_SandboxV2NpcType::RANDOM_RIFT,
    enum__Torappu_SandboxV2NpcType::PREY_RIFT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2NpcType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2NpcType {
    pub const NORMAL: Self = Self(0);
    pub const FIXED_RIFT: Self = Self(1);
    pub const RANDOM_RIFT: Self = Self(2);
    pub const PREY_RIFT: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NORMAL,
        Self::FIXED_RIFT,
        Self::RANDOM_RIFT,
        Self::PREY_RIFT,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NORMAL => Some("NORMAL"),
            Self::FIXED_RIFT => Some("FIXED_RIFT"),
            Self::RANDOM_RIFT => Some("RANDOM_RIFT"),
            Self::PREY_RIFT => Some("PREY_RIFT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2NpcType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2NpcType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2NpcType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2NpcType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2NpcType {
    type Output = enum__Torappu_SandboxV2NpcType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2NpcType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2NpcType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2NpcType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BATTLE_DIALOG_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BATTLE_DIALOG_TYPE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BATTLE_DIALOG_TYPE: [enum__Torappu_BattleDialogType; 5] = [
    enum__Torappu_BattleDialogType::NONE,
    enum__Torappu_BattleDialogType::BEFORE,
    enum__Torappu_BattleDialogType::REACT,
    enum__Torappu_BattleDialogType::AFTER,
    enum__Torappu_BattleDialogType::ENUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BattleDialogType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BattleDialogType {
    pub const NONE: Self = Self(0);
    pub const BEFORE: Self = Self(1);
    pub const REACT: Self = Self(2);
    pub const AFTER: Self = Self(3);
    pub const ENUM: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::BEFORE,
        Self::REACT,
        Self::AFTER,
        Self::ENUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::BEFORE => Some("BEFORE"),
            Self::REACT => Some("REACT"),
            Self::AFTER => Some("AFTER"),
            Self::ENUM => Some("ENUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BattleDialogType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_BattleDialogType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_BattleDialogType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BattleDialogType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BattleDialogType {
    type Output = enum__Torappu_BattleDialogType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BattleDialogType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BattleDialogType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BattleDialogType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SHARED_CONSTS_DIRECTION: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SHARED_CONSTS_DIRECTION: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SHARED_CONSTS_DIRECTION:
    [enum__Torappu_SharedConsts_Direction; 6] = [
    enum__Torappu_SharedConsts_Direction::UP,
    enum__Torappu_SharedConsts_Direction::RIGHT,
    enum__Torappu_SharedConsts_Direction::DOWN,
    enum__Torappu_SharedConsts_Direction::LEFT,
    enum__Torappu_SharedConsts_Direction::E_NUM,
    enum__Torappu_SharedConsts_Direction::INVALID,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SharedConsts_Direction(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SharedConsts_Direction {
    pub const UP: Self = Self(0);
    pub const RIGHT: Self = Self(1);
    pub const DOWN: Self = Self(2);
    pub const LEFT: Self = Self(3);
    pub const E_NUM: Self = Self(4);
    pub const INVALID: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::UP,
        Self::RIGHT,
        Self::DOWN,
        Self::LEFT,
        Self::E_NUM,
        Self::INVALID,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::UP => Some("UP"),
            Self::RIGHT => Some("RIGHT"),
            Self::DOWN => Some("DOWN"),
            Self::LEFT => Some("LEFT"),
            Self::E_NUM => Some("E_NUM"),
            Self::INVALID => Some("INVALID"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SharedConsts_Direction {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SharedConsts_Direction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SharedConsts_Direction",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SharedConsts_Direction {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SharedConsts_Direction {
    type Output = enum__Torappu_SharedConsts_Direction;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SharedConsts_Direction {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SharedConsts_Direction {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SharedConsts_Direction {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_QUEST_LINE_BADGE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_QUEST_LINE_BADGE_TYPE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_QUEST_LINE_BADGE_TYPE:
    [enum__Torappu_SandboxV2QuestLineBadgeType; 5] = [
    enum__Torappu_SandboxV2QuestLineBadgeType::NONE,
    enum__Torappu_SandboxV2QuestLineBadgeType::SIDE,
    enum__Torappu_SandboxV2QuestLineBadgeType::GUIDE,
    enum__Torappu_SandboxV2QuestLineBadgeType::MAIN,
    enum__Torappu_SandboxV2QuestLineBadgeType::RIFT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2QuestLineBadgeType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2QuestLineBadgeType {
    pub const NONE: Self = Self(0);
    pub const SIDE: Self = Self(1);
    pub const GUIDE: Self = Self(2);
    pub const MAIN: Self = Self(3);
    pub const RIFT: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::SIDE, Self::GUIDE, Self::MAIN, Self::RIFT];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::SIDE => Some("SIDE"),
            Self::GUIDE => Some("GUIDE"),
            Self::MAIN => Some("MAIN"),
            Self::RIFT => Some("RIFT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2QuestLineBadgeType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2QuestLineBadgeType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2QuestLineBadgeType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2QuestLineBadgeType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2QuestLineBadgeType {
    type Output = enum__Torappu_SandboxV2QuestLineBadgeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2QuestLineBadgeType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2QuestLineBadgeType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2QuestLineBadgeType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_QUEST_LINE_SCOPE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_QUEST_LINE_SCOPE_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_QUEST_LINE_SCOPE_TYPE:
    [enum__Torappu_SandboxV2QuestLineScopeType; 3] = [
    enum__Torappu_SandboxV2QuestLineScopeType::MAIN,
    enum__Torappu_SandboxV2QuestLineScopeType::RIFT,
    enum__Torappu_SandboxV2QuestLineScopeType::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2QuestLineScopeType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2QuestLineScopeType {
    pub const MAIN: Self = Self(0);
    pub const RIFT: Self = Self(1);
    pub const ALL: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::MAIN, Self::RIFT, Self::ALL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::MAIN => Some("MAIN"),
            Self::RIFT => Some("RIFT"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2QuestLineScopeType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2QuestLineScopeType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2QuestLineScopeType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2QuestLineScopeType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2QuestLineScopeType {
    type Output = enum__Torappu_SandboxV2QuestLineScopeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2QuestLineScopeType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2QuestLineScopeType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2QuestLineScopeType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_DEVELOPMENT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_DEVELOPMENT_TYPE: i32 = 5;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_DEVELOPMENT_TYPE:
    [enum__Torappu_SandboxV2DevelopmentType; 6] = [
    enum__Torappu_SandboxV2DevelopmentType::NONE,
    enum__Torappu_SandboxV2DevelopmentType::SURVIVE,
    enum__Torappu_SandboxV2DevelopmentType::COLLECT,
    enum__Torappu_SandboxV2DevelopmentType::SHOP,
    enum__Torappu_SandboxV2DevelopmentType::BATTLE,
    enum__Torappu_SandboxV2DevelopmentType::DUNGEON,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2DevelopmentType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2DevelopmentType {
    pub const NONE: Self = Self(0);
    pub const SURVIVE: Self = Self(1);
    pub const COLLECT: Self = Self(2);
    pub const SHOP: Self = Self(3);
    pub const BATTLE: Self = Self(4);
    pub const DUNGEON: Self = Self(5);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 5;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::SURVIVE,
        Self::COLLECT,
        Self::SHOP,
        Self::BATTLE,
        Self::DUNGEON,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::SURVIVE => Some("SURVIVE"),
            Self::COLLECT => Some("COLLECT"),
            Self::SHOP => Some("SHOP"),
            Self::BATTLE => Some("BATTLE"),
            Self::DUNGEON => Some("DUNGEON"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2DevelopmentType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2DevelopmentType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2DevelopmentType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2DevelopmentType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2DevelopmentType {
    type Output = enum__Torappu_SandboxV2DevelopmentType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2DevelopmentType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2DevelopmentType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2DevelopmentType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_EVENT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_EVENT_TYPE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_EVENT_TYPE: [enum__Torappu_SandboxV2EventType; 5] = [
    enum__Torappu_SandboxV2EventType::NONE,
    enum__Torappu_SandboxV2EventType::EVENT,
    enum__Torappu_SandboxV2EventType::MISSION,
    enum__Torappu_SandboxV2EventType::QUEST_EVENT,
    enum__Torappu_SandboxV2EventType::QUEST_MISSION,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2EventType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2EventType {
    pub const NONE: Self = Self(0);
    pub const EVENT: Self = Self(1);
    pub const MISSION: Self = Self(2);
    pub const QUEST_EVENT: Self = Self(3);
    pub const QUEST_MISSION: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::EVENT,
        Self::MISSION,
        Self::QUEST_EVENT,
        Self::QUEST_MISSION,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::EVENT => Some("EVENT"),
            Self::MISSION => Some("MISSION"),
            Self::QUEST_EVENT => Some("QUEST_EVENT"),
            Self::QUEST_MISSION => Some("QUEST_MISSION"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2EventType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2EventType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2EventType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2EventType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2EventType {
    type Output = enum__Torappu_SandboxV2EventType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2EventType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2EventType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2EventType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_EVENT_CHOICE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_EVENT_CHOICE_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_EVENT_CHOICE_TYPE:
    [enum__Torappu_SandboxV2EventChoiceType; 4] = [
    enum__Torappu_SandboxV2EventChoiceType::NONE,
    enum__Torappu_SandboxV2EventChoiceType::NEXT,
    enum__Torappu_SandboxV2EventChoiceType::LEAVE,
    enum__Torappu_SandboxV2EventChoiceType::MISSION,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2EventChoiceType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2EventChoiceType {
    pub const NONE: Self = Self(0);
    pub const NEXT: Self = Self(1);
    pub const LEAVE: Self = Self(2);
    pub const MISSION: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::NEXT, Self::LEAVE, Self::MISSION];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::NEXT => Some("NEXT"),
            Self::LEAVE => Some("LEAVE"),
            Self::MISSION => Some("MISSION"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2EventChoiceType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2EventChoiceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2EventChoiceType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2EventChoiceType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2EventChoiceType {
    type Output = enum__Torappu_SandboxV2EventChoiceType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2EventChoiceType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2EventChoiceType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2EventChoiceType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_PROFESSION_ID: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_PROFESSION_ID: i32 = 9;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_PROFESSION_ID: [enum__Torappu_ProfessionID; 10] = [
    enum__Torappu_ProfessionID::WARRIOR,
    enum__Torappu_ProfessionID::SNIPER,
    enum__Torappu_ProfessionID::TANK,
    enum__Torappu_ProfessionID::MEDIC,
    enum__Torappu_ProfessionID::SUPPORT,
    enum__Torappu_ProfessionID::CASTER,
    enum__Torappu_ProfessionID::SPECIAL,
    enum__Torappu_ProfessionID::TOKEN,
    enum__Torappu_ProfessionID::TRAP,
    enum__Torappu_ProfessionID::PIONEER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ProfessionID(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ProfessionID {
    pub const WARRIOR: Self = Self(0);
    pub const SNIPER: Self = Self(1);
    pub const TANK: Self = Self(2);
    pub const MEDIC: Self = Self(3);
    pub const SUPPORT: Self = Self(4);
    pub const CASTER: Self = Self(5);
    pub const SPECIAL: Self = Self(6);
    pub const TOKEN: Self = Self(7);
    pub const TRAP: Self = Self(8);
    pub const PIONEER: Self = Self(9);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 9;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::WARRIOR,
        Self::SNIPER,
        Self::TANK,
        Self::MEDIC,
        Self::SUPPORT,
        Self::CASTER,
        Self::SPECIAL,
        Self::TOKEN,
        Self::TRAP,
        Self::PIONEER,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::WARRIOR => Some("WARRIOR"),
            Self::SNIPER => Some("SNIPER"),
            Self::TANK => Some("TANK"),
            Self::MEDIC => Some("MEDIC"),
            Self::SUPPORT => Some("SUPPORT"),
            Self::CASTER => Some("CASTER"),
            Self::SPECIAL => Some("SPECIAL"),
            Self::TOKEN => Some("TOKEN"),
            Self::TRAP => Some("TRAP"),
            Self::PIONEER => Some("PIONEER"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ProfessionID {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ProfessionID {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ProfessionID",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ProfessionID {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ProfessionID {
    type Output = enum__Torappu_ProfessionID;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ProfessionID {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ProfessionID {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ProfessionID {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_COIN_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_COIN_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_COIN_TYPE: [enum__Torappu_SandboxV2CoinType; 2] = [
    enum__Torappu_SandboxV2CoinType::DIMENSION_COIN,
    enum__Torappu_SandboxV2CoinType::GOLD,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2CoinType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2CoinType {
    pub const DIMENSION_COIN: Self = Self(0);
    pub const GOLD: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::DIMENSION_COIN, Self::GOLD];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::DIMENSION_COIN => Some("DIMENSION_COIN"),
            Self::GOLD => Some("GOLD"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2CoinType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2CoinType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2CoinType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2CoinType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2CoinType {
    type Output = enum__Torappu_SandboxV2CoinType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2CoinType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2CoinType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2CoinType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_RIFT_MAIN_TARGET_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_RIFT_MAIN_TARGET_TYPE: i32 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_RIFT_MAIN_TARGET_TYPE:
    [enum__Torappu_SandboxV2RiftMainTargetType; 8] = [
    enum__Torappu_SandboxV2RiftMainTargetType::NONE,
    enum__Torappu_SandboxV2RiftMainTargetType::FIND,
    enum__Torappu_SandboxV2RiftMainTargetType::BOSS_HUNT,
    enum__Torappu_SandboxV2RiftMainTargetType::WILD_HUNT,
    enum__Torappu_SandboxV2RiftMainTargetType::PROTECT,
    enum__Torappu_SandboxV2RiftMainTargetType::FIGHT,
    enum__Torappu_SandboxV2RiftMainTargetType::CATCH_THIEF,
    enum__Torappu_SandboxV2RiftMainTargetType::PREY_HUNT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2RiftMainTargetType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2RiftMainTargetType {
    pub const NONE: Self = Self(0);
    pub const FIND: Self = Self(1);
    pub const BOSS_HUNT: Self = Self(2);
    pub const WILD_HUNT: Self = Self(3);
    pub const PROTECT: Self = Self(4);
    pub const FIGHT: Self = Self(5);
    pub const CATCH_THIEF: Self = Self(6);
    pub const PREY_HUNT: Self = Self(7);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 7;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::FIND,
        Self::BOSS_HUNT,
        Self::WILD_HUNT,
        Self::PROTECT,
        Self::FIGHT,
        Self::CATCH_THIEF,
        Self::PREY_HUNT,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::FIND => Some("FIND"),
            Self::BOSS_HUNT => Some("BOSS_HUNT"),
            Self::WILD_HUNT => Some("WILD_HUNT"),
            Self::PROTECT => Some("PROTECT"),
            Self::FIGHT => Some("FIGHT"),
            Self::CATCH_THIEF => Some("CATCH_THIEF"),
            Self::PREY_HUNT => Some("PREY_HUNT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2RiftMainTargetType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2RiftMainTargetType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2RiftMainTargetType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2RiftMainTargetType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2RiftMainTargetType {
    type Output = enum__Torappu_SandboxV2RiftMainTargetType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2RiftMainTargetType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2RiftMainTargetType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2RiftMainTargetType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_ARCHIVE_QUEST_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_ARCHIVE_QUEST_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_ARCHIVE_QUEST_TYPE:
    [enum__Torappu_SandboxV2ArchiveQuestType; 3] = [
    enum__Torappu_SandboxV2ArchiveQuestType::NONE,
    enum__Torappu_SandboxV2ArchiveQuestType::MAIN,
    enum__Torappu_SandboxV2ArchiveQuestType::SIDE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2ArchiveQuestType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2ArchiveQuestType {
    pub const NONE: Self = Self(0);
    pub const MAIN: Self = Self(1);
    pub const SIDE: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::MAIN, Self::SIDE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MAIN => Some("MAIN"),
            Self::SIDE => Some("SIDE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2ArchiveQuestType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2ArchiveQuestType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2ArchiveQuestType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2ArchiveQuestType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2ArchiveQuestType {
    type Output = enum__Torappu_SandboxV2ArchiveQuestType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2ArchiveQuestType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2ArchiveQuestType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2ArchiveQuestType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_BASE_UNLOCK_FUNC_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_BASE_UNLOCK_FUNC_TYPE: i32 = 8;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_BASE_UNLOCK_FUNC_TYPE:
    [enum__Torappu_SandboxV2BaseUnlockFuncType; 9] = [
    enum__Torappu_SandboxV2BaseUnlockFuncType::NONE,
    enum__Torappu_SandboxV2BaseUnlockFuncType::HOME_PUTPOST,
    enum__Torappu_SandboxV2BaseUnlockFuncType::HOME_PORTABLE,
    enum__Torappu_SandboxV2BaseUnlockFuncType::REWARDSHOP,
    enum__Torappu_SandboxV2BaseUnlockFuncType::TECH,
    enum__Torappu_SandboxV2BaseUnlockFuncType::REAR,
    enum__Torappu_SandboxV2BaseUnlockFuncType::BUILD,
    enum__Torappu_SandboxV2BaseUnlockFuncType::SHOP,
    enum__Torappu_SandboxV2BaseUnlockFuncType::RACING,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2BaseUnlockFuncType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2BaseUnlockFuncType {
    pub const NONE: Self = Self(0);
    pub const HOME_PUTPOST: Self = Self(1);
    pub const HOME_PORTABLE: Self = Self(2);
    pub const REWARDSHOP: Self = Self(3);
    pub const TECH: Self = Self(4);
    pub const REAR: Self = Self(5);
    pub const BUILD: Self = Self(6);
    pub const SHOP: Self = Self(7);
    pub const RACING: Self = Self(8);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 8;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::HOME_PUTPOST,
        Self::HOME_PORTABLE,
        Self::REWARDSHOP,
        Self::TECH,
        Self::REAR,
        Self::BUILD,
        Self::SHOP,
        Self::RACING,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::HOME_PUTPOST => Some("HOME_PUTPOST"),
            Self::HOME_PORTABLE => Some("HOME_PORTABLE"),
            Self::REWARDSHOP => Some("REWARDSHOP"),
            Self::TECH => Some("TECH"),
            Self::REAR => Some("REAR"),
            Self::BUILD => Some("BUILD"),
            Self::SHOP => Some("SHOP"),
            Self::RACING => Some("RACING"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2BaseUnlockFuncType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2BaseUnlockFuncType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2BaseUnlockFuncType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2BaseUnlockFuncType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2BaseUnlockFuncType {
    type Output = enum__Torappu_SandboxV2BaseUnlockFuncType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2BaseUnlockFuncType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2BaseUnlockFuncType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2BaseUnlockFuncType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_BASE_UNLOCK_FUNC_DISPLAY_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_BASE_UNLOCK_FUNC_DISPLAY_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_BASE_UNLOCK_FUNC_DISPLAY_TYPE:
    [enum__Torappu_SandboxV2BaseUnlockFuncDisplayType; 4] = [
    enum__Torappu_SandboxV2BaseUnlockFuncDisplayType::NONE,
    enum__Torappu_SandboxV2BaseUnlockFuncDisplayType::NEW,
    enum__Torappu_SandboxV2BaseUnlockFuncDisplayType::UPDATE,
    enum__Torappu_SandboxV2BaseUnlockFuncDisplayType::NUMBER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2BaseUnlockFuncDisplayType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2BaseUnlockFuncDisplayType {
    pub const NONE: Self = Self(0);
    pub const NEW: Self = Self(1);
    pub const UPDATE: Self = Self(2);
    pub const NUMBER: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::NEW, Self::UPDATE, Self::NUMBER];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::NEW => Some("NEW"),
            Self::UPDATE => Some("UPDATE"),
            Self::NUMBER => Some("NUMBER"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2BaseUnlockFuncDisplayType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2BaseUnlockFuncDisplayType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2BaseUnlockFuncDisplayType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2BaseUnlockFuncDisplayType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2BaseUnlockFuncDisplayType {
    type Output = enum__Torappu_SandboxV2BaseUnlockFuncDisplayType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2BaseUnlockFuncDisplayType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2BaseUnlockFuncDisplayType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2BaseUnlockFuncDisplayType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_DEVELOPMENT_LINE_STYLE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_DEVELOPMENT_LINE_STYLE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_DEVELOPMENT_LINE_STYLE:
    [enum__Torappu_SandboxV2DevelopmentLineStyle; 3] = [
    enum__Torappu_SandboxV2DevelopmentLineStyle::EMPTY,
    enum__Torappu_SandboxV2DevelopmentLineStyle::LEVEL_PASS,
    enum__Torappu_SandboxV2DevelopmentLineStyle::LEVEL_BLOCK,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2DevelopmentLineStyle(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2DevelopmentLineStyle {
    pub const EMPTY: Self = Self(0);
    pub const LEVEL_PASS: Self = Self(1);
    pub const LEVEL_BLOCK: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::EMPTY, Self::LEVEL_PASS, Self::LEVEL_BLOCK];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::EMPTY => Some("EMPTY"),
            Self::LEVEL_PASS => Some("LEVEL_PASS"),
            Self::LEVEL_BLOCK => Some("LEVEL_BLOCK"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2DevelopmentLineStyle {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2DevelopmentLineStyle {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2DevelopmentLineStyle",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2DevelopmentLineStyle {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2DevelopmentLineStyle {
    type Output = enum__Torappu_SandboxV2DevelopmentLineStyle;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2DevelopmentLineStyle {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2DevelopmentLineStyle {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2DevelopmentLineStyle {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_CONFIRM_ICON_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_CONFIRM_ICON_TYPE: i32 = 10;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_CONFIRM_ICON_TYPE:
    [enum__Torappu_SandboxV2ConfirmIconType; 11] = [
    enum__Torappu_SandboxV2ConfirmIconType::COMMON,
    enum__Torappu_SandboxV2ConfirmIconType::EMERGENCY,
    enum__Torappu_SandboxV2ConfirmIconType::QUIT,
    enum__Torappu_SandboxV2ConfirmIconType::EVACUATE,
    enum__Torappu_SandboxV2ConfirmIconType::EVACUATELOSS,
    enum__Torappu_SandboxV2ConfirmIconType::NORMAL,
    enum__Torappu_SandboxV2ConfirmIconType::COMBAT,
    enum__Torappu_SandboxV2ConfirmIconType::CONSTRUCT,
    enum__Torappu_SandboxV2ConfirmIconType::NEXTDAY,
    enum__Torappu_SandboxV2ConfirmIconType::RIFT_EXIT,
    enum__Torappu_SandboxV2ConfirmIconType::LOAD_ARCHIVE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2ConfirmIconType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2ConfirmIconType {
    pub const COMMON: Self = Self(0);
    pub const EMERGENCY: Self = Self(1);
    pub const QUIT: Self = Self(2);
    pub const EVACUATE: Self = Self(3);
    pub const EVACUATELOSS: Self = Self(4);
    pub const NORMAL: Self = Self(5);
    pub const COMBAT: Self = Self(6);
    pub const CONSTRUCT: Self = Self(7);
    pub const NEXTDAY: Self = Self(8);
    pub const RIFT_EXIT: Self = Self(9);
    pub const LOAD_ARCHIVE: Self = Self(10);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 10;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::COMMON,
        Self::EMERGENCY,
        Self::QUIT,
        Self::EVACUATE,
        Self::EVACUATELOSS,
        Self::NORMAL,
        Self::COMBAT,
        Self::CONSTRUCT,
        Self::NEXTDAY,
        Self::RIFT_EXIT,
        Self::LOAD_ARCHIVE,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::COMMON => Some("COMMON"),
            Self::EMERGENCY => Some("EMERGENCY"),
            Self::QUIT => Some("QUIT"),
            Self::EVACUATE => Some("EVACUATE"),
            Self::EVACUATELOSS => Some("EVACUATELOSS"),
            Self::NORMAL => Some("NORMAL"),
            Self::COMBAT => Some("COMBAT"),
            Self::CONSTRUCT => Some("CONSTRUCT"),
            Self::NEXTDAY => Some("NEXTDAY"),
            Self::RIFT_EXIT => Some("RIFT_EXIT"),
            Self::LOAD_ARCHIVE => Some("LOAD_ARCHIVE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2ConfirmIconType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2ConfirmIconType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2ConfirmIconType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2ConfirmIconType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2ConfirmIconType {
    type Output = enum__Torappu_SandboxV2ConfirmIconType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2ConfirmIconType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2ConfirmIconType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2ConfirmIconType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_EVOLVE_PHASE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_EVOLVE_PHASE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_EVOLVE_PHASE: [enum__Torappu_EvolvePhase; 5] = [
    enum__Torappu_EvolvePhase::PHASE_0,
    enum__Torappu_EvolvePhase::PHASE_1,
    enum__Torappu_EvolvePhase::PHASE_2,
    enum__Torappu_EvolvePhase::PHASE_3,
    enum__Torappu_EvolvePhase::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_EvolvePhase(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_EvolvePhase {
    pub const PHASE_0: Self = Self(0);
    pub const PHASE_1: Self = Self(1);
    pub const PHASE_2: Self = Self(2);
    pub const PHASE_3: Self = Self(3);
    pub const E_NUM: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::PHASE_0,
        Self::PHASE_1,
        Self::PHASE_2,
        Self::PHASE_3,
        Self::E_NUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::PHASE_0 => Some("PHASE_0"),
            Self::PHASE_1 => Some("PHASE_1"),
            Self::PHASE_2 => Some("PHASE_2"),
            Self::PHASE_3 => Some("PHASE_3"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_EvolvePhase {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_EvolvePhase {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_EvolvePhase",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_EvolvePhase {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_EvolvePhase {
    type Output = enum__Torappu_EvolvePhase;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_EvolvePhase {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_EvolvePhase {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_EvolvePhase {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_RACER_TALENT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_RACER_TALENT_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_RACER_TALENT_TYPE:
    [enum__Torappu_SandboxV2RacerTalentType; 2] = [
    enum__Torappu_SandboxV2RacerTalentType::BORN,
    enum__Torappu_SandboxV2RacerTalentType::LEARNED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2RacerTalentType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2RacerTalentType {
    pub const BORN: Self = Self(0);
    pub const LEARNED: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::BORN, Self::LEARNED];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::BORN => Some("BORN"),
            Self::LEARNED => Some("LEARNED"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2RacerTalentType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2RacerTalentType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2RacerTalentType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2RacerTalentType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2RacerTalentType {
    type Output = enum__Torappu_SandboxV2RacerTalentType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2RacerTalentType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2RacerTalentType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2RacerTalentType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_V_2_RACER_NAME_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_V_2_RACER_NAME_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_V_2_RACER_NAME_TYPE:
    [enum__Torappu_SandboxV2RacerNameType; 2] = [
    enum__Torappu_SandboxV2RacerNameType::PREFIX,
    enum__Torappu_SandboxV2RacerNameType::SUFFIX,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxV2RacerNameType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxV2RacerNameType {
    pub const PREFIX: Self = Self(0);
    pub const SUFFIX: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::PREFIX, Self::SUFFIX];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::PREFIX => Some("PREFIX"),
            Self::SUFFIX => Some("SUFFIX"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxV2RacerNameType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SandboxV2RacerNameType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SandboxV2RacerNameType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxV2RacerNameType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxV2RacerNameType {
    type Output = enum__Torappu_SandboxV2RacerNameType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxV2RacerNameType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxV2RacerNameType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxV2RacerNameType {}
pub enum clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'a> {
    type Inner = clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'a> {
    pub const VT_DISPLAYID: flatbuffers::VOffsetT = 4;
    pub const VT_TOPICID: flatbuffers::VOffsetT = 6;
    pub const VT_STARTTS: flatbuffers::VOffsetT = 8;
    pub const VT_ENDTS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'bldr>> {
        let mut builder = clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataBuilder::new(_fbb);
        builder.add_endTs(args.endTs);
        builder.add_startTs(args.startTs);
        if let Some(x) = args.topicId {
            builder.add_topicId(x);
        }
        if let Some(x) = args.displayId {
            builder.add_displayId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataT {
        let displayId = self.displayId().map(|x| x.to_string());
        let topicId = self.topicId().map(|x| x.to_string());
        let startTs = self.startTs();
        let endTs = self.endTs();
        clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataT {
            displayId,
            topicId,
            startTs,
            endTs,
        }
    }

    #[inline]
    pub fn displayId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData::VT_DISPLAYID,
                None,
            )
        }
    }
    #[inline]
    pub fn topicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData::VT_TOPICID,
                None,
            )
        }
    }
    #[inline]
    pub fn startTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData::VT_STARTTS,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn endTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData::VT_ENDTS,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "displayId",
                Self::VT_DISPLAYID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("topicId", Self::VT_TOPICID, false)?
            .visit_field::<i64>("startTs", Self::VT_STARTTS, false)?
            .visit_field::<i64>("endTs", Self::VT_ENDTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataArgs<'a> {
    pub displayId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub topicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub startTs: i64,
    pub endTs: i64,
}
impl<'a> Default for clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataArgs {
            displayId: None,
            topicId: None,
            startTs: 0,
            endTs: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData", 4)?;
        if let Some(f) = self.displayId() {
            s.serialize_field("displayId", &f)?;
        } else {
            s.skip_field("displayId")?;
        }
        if let Some(f) = self.topicId() {
            s.serialize_field("topicId", &f)?;
        } else {
            s.skip_field("topicId")?;
        }
        s.serialize_field("startTs", &self.startTs())?;
        s.serialize_field("endTs", &self.endTs())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_displayId(&mut self, displayId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData::VT_DISPLAYID,
            displayId,
        );
    }
    #[inline]
    pub fn add_topicId(&mut self, topicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData::VT_TOPICID,
            topicId,
        );
    }
    #[inline]
    pub fn add_startTs(&mut self, startTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData::VT_STARTTS,
            startTs,
            0,
        );
    }
    #[inline]
    pub fn add_endTs(&mut self, endTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData::VT_ENDTS,
            endTs,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData");
        ds.field("displayId", &self.displayId());
        ds.field("topicId", &self.topicId());
        ds.field("startTs", &self.startTs());
        ds.field("endTs", &self.endTs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataT {
    pub displayId: Option<String>,
    pub topicId: Option<String>,
    pub startTs: i64,
    pub endTs: i64,
}
impl Default for clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataT {
    fn default() -> Self {
        Self {
            displayId: None,
            topicId: None,
            startTs: 0,
            endTs: 0,
        }
    }
}
impl clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'b>> {
        let displayId = self.displayId.as_ref().map(|x| _fbb.create_string(x));
        let topicId = self.topicId.as_ref().map(|x| _fbb.create_string(x));
        let startTs = self.startTs;
        let endTs = self.endTs;
        clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData::create(
            _fbb,
            &clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataArgs {
                displayId,
                topicId,
                startTs,
                endTs,
            },
        )
    }
}
pub enum clz_Torappu_SandboxPermBasicDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxPermBasicData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxPermBasicData<'a> {
    type Inner = clz_Torappu_SandboxPermBasicData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxPermBasicData<'a> {
    pub const VT_TOPICID: flatbuffers::VOffsetT = 4;
    pub const VT_TOPICTEMPLATE: flatbuffers::VOffsetT = 6;
    pub const VT_TOPICNAME: flatbuffers::VOffsetT = 8;
    pub const VT_TOPICSTARTTIME: flatbuffers::VOffsetT = 10;
    pub const VT_FULLSTOREDTIME: flatbuffers::VOffsetT = 12;
    pub const VT_SORTID: flatbuffers::VOffsetT = 14;
    pub const VT_PRICEITEMID: flatbuffers::VOffsetT = 16;
    pub const VT_TEMPLATESHOPID: flatbuffers::VOffsetT = 18;
    pub const VT_HOMEENTRYDISPLAYDATA: flatbuffers::VOffsetT = 20;
    pub const VT_WEBBUSTYPE: flatbuffers::VOffsetT = 22;
    pub const VT_MEDALGROUPID: flatbuffers::VOffsetT = 24;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxPermBasicData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxPermBasicDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermBasicData<'bldr>> {
        let mut builder = clz_Torappu_SandboxPermBasicDataBuilder::new(_fbb);
        builder.add_fullStoredTime(args.fullStoredTime);
        builder.add_topicStartTime(args.topicStartTime);
        if let Some(x) = args.medalGroupId {
            builder.add_medalGroupId(x);
        }
        if let Some(x) = args.webBusType {
            builder.add_webBusType(x);
        }
        if let Some(x) = args.homeEntryDisplayData {
            builder.add_homeEntryDisplayData(x);
        }
        if let Some(x) = args.templateShopId {
            builder.add_templateShopId(x);
        }
        if let Some(x) = args.priceItemId {
            builder.add_priceItemId(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.topicName {
            builder.add_topicName(x);
        }
        builder.add_topicTemplate(args.topicTemplate);
        if let Some(x) = args.topicId {
            builder.add_topicId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxPermBasicDataT {
        let topicId = self.topicId().map(|x| x.to_string());
        let topicTemplate = self.topicTemplate();
        let topicName = self.topicName().map(|x| x.to_string());
        let topicStartTime = self.topicStartTime();
        let fullStoredTime = self.fullStoredTime();
        let sortId = self.sortId();
        let priceItemId = self.priceItemId().map(|x| x.to_string());
        let templateShopId = self.templateShopId().map(|x| x.to_string());
        let homeEntryDisplayData = self
            .homeEntryDisplayData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let webBusType = self.webBusType().map(|x| x.to_string());
        let medalGroupId = self.medalGroupId().map(|x| x.to_string());
        clz_Torappu_SandboxPermBasicDataT {
            topicId,
            topicTemplate,
            topicName,
            topicStartTime,
            fullStoredTime,
            sortId,
            priceItemId,
            templateShopId,
            homeEntryDisplayData,
            webBusType,
            medalGroupId,
        }
    }

    #[inline]
    pub fn topicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermBasicData::VT_TOPICID,
                None,
            )
        }
    }
    #[inline]
    pub fn topicTemplate(&self) -> enum__Torappu_SandboxPermTemplateType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxPermTemplateType>(
                    clz_Torappu_SandboxPermBasicData::VT_TOPICTEMPLATE,
                    Some(enum__Torappu_SandboxPermTemplateType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn topicName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermBasicData::VT_TOPICNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn topicStartTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_SandboxPermBasicData::VT_TOPICSTARTTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn fullStoredTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_SandboxPermBasicData::VT_FULLSTOREDTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxPermBasicData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn priceItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermBasicData::VT_PRICEITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn templateShopId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermBasicData::VT_TEMPLATESHOPID,
                None,
            )
        }
    }
    #[inline]
    pub fn homeEntryDisplayData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData,
                    >,
                >,
            >>(
                clz_Torappu_SandboxPermBasicData::VT_HOMEENTRYDISPLAYDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn webBusType(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermBasicData::VT_WEBBUSTYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn medalGroupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermBasicData::VT_MEDALGROUPID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxPermBasicData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("topicId", Self::VT_TOPICID, false)?
            .visit_field::<enum__Torappu_SandboxPermTemplateType>(
                "topicTemplate",
                Self::VT_TOPICTEMPLATE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "topicName",
                Self::VT_TOPICNAME,
                false,
            )?
            .visit_field::<i64>("topicStartTime", Self::VT_TOPICSTARTTIME, false)?
            .visit_field::<i64>("fullStoredTime", Self::VT_FULLSTOREDTIME, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "priceItemId",
                Self::VT_PRICEITEMID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "templateShopId",
                Self::VT_TEMPLATESHOPID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData,
                    >,
                >,
            >>("homeEntryDisplayData", Self::VT_HOMEENTRYDISPLAYDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "webBusType",
                Self::VT_WEBBUSTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "medalGroupId",
                Self::VT_MEDALGROUPID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxPermBasicDataArgs<'a> {
    pub topicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub topicTemplate: enum__Torappu_SandboxPermTemplateType,
    pub topicName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub topicStartTime: i64,
    pub fullStoredTime: i64,
    pub sortId: i32,
    pub priceItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub templateShopId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub homeEntryDisplayData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'a>,
                >,
            >,
        >,
    >,
    pub webBusType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub medalGroupId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxPermBasicDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxPermBasicDataArgs {
            topicId: None,
            topicTemplate: enum__Torappu_SandboxPermTemplateType::NONE,
            topicName: None,
            topicStartTime: 0,
            fullStoredTime: 0,
            sortId: 0,
            priceItemId: None,
            templateShopId: None,
            homeEntryDisplayData: None,
            webBusType: None,
            medalGroupId: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxPermBasicData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxPermBasicData", 11)?;
        if let Some(f) = self.topicId() {
            s.serialize_field("topicId", &f)?;
        } else {
            s.skip_field("topicId")?;
        }
        s.serialize_field("topicTemplate", &self.topicTemplate())?;
        if let Some(f) = self.topicName() {
            s.serialize_field("topicName", &f)?;
        } else {
            s.skip_field("topicName")?;
        }
        s.serialize_field("topicStartTime", &self.topicStartTime())?;
        s.serialize_field("fullStoredTime", &self.fullStoredTime())?;
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.priceItemId() {
            s.serialize_field("priceItemId", &f)?;
        } else {
            s.skip_field("priceItemId")?;
        }
        if let Some(f) = self.templateShopId() {
            s.serialize_field("templateShopId", &f)?;
        } else {
            s.skip_field("templateShopId")?;
        }
        if let Some(f) = self.homeEntryDisplayData() {
            s.serialize_field("homeEntryDisplayData", &f)?;
        } else {
            s.skip_field("homeEntryDisplayData")?;
        }
        if let Some(f) = self.webBusType() {
            s.serialize_field("webBusType", &f)?;
        } else {
            s.skip_field("webBusType")?;
        }
        if let Some(f) = self.medalGroupId() {
            s.serialize_field("medalGroupId", &f)?;
        } else {
            s.skip_field("medalGroupId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxPermBasicDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxPermBasicDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_topicId(&mut self, topicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermBasicData::VT_TOPICID,
            topicId,
        );
    }
    #[inline]
    pub fn add_topicTemplate(&mut self, topicTemplate: enum__Torappu_SandboxPermTemplateType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxPermTemplateType>(
                clz_Torappu_SandboxPermBasicData::VT_TOPICTEMPLATE,
                topicTemplate,
                enum__Torappu_SandboxPermTemplateType::NONE,
            );
    }
    #[inline]
    pub fn add_topicName(&mut self, topicName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermBasicData::VT_TOPICNAME,
            topicName,
        );
    }
    #[inline]
    pub fn add_topicStartTime(&mut self, topicStartTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_SandboxPermBasicData::VT_TOPICSTARTTIME,
            topicStartTime,
            0,
        );
    }
    #[inline]
    pub fn add_fullStoredTime(&mut self, fullStoredTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_SandboxPermBasicData::VT_FULLSTOREDTIME,
            fullStoredTime,
            0,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxPermBasicData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_priceItemId(&mut self, priceItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermBasicData::VT_PRICEITEMID,
            priceItemId,
        );
    }
    #[inline]
    pub fn add_templateShopId(&mut self, templateShopId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermBasicData::VT_TEMPLATESHOPID,
            templateShopId,
        );
    }
    #[inline]
    pub fn add_homeEntryDisplayData(
        &mut self,
        homeEntryDisplayData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_SandboxPermBasicData_HomeEntryDisplayData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermBasicData::VT_HOMEENTRYDISPLAYDATA,
            homeEntryDisplayData,
        );
    }
    #[inline]
    pub fn add_webBusType(&mut self, webBusType: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermBasicData::VT_WEBBUSTYPE,
            webBusType,
        );
    }
    #[inline]
    pub fn add_medalGroupId(&mut self, medalGroupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermBasicData::VT_MEDALGROUPID,
            medalGroupId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxPermBasicDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxPermBasicDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermBasicData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxPermBasicData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxPermBasicData");
        ds.field("topicId", &self.topicId());
        ds.field("topicTemplate", &self.topicTemplate());
        ds.field("topicName", &self.topicName());
        ds.field("topicStartTime", &self.topicStartTime());
        ds.field("fullStoredTime", &self.fullStoredTime());
        ds.field("sortId", &self.sortId());
        ds.field("priceItemId", &self.priceItemId());
        ds.field("templateShopId", &self.templateShopId());
        ds.field("homeEntryDisplayData", &self.homeEntryDisplayData());
        ds.field("webBusType", &self.webBusType());
        ds.field("medalGroupId", &self.medalGroupId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxPermBasicDataT {
    pub topicId: Option<String>,
    pub topicTemplate: enum__Torappu_SandboxPermTemplateType,
    pub topicName: Option<String>,
    pub topicStartTime: i64,
    pub fullStoredTime: i64,
    pub sortId: i32,
    pub priceItemId: Option<String>,
    pub templateShopId: Option<String>,
    pub homeEntryDisplayData: Option<Vec<clz_Torappu_SandboxPermBasicData_HomeEntryDisplayDataT>>,
    pub webBusType: Option<String>,
    pub medalGroupId: Option<String>,
}
impl Default for clz_Torappu_SandboxPermBasicDataT {
    fn default() -> Self {
        Self {
            topicId: None,
            topicTemplate: enum__Torappu_SandboxPermTemplateType::NONE,
            topicName: None,
            topicStartTime: 0,
            fullStoredTime: 0,
            sortId: 0,
            priceItemId: None,
            templateShopId: None,
            homeEntryDisplayData: None,
            webBusType: None,
            medalGroupId: None,
        }
    }
}
impl clz_Torappu_SandboxPermBasicDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermBasicData<'b>> {
        let topicId = self.topicId.as_ref().map(|x| _fbb.create_string(x));
        let topicTemplate = self.topicTemplate;
        let topicName = self.topicName.as_ref().map(|x| _fbb.create_string(x));
        let topicStartTime = self.topicStartTime;
        let fullStoredTime = self.fullStoredTime;
        let sortId = self.sortId;
        let priceItemId = self.priceItemId.as_ref().map(|x| _fbb.create_string(x));
        let templateShopId = self.templateShopId.as_ref().map(|x| _fbb.create_string(x));
        let homeEntryDisplayData = self.homeEntryDisplayData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let webBusType = self.webBusType.as_ref().map(|x| _fbb.create_string(x));
        let medalGroupId = self.medalGroupId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxPermBasicData::create(
            _fbb,
            &clz_Torappu_SandboxPermBasicDataArgs {
                topicId,
                topicTemplate,
                topicName,
                topicStartTime,
                fullStoredTime,
                sortId,
                priceItemId,
                templateShopId,
                homeEntryDisplayData,
                webBusType,
                medalGroupId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxPermBasicDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxPermBasicData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxPermBasicData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxPermBasicData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxPermBasicData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxPermBasicData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxPermBasicDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxPermBasicData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxPermBasicDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxPermBasicDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxPermBasicDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxPermBasicData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxPermBasicData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxPermBasicData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxPermBasicData>>(
                    dict__string__clz_Torappu_SandboxPermBasicData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxPermBasicData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxPermBasicData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxPermBasicDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxPermBasicData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxPermBasicDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxPermBasicDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxPermBasicData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxPermBasicData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxPermBasicDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxPermBasicDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxPermBasicData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxPermBasicData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxPermBasicData>>(
                dict__string__clz_Torappu_SandboxPermBasicData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxPermBasicDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxPermBasicDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxPermBasicData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxPermBasicData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxPermBasicData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxPermBasicData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxPermBasicDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxPermBasicDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxPermBasicDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxPermBasicDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxPermBasicData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxPermBasicData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxPermBasicDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2NodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2NodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2NodeData<'a> {
    type Inner = clz_Torappu_SandboxV2NodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2NodeData<'a> {
    pub const VT_MINDISTANCE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2NodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2NodeDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2NodeDataBuilder::new(_fbb);
        builder.add_minDistance(args.minDistance);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2NodeDataT {
        let minDistance = self.minDistance();
        clz_Torappu_SandboxV2NodeDataT { minDistance }
    }

    #[inline]
    pub fn minDistance(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_SandboxV2NodeData::VT_MINDISTANCE, Some(0.0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2NodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("minDistance", Self::VT_MINDISTANCE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2NodeDataArgs {
    pub minDistance: f32,
}
impl<'a> Default for clz_Torappu_SandboxV2NodeDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2NodeDataArgs { minDistance: 0.0 }
    }
}

impl Serialize for clz_Torappu_SandboxV2NodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2NodeData", 1)?;
        s.serialize_field("minDistance", &self.minDistance())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2NodeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2NodeDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_minDistance(&mut self, minDistance: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2NodeData::VT_MINDISTANCE,
            minDistance,
            0.0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2NodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2NodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2NodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2NodeData");
        ds.field("minDistance", &self.minDistance());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2NodeDataT {
    pub minDistance: f32,
}
impl Default for clz_Torappu_SandboxV2NodeDataT {
    fn default() -> Self {
        Self { minDistance: 0.0 }
    }
}
impl clz_Torappu_SandboxV2NodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeData<'b>> {
        let minDistance = self.minDistance;
        clz_Torappu_SandboxV2NodeData::create(
            _fbb,
            &clz_Torappu_SandboxV2NodeDataArgs { minDistance },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2NodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2NodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2NodeData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2NodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2NodeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2NodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2NodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NodeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2NodeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2NodeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2NodeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2NodeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2NodeData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2NodeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2NodeData>>(
                    dict__string__clz_Torappu_SandboxV2NodeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2NodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2NodeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2NodeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2NodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2NodeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2NodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2NodeData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2NodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2NodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2NodeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeData>>(
                dict__string__clz_Torappu_SandboxV2NodeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2NodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2NodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2NodeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2NodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2NodeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2NodeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2NodeDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2NodeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2NodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NodeData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2NodeData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2NodeDataArgs { key, value },
        )
    }
}
pub enum clz_UnityEngine_Vector2Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_UnityEngine_Vector2<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_UnityEngine_Vector2<'a> {
    type Inner = clz_UnityEngine_Vector2<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_UnityEngine_Vector2<'a> {
    pub const VT_X: flatbuffers::VOffsetT = 4;
    pub const VT_Y: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_UnityEngine_Vector2 { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_UnityEngine_Vector2Args,
    ) -> flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'bldr>> {
        let mut builder = clz_UnityEngine_Vector2Builder::new(_fbb);
        builder.add_y(args.y);
        builder.add_x(args.x);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_UnityEngine_Vector2T {
        let x = self.x();
        let y = self.y();
        clz_UnityEngine_Vector2T { x, y }
    }

    #[inline]
    pub fn x(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_UnityEngine_Vector2::VT_X, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn y(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_UnityEngine_Vector2::VT_Y, Some(0.0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_UnityEngine_Vector2<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("x", Self::VT_X, false)?
            .visit_field::<f32>("y", Self::VT_Y, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_UnityEngine_Vector2Args {
    pub x: f32,
    pub y: f32,
}
impl<'a> Default for clz_UnityEngine_Vector2Args {
    #[inline]
    fn default() -> Self {
        clz_UnityEngine_Vector2Args { x: 0.0, y: 0.0 }
    }
}

impl Serialize for clz_UnityEngine_Vector2<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_UnityEngine_Vector2", 2)?;
        s.serialize_field("x", &self.x())?;
        s.serialize_field("y", &self.y())?;
        s.end()
    }
}

pub struct clz_UnityEngine_Vector2Builder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_UnityEngine_Vector2Builder<'a, 'b, A> {
    #[inline]
    pub fn add_x(&mut self, x: f32) {
        self.fbb_
            .push_slot::<f32>(clz_UnityEngine_Vector2::VT_X, x, 0.0);
    }
    #[inline]
    pub fn add_y(&mut self, y: f32) {
        self.fbb_
            .push_slot::<f32>(clz_UnityEngine_Vector2::VT_Y, y, 0.0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_UnityEngine_Vector2Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_UnityEngine_Vector2Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_UnityEngine_Vector2<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_UnityEngine_Vector2");
        ds.field("x", &self.x());
        ds.field("y", &self.y());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_UnityEngine_Vector2T {
    pub x: f32,
    pub y: f32,
}
impl Default for clz_UnityEngine_Vector2T {
    fn default() -> Self {
        Self { x: 0.0, y: 0.0 }
    }
}
impl clz_UnityEngine_Vector2T {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'b>> {
        let x = self.x;
        let y = self.y;
        clz_UnityEngine_Vector2::create(_fbb, &clz_UnityEngine_Vector2Args { x, y })
    }
}
pub enum list_intOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct list_int<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for list_int<'a> {
    type Inner = list_int<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> list_int<'a> {
    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        list_int { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args list_intArgs<'args>,
    ) -> flatbuffers::WIPOffset<list_int<'bldr>> {
        let mut builder = list_intBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> list_intT {
        let values = self.values().map(|x| x.into_iter().collect());
        list_intT { values }
    }

    #[inline]
    pub fn values(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    list_int::VT_VALUES,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for list_int<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "values",
                Self::VT_VALUES,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct list_intArgs<'a> {
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for list_intArgs<'a> {
    #[inline]
    fn default() -> Self {
        list_intArgs { values: None }
    }
}

impl Serialize for list_int<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("list_int", 1)?;
        if let Some(f) = self.values() {
            s.serialize_field("values", &f)?;
        } else {
            s.skip_field("values")?;
        }
        s.end()
    }
}

pub struct list_intBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> list_intBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(list_int::VT_VALUES, values);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> list_intBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        list_intBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<list_int<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for list_int<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("list_int");
        ds.field("values", &self.values());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct list_intT {
    pub values: Option<Vec<i32>>,
}
impl Default for list_intT {
    fn default() -> Self {
        Self { values: None }
    }
}
impl list_intT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<list_int<'b>> {
        let values = self.values.as_ref().map(|x| _fbb.create_vector(x));
        list_int::create(_fbb, &list_intArgs { values })
    }
}
pub enum clz_Torappu_SandboxV2MapZoneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2MapZoneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2MapZoneData<'a> {
    type Inner = clz_Torappu_SandboxV2MapZoneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2MapZoneData<'a> {
    pub const VT_ZONEID: flatbuffers::VOffsetT = 4;
    pub const VT_CENTER: flatbuffers::VOffsetT = 6;
    pub const VT_VERTICES: flatbuffers::VOffsetT = 8;
    pub const VT_TRIANGLES: flatbuffers::VOffsetT = 10;
    pub const VT_HASBORDER: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2MapZoneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2MapZoneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapZoneData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2MapZoneDataBuilder::new(_fbb);
        if let Some(x) = args.triangles {
            builder.add_triangles(x);
        }
        if let Some(x) = args.vertices {
            builder.add_vertices(x);
        }
        if let Some(x) = args.center {
            builder.add_center(x);
        }
        if let Some(x) = args.zoneId {
            builder.add_zoneId(x);
        }
        builder.add_hasBorder(args.hasBorder);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2MapZoneDataT {
        let zoneId = self.zoneId().map(|x| x.to_string());
        let center = self.center().map(|x| Box::new(x.unpack()));
        let vertices = self
            .vertices()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let triangles = self
            .triangles()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let hasBorder = self.hasBorder();
        clz_Torappu_SandboxV2MapZoneDataT {
            zoneId,
            center,
            vertices,
            triangles,
            hasBorder,
        }
    }

    #[inline]
    pub fn zoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MapZoneData::VT_ZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn center(&self) -> Option<clz_UnityEngine_Vector2<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                    clz_Torappu_SandboxV2MapZoneData::VT_CENTER,
                    None,
                )
        }
    }
    #[inline]
    pub fn vertices(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>,
            >>(clz_Torappu_SandboxV2MapZoneData::VT_VERTICES, None)
        }
    }
    #[inline]
    pub fn triangles(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<list_int<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<list_int>>,
            >>(clz_Torappu_SandboxV2MapZoneData::VT_TRIANGLES, None)
        }
    }
    #[inline]
    pub fn hasBorder(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_SandboxV2MapZoneData::VT_HASBORDER, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2MapZoneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zoneId", Self::VT_ZONEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                "center",
                Self::VT_CENTER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>,
            >>("vertices", Self::VT_VERTICES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<list_int>>,
            >>("triangles", Self::VT_TRIANGLES, false)?
            .visit_field::<bool>("hasBorder", Self::VT_HASBORDER, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2MapZoneDataArgs<'a> {
    pub zoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub center: Option<flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'a>>>,
    pub vertices: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2<'a>>>,
        >,
    >,
    pub triangles: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<list_int<'a>>>>,
    >,
    pub hasBorder: bool,
}
impl<'a> Default for clz_Torappu_SandboxV2MapZoneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2MapZoneDataArgs {
            zoneId: None,
            center: None,
            vertices: None,
            triangles: None,
            hasBorder: false,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2MapZoneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2MapZoneData", 5)?;
        if let Some(f) = self.zoneId() {
            s.serialize_field("zoneId", &f)?;
        } else {
            s.skip_field("zoneId")?;
        }
        if let Some(f) = self.center() {
            s.serialize_field("center", &f)?;
        } else {
            s.skip_field("center")?;
        }
        if let Some(f) = self.vertices() {
            s.serialize_field("vertices", &f)?;
        } else {
            s.skip_field("vertices")?;
        }
        if let Some(f) = self.triangles() {
            s.serialize_field("triangles", &f)?;
        } else {
            s.skip_field("triangles")?;
        }
        s.serialize_field("hasBorder", &self.hasBorder())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2MapZoneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2MapZoneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_zoneId(&mut self, zoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MapZoneData::VT_ZONEID,
            zoneId,
        );
    }
    #[inline]
    pub fn add_center(&mut self, center: flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_UnityEngine_Vector2>>(
                clz_Torappu_SandboxV2MapZoneData::VT_CENTER,
                center,
            );
    }
    #[inline]
    pub fn add_vertices(
        &mut self,
        vertices: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MapZoneData::VT_VERTICES,
            vertices,
        );
    }
    #[inline]
    pub fn add_triangles(
        &mut self,
        triangles: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<list_int<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MapZoneData::VT_TRIANGLES,
            triangles,
        );
    }
    #[inline]
    pub fn add_hasBorder(&mut self, hasBorder: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SandboxV2MapZoneData::VT_HASBORDER,
            hasBorder,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2MapZoneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2MapZoneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapZoneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2MapZoneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2MapZoneData");
        ds.field("zoneId", &self.zoneId());
        ds.field("center", &self.center());
        ds.field("vertices", &self.vertices());
        ds.field("triangles", &self.triangles());
        ds.field("hasBorder", &self.hasBorder());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2MapZoneDataT {
    pub zoneId: Option<String>,
    pub center: Option<Box<clz_UnityEngine_Vector2T>>,
    pub vertices: Option<Vec<clz_UnityEngine_Vector2T>>,
    pub triangles: Option<Vec<list_intT>>,
    pub hasBorder: bool,
}
impl Default for clz_Torappu_SandboxV2MapZoneDataT {
    fn default() -> Self {
        Self {
            zoneId: None,
            center: None,
            vertices: None,
            triangles: None,
            hasBorder: false,
        }
    }
}
impl clz_Torappu_SandboxV2MapZoneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapZoneData<'b>> {
        let zoneId = self.zoneId.as_ref().map(|x| _fbb.create_string(x));
        let center = self.center.as_ref().map(|x| x.pack(_fbb));
        let vertices = self.vertices.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let triangles = self.triangles.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let hasBorder = self.hasBorder;
        clz_Torappu_SandboxV2MapZoneData::create(
            _fbb,
            &clz_Torappu_SandboxV2MapZoneDataArgs {
                zoneId,
                center,
                vertices,
                triangles,
                hasBorder,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2MapZoneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2MapZoneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2MapZoneData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2MapZoneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2MapZoneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2MapZoneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2MapZoneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2MapZoneData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2MapZoneDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2MapZoneDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2MapZoneDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2MapZoneData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2MapZoneData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2MapZoneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2MapZoneData>>(
                    dict__string__clz_Torappu_SandboxV2MapZoneData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2MapZoneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2MapZoneData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2MapZoneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapZoneData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2MapZoneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2MapZoneDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2MapZoneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2MapZoneData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2MapZoneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2MapZoneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2MapZoneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapZoneData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapZoneData>>(
                dict__string__clz_Torappu_SandboxV2MapZoneData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2MapZoneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2MapZoneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2MapZoneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2MapZoneData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2MapZoneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2MapZoneData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2MapZoneDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2MapZoneDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2MapZoneDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2MapZoneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2MapZoneData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2MapZoneData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2MapZoneDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2MapConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2MapConfig<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2MapConfig<'a> {
    type Inner = clz_Torappu_SandboxV2MapConfig<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2MapConfig<'a> {
    pub const VT_ISRIFT: flatbuffers::VOffsetT = 4;
    pub const VT_ISGUIDE: flatbuffers::VOffsetT = 6;
    pub const VT_CAMERABOUNDMIN: flatbuffers::VOffsetT = 8;
    pub const VT_CAMERABOUNDMAX: flatbuffers::VOffsetT = 10;
    pub const VT_CAMERAMAXNORMALIZEDZOOM: flatbuffers::VOffsetT = 12;
    pub const VT_BACKGROUNDID: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2MapConfig { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2MapConfigArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapConfig<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2MapConfigBuilder::new(_fbb);
        if let Some(x) = args.backgroundId {
            builder.add_backgroundId(x);
        }
        builder.add_cameraMaxNormalizedZoom(args.cameraMaxNormalizedZoom);
        if let Some(x) = args.cameraBoundMax {
            builder.add_cameraBoundMax(x);
        }
        if let Some(x) = args.cameraBoundMin {
            builder.add_cameraBoundMin(x);
        }
        builder.add_isGuide(args.isGuide);
        builder.add_isRift(args.isRift);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2MapConfigT {
        let isRift = self.isRift();
        let isGuide = self.isGuide();
        let cameraBoundMin = self.cameraBoundMin().map(|x| Box::new(x.unpack()));
        let cameraBoundMax = self.cameraBoundMax().map(|x| Box::new(x.unpack()));
        let cameraMaxNormalizedZoom = self.cameraMaxNormalizedZoom();
        let backgroundId = self.backgroundId().map(|x| x.to_string());
        clz_Torappu_SandboxV2MapConfigT {
            isRift,
            isGuide,
            cameraBoundMin,
            cameraBoundMax,
            cameraMaxNormalizedZoom,
            backgroundId,
        }
    }

    #[inline]
    pub fn isRift(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_SandboxV2MapConfig::VT_ISRIFT, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn isGuide(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_SandboxV2MapConfig::VT_ISGUIDE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn cameraBoundMin(&self) -> Option<clz_UnityEngine_Vector2<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                    clz_Torappu_SandboxV2MapConfig::VT_CAMERABOUNDMIN,
                    None,
                )
        }
    }
    #[inline]
    pub fn cameraBoundMax(&self) -> Option<clz_UnityEngine_Vector2<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                    clz_Torappu_SandboxV2MapConfig::VT_CAMERABOUNDMAX,
                    None,
                )
        }
    }
    #[inline]
    pub fn cameraMaxNormalizedZoom(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2MapConfig::VT_CAMERAMAXNORMALIZEDZOOM,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn backgroundId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MapConfig::VT_BACKGROUNDID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2MapConfig<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("isRift", Self::VT_ISRIFT, false)?
            .visit_field::<bool>("isGuide", Self::VT_ISGUIDE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                "cameraBoundMin",
                Self::VT_CAMERABOUNDMIN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                "cameraBoundMax",
                Self::VT_CAMERABOUNDMAX,
                false,
            )?
            .visit_field::<f32>(
                "cameraMaxNormalizedZoom",
                Self::VT_CAMERAMAXNORMALIZEDZOOM,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "backgroundId",
                Self::VT_BACKGROUNDID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2MapConfigArgs<'a> {
    pub isRift: bool,
    pub isGuide: bool,
    pub cameraBoundMin: Option<flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'a>>>,
    pub cameraBoundMax: Option<flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'a>>>,
    pub cameraMaxNormalizedZoom: f32,
    pub backgroundId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2MapConfigArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2MapConfigArgs {
            isRift: false,
            isGuide: false,
            cameraBoundMin: None,
            cameraBoundMax: None,
            cameraMaxNormalizedZoom: 0.0,
            backgroundId: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2MapConfig<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2MapConfig", 6)?;
        s.serialize_field("isRift", &self.isRift())?;
        s.serialize_field("isGuide", &self.isGuide())?;
        if let Some(f) = self.cameraBoundMin() {
            s.serialize_field("cameraBoundMin", &f)?;
        } else {
            s.skip_field("cameraBoundMin")?;
        }
        if let Some(f) = self.cameraBoundMax() {
            s.serialize_field("cameraBoundMax", &f)?;
        } else {
            s.skip_field("cameraBoundMax")?;
        }
        s.serialize_field("cameraMaxNormalizedZoom", &self.cameraMaxNormalizedZoom())?;
        if let Some(f) = self.backgroundId() {
            s.serialize_field("backgroundId", &f)?;
        } else {
            s.skip_field("backgroundId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2MapConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2MapConfigBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_isRift(&mut self, isRift: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_SandboxV2MapConfig::VT_ISRIFT, isRift, false);
    }
    #[inline]
    pub fn add_isGuide(&mut self, isGuide: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_SandboxV2MapConfig::VT_ISGUIDE, isGuide, false);
    }
    #[inline]
    pub fn add_cameraBoundMin(
        &mut self,
        cameraBoundMin: flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_UnityEngine_Vector2>>(
                clz_Torappu_SandboxV2MapConfig::VT_CAMERABOUNDMIN,
                cameraBoundMin,
            );
    }
    #[inline]
    pub fn add_cameraBoundMax(
        &mut self,
        cameraBoundMax: flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_UnityEngine_Vector2>>(
                clz_Torappu_SandboxV2MapConfig::VT_CAMERABOUNDMAX,
                cameraBoundMax,
            );
    }
    #[inline]
    pub fn add_cameraMaxNormalizedZoom(&mut self, cameraMaxNormalizedZoom: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2MapConfig::VT_CAMERAMAXNORMALIZEDZOOM,
            cameraMaxNormalizedZoom,
            0.0,
        );
    }
    #[inline]
    pub fn add_backgroundId(&mut self, backgroundId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MapConfig::VT_BACKGROUNDID,
            backgroundId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2MapConfigBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2MapConfigBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapConfig<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2MapConfig<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2MapConfig");
        ds.field("isRift", &self.isRift());
        ds.field("isGuide", &self.isGuide());
        ds.field("cameraBoundMin", &self.cameraBoundMin());
        ds.field("cameraBoundMax", &self.cameraBoundMax());
        ds.field("cameraMaxNormalizedZoom", &self.cameraMaxNormalizedZoom());
        ds.field("backgroundId", &self.backgroundId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2MapConfigT {
    pub isRift: bool,
    pub isGuide: bool,
    pub cameraBoundMin: Option<Box<clz_UnityEngine_Vector2T>>,
    pub cameraBoundMax: Option<Box<clz_UnityEngine_Vector2T>>,
    pub cameraMaxNormalizedZoom: f32,
    pub backgroundId: Option<String>,
}
impl Default for clz_Torappu_SandboxV2MapConfigT {
    fn default() -> Self {
        Self {
            isRift: false,
            isGuide: false,
            cameraBoundMin: None,
            cameraBoundMax: None,
            cameraMaxNormalizedZoom: 0.0,
            backgroundId: None,
        }
    }
}
impl clz_Torappu_SandboxV2MapConfigT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapConfig<'b>> {
        let isRift = self.isRift;
        let isGuide = self.isGuide;
        let cameraBoundMin = self.cameraBoundMin.as_ref().map(|x| x.pack(_fbb));
        let cameraBoundMax = self.cameraBoundMax.as_ref().map(|x| x.pack(_fbb));
        let cameraMaxNormalizedZoom = self.cameraMaxNormalizedZoom;
        let backgroundId = self.backgroundId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2MapConfig::create(
            _fbb,
            &clz_Torappu_SandboxV2MapConfigArgs {
                isRift,
                isGuide,
                cameraBoundMin,
                cameraBoundMax,
                cameraMaxNormalizedZoom,
                backgroundId,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2MapDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2MapData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2MapData<'a> {
    type Inner = clz_Torappu_SandboxV2MapData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2MapData<'a> {
    pub const VT_NODES: flatbuffers::VOffsetT = 4;
    pub const VT_ZONES: flatbuffers::VOffsetT = 6;
    pub const VT_MAPCONFIG: flatbuffers::VOffsetT = 8;
    pub const VT_CENTERNODEID: flatbuffers::VOffsetT = 10;
    pub const VT_MONTHMODENODEID: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2MapData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2MapDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2MapDataBuilder::new(_fbb);
        if let Some(x) = args.monthModeNodeId {
            builder.add_monthModeNodeId(x);
        }
        if let Some(x) = args.centerNodeId {
            builder.add_centerNodeId(x);
        }
        if let Some(x) = args.mapConfig {
            builder.add_mapConfig(x);
        }
        if let Some(x) = args.zones {
            builder.add_zones(x);
        }
        if let Some(x) = args.nodes {
            builder.add_nodes(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2MapDataT {
        let nodes = self.nodes().map(|x| x.iter().map(|t| t.unpack()).collect());
        let zones = self.zones().map(|x| x.iter().map(|t| t.unpack()).collect());
        let mapConfig = self.mapConfig().map(|x| Box::new(x.unpack()));
        let centerNodeId = self.centerNodeId().map(|x| x.to_string());
        let monthModeNodeId = self.monthModeNodeId().map(|x| x.to_string());
        clz_Torappu_SandboxV2MapDataT {
            nodes,
            zones,
            mapConfig,
            centerNodeId,
            monthModeNodeId,
        }
    }

    #[inline]
    pub fn nodes(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeData>,
                >,
            >>(clz_Torappu_SandboxV2MapData::VT_NODES, None)
        }
    }
    #[inline]
    pub fn zones(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2MapZoneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2MapZoneData>,
                >,
            >>(clz_Torappu_SandboxV2MapData::VT_ZONES, None)
        }
    }
    #[inline]
    pub fn mapConfig(&self) -> Option<clz_Torappu_SandboxV2MapConfig<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2MapConfig>>(
                    clz_Torappu_SandboxV2MapData::VT_MAPCONFIG,
                    None,
                )
        }
    }
    #[inline]
    pub fn centerNodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MapData::VT_CENTERNODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn monthModeNodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MapData::VT_MONTHMODENODEID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2MapData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeData>,
                >,
            >>("nodes", Self::VT_NODES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2MapZoneData>,
                >,
            >>("zones", Self::VT_ZONES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2MapConfig>>(
                "mapConfig",
                Self::VT_MAPCONFIG,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "centerNodeId",
                Self::VT_CENTERNODEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "monthModeNodeId",
                Self::VT_MONTHMODENODEID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2MapDataArgs<'a> {
    pub nodes: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeData<'a>>,
            >,
        >,
    >,
    pub zones: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2MapZoneData<'a>>,
            >,
        >,
    >,
    pub mapConfig: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapConfig<'a>>>,
    pub centerNodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub monthModeNodeId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2MapDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2MapDataArgs {
            nodes: None,
            zones: None,
            mapConfig: None,
            centerNodeId: None,
            monthModeNodeId: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2MapData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2MapData", 5)?;
        if let Some(f) = self.nodes() {
            s.serialize_field("nodes", &f)?;
        } else {
            s.skip_field("nodes")?;
        }
        if let Some(f) = self.zones() {
            s.serialize_field("zones", &f)?;
        } else {
            s.skip_field("zones")?;
        }
        if let Some(f) = self.mapConfig() {
            s.serialize_field("mapConfig", &f)?;
        } else {
            s.skip_field("mapConfig")?;
        }
        if let Some(f) = self.centerNodeId() {
            s.serialize_field("centerNodeId", &f)?;
        } else {
            s.skip_field("centerNodeId")?;
        }
        if let Some(f) = self.monthModeNodeId() {
            s.serialize_field("monthModeNodeId", &f)?;
        } else {
            s.skip_field("monthModeNodeId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2MapDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2MapDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_nodes(
        &mut self,
        nodes: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MapData::VT_NODES,
            nodes,
        );
    }
    #[inline]
    pub fn add_zones(
        &mut self,
        zones: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2MapZoneData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MapData::VT_ZONES,
            zones,
        );
    }
    #[inline]
    pub fn add_mapConfig(
        &mut self,
        mapConfig: flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapConfig<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapConfig>>(
                clz_Torappu_SandboxV2MapData::VT_MAPCONFIG,
                mapConfig,
            );
    }
    #[inline]
    pub fn add_centerNodeId(&mut self, centerNodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MapData::VT_CENTERNODEID,
            centerNodeId,
        );
    }
    #[inline]
    pub fn add_monthModeNodeId(&mut self, monthModeNodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MapData::VT_MONTHMODENODEID,
            monthModeNodeId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2MapDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2MapDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2MapData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2MapData");
        ds.field("nodes", &self.nodes());
        ds.field("zones", &self.zones());
        ds.field("mapConfig", &self.mapConfig());
        ds.field("centerNodeId", &self.centerNodeId());
        ds.field("monthModeNodeId", &self.monthModeNodeId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2MapDataT {
    pub nodes: Option<Vec<dict__string__clz_Torappu_SandboxV2NodeDataT>>,
    pub zones: Option<Vec<dict__string__clz_Torappu_SandboxV2MapZoneDataT>>,
    pub mapConfig: Option<Box<clz_Torappu_SandboxV2MapConfigT>>,
    pub centerNodeId: Option<String>,
    pub monthModeNodeId: Option<String>,
}
impl Default for clz_Torappu_SandboxV2MapDataT {
    fn default() -> Self {
        Self {
            nodes: None,
            zones: None,
            mapConfig: None,
            centerNodeId: None,
            monthModeNodeId: None,
        }
    }
}
impl clz_Torappu_SandboxV2MapDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapData<'b>> {
        let nodes = self.nodes.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let zones = self.zones.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let mapConfig = self.mapConfig.as_ref().map(|x| x.pack(_fbb));
        let centerNodeId = self.centerNodeId.as_ref().map(|x| _fbb.create_string(x));
        let monthModeNodeId = self.monthModeNodeId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2MapData::create(
            _fbb,
            &clz_Torappu_SandboxV2MapDataArgs {
                nodes,
                zones,
                mapConfig,
                centerNodeId,
                monthModeNodeId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2MapDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2MapData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2MapData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2MapData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2MapData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2MapData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2MapDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2MapData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2MapDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2MapDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2MapDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2MapData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2MapData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2MapData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2MapData>>(
                    dict__string__clz_Torappu_SandboxV2MapData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2MapData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2MapData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2MapDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2MapDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2MapDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2MapData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2MapData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2MapDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2MapDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2MapData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2MapData>>(
                dict__string__clz_Torappu_SandboxV2MapData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2MapDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2MapDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2MapData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_SandboxV2MapData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2MapData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2MapData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2MapDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2MapDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2MapDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2MapDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2MapData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2MapData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2MapDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2ItemTrapDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ItemTrapData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ItemTrapData<'a> {
    type Inner = clz_Torappu_SandboxV2ItemTrapData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ItemTrapData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_TRAPID: flatbuffers::VOffsetT = 6;
    pub const VT_TRAPPHASE: flatbuffers::VOffsetT = 8;
    pub const VT_TRAPLEVEL: flatbuffers::VOffsetT = 10;
    pub const VT_SKILLINDEX: flatbuffers::VOffsetT = 12;
    pub const VT_SKILLLEVEL: flatbuffers::VOffsetT = 14;
    pub const VT_BUILDINGLEVEL: flatbuffers::VOffsetT = 16;
    pub const VT_UPDATEDITEMID: flatbuffers::VOffsetT = 18;
    pub const VT_MINLEVELITEMID: flatbuffers::VOffsetT = 20;
    pub const VT_BASEITEMNAME: flatbuffers::VOffsetT = 22;
    pub const VT_ITEMTYPE: flatbuffers::VOffsetT = 24;
    pub const VT_ITEMTAG: flatbuffers::VOffsetT = 26;
    pub const VT_BUFFID: flatbuffers::VOffsetT = 28;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ItemTrapData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ItemTrapDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ItemTrapData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ItemTrapDataBuilder::new(_fbb);
        if let Some(x) = args.buffId {
            builder.add_buffId(x);
        }
        builder.add_itemTag(args.itemTag);
        builder.add_itemType(args.itemType);
        if let Some(x) = args.baseItemName {
            builder.add_baseItemName(x);
        }
        if let Some(x) = args.minLevelItemId {
            builder.add_minLevelItemId(x);
        }
        if let Some(x) = args.updatedItemId {
            builder.add_updatedItemId(x);
        }
        builder.add_buildingLevel(args.buildingLevel);
        builder.add_skillLevel(args.skillLevel);
        builder.add_skillIndex(args.skillIndex);
        builder.add_trapLevel(args.trapLevel);
        builder.add_trapPhase(args.trapPhase);
        if let Some(x) = args.trapId {
            builder.add_trapId(x);
        }
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2ItemTrapDataT {
        let itemId = self.itemId().map(|x| x.to_string());
        let trapId = self.trapId().map(|x| x.to_string());
        let trapPhase = self.trapPhase();
        let trapLevel = self.trapLevel();
        let skillIndex = self.skillIndex();
        let skillLevel = self.skillLevel();
        let buildingLevel = self.buildingLevel();
        let updatedItemId = self.updatedItemId().map(|x| x.to_string());
        let minLevelItemId = self.minLevelItemId().map(|x| x.to_string());
        let baseItemName = self.baseItemName().map(|x| x.to_string());
        let itemType = self.itemType();
        let itemTag = self.itemTag();
        let buffId = self.buffId().map(|x| x.to_string());
        clz_Torappu_SandboxV2ItemTrapDataT {
            itemId,
            trapId,
            trapPhase,
            trapLevel,
            skillIndex,
            skillLevel,
            buildingLevel,
            updatedItemId,
            minLevelItemId,
            baseItemName,
            itemType,
            itemTag,
            buffId,
        }
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ItemTrapData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn trapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ItemTrapData::VT_TRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn trapPhase(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ItemTrapData::VT_TRAPPHASE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn trapLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ItemTrapData::VT_TRAPLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn skillIndex(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ItemTrapData::VT_SKILLINDEX, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn skillLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ItemTrapData::VT_SKILLLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn buildingLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ItemTrapData::VT_BUILDINGLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn updatedItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ItemTrapData::VT_UPDATEDITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn minLevelItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ItemTrapData::VT_MINLEVELITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn baseItemName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ItemTrapData::VT_BASEITEMNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn itemType(&self) -> enum__Torappu_SandboxV2TrapItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2TrapItemType>(
                    clz_Torappu_SandboxV2ItemTrapData::VT_ITEMTYPE,
                    Some(enum__Torappu_SandboxV2TrapItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn itemTag(&self) -> enum__Torappu_SandboxV2ItemTrapTag {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2ItemTrapTag>(
                    clz_Torappu_SandboxV2ItemTrapData::VT_ITEMTAG,
                    Some(enum__Torappu_SandboxV2ItemTrapTag::OUTPUT),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn buffId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ItemTrapData::VT_BUFFID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ItemTrapData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("trapId", Self::VT_TRAPID, false)?
            .visit_field::<i32>("trapPhase", Self::VT_TRAPPHASE, false)?
            .visit_field::<i32>("trapLevel", Self::VT_TRAPLEVEL, false)?
            .visit_field::<i32>("skillIndex", Self::VT_SKILLINDEX, false)?
            .visit_field::<i32>("skillLevel", Self::VT_SKILLLEVEL, false)?
            .visit_field::<i32>("buildingLevel", Self::VT_BUILDINGLEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "updatedItemId",
                Self::VT_UPDATEDITEMID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "minLevelItemId",
                Self::VT_MINLEVELITEMID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "baseItemName",
                Self::VT_BASEITEMNAME,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxV2TrapItemType>(
                "itemType",
                Self::VT_ITEMTYPE,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxV2ItemTrapTag>("itemTag", Self::VT_ITEMTAG, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buffId", Self::VT_BUFFID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ItemTrapDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trapPhase: i32,
    pub trapLevel: i32,
    pub skillIndex: i32,
    pub skillLevel: i32,
    pub buildingLevel: i32,
    pub updatedItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub minLevelItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub baseItemName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemType: enum__Torappu_SandboxV2TrapItemType,
    pub itemTag: enum__Torappu_SandboxV2ItemTrapTag,
    pub buffId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ItemTrapDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ItemTrapDataArgs {
            itemId: None,
            trapId: None,
            trapPhase: 0,
            trapLevel: 0,
            skillIndex: 0,
            skillLevel: 0,
            buildingLevel: 0,
            updatedItemId: None,
            minLevelItemId: None,
            baseItemName: None,
            itemType: enum__Torappu_SandboxV2TrapItemType::NONE,
            itemTag: enum__Torappu_SandboxV2ItemTrapTag::OUTPUT,
            buffId: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2ItemTrapData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2ItemTrapData", 13)?;
        if let Some(f) = self.itemId() {
            s.serialize_field("itemId", &f)?;
        } else {
            s.skip_field("itemId")?;
        }
        if let Some(f) = self.trapId() {
            s.serialize_field("trapId", &f)?;
        } else {
            s.skip_field("trapId")?;
        }
        s.serialize_field("trapPhase", &self.trapPhase())?;
        s.serialize_field("trapLevel", &self.trapLevel())?;
        s.serialize_field("skillIndex", &self.skillIndex())?;
        s.serialize_field("skillLevel", &self.skillLevel())?;
        s.serialize_field("buildingLevel", &self.buildingLevel())?;
        if let Some(f) = self.updatedItemId() {
            s.serialize_field("updatedItemId", &f)?;
        } else {
            s.skip_field("updatedItemId")?;
        }
        if let Some(f) = self.minLevelItemId() {
            s.serialize_field("minLevelItemId", &f)?;
        } else {
            s.skip_field("minLevelItemId")?;
        }
        if let Some(f) = self.baseItemName() {
            s.serialize_field("baseItemName", &f)?;
        } else {
            s.skip_field("baseItemName")?;
        }
        s.serialize_field("itemType", &self.itemType())?;
        s.serialize_field("itemTag", &self.itemTag())?;
        if let Some(f) = self.buffId() {
            s.serialize_field("buffId", &f)?;
        } else {
            s.skip_field("buffId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2ItemTrapDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ItemTrapDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ItemTrapData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_trapId(&mut self, trapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ItemTrapData::VT_TRAPID,
            trapId,
        );
    }
    #[inline]
    pub fn add_trapPhase(&mut self, trapPhase: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ItemTrapData::VT_TRAPPHASE,
            trapPhase,
            0,
        );
    }
    #[inline]
    pub fn add_trapLevel(&mut self, trapLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ItemTrapData::VT_TRAPLEVEL,
            trapLevel,
            0,
        );
    }
    #[inline]
    pub fn add_skillIndex(&mut self, skillIndex: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ItemTrapData::VT_SKILLINDEX,
            skillIndex,
            0,
        );
    }
    #[inline]
    pub fn add_skillLevel(&mut self, skillLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ItemTrapData::VT_SKILLLEVEL,
            skillLevel,
            0,
        );
    }
    #[inline]
    pub fn add_buildingLevel(&mut self, buildingLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ItemTrapData::VT_BUILDINGLEVEL,
            buildingLevel,
            0,
        );
    }
    #[inline]
    pub fn add_updatedItemId(&mut self, updatedItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ItemTrapData::VT_UPDATEDITEMID,
            updatedItemId,
        );
    }
    #[inline]
    pub fn add_minLevelItemId(&mut self, minLevelItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ItemTrapData::VT_MINLEVELITEMID,
            minLevelItemId,
        );
    }
    #[inline]
    pub fn add_baseItemName(&mut self, baseItemName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ItemTrapData::VT_BASEITEMNAME,
            baseItemName,
        );
    }
    #[inline]
    pub fn add_itemType(&mut self, itemType: enum__Torappu_SandboxV2TrapItemType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2TrapItemType>(
            clz_Torappu_SandboxV2ItemTrapData::VT_ITEMTYPE,
            itemType,
            enum__Torappu_SandboxV2TrapItemType::NONE,
        );
    }
    #[inline]
    pub fn add_itemTag(&mut self, itemTag: enum__Torappu_SandboxV2ItemTrapTag) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2ItemTrapTag>(
            clz_Torappu_SandboxV2ItemTrapData::VT_ITEMTAG,
            itemTag,
            enum__Torappu_SandboxV2ItemTrapTag::OUTPUT,
        );
    }
    #[inline]
    pub fn add_buffId(&mut self, buffId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ItemTrapData::VT_BUFFID,
            buffId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ItemTrapDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ItemTrapDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ItemTrapData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ItemTrapData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ItemTrapData");
        ds.field("itemId", &self.itemId());
        ds.field("trapId", &self.trapId());
        ds.field("trapPhase", &self.trapPhase());
        ds.field("trapLevel", &self.trapLevel());
        ds.field("skillIndex", &self.skillIndex());
        ds.field("skillLevel", &self.skillLevel());
        ds.field("buildingLevel", &self.buildingLevel());
        ds.field("updatedItemId", &self.updatedItemId());
        ds.field("minLevelItemId", &self.minLevelItemId());
        ds.field("baseItemName", &self.baseItemName());
        ds.field("itemType", &self.itemType());
        ds.field("itemTag", &self.itemTag());
        ds.field("buffId", &self.buffId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2ItemTrapDataT {
    pub itemId: Option<String>,
    pub trapId: Option<String>,
    pub trapPhase: i32,
    pub trapLevel: i32,
    pub skillIndex: i32,
    pub skillLevel: i32,
    pub buildingLevel: i32,
    pub updatedItemId: Option<String>,
    pub minLevelItemId: Option<String>,
    pub baseItemName: Option<String>,
    pub itemType: enum__Torappu_SandboxV2TrapItemType,
    pub itemTag: enum__Torappu_SandboxV2ItemTrapTag,
    pub buffId: Option<String>,
}
impl Default for clz_Torappu_SandboxV2ItemTrapDataT {
    fn default() -> Self {
        Self {
            itemId: None,
            trapId: None,
            trapPhase: 0,
            trapLevel: 0,
            skillIndex: 0,
            skillLevel: 0,
            buildingLevel: 0,
            updatedItemId: None,
            minLevelItemId: None,
            baseItemName: None,
            itemType: enum__Torappu_SandboxV2TrapItemType::NONE,
            itemTag: enum__Torappu_SandboxV2ItemTrapTag::OUTPUT,
            buffId: None,
        }
    }
}
impl clz_Torappu_SandboxV2ItemTrapDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ItemTrapData<'b>> {
        let itemId = self.itemId.as_ref().map(|x| _fbb.create_string(x));
        let trapId = self.trapId.as_ref().map(|x| _fbb.create_string(x));
        let trapPhase = self.trapPhase;
        let trapLevel = self.trapLevel;
        let skillIndex = self.skillIndex;
        let skillLevel = self.skillLevel;
        let buildingLevel = self.buildingLevel;
        let updatedItemId = self.updatedItemId.as_ref().map(|x| _fbb.create_string(x));
        let minLevelItemId = self.minLevelItemId.as_ref().map(|x| _fbb.create_string(x));
        let baseItemName = self.baseItemName.as_ref().map(|x| _fbb.create_string(x));
        let itemType = self.itemType;
        let itemTag = self.itemTag;
        let buffId = self.buffId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2ItemTrapData::create(
            _fbb,
            &clz_Torappu_SandboxV2ItemTrapDataArgs {
                itemId,
                trapId,
                trapPhase,
                trapLevel,
                skillIndex,
                skillLevel,
                buildingLevel,
                updatedItemId,
                minLevelItemId,
                baseItemName,
                itemType,
                itemTag,
                buffId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ItemTrapDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ItemTrapData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2ItemTrapData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2ItemTrapData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ItemTrapData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ItemTrapData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ItemTrapDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ItemTrapData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2ItemTrapDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2ItemTrapDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2ItemTrapDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ItemTrapData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2ItemTrapData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ItemTrapData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ItemTrapData>>(
                    dict__string__clz_Torappu_SandboxV2ItemTrapData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ItemTrapData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ItemTrapData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ItemTrapDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ItemTrapData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ItemTrapDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ItemTrapDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2ItemTrapData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2ItemTrapData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ItemTrapDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ItemTrapDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ItemTrapData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ItemTrapData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ItemTrapData>>(
                dict__string__clz_Torappu_SandboxV2ItemTrapData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ItemTrapDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ItemTrapDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ItemTrapData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ItemTrapData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ItemTrapData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2ItemTrapData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2ItemTrapDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2ItemTrapDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2ItemTrapDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2ItemTrapDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ItemTrapData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2ItemTrapData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2ItemTrapDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2ItemTrapTagDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ItemTrapTagData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ItemTrapTagData<'a> {
    type Inner = clz_Torappu_SandboxV2ItemTrapTagData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ItemTrapTagData<'a> {
    pub const VT_TAG: flatbuffers::VOffsetT = 4;
    pub const VT_TAGNAME: flatbuffers::VOffsetT = 6;
    pub const VT_TAGPIC: flatbuffers::VOffsetT = 8;
    pub const VT_SORTID: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ItemTrapTagData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ItemTrapTagDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ItemTrapTagData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ItemTrapTagDataBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.tagPic {
            builder.add_tagPic(x);
        }
        if let Some(x) = args.tagName {
            builder.add_tagName(x);
        }
        builder.add_tag(args.tag);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2ItemTrapTagDataT {
        let tag = self.tag();
        let tagName = self.tagName().map(|x| x.to_string());
        let tagPic = self.tagPic().map(|x| x.to_string());
        let sortId = self.sortId();
        clz_Torappu_SandboxV2ItemTrapTagDataT {
            tag,
            tagName,
            tagPic,
            sortId,
        }
    }

    #[inline]
    pub fn tag(&self) -> enum__Torappu_SandboxV2ItemTrapTag {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2ItemTrapTag>(
                    clz_Torappu_SandboxV2ItemTrapTagData::VT_TAG,
                    Some(enum__Torappu_SandboxV2ItemTrapTag::OUTPUT),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn tagName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ItemTrapTagData::VT_TAGNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn tagPic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ItemTrapTagData::VT_TAGPIC,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ItemTrapTagData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ItemTrapTagData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxV2ItemTrapTag>("tag", Self::VT_TAG, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tagName", Self::VT_TAGNAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tagPic", Self::VT_TAGPIC, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ItemTrapTagDataArgs<'a> {
    pub tag: enum__Torappu_SandboxV2ItemTrapTag,
    pub tagName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tagPic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2ItemTrapTagDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ItemTrapTagDataArgs {
            tag: enum__Torappu_SandboxV2ItemTrapTag::OUTPUT,
            tagName: None,
            tagPic: None,
            sortId: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2ItemTrapTagData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2ItemTrapTagData", 4)?;
        s.serialize_field("tag", &self.tag())?;
        if let Some(f) = self.tagName() {
            s.serialize_field("tagName", &f)?;
        } else {
            s.skip_field("tagName")?;
        }
        if let Some(f) = self.tagPic() {
            s.serialize_field("tagPic", &f)?;
        } else {
            s.skip_field("tagPic")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2ItemTrapTagDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ItemTrapTagDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_tag(&mut self, tag: enum__Torappu_SandboxV2ItemTrapTag) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2ItemTrapTag>(
            clz_Torappu_SandboxV2ItemTrapTagData::VT_TAG,
            tag,
            enum__Torappu_SandboxV2ItemTrapTag::OUTPUT,
        );
    }
    #[inline]
    pub fn add_tagName(&mut self, tagName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ItemTrapTagData::VT_TAGNAME,
            tagName,
        );
    }
    #[inline]
    pub fn add_tagPic(&mut self, tagPic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ItemTrapTagData::VT_TAGPIC,
            tagPic,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2ItemTrapTagData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ItemTrapTagDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ItemTrapTagDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ItemTrapTagData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ItemTrapTagData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ItemTrapTagData");
        ds.field("tag", &self.tag());
        ds.field("tagName", &self.tagName());
        ds.field("tagPic", &self.tagPic());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2ItemTrapTagDataT {
    pub tag: enum__Torappu_SandboxV2ItemTrapTag,
    pub tagName: Option<String>,
    pub tagPic: Option<String>,
    pub sortId: i32,
}
impl Default for clz_Torappu_SandboxV2ItemTrapTagDataT {
    fn default() -> Self {
        Self {
            tag: enum__Torappu_SandboxV2ItemTrapTag::OUTPUT,
            tagName: None,
            tagPic: None,
            sortId: 0,
        }
    }
}
impl clz_Torappu_SandboxV2ItemTrapTagDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ItemTrapTagData<'b>> {
        let tag = self.tag;
        let tagName = self.tagName.as_ref().map(|x| _fbb.create_string(x));
        let tagPic = self.tagPic.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        clz_Torappu_SandboxV2ItemTrapTagData::create(
            _fbb,
            &clz_Torappu_SandboxV2ItemTrapTagDataArgs {
                tag,
                tagName,
                tagPic,
                sortId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ItemTrapTagDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ItemTrapTagData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ItemTrapTagDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2ItemTrapTagDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2ItemTrapTagDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2ItemTrapTagDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ItemTrapTagData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2ItemTrapTagData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ItemTrapTagData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ItemTrapTagData>>(
                    dict__string__clz_Torappu_SandboxV2ItemTrapTagData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ItemTrapTagData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ItemTrapTagDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ItemTrapTagData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ItemTrapTagDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ItemTrapTagDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2ItemTrapTagData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ItemTrapTagDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ItemTrapTagDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ItemTrapTagData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ItemTrapTagData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ItemTrapTagData>>(
                dict__string__clz_Torappu_SandboxV2ItemTrapTagData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ItemTrapTagDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ItemTrapTagDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ItemTrapTagData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2ItemTrapTagData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2ItemTrapTagDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2ItemTrapTagDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2ItemTrapTagDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2ItemTrapTagDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2ItemTrapTagData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2ItemTrapTagDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2BuildingItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2BuildingItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2BuildingItemData<'a> {
    type Inner = clz_Torappu_SandboxV2BuildingItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2BuildingItemData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_ITEMRARITY: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2BuildingItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2BuildingItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BuildingItemData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2BuildingItemDataBuilder::new(_fbb);
        builder.add_itemRarity(args.itemRarity);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2BuildingItemDataT {
        let itemId = self.itemId().map(|x| x.to_string());
        let itemRarity = self.itemRarity();
        clz_Torappu_SandboxV2BuildingItemDataT { itemId, itemRarity }
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BuildingItemData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn itemRarity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BuildingItemData::VT_ITEMRARITY,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2BuildingItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<i32>("itemRarity", Self::VT_ITEMRARITY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2BuildingItemDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemRarity: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2BuildingItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2BuildingItemDataArgs {
            itemId: None,
            itemRarity: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2BuildingItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2BuildingItemData", 2)?;
        if let Some(f) = self.itemId() {
            s.serialize_field("itemId", &f)?;
        } else {
            s.skip_field("itemId")?;
        }
        s.serialize_field("itemRarity", &self.itemRarity())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2BuildingItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2BuildingItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BuildingItemData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_itemRarity(&mut self, itemRarity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BuildingItemData::VT_ITEMRARITY,
            itemRarity,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2BuildingItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2BuildingItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BuildingItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2BuildingItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2BuildingItemData");
        ds.field("itemId", &self.itemId());
        ds.field("itemRarity", &self.itemRarity());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2BuildingItemDataT {
    pub itemId: Option<String>,
    pub itemRarity: i32,
}
impl Default for clz_Torappu_SandboxV2BuildingItemDataT {
    fn default() -> Self {
        Self {
            itemId: None,
            itemRarity: 0,
        }
    }
}
impl clz_Torappu_SandboxV2BuildingItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BuildingItemData<'b>> {
        let itemId = self.itemId.as_ref().map(|x| _fbb.create_string(x));
        let itemRarity = self.itemRarity;
        clz_Torappu_SandboxV2BuildingItemData::create(
            _fbb,
            &clz_Torappu_SandboxV2BuildingItemDataArgs { itemId, itemRarity },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2BuildingItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2BuildingItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2BuildingItemData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2BuildingItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2BuildingItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2BuildingItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2BuildingItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2BuildingItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2BuildingItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2BuildingItemDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2BuildingItemDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2BuildingItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2BuildingItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2BuildingItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BuildingItemData>>(
                    dict__string__clz_Torappu_SandboxV2BuildingItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2BuildingItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BuildingItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2BuildingItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2BuildingItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2BuildingItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2BuildingItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2BuildingItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_SandboxV2BuildingItemData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2BuildingItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2BuildingItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2BuildingItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2BuildingItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2BuildingItemData>>(
                dict__string__clz_Torappu_SandboxV2BuildingItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2BuildingItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2BuildingItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2BuildingItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2BuildingItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2BuildingItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2BuildingItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2BuildingItemDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2BuildingItemDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2BuildingItemDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2BuildingItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2BuildingItemData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2BuildingItemData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2BuildingItemDataArgs { key, value },
        )
    }
}
pub enum dict__string__intOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__int<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__int<'a> {
    type Inner = dict__string__int<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__int<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__int { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__intArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__int<'bldr>> {
        let mut builder = dict__string__intBuilder::new(_fbb);
        builder.add_value(args.value);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__intT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value();
        dict__string__intT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__int::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__int) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(dict__string__int::VT_VALUE, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for dict__string__int<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<i32>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__intArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: i32,
}
impl<'a> Default for dict__string__intArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__intArgs {
            key: None, // required field
            value: 0,
        }
    }
}

impl Serialize for dict__string__int<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__int", 2)?;
        s.serialize_field("key", &self.key())?;
        s.serialize_field("value", &self.value())?;
        s.end()
    }
}

pub struct dict__string__intBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__intBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__int::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(&mut self, value: i32) {
        self.fbb_
            .push_slot::<i32>(dict__string__int::VT_VALUE, value, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__intBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__intBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__int<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, dict__string__int::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__int<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__int");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__intT {
    pub key: String,
    pub value: i32,
}
impl Default for dict__string__intT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: 0,
        }
    }
}
impl dict__string__intT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__int<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value;
        dict__string__int::create(_fbb, &dict__string__intArgs { key, value })
    }
}
pub enum clz_Torappu_SandboxV2CraftItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2CraftItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2CraftItemData<'a> {
    type Inner = clz_Torappu_SandboxV2CraftItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2CraftItemData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_BUILDINGUNLOCKDESC: flatbuffers::VOffsetT = 8;
    pub const VT_MATERIALITEMS: flatbuffers::VOffsetT = 10;
    pub const VT_UPGRADEITEMS: flatbuffers::VOffsetT = 12;
    pub const VT_OUTPUTRATIO: flatbuffers::VOffsetT = 14;
    pub const VT_WITHDRAWRATIO: flatbuffers::VOffsetT = 16;
    pub const VT_REPAIRCOST: flatbuffers::VOffsetT = 18;
    pub const VT_ISHIDDEN: flatbuffers::VOffsetT = 20;
    pub const VT_CRAFTGROUPID: flatbuffers::VOffsetT = 22;
    pub const VT_RECIPELEVEL: flatbuffers::VOffsetT = 24;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2CraftItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2CraftItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2CraftItemData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2CraftItemDataBuilder::new(_fbb);
        builder.add_recipeLevel(args.recipeLevel);
        if let Some(x) = args.craftGroupId {
            builder.add_craftGroupId(x);
        }
        builder.add_repairCost(args.repairCost);
        builder.add_withdrawRatio(args.withdrawRatio);
        builder.add_outputRatio(args.outputRatio);
        if let Some(x) = args.upgradeItems {
            builder.add_upgradeItems(x);
        }
        if let Some(x) = args.materialItems {
            builder.add_materialItems(x);
        }
        if let Some(x) = args.buildingUnlockDesc {
            builder.add_buildingUnlockDesc(x);
        }
        builder.add_type_(args.type_);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.add_isHidden(args.isHidden);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2CraftItemDataT {
        let itemId = self.itemId().map(|x| x.to_string());
        let type_ = self.type_();
        let buildingUnlockDesc = self.buildingUnlockDesc().map(|x| x.to_string());
        let materialItems = self
            .materialItems()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let upgradeItems = self
            .upgradeItems()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let outputRatio = self.outputRatio();
        let withdrawRatio = self.withdrawRatio();
        let repairCost = self.repairCost();
        let isHidden = self.isHidden();
        let craftGroupId = self.craftGroupId().map(|x| x.to_string());
        let recipeLevel = self.recipeLevel();
        clz_Torappu_SandboxV2CraftItemDataT {
            itemId,
            type_,
            buildingUnlockDesc,
            materialItems,
            upgradeItems,
            outputRatio,
            withdrawRatio,
            repairCost,
            isHidden,
            craftGroupId,
            recipeLevel,
        }
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2CraftItemData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_SandboxV2CraftItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2CraftItemType>(
                    clz_Torappu_SandboxV2CraftItemData::VT_TYPE_,
                    Some(enum__Torappu_SandboxV2CraftItemType::BASE_BUILDING),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn buildingUnlockDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2CraftItemData::VT_BUILDINGUNLOCKDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn materialItems(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>(clz_Torappu_SandboxV2CraftItemData::VT_MATERIALITEMS, None)
        }
    }
    #[inline]
    pub fn upgradeItems(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>(clz_Torappu_SandboxV2CraftItemData::VT_UPGRADEITEMS, None)
        }
    }
    #[inline]
    pub fn outputRatio(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2CraftItemData::VT_OUTPUTRATIO, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn withdrawRatio(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2CraftItemData::VT_WITHDRAWRATIO,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn repairCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2CraftItemData::VT_REPAIRCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn isHidden(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_SandboxV2CraftItemData::VT_ISHIDDEN, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn craftGroupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2CraftItemData::VT_CRAFTGROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn recipeLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2CraftItemData::VT_RECIPELEVEL, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2CraftItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<enum__Torappu_SandboxV2CraftItemType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buildingUnlockDesc",
                Self::VT_BUILDINGUNLOCKDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>("materialItems", Self::VT_MATERIALITEMS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>("upgradeItems", Self::VT_UPGRADEITEMS, false)?
            .visit_field::<i32>("outputRatio", Self::VT_OUTPUTRATIO, false)?
            .visit_field::<i32>("withdrawRatio", Self::VT_WITHDRAWRATIO, false)?
            .visit_field::<i32>("repairCost", Self::VT_REPAIRCOST, false)?
            .visit_field::<bool>("isHidden", Self::VT_ISHIDDEN, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "craftGroupId",
                Self::VT_CRAFTGROUPID,
                false,
            )?
            .visit_field::<i32>("recipeLevel", Self::VT_RECIPELEVEL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2CraftItemDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_SandboxV2CraftItemType,
    pub buildingUnlockDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub materialItems: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>,
        >,
    >,
    pub upgradeItems: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>,
        >,
    >,
    pub outputRatio: i32,
    pub withdrawRatio: i32,
    pub repairCost: i32,
    pub isHidden: bool,
    pub craftGroupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub recipeLevel: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2CraftItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2CraftItemDataArgs {
            itemId: None,
            type_: enum__Torappu_SandboxV2CraftItemType::BASE_BUILDING,
            buildingUnlockDesc: None,
            materialItems: None,
            upgradeItems: None,
            outputRatio: 0,
            withdrawRatio: 0,
            repairCost: 0,
            isHidden: false,
            craftGroupId: None,
            recipeLevel: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2CraftItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2CraftItemData", 11)?;
        if let Some(f) = self.itemId() {
            s.serialize_field("itemId", &f)?;
        } else {
            s.skip_field("itemId")?;
        }
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.buildingUnlockDesc() {
            s.serialize_field("buildingUnlockDesc", &f)?;
        } else {
            s.skip_field("buildingUnlockDesc")?;
        }
        if let Some(f) = self.materialItems() {
            s.serialize_field("materialItems", &f)?;
        } else {
            s.skip_field("materialItems")?;
        }
        if let Some(f) = self.upgradeItems() {
            s.serialize_field("upgradeItems", &f)?;
        } else {
            s.skip_field("upgradeItems")?;
        }
        s.serialize_field("outputRatio", &self.outputRatio())?;
        s.serialize_field("withdrawRatio", &self.withdrawRatio())?;
        s.serialize_field("repairCost", &self.repairCost())?;
        s.serialize_field("isHidden", &self.isHidden())?;
        if let Some(f) = self.craftGroupId() {
            s.serialize_field("craftGroupId", &f)?;
        } else {
            s.skip_field("craftGroupId")?;
        }
        s.serialize_field("recipeLevel", &self.recipeLevel())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2CraftItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2CraftItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2CraftItemData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_SandboxV2CraftItemType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2CraftItemType>(
            clz_Torappu_SandboxV2CraftItemData::VT_TYPE_,
            type_,
            enum__Torappu_SandboxV2CraftItemType::BASE_BUILDING,
        );
    }
    #[inline]
    pub fn add_buildingUnlockDesc(&mut self, buildingUnlockDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2CraftItemData::VT_BUILDINGUNLOCKDESC,
            buildingUnlockDesc,
        );
    }
    #[inline]
    pub fn add_materialItems(
        &mut self,
        materialItems: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__int<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2CraftItemData::VT_MATERIALITEMS,
            materialItems,
        );
    }
    #[inline]
    pub fn add_upgradeItems(
        &mut self,
        upgradeItems: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__int<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2CraftItemData::VT_UPGRADEITEMS,
            upgradeItems,
        );
    }
    #[inline]
    pub fn add_outputRatio(&mut self, outputRatio: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2CraftItemData::VT_OUTPUTRATIO,
            outputRatio,
            0,
        );
    }
    #[inline]
    pub fn add_withdrawRatio(&mut self, withdrawRatio: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2CraftItemData::VT_WITHDRAWRATIO,
            withdrawRatio,
            0,
        );
    }
    #[inline]
    pub fn add_repairCost(&mut self, repairCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2CraftItemData::VT_REPAIRCOST,
            repairCost,
            0,
        );
    }
    #[inline]
    pub fn add_isHidden(&mut self, isHidden: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SandboxV2CraftItemData::VT_ISHIDDEN,
            isHidden,
            false,
        );
    }
    #[inline]
    pub fn add_craftGroupId(&mut self, craftGroupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2CraftItemData::VT_CRAFTGROUPID,
            craftGroupId,
        );
    }
    #[inline]
    pub fn add_recipeLevel(&mut self, recipeLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2CraftItemData::VT_RECIPELEVEL,
            recipeLevel,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2CraftItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2CraftItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2CraftItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2CraftItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2CraftItemData");
        ds.field("itemId", &self.itemId());
        ds.field("type_", &self.type_());
        ds.field("buildingUnlockDesc", &self.buildingUnlockDesc());
        ds.field("materialItems", &self.materialItems());
        ds.field("upgradeItems", &self.upgradeItems());
        ds.field("outputRatio", &self.outputRatio());
        ds.field("withdrawRatio", &self.withdrawRatio());
        ds.field("repairCost", &self.repairCost());
        ds.field("isHidden", &self.isHidden());
        ds.field("craftGroupId", &self.craftGroupId());
        ds.field("recipeLevel", &self.recipeLevel());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2CraftItemDataT {
    pub itemId: Option<String>,
    pub type_: enum__Torappu_SandboxV2CraftItemType,
    pub buildingUnlockDesc: Option<String>,
    pub materialItems: Option<Vec<dict__string__intT>>,
    pub upgradeItems: Option<Vec<dict__string__intT>>,
    pub outputRatio: i32,
    pub withdrawRatio: i32,
    pub repairCost: i32,
    pub isHidden: bool,
    pub craftGroupId: Option<String>,
    pub recipeLevel: i32,
}
impl Default for clz_Torappu_SandboxV2CraftItemDataT {
    fn default() -> Self {
        Self {
            itemId: None,
            type_: enum__Torappu_SandboxV2CraftItemType::BASE_BUILDING,
            buildingUnlockDesc: None,
            materialItems: None,
            upgradeItems: None,
            outputRatio: 0,
            withdrawRatio: 0,
            repairCost: 0,
            isHidden: false,
            craftGroupId: None,
            recipeLevel: 0,
        }
    }
}
impl clz_Torappu_SandboxV2CraftItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2CraftItemData<'b>> {
        let itemId = self.itemId.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let buildingUnlockDesc = self
            .buildingUnlockDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let materialItems = self.materialItems.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let upgradeItems = self.upgradeItems.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let outputRatio = self.outputRatio;
        let withdrawRatio = self.withdrawRatio;
        let repairCost = self.repairCost;
        let isHidden = self.isHidden;
        let craftGroupId = self.craftGroupId.as_ref().map(|x| _fbb.create_string(x));
        let recipeLevel = self.recipeLevel;
        clz_Torappu_SandboxV2CraftItemData::create(
            _fbb,
            &clz_Torappu_SandboxV2CraftItemDataArgs {
                itemId,
                type_,
                buildingUnlockDesc,
                materialItems,
                upgradeItems,
                outputRatio,
                withdrawRatio,
                repairCost,
                isHidden,
                craftGroupId,
                recipeLevel,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2CraftItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2CraftItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2CraftItemData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2CraftItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2CraftItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2CraftItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2CraftItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2CraftItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2CraftItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2CraftItemDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2CraftItemDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2CraftItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2CraftItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2CraftItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2CraftItemData>>(
                    dict__string__clz_Torappu_SandboxV2CraftItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2CraftItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2CraftItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2CraftItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2CraftItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2CraftItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2CraftItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2CraftItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2CraftItemData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2CraftItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2CraftItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2CraftItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2CraftItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2CraftItemData>>(
                dict__string__clz_Torappu_SandboxV2CraftItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2CraftItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2CraftItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2CraftItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2CraftItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2CraftItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2CraftItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2CraftItemDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2CraftItemDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2CraftItemDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2CraftItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2CraftItemData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2CraftItemData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2CraftItemDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2LivestockDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2LivestockData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2LivestockData<'a> {
    type Inner = clz_Torappu_SandboxV2LivestockData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2LivestockData<'a> {
    pub const VT_LIVESTOCKITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_SHINYLIVESTOCKITEMID: flatbuffers::VOffsetT = 6;
    pub const VT_LIVESTOCKENEMYID: flatbuffers::VOffsetT = 8;
    pub const VT_TARGETFENCEID: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2LivestockData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2LivestockDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2LivestockData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2LivestockDataBuilder::new(_fbb);
        if let Some(x) = args.targetFenceId {
            builder.add_targetFenceId(x);
        }
        if let Some(x) = args.livestockEnemyId {
            builder.add_livestockEnemyId(x);
        }
        if let Some(x) = args.shinyLivestockItemId {
            builder.add_shinyLivestockItemId(x);
        }
        if let Some(x) = args.livestockItemId {
            builder.add_livestockItemId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2LivestockDataT {
        let livestockItemId = self.livestockItemId().map(|x| x.to_string());
        let shinyLivestockItemId = self.shinyLivestockItemId().map(|x| x.to_string());
        let livestockEnemyId = self.livestockEnemyId().map(|x| x.to_string());
        let targetFenceId = self.targetFenceId().map(|x| x.to_string());
        clz_Torappu_SandboxV2LivestockDataT {
            livestockItemId,
            shinyLivestockItemId,
            livestockEnemyId,
            targetFenceId,
        }
    }

    #[inline]
    pub fn livestockItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2LivestockData::VT_LIVESTOCKITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn shinyLivestockItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2LivestockData::VT_SHINYLIVESTOCKITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn livestockEnemyId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2LivestockData::VT_LIVESTOCKENEMYID,
                None,
            )
        }
    }
    #[inline]
    pub fn targetFenceId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2LivestockData::VT_TARGETFENCEID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2LivestockData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "livestockItemId",
                Self::VT_LIVESTOCKITEMID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "shinyLivestockItemId",
                Self::VT_SHINYLIVESTOCKITEMID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "livestockEnemyId",
                Self::VT_LIVESTOCKENEMYID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "targetFenceId",
                Self::VT_TARGETFENCEID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2LivestockDataArgs<'a> {
    pub livestockItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub shinyLivestockItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub livestockEnemyId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub targetFenceId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2LivestockDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2LivestockDataArgs {
            livestockItemId: None,
            shinyLivestockItemId: None,
            livestockEnemyId: None,
            targetFenceId: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2LivestockData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2LivestockData", 4)?;
        if let Some(f) = self.livestockItemId() {
            s.serialize_field("livestockItemId", &f)?;
        } else {
            s.skip_field("livestockItemId")?;
        }
        if let Some(f) = self.shinyLivestockItemId() {
            s.serialize_field("shinyLivestockItemId", &f)?;
        } else {
            s.skip_field("shinyLivestockItemId")?;
        }
        if let Some(f) = self.livestockEnemyId() {
            s.serialize_field("livestockEnemyId", &f)?;
        } else {
            s.skip_field("livestockEnemyId")?;
        }
        if let Some(f) = self.targetFenceId() {
            s.serialize_field("targetFenceId", &f)?;
        } else {
            s.skip_field("targetFenceId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2LivestockDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2LivestockDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_livestockItemId(&mut self, livestockItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2LivestockData::VT_LIVESTOCKITEMID,
            livestockItemId,
        );
    }
    #[inline]
    pub fn add_shinyLivestockItemId(
        &mut self,
        shinyLivestockItemId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2LivestockData::VT_SHINYLIVESTOCKITEMID,
            shinyLivestockItemId,
        );
    }
    #[inline]
    pub fn add_livestockEnemyId(&mut self, livestockEnemyId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2LivestockData::VT_LIVESTOCKENEMYID,
            livestockEnemyId,
        );
    }
    #[inline]
    pub fn add_targetFenceId(&mut self, targetFenceId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2LivestockData::VT_TARGETFENCEID,
            targetFenceId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2LivestockDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2LivestockDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2LivestockData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2LivestockData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2LivestockData");
        ds.field("livestockItemId", &self.livestockItemId());
        ds.field("shinyLivestockItemId", &self.shinyLivestockItemId());
        ds.field("livestockEnemyId", &self.livestockEnemyId());
        ds.field("targetFenceId", &self.targetFenceId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2LivestockDataT {
    pub livestockItemId: Option<String>,
    pub shinyLivestockItemId: Option<String>,
    pub livestockEnemyId: Option<String>,
    pub targetFenceId: Option<String>,
}
impl Default for clz_Torappu_SandboxV2LivestockDataT {
    fn default() -> Self {
        Self {
            livestockItemId: None,
            shinyLivestockItemId: None,
            livestockEnemyId: None,
            targetFenceId: None,
        }
    }
}
impl clz_Torappu_SandboxV2LivestockDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2LivestockData<'b>> {
        let livestockItemId = self.livestockItemId.as_ref().map(|x| _fbb.create_string(x));
        let shinyLivestockItemId = self
            .shinyLivestockItemId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let livestockEnemyId = self
            .livestockEnemyId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let targetFenceId = self.targetFenceId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2LivestockData::create(
            _fbb,
            &clz_Torappu_SandboxV2LivestockDataArgs {
                livestockItemId,
                shinyLivestockItemId,
                livestockEnemyId,
                targetFenceId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2LivestockDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2LivestockData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2LivestockData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2LivestockData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2LivestockData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2LivestockData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2LivestockDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2LivestockData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2LivestockDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2LivestockDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2LivestockDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2LivestockData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2LivestockData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2LivestockData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LivestockData>>(
                    dict__string__clz_Torappu_SandboxV2LivestockData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2LivestockData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LivestockData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2LivestockDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2LivestockData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2LivestockDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2LivestockDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2LivestockData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2LivestockData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2LivestockDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2LivestockDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2LivestockData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2LivestockData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2LivestockData>>(
                dict__string__clz_Torappu_SandboxV2LivestockData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2LivestockDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2LivestockDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2LivestockData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2LivestockData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2LivestockData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2LivestockData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2LivestockDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2LivestockDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2LivestockDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2LivestockDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2LivestockData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2LivestockData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2LivestockDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2CraftGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2CraftGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2CraftGroupData<'a> {
    type Inner = clz_Torappu_SandboxV2CraftGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2CraftGroupData<'a> {
    pub const VT_ITEMS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2CraftGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2CraftGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2CraftGroupData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2CraftGroupDataBuilder::new(_fbb);
        if let Some(x) = args.items {
            builder.add_items(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2CraftGroupDataT {
        let items = self
            .items()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_SandboxV2CraftGroupDataT { items }
    }

    #[inline]
    pub fn items(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxV2CraftGroupData::VT_ITEMS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2CraftGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("items", Self::VT_ITEMS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2CraftGroupDataArgs<'a> {
    pub items: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2CraftGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2CraftGroupDataArgs { items: None }
    }
}

impl Serialize for clz_Torappu_SandboxV2CraftGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2CraftGroupData", 1)?;
        if let Some(f) = self.items() {
            s.serialize_field("items", &f)?;
        } else {
            s.skip_field("items")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2CraftGroupDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2CraftGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_items(
        &mut self,
        items: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2CraftGroupData::VT_ITEMS,
            items,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2CraftGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2CraftGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2CraftGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2CraftGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2CraftGroupData");
        ds.field("items", &self.items());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2CraftGroupDataT {
    pub items: Option<Vec<String>>,
}
impl Default for clz_Torappu_SandboxV2CraftGroupDataT {
    fn default() -> Self {
        Self { items: None }
    }
}
impl clz_Torappu_SandboxV2CraftGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2CraftGroupData<'b>> {
        let items = self.items.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SandboxV2CraftGroupData::create(
            _fbb,
            &clz_Torappu_SandboxV2CraftGroupDataArgs { items },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2CraftGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2CraftGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2CraftGroupData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2CraftGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2CraftGroupData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2CraftGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2CraftGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2CraftGroupData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2CraftGroupDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2CraftGroupDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2CraftGroupDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2CraftGroupData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2CraftGroupData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2CraftGroupData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2CraftGroupData>>(
                    dict__string__clz_Torappu_SandboxV2CraftGroupData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2CraftGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2CraftGroupData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2CraftGroupDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2CraftGroupData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2CraftGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2CraftGroupDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2CraftGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2CraftGroupData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2CraftGroupDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2CraftGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2CraftGroupData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2CraftGroupData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2CraftGroupData>>(
                dict__string__clz_Torappu_SandboxV2CraftGroupData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2CraftGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2CraftGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2CraftGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2CraftGroupData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2CraftGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2CraftGroupData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2CraftGroupDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2CraftGroupDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2CraftGroupDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2CraftGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2CraftGroupData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2CraftGroupData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2CraftGroupDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2AlchemyMaterialDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2AlchemyMaterialData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2AlchemyMaterialData<'a> {
    type Inner = clz_Torappu_SandboxV2AlchemyMaterialData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2AlchemyMaterialData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_COUNT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2AlchemyMaterialData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2AlchemyMaterialDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2AlchemyMaterialData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2AlchemyMaterialDataBuilder::new(_fbb);
        builder.add_count(args.count);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2AlchemyMaterialDataT {
        let itemId = self.itemId().map(|x| x.to_string());
        let count = self.count();
        clz_Torappu_SandboxV2AlchemyMaterialDataT { itemId, count }
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2AlchemyMaterialData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2AlchemyMaterialData::VT_COUNT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2AlchemyMaterialData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2AlchemyMaterialDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2AlchemyMaterialDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2AlchemyMaterialDataArgs {
            itemId: None,
            count: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2AlchemyMaterialData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2AlchemyMaterialData", 2)?;
        if let Some(f) = self.itemId() {
            s.serialize_field("itemId", &f)?;
        } else {
            s.skip_field("itemId")?;
        }
        s.serialize_field("count", &self.count())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2AlchemyMaterialDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2AlchemyMaterialDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2AlchemyMaterialData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2AlchemyMaterialData::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2AlchemyMaterialDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2AlchemyMaterialDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2AlchemyMaterialData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2AlchemyMaterialData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2AlchemyMaterialData");
        ds.field("itemId", &self.itemId());
        ds.field("count", &self.count());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2AlchemyMaterialDataT {
    pub itemId: Option<String>,
    pub count: i32,
}
impl Default for clz_Torappu_SandboxV2AlchemyMaterialDataT {
    fn default() -> Self {
        Self {
            itemId: None,
            count: 0,
        }
    }
}
impl clz_Torappu_SandboxV2AlchemyMaterialDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2AlchemyMaterialData<'b>> {
        let itemId = self.itemId.as_ref().map(|x| _fbb.create_string(x));
        let count = self.count;
        clz_Torappu_SandboxV2AlchemyMaterialData::create(
            _fbb,
            &clz_Torappu_SandboxV2AlchemyMaterialDataArgs { itemId, count },
        )
    }
}
pub enum clz_Torappu_SandboxV2AlchemyRecipeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2AlchemyRecipeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2AlchemyRecipeData<'a> {
    type Inner = clz_Torappu_SandboxV2AlchemyRecipeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2AlchemyRecipeData<'a> {
    pub const VT_RECIPEID: flatbuffers::VOffsetT = 4;
    pub const VT_MATERIALS: flatbuffers::VOffsetT = 6;
    pub const VT_ITEMID: flatbuffers::VOffsetT = 8;
    pub const VT_ONCEALCHEMYRATIO: flatbuffers::VOffsetT = 10;
    pub const VT_RECIPELEVEL: flatbuffers::VOffsetT = 12;
    pub const VT_UNLOCKDESC: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2AlchemyRecipeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2AlchemyRecipeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2AlchemyRecipeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2AlchemyRecipeDataBuilder::new(_fbb);
        if let Some(x) = args.unlockDesc {
            builder.add_unlockDesc(x);
        }
        builder.add_recipeLevel(args.recipeLevel);
        builder.add_onceAlchemyRatio(args.onceAlchemyRatio);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        if let Some(x) = args.materials {
            builder.add_materials(x);
        }
        if let Some(x) = args.recipeId {
            builder.add_recipeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2AlchemyRecipeDataT {
        let recipeId = self.recipeId().map(|x| x.to_string());
        let materials = self
            .materials()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let itemId = self.itemId().map(|x| x.to_string());
        let onceAlchemyRatio = self.onceAlchemyRatio();
        let recipeLevel = self.recipeLevel();
        let unlockDesc = self.unlockDesc().map(|x| x.to_string());
        clz_Torappu_SandboxV2AlchemyRecipeDataT {
            recipeId,
            materials,
            itemId,
            onceAlchemyRatio,
            recipeLevel,
            unlockDesc,
        }
    }

    #[inline]
    pub fn recipeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2AlchemyRecipeData::VT_RECIPEID,
                None,
            )
        }
    }
    #[inline]
    pub fn materials(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2AlchemyMaterialData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2AlchemyMaterialData>,
                >,
            >>(clz_Torappu_SandboxV2AlchemyRecipeData::VT_MATERIALS, None)
        }
    }
    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2AlchemyRecipeData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn onceAlchemyRatio(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2AlchemyRecipeData::VT_ONCEALCHEMYRATIO,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn recipeLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2AlchemyRecipeData::VT_RECIPELEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2AlchemyRecipeData::VT_UNLOCKDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2AlchemyRecipeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "recipeId",
                Self::VT_RECIPEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2AlchemyMaterialData>,
                >,
            >>("materials", Self::VT_MATERIALS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<i32>("onceAlchemyRatio", Self::VT_ONCEALCHEMYRATIO, false)?
            .visit_field::<i32>("recipeLevel", Self::VT_RECIPELEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockDesc",
                Self::VT_UNLOCKDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2AlchemyRecipeDataArgs<'a> {
    pub recipeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub materials: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2AlchemyMaterialData<'a>>,
            >,
        >,
    >,
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub onceAlchemyRatio: i32,
    pub recipeLevel: i32,
    pub unlockDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2AlchemyRecipeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2AlchemyRecipeDataArgs {
            recipeId: None,
            materials: None,
            itemId: None,
            onceAlchemyRatio: 0,
            recipeLevel: 0,
            unlockDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2AlchemyRecipeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2AlchemyRecipeData", 6)?;
        if let Some(f) = self.recipeId() {
            s.serialize_field("recipeId", &f)?;
        } else {
            s.skip_field("recipeId")?;
        }
        if let Some(f) = self.materials() {
            s.serialize_field("materials", &f)?;
        } else {
            s.skip_field("materials")?;
        }
        if let Some(f) = self.itemId() {
            s.serialize_field("itemId", &f)?;
        } else {
            s.skip_field("itemId")?;
        }
        s.serialize_field("onceAlchemyRatio", &self.onceAlchemyRatio())?;
        s.serialize_field("recipeLevel", &self.recipeLevel())?;
        if let Some(f) = self.unlockDesc() {
            s.serialize_field("unlockDesc", &f)?;
        } else {
            s.skip_field("unlockDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2AlchemyRecipeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2AlchemyRecipeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_recipeId(&mut self, recipeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2AlchemyRecipeData::VT_RECIPEID,
            recipeId,
        );
    }
    #[inline]
    pub fn add_materials(
        &mut self,
        materials: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2AlchemyMaterialData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2AlchemyRecipeData::VT_MATERIALS,
            materials,
        );
    }
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2AlchemyRecipeData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_onceAlchemyRatio(&mut self, onceAlchemyRatio: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2AlchemyRecipeData::VT_ONCEALCHEMYRATIO,
            onceAlchemyRatio,
            0,
        );
    }
    #[inline]
    pub fn add_recipeLevel(&mut self, recipeLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2AlchemyRecipeData::VT_RECIPELEVEL,
            recipeLevel,
            0,
        );
    }
    #[inline]
    pub fn add_unlockDesc(&mut self, unlockDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2AlchemyRecipeData::VT_UNLOCKDESC,
            unlockDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2AlchemyRecipeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2AlchemyRecipeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2AlchemyRecipeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2AlchemyRecipeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2AlchemyRecipeData");
        ds.field("recipeId", &self.recipeId());
        ds.field("materials", &self.materials());
        ds.field("itemId", &self.itemId());
        ds.field("onceAlchemyRatio", &self.onceAlchemyRatio());
        ds.field("recipeLevel", &self.recipeLevel());
        ds.field("unlockDesc", &self.unlockDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2AlchemyRecipeDataT {
    pub recipeId: Option<String>,
    pub materials: Option<Vec<clz_Torappu_SandboxV2AlchemyMaterialDataT>>,
    pub itemId: Option<String>,
    pub onceAlchemyRatio: i32,
    pub recipeLevel: i32,
    pub unlockDesc: Option<String>,
}
impl Default for clz_Torappu_SandboxV2AlchemyRecipeDataT {
    fn default() -> Self {
        Self {
            recipeId: None,
            materials: None,
            itemId: None,
            onceAlchemyRatio: 0,
            recipeLevel: 0,
            unlockDesc: None,
        }
    }
}
impl clz_Torappu_SandboxV2AlchemyRecipeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2AlchemyRecipeData<'b>> {
        let recipeId = self.recipeId.as_ref().map(|x| _fbb.create_string(x));
        let materials = self.materials.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let itemId = self.itemId.as_ref().map(|x| _fbb.create_string(x));
        let onceAlchemyRatio = self.onceAlchemyRatio;
        let recipeLevel = self.recipeLevel;
        let unlockDesc = self.unlockDesc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2AlchemyRecipeData::create(
            _fbb,
            &clz_Torappu_SandboxV2AlchemyRecipeDataArgs {
                recipeId,
                materials,
                itemId,
                onceAlchemyRatio,
                recipeLevel,
                unlockDesc,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2AlchemyRecipeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2AlchemyRecipeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2AlchemyRecipeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2AlchemyRecipeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2AlchemyRecipeData>>(
                    dict__string__clz_Torappu_SandboxV2AlchemyRecipeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2AlchemyRecipeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2AlchemyRecipeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_SandboxV2AlchemyRecipeData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2AlchemyRecipeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2AlchemyRecipeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2AlchemyRecipeData>>(
                dict__string__clz_Torappu_SandboxV2AlchemyRecipeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2AlchemyRecipeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2AlchemyRecipeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2AlchemyRecipeDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2AlchemyRecipeData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2DrinkMatDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2DrinkMatData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2DrinkMatData<'a> {
    type Inner = clz_Torappu_SandboxV2DrinkMatData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2DrinkMatData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_COUNT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2DrinkMatData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2DrinkMatDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DrinkMatData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2DrinkMatDataBuilder::new(_fbb);
        builder.add_count(args.count);
        builder.add_type_(args.type_);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2DrinkMatDataT {
        let id = self.id().map(|x| x.to_string());
        let type_ = self.type_();
        let count = self.count();
        clz_Torappu_SandboxV2DrinkMatDataT { id, type_, count }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DrinkMatData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_SandboxPermItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxPermItemType>(
                    clz_Torappu_SandboxV2DrinkMatData::VT_TYPE_,
                    Some(enum__Torappu_SandboxPermItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2DrinkMatData::VT_COUNT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2DrinkMatData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_SandboxPermItemType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2DrinkMatDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_SandboxPermItemType,
    pub count: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2DrinkMatDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2DrinkMatDataArgs {
            id: None,
            type_: enum__Torappu_SandboxPermItemType::NONE,
            count: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2DrinkMatData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2DrinkMatData", 3)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("type_", &self.type_())?;
        s.serialize_field("count", &self.count())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2DrinkMatDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2DrinkMatDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DrinkMatData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_SandboxPermItemType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxPermItemType>(
            clz_Torappu_SandboxV2DrinkMatData::VT_TYPE_,
            type_,
            enum__Torappu_SandboxPermItemType::NONE,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2DrinkMatData::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2DrinkMatDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2DrinkMatDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DrinkMatData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2DrinkMatData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2DrinkMatData");
        ds.field("id", &self.id());
        ds.field("type_", &self.type_());
        ds.field("count", &self.count());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2DrinkMatDataT {
    pub id: Option<String>,
    pub type_: enum__Torappu_SandboxPermItemType,
    pub count: i32,
}
impl Default for clz_Torappu_SandboxV2DrinkMatDataT {
    fn default() -> Self {
        Self {
            id: None,
            type_: enum__Torappu_SandboxPermItemType::NONE,
            count: 0,
        }
    }
}
impl clz_Torappu_SandboxV2DrinkMatDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DrinkMatData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let count = self.count;
        clz_Torappu_SandboxV2DrinkMatData::create(
            _fbb,
            &clz_Torappu_SandboxV2DrinkMatDataArgs { id, type_, count },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2DrinkMatDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2DrinkMatData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2DrinkMatData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2DrinkMatData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2DrinkMatData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2DrinkMatData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2DrinkMatDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2DrinkMatData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2DrinkMatDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2DrinkMatDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2DrinkMatDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2DrinkMatData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2DrinkMatData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2DrinkMatData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DrinkMatData>>(
                    dict__string__clz_Torappu_SandboxV2DrinkMatData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2DrinkMatData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DrinkMatData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2DrinkMatDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2DrinkMatData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2DrinkMatDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2DrinkMatDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2DrinkMatData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2DrinkMatData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2DrinkMatDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2DrinkMatDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2DrinkMatData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2DrinkMatData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2DrinkMatData>>(
                dict__string__clz_Torappu_SandboxV2DrinkMatData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2DrinkMatDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2DrinkMatDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2DrinkMatData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2DrinkMatData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2DrinkMatData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2DrinkMatData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2DrinkMatDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2DrinkMatDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2DrinkMatDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2DrinkMatDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2DrinkMatData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2DrinkMatData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2DrinkMatDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2FoodMatDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2FoodMatData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2FoodMatData<'a> {
    type Inner = clz_Torappu_SandboxV2FoodMatData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2FoodMatData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_ATTRIBUTE: flatbuffers::VOffsetT = 8;
    pub const VT_VARIANTTYPE: flatbuffers::VOffsetT = 10;
    pub const VT_BONUSDURATION: flatbuffers::VOffsetT = 12;
    pub const VT_BUFFDESC: flatbuffers::VOffsetT = 14;
    pub const VT_SORTID: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2FoodMatData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2FoodMatDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodMatData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2FoodMatDataBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.buffDesc {
            builder.add_buffDesc(x);
        }
        builder.add_bonusDuration(args.bonusDuration);
        builder.add_variantType(args.variantType);
        builder.add_attribute(args.attribute);
        builder.add_type_(args.type_);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2FoodMatDataT {
        let id = self.id().map(|x| x.to_string());
        let type_ = self.type_();
        let attribute = self.attribute();
        let variantType = self.variantType();
        let bonusDuration = self.bonusDuration();
        let buffDesc = self.buffDesc().map(|x| x.to_string());
        let sortId = self.sortId();
        clz_Torappu_SandboxV2FoodMatDataT {
            id,
            type_,
            attribute,
            variantType,
            bonusDuration,
            buffDesc,
            sortId,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2FoodMatData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_SandboxV2FoodMatType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2FoodMatType>(
                    clz_Torappu_SandboxV2FoodMatData::VT_TYPE_,
                    Some(enum__Torappu_SandboxV2FoodMatType::MAIN),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn attribute(&self) -> enum__Torappu_SandboxV2FoodAttribute {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2FoodAttribute>(
                    clz_Torappu_SandboxV2FoodMatData::VT_ATTRIBUTE,
                    Some(enum__Torappu_SandboxV2FoodAttribute::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn variantType(&self) -> enum__Torappu_SandboxV2FoodVariantType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2FoodVariantType>(
                    clz_Torappu_SandboxV2FoodMatData::VT_VARIANTTYPE,
                    Some(enum__Torappu_SandboxV2FoodVariantType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn bonusDuration(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2FoodMatData::VT_BONUSDURATION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn buffDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2FoodMatData::VT_BUFFDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2FoodMatData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2FoodMatData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_SandboxV2FoodMatType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<enum__Torappu_SandboxV2FoodAttribute>(
                "attribute",
                Self::VT_ATTRIBUTE,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxV2FoodVariantType>(
                "variantType",
                Self::VT_VARIANTTYPE,
                false,
            )?
            .visit_field::<i32>("bonusDuration", Self::VT_BONUSDURATION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffDesc",
                Self::VT_BUFFDESC,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2FoodMatDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_SandboxV2FoodMatType,
    pub attribute: enum__Torappu_SandboxV2FoodAttribute,
    pub variantType: enum__Torappu_SandboxV2FoodVariantType,
    pub bonusDuration: i32,
    pub buffDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2FoodMatDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2FoodMatDataArgs {
            id: None,
            type_: enum__Torappu_SandboxV2FoodMatType::MAIN,
            attribute: enum__Torappu_SandboxV2FoodAttribute::NONE,
            variantType: enum__Torappu_SandboxV2FoodVariantType::NONE,
            bonusDuration: 0,
            buffDesc: None,
            sortId: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2FoodMatData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2FoodMatData", 7)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("type_", &self.type_())?;
        s.serialize_field("attribute", &self.attribute())?;
        s.serialize_field("variantType", &self.variantType())?;
        s.serialize_field("bonusDuration", &self.bonusDuration())?;
        if let Some(f) = self.buffDesc() {
            s.serialize_field("buffDesc", &f)?;
        } else {
            s.skip_field("buffDesc")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2FoodMatDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2FoodMatDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FoodMatData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_SandboxV2FoodMatType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2FoodMatType>(
            clz_Torappu_SandboxV2FoodMatData::VT_TYPE_,
            type_,
            enum__Torappu_SandboxV2FoodMatType::MAIN,
        );
    }
    #[inline]
    pub fn add_attribute(&mut self, attribute: enum__Torappu_SandboxV2FoodAttribute) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2FoodAttribute>(
            clz_Torappu_SandboxV2FoodMatData::VT_ATTRIBUTE,
            attribute,
            enum__Torappu_SandboxV2FoodAttribute::NONE,
        );
    }
    #[inline]
    pub fn add_variantType(&mut self, variantType: enum__Torappu_SandboxV2FoodVariantType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2FoodVariantType>(
                clz_Torappu_SandboxV2FoodMatData::VT_VARIANTTYPE,
                variantType,
                enum__Torappu_SandboxV2FoodVariantType::NONE,
            );
    }
    #[inline]
    pub fn add_bonusDuration(&mut self, bonusDuration: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2FoodMatData::VT_BONUSDURATION,
            bonusDuration,
            0,
        );
    }
    #[inline]
    pub fn add_buffDesc(&mut self, buffDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FoodMatData::VT_BUFFDESC,
            buffDesc,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2FoodMatData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2FoodMatDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2FoodMatDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodMatData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2FoodMatData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2FoodMatData");
        ds.field("id", &self.id());
        ds.field("type_", &self.type_());
        ds.field("attribute", &self.attribute());
        ds.field("variantType", &self.variantType());
        ds.field("bonusDuration", &self.bonusDuration());
        ds.field("buffDesc", &self.buffDesc());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2FoodMatDataT {
    pub id: Option<String>,
    pub type_: enum__Torappu_SandboxV2FoodMatType,
    pub attribute: enum__Torappu_SandboxV2FoodAttribute,
    pub variantType: enum__Torappu_SandboxV2FoodVariantType,
    pub bonusDuration: i32,
    pub buffDesc: Option<String>,
    pub sortId: i32,
}
impl Default for clz_Torappu_SandboxV2FoodMatDataT {
    fn default() -> Self {
        Self {
            id: None,
            type_: enum__Torappu_SandboxV2FoodMatType::MAIN,
            attribute: enum__Torappu_SandboxV2FoodAttribute::NONE,
            variantType: enum__Torappu_SandboxV2FoodVariantType::NONE,
            bonusDuration: 0,
            buffDesc: None,
            sortId: 0,
        }
    }
}
impl clz_Torappu_SandboxV2FoodMatDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodMatData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let attribute = self.attribute;
        let variantType = self.variantType;
        let bonusDuration = self.bonusDuration;
        let buffDesc = self.buffDesc.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        clz_Torappu_SandboxV2FoodMatData::create(
            _fbb,
            &clz_Torappu_SandboxV2FoodMatDataArgs {
                id,
                type_,
                attribute,
                variantType,
                bonusDuration,
                buffDesc,
                sortId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2FoodMatDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2FoodMatData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2FoodMatData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2FoodMatData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2FoodMatData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2FoodMatData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2FoodMatDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2FoodMatData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2FoodMatDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2FoodMatDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2FoodMatDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2FoodMatData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2FoodMatData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2FoodMatData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodMatData>>(
                    dict__string__clz_Torappu_SandboxV2FoodMatData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2FoodMatData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodMatData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2FoodMatDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodMatData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2FoodMatDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2FoodMatDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2FoodMatData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2FoodMatData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2FoodMatDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2FoodMatDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2FoodMatData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodMatData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodMatData>>(
                dict__string__clz_Torappu_SandboxV2FoodMatData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2FoodMatDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2FoodMatDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2FoodMatData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2FoodMatData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2FoodMatData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2FoodMatData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2FoodMatDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2FoodMatDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2FoodMatDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2FoodMatDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2FoodMatData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2FoodMatData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2FoodMatDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2FoodRecipeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2FoodRecipeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2FoodRecipeData<'a> {
    type Inner = clz_Torappu_SandboxV2FoodRecipeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2FoodRecipeData<'a> {
    pub const VT_FOODID: flatbuffers::VOffsetT = 4;
    pub const VT_MATS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2FoodRecipeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2FoodRecipeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodRecipeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2FoodRecipeDataBuilder::new(_fbb);
        if let Some(x) = args.mats {
            builder.add_mats(x);
        }
        if let Some(x) = args.foodId {
            builder.add_foodId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2FoodRecipeDataT {
        let foodId = self.foodId().map(|x| x.to_string());
        let mats = self
            .mats()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_SandboxV2FoodRecipeDataT { foodId, mats }
    }

    #[inline]
    pub fn foodId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2FoodRecipeData::VT_FOODID,
                None,
            )
        }
    }
    #[inline]
    pub fn mats(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxV2FoodRecipeData::VT_MATS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2FoodRecipeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("foodId", Self::VT_FOODID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("mats", Self::VT_MATS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2FoodRecipeDataArgs<'a> {
    pub foodId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mats: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2FoodRecipeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2FoodRecipeDataArgs {
            foodId: None,
            mats: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2FoodRecipeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2FoodRecipeData", 2)?;
        if let Some(f) = self.foodId() {
            s.serialize_field("foodId", &f)?;
        } else {
            s.skip_field("foodId")?;
        }
        if let Some(f) = self.mats() {
            s.serialize_field("mats", &f)?;
        } else {
            s.skip_field("mats")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2FoodRecipeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2FoodRecipeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_foodId(&mut self, foodId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FoodRecipeData::VT_FOODID,
            foodId,
        );
    }
    #[inline]
    pub fn add_mats(
        &mut self,
        mats: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FoodRecipeData::VT_MATS,
            mats,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2FoodRecipeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2FoodRecipeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodRecipeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2FoodRecipeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2FoodRecipeData");
        ds.field("foodId", &self.foodId());
        ds.field("mats", &self.mats());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2FoodRecipeDataT {
    pub foodId: Option<String>,
    pub mats: Option<Vec<String>>,
}
impl Default for clz_Torappu_SandboxV2FoodRecipeDataT {
    fn default() -> Self {
        Self {
            foodId: None,
            mats: None,
        }
    }
}
impl clz_Torappu_SandboxV2FoodRecipeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodRecipeData<'b>> {
        let foodId = self.foodId.as_ref().map(|x| _fbb.create_string(x));
        let mats = self.mats.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SandboxV2FoodRecipeData::create(
            _fbb,
            &clz_Torappu_SandboxV2FoodRecipeDataArgs { foodId, mats },
        )
    }
}
pub enum clz_Torappu_SandboxV2FoodVariantDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2FoodVariantData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2FoodVariantData<'a> {
    type Inner = clz_Torappu_SandboxV2FoodVariantData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2FoodVariantData<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_USAGE: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2FoodVariantData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2FoodVariantDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodVariantData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2FoodVariantDataBuilder::new(_fbb);
        if let Some(x) = args.usage {
            builder.add_usage(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2FoodVariantDataT {
        let type_ = self.type_();
        let name = self.name().map(|x| x.to_string());
        let usage = self.usage().map(|x| x.to_string());
        clz_Torappu_SandboxV2FoodVariantDataT { type_, name, usage }
    }

    #[inline]
    pub fn type_(&self) -> enum__Torappu_SandboxV2FoodVariantType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2FoodVariantType>(
                    clz_Torappu_SandboxV2FoodVariantData::VT_TYPE_,
                    Some(enum__Torappu_SandboxV2FoodVariantType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2FoodVariantData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn usage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2FoodVariantData::VT_USAGE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2FoodVariantData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxV2FoodVariantType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("usage", Self::VT_USAGE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2FoodVariantDataArgs<'a> {
    pub type_: enum__Torappu_SandboxV2FoodVariantType,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub usage: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2FoodVariantDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2FoodVariantDataArgs {
            type_: enum__Torappu_SandboxV2FoodVariantType::NONE,
            name: None,
            usage: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2FoodVariantData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2FoodVariantData", 3)?;
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.usage() {
            s.serialize_field("usage", &f)?;
        } else {
            s.skip_field("usage")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2FoodVariantDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2FoodVariantDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_SandboxV2FoodVariantType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2FoodVariantType>(
                clz_Torappu_SandboxV2FoodVariantData::VT_TYPE_,
                type_,
                enum__Torappu_SandboxV2FoodVariantType::NONE,
            );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FoodVariantData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_usage(&mut self, usage: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FoodVariantData::VT_USAGE,
            usage,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2FoodVariantDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2FoodVariantDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodVariantData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2FoodVariantData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2FoodVariantData");
        ds.field("type_", &self.type_());
        ds.field("name", &self.name());
        ds.field("usage", &self.usage());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2FoodVariantDataT {
    pub type_: enum__Torappu_SandboxV2FoodVariantType,
    pub name: Option<String>,
    pub usage: Option<String>,
}
impl Default for clz_Torappu_SandboxV2FoodVariantDataT {
    fn default() -> Self {
        Self {
            type_: enum__Torappu_SandboxV2FoodVariantType::NONE,
            name: None,
            usage: None,
        }
    }
}
impl clz_Torappu_SandboxV2FoodVariantDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodVariantData<'b>> {
        let type_ = self.type_;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let usage = self.usage.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2FoodVariantData::create(
            _fbb,
            &clz_Torappu_SandboxV2FoodVariantDataArgs { type_, name, usage },
        )
    }
}
pub enum clz_Torappu_SandboxV2FoodDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2FoodData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2FoodData<'a> {
    type Inner = clz_Torappu_SandboxV2FoodData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2FoodData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 6;
    pub const VT_RECIPES: flatbuffers::VOffsetT = 8;
    pub const VT_VARIANTS: flatbuffers::VOffsetT = 10;
    pub const VT_DURATION: flatbuffers::VOffsetT = 12;
    pub const VT_SORTID: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2FoodData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2FoodDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2FoodDataBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        builder.add_duration(args.duration);
        if let Some(x) = args.variants {
            builder.add_variants(x);
        }
        if let Some(x) = args.recipes {
            builder.add_recipes(x);
        }
        if let Some(x) = args.attributes {
            builder.add_attributes(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2FoodDataT {
        let id = self.id().map(|x| x.to_string());
        let attributes = self.attributes().map(|x| x.into_iter().collect());
        let recipes = self
            .recipes()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let variants = self
            .variants()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let duration = self.duration();
        let sortId = self.sortId();
        clz_Torappu_SandboxV2FoodDataT {
            id,
            attributes,
            recipes,
            variants,
            duration,
            sortId,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2FoodData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn attributes(
        &self,
    ) -> Option<flatbuffers::Vector<'a, enum__Torappu_SandboxV2FoodAttribute>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_SandboxV2FoodAttribute>,
            >>(clz_Torappu_SandboxV2FoodData::VT_ATTRIBUTES, None)
        }
    }
    #[inline]
    pub fn recipes(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodRecipeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodRecipeData>,
                >,
            >>(clz_Torappu_SandboxV2FoodData::VT_RECIPES, None)
        }
    }
    #[inline]
    pub fn variants(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodVariantData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodVariantData>,
                >,
            >>(clz_Torappu_SandboxV2FoodData::VT_VARIANTS, None)
        }
    }
    #[inline]
    pub fn duration(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2FoodData::VT_DURATION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2FoodData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2FoodData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, enum__Torappu_SandboxV2FoodAttribute>,
            >>("attributes", Self::VT_ATTRIBUTES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodRecipeData>,
                >,
            >>("recipes", Self::VT_RECIPES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodVariantData>,
                >,
            >>("variants", Self::VT_VARIANTS, false)?
            .visit_field::<i32>("duration", Self::VT_DURATION, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2FoodDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub attributes: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_SandboxV2FoodAttribute>>,
    >,
    pub recipes: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodRecipeData<'a>>,
            >,
        >,
    >,
    pub variants: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodVariantData<'a>>,
            >,
        >,
    >,
    pub duration: i32,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2FoodDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2FoodDataArgs {
            id: None,
            attributes: None,
            recipes: None,
            variants: None,
            duration: 0,
            sortId: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2FoodData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2FoodData", 6)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.attributes() {
            s.serialize_field("attributes", &f)?;
        } else {
            s.skip_field("attributes")?;
        }
        if let Some(f) = self.recipes() {
            s.serialize_field("recipes", &f)?;
        } else {
            s.skip_field("recipes")?;
        }
        if let Some(f) = self.variants() {
            s.serialize_field("variants", &f)?;
        } else {
            s.skip_field("variants")?;
        }
        s.serialize_field("duration", &self.duration())?;
        s.serialize_field("sortId", &self.sortId())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2FoodDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2FoodDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FoodData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_attributes(
        &mut self,
        attributes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, enum__Torappu_SandboxV2FoodAttribute>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FoodData::VT_ATTRIBUTES,
            attributes,
        );
    }
    #[inline]
    pub fn add_recipes(
        &mut self,
        recipes: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodRecipeData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FoodData::VT_RECIPES,
            recipes,
        );
    }
    #[inline]
    pub fn add_variants(
        &mut self,
        variants: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodVariantData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FoodData::VT_VARIANTS,
            variants,
        );
    }
    #[inline]
    pub fn add_duration(&mut self, duration: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2FoodData::VT_DURATION, duration, 0);
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2FoodData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2FoodDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2FoodDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2FoodData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2FoodData");
        ds.field("id", &self.id());
        ds.field("attributes", &self.attributes());
        ds.field("recipes", &self.recipes());
        ds.field("variants", &self.variants());
        ds.field("duration", &self.duration());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2FoodDataT {
    pub id: Option<String>,
    pub attributes: Option<Vec<enum__Torappu_SandboxV2FoodAttribute>>,
    pub recipes: Option<Vec<clz_Torappu_SandboxV2FoodRecipeDataT>>,
    pub variants: Option<Vec<clz_Torappu_SandboxV2FoodVariantDataT>>,
    pub duration: i32,
    pub sortId: i32,
}
impl Default for clz_Torappu_SandboxV2FoodDataT {
    fn default() -> Self {
        Self {
            id: None,
            attributes: None,
            recipes: None,
            variants: None,
            duration: 0,
            sortId: 0,
        }
    }
}
impl clz_Torappu_SandboxV2FoodDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let attributes = self.attributes.as_ref().map(|x| _fbb.create_vector(x));
        let recipes = self.recipes.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let variants = self.variants.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let duration = self.duration;
        let sortId = self.sortId;
        clz_Torappu_SandboxV2FoodData::create(
            _fbb,
            &clz_Torappu_SandboxV2FoodDataArgs {
                id,
                attributes,
                recipes,
                variants,
                duration,
                sortId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2FoodDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2FoodData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2FoodData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2FoodData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2FoodData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2FoodData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2FoodDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2FoodData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2FoodDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2FoodDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2FoodDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2FoodData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2FoodData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2FoodData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodData>>(
                    dict__string__clz_Torappu_SandboxV2FoodData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2FoodData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FoodData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2FoodDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2FoodDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2FoodDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2FoodData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2FoodData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2FoodDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2FoodDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2FoodData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2FoodData>>(
                dict__string__clz_Torappu_SandboxV2FoodData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2FoodDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2FoodDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2FoodData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2FoodData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2FoodData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2FoodData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2FoodDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2FoodDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2FoodDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2FoodDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2FoodData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2FoodData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2FoodDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2NodeTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2NodeTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2NodeTypeData<'a> {
    type Inner = clz_Torappu_SandboxV2NodeTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2NodeTypeData<'a> {
    pub const VT_NODETYPE: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_ICONID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2NodeTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2NodeTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeTypeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2NodeTypeDataBuilder::new(_fbb);
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_nodeType(args.nodeType);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2NodeTypeDataT {
        let nodeType = self.nodeType();
        let name = self.name().map(|x| x.to_string());
        let iconId = self.iconId().map(|x| x.to_string());
        clz_Torappu_SandboxV2NodeTypeDataT {
            nodeType,
            name,
            iconId,
        }
    }

    #[inline]
    pub fn nodeType(&self) -> enum__Torappu_SandboxV2NodeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2NodeType>(
                    clz_Torappu_SandboxV2NodeTypeData::VT_NODETYPE,
                    Some(enum__Torappu_SandboxV2NodeType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeTypeData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeTypeData::VT_ICONID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2NodeTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxV2NodeType>("nodeType", Self::VT_NODETYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2NodeTypeDataArgs<'a> {
    pub nodeType: enum__Torappu_SandboxV2NodeType,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2NodeTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2NodeTypeDataArgs {
            nodeType: enum__Torappu_SandboxV2NodeType::NONE,
            name: None,
            iconId: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2NodeTypeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2NodeTypeData", 3)?;
        s.serialize_field("nodeType", &self.nodeType())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.iconId() {
            s.serialize_field("iconId", &f)?;
        } else {
            s.skip_field("iconId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2NodeTypeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2NodeTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeType(&mut self, nodeType: enum__Torappu_SandboxV2NodeType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2NodeType>(
            clz_Torappu_SandboxV2NodeTypeData::VT_NODETYPE,
            nodeType,
            enum__Torappu_SandboxV2NodeType::NONE,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeTypeData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeTypeData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2NodeTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2NodeTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2NodeTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2NodeTypeData");
        ds.field("nodeType", &self.nodeType());
        ds.field("name", &self.name());
        ds.field("iconId", &self.iconId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2NodeTypeDataT {
    pub nodeType: enum__Torappu_SandboxV2NodeType,
    pub name: Option<String>,
    pub iconId: Option<String>,
}
impl Default for clz_Torappu_SandboxV2NodeTypeDataT {
    fn default() -> Self {
        Self {
            nodeType: enum__Torappu_SandboxV2NodeType::NONE,
            name: None,
            iconId: None,
        }
    }
}
impl clz_Torappu_SandboxV2NodeTypeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeTypeData<'b>> {
        let nodeType = self.nodeType;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let iconId = self.iconId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2NodeTypeData::create(
            _fbb,
            &clz_Torappu_SandboxV2NodeTypeDataArgs {
                nodeType,
                name,
                iconId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2NodeTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2NodeTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2NodeTypeData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2NodeTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2NodeTypeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2NodeTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2NodeTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NodeTypeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2NodeTypeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2NodeTypeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2NodeTypeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2NodeTypeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2NodeTypeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2NodeTypeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2NodeTypeData>>(
                    dict__string__clz_Torappu_SandboxV2NodeTypeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2NodeTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2NodeTypeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2NodeTypeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeTypeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2NodeTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2NodeTypeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2NodeTypeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2NodeTypeData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2NodeTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2NodeTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2NodeTypeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeTypeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeTypeData>>(
                dict__string__clz_Torappu_SandboxV2NodeTypeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2NodeTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2NodeTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NodeTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2NodeTypeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2NodeTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2NodeTypeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2NodeTypeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2NodeTypeDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2NodeTypeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2NodeTypeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NodeTypeData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2NodeTypeData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2NodeTypeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2NodeUpgradeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2NodeUpgradeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2NodeUpgradeData<'a> {
    type Inner = clz_Torappu_SandboxV2NodeUpgradeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2NodeUpgradeData<'a> {
    pub const VT_NODEUPGRADEID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 8;
    pub const VT_UPGRADEDESC: flatbuffers::VOffsetT = 10;
    pub const VT_UPGRADETIPS: flatbuffers::VOffsetT = 12;
    pub const VT_ITEMTYPE: flatbuffers::VOffsetT = 14;
    pub const VT_ITEMTAG: flatbuffers::VOffsetT = 16;
    pub const VT_ITEMCNT: flatbuffers::VOffsetT = 18;
    pub const VT_ITEMRARITY: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2NodeUpgradeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2NodeUpgradeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeUpgradeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2NodeUpgradeDataBuilder::new(_fbb);
        builder.add_itemRarity(args.itemRarity);
        builder.add_itemCnt(args.itemCnt);
        builder.add_itemTag(args.itemTag);
        builder.add_itemType(args.itemType);
        if let Some(x) = args.upgradeTips {
            builder.add_upgradeTips(x);
        }
        if let Some(x) = args.upgradeDesc {
            builder.add_upgradeDesc(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.nodeUpgradeId {
            builder.add_nodeUpgradeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2NodeUpgradeDataT {
        let nodeUpgradeId = self.nodeUpgradeId().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let upgradeDesc = self.upgradeDesc().map(|x| x.to_string());
        let upgradeTips = self.upgradeTips().map(|x| x.to_string());
        let itemType = self.itemType();
        let itemTag = self.itemTag();
        let itemCnt = self.itemCnt();
        let itemRarity = self.itemRarity();
        clz_Torappu_SandboxV2NodeUpgradeDataT {
            nodeUpgradeId,
            name,
            description,
            upgradeDesc,
            upgradeTips,
            itemType,
            itemTag,
            itemCnt,
            itemRarity,
        }
    }

    #[inline]
    pub fn nodeUpgradeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeUpgradeData::VT_NODEUPGRADEID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeUpgradeData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeUpgradeData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn upgradeDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeUpgradeData::VT_UPGRADEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn upgradeTips(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeUpgradeData::VT_UPGRADETIPS,
                None,
            )
        }
    }
    #[inline]
    pub fn itemType(&self) -> enum__Torappu_SandboxPermItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxPermItemType>(
                    clz_Torappu_SandboxV2NodeUpgradeData::VT_ITEMTYPE,
                    Some(enum__Torappu_SandboxPermItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn itemTag(&self) -> enum__Torappu_SandboxV2ItemTrapTag {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2ItemTrapTag>(
                    clz_Torappu_SandboxV2NodeUpgradeData::VT_ITEMTAG,
                    Some(enum__Torappu_SandboxV2ItemTrapTag::OUTPUT),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn itemCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2NodeUpgradeData::VT_ITEMCNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn itemRarity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2NodeUpgradeData::VT_ITEMRARITY, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2NodeUpgradeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nodeUpgradeId",
                Self::VT_NODEUPGRADEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "upgradeDesc",
                Self::VT_UPGRADEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "upgradeTips",
                Self::VT_UPGRADETIPS,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxPermItemType>("itemType", Self::VT_ITEMTYPE, false)?
            .visit_field::<enum__Torappu_SandboxV2ItemTrapTag>("itemTag", Self::VT_ITEMTAG, false)?
            .visit_field::<i32>("itemCnt", Self::VT_ITEMCNT, false)?
            .visit_field::<i32>("itemRarity", Self::VT_ITEMRARITY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2NodeUpgradeDataArgs<'a> {
    pub nodeUpgradeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub upgradeDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub upgradeTips: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemType: enum__Torappu_SandboxPermItemType,
    pub itemTag: enum__Torappu_SandboxV2ItemTrapTag,
    pub itemCnt: i32,
    pub itemRarity: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2NodeUpgradeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2NodeUpgradeDataArgs {
            nodeUpgradeId: None,
            name: None,
            description: None,
            upgradeDesc: None,
            upgradeTips: None,
            itemType: enum__Torappu_SandboxPermItemType::NONE,
            itemTag: enum__Torappu_SandboxV2ItemTrapTag::OUTPUT,
            itemCnt: 0,
            itemRarity: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2NodeUpgradeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2NodeUpgradeData", 9)?;
        if let Some(f) = self.nodeUpgradeId() {
            s.serialize_field("nodeUpgradeId", &f)?;
        } else {
            s.skip_field("nodeUpgradeId")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        if let Some(f) = self.upgradeDesc() {
            s.serialize_field("upgradeDesc", &f)?;
        } else {
            s.skip_field("upgradeDesc")?;
        }
        if let Some(f) = self.upgradeTips() {
            s.serialize_field("upgradeTips", &f)?;
        } else {
            s.skip_field("upgradeTips")?;
        }
        s.serialize_field("itemType", &self.itemType())?;
        s.serialize_field("itemTag", &self.itemTag())?;
        s.serialize_field("itemCnt", &self.itemCnt())?;
        s.serialize_field("itemRarity", &self.itemRarity())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2NodeUpgradeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2NodeUpgradeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeUpgradeId(&mut self, nodeUpgradeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeUpgradeData::VT_NODEUPGRADEID,
            nodeUpgradeId,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeUpgradeData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeUpgradeData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_upgradeDesc(&mut self, upgradeDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeUpgradeData::VT_UPGRADEDESC,
            upgradeDesc,
        );
    }
    #[inline]
    pub fn add_upgradeTips(&mut self, upgradeTips: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeUpgradeData::VT_UPGRADETIPS,
            upgradeTips,
        );
    }
    #[inline]
    pub fn add_itemType(&mut self, itemType: enum__Torappu_SandboxPermItemType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxPermItemType>(
            clz_Torappu_SandboxV2NodeUpgradeData::VT_ITEMTYPE,
            itemType,
            enum__Torappu_SandboxPermItemType::NONE,
        );
    }
    #[inline]
    pub fn add_itemTag(&mut self, itemTag: enum__Torappu_SandboxV2ItemTrapTag) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2ItemTrapTag>(
            clz_Torappu_SandboxV2NodeUpgradeData::VT_ITEMTAG,
            itemTag,
            enum__Torappu_SandboxV2ItemTrapTag::OUTPUT,
        );
    }
    #[inline]
    pub fn add_itemCnt(&mut self, itemCnt: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2NodeUpgradeData::VT_ITEMCNT, itemCnt, 0);
    }
    #[inline]
    pub fn add_itemRarity(&mut self, itemRarity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2NodeUpgradeData::VT_ITEMRARITY,
            itemRarity,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2NodeUpgradeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2NodeUpgradeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeUpgradeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2NodeUpgradeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2NodeUpgradeData");
        ds.field("nodeUpgradeId", &self.nodeUpgradeId());
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.field("upgradeDesc", &self.upgradeDesc());
        ds.field("upgradeTips", &self.upgradeTips());
        ds.field("itemType", &self.itemType());
        ds.field("itemTag", &self.itemTag());
        ds.field("itemCnt", &self.itemCnt());
        ds.field("itemRarity", &self.itemRarity());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2NodeUpgradeDataT {
    pub nodeUpgradeId: Option<String>,
    pub name: Option<String>,
    pub description: Option<String>,
    pub upgradeDesc: Option<String>,
    pub upgradeTips: Option<String>,
    pub itemType: enum__Torappu_SandboxPermItemType,
    pub itemTag: enum__Torappu_SandboxV2ItemTrapTag,
    pub itemCnt: i32,
    pub itemRarity: i32,
}
impl Default for clz_Torappu_SandboxV2NodeUpgradeDataT {
    fn default() -> Self {
        Self {
            nodeUpgradeId: None,
            name: None,
            description: None,
            upgradeDesc: None,
            upgradeTips: None,
            itemType: enum__Torappu_SandboxPermItemType::NONE,
            itemTag: enum__Torappu_SandboxV2ItemTrapTag::OUTPUT,
            itemCnt: 0,
            itemRarity: 0,
        }
    }
}
impl clz_Torappu_SandboxV2NodeUpgradeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeUpgradeData<'b>> {
        let nodeUpgradeId = self.nodeUpgradeId.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let upgradeDesc = self.upgradeDesc.as_ref().map(|x| _fbb.create_string(x));
        let upgradeTips = self.upgradeTips.as_ref().map(|x| _fbb.create_string(x));
        let itemType = self.itemType;
        let itemTag = self.itemTag;
        let itemCnt = self.itemCnt;
        let itemRarity = self.itemRarity;
        clz_Torappu_SandboxV2NodeUpgradeData::create(
            _fbb,
            &clz_Torappu_SandboxV2NodeUpgradeDataArgs {
                nodeUpgradeId,
                name,
                description,
                upgradeDesc,
                upgradeTips,
                itemType,
                itemTag,
                itemCnt,
                itemRarity,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2NodeUpgradeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2NodeUpgradeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2NodeUpgradeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2NodeUpgradeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2NodeUpgradeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2NodeUpgradeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2NodeUpgradeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2NodeUpgradeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2NodeUpgradeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2NodeUpgradeData>>(
                    dict__string__clz_Torappu_SandboxV2NodeUpgradeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2NodeUpgradeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2NodeUpgradeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeUpgradeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2NodeUpgradeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2NodeUpgradeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2NodeUpgradeData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2NodeUpgradeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2NodeUpgradeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2NodeUpgradeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeUpgradeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeUpgradeData>>(
                dict__string__clz_Torappu_SandboxV2NodeUpgradeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2NodeUpgradeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2NodeUpgradeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2NodeUpgradeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2NodeUpgradeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2NodeUpgradeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2NodeUpgradeDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2NodeUpgradeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2NodeUpgradeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2NodeUpgradeData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2NodeUpgradeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2WeatherDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2WeatherData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2WeatherData<'a> {
    type Inner = clz_Torappu_SandboxV2WeatherData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2WeatherData<'a> {
    pub const VT_WEATHERID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_WEATHERLEVEL: flatbuffers::VOffsetT = 8;
    pub const VT_WEATHERTYPE: flatbuffers::VOffsetT = 10;
    pub const VT_WEATHERTYPENAME: flatbuffers::VOffsetT = 12;
    pub const VT_WEATHERICONID: flatbuffers::VOffsetT = 14;
    pub const VT_FUNCTIONDESC: flatbuffers::VOffsetT = 16;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 18;
    pub const VT_BUFFID: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2WeatherData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2WeatherDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2WeatherData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2WeatherDataBuilder::new(_fbb);
        if let Some(x) = args.buffId {
            builder.add_buffId(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.functionDesc {
            builder.add_functionDesc(x);
        }
        if let Some(x) = args.weatherIconId {
            builder.add_weatherIconId(x);
        }
        if let Some(x) = args.weatherTypeName {
            builder.add_weatherTypeName(x);
        }
        builder.add_weatherType(args.weatherType);
        builder.add_weatherLevel(args.weatherLevel);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.weatherId {
            builder.add_weatherId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2WeatherDataT {
        let weatherId = self.weatherId().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let weatherLevel = self.weatherLevel();
        let weatherType = self.weatherType();
        let weatherTypeName = self.weatherTypeName().map(|x| x.to_string());
        let weatherIconId = self.weatherIconId().map(|x| x.to_string());
        let functionDesc = self.functionDesc().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let buffId = self.buffId().map(|x| x.to_string());
        clz_Torappu_SandboxV2WeatherDataT {
            weatherId,
            name,
            weatherLevel,
            weatherType,
            weatherTypeName,
            weatherIconId,
            functionDesc,
            description,
            buffId,
        }
    }

    #[inline]
    pub fn weatherId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2WeatherData::VT_WEATHERID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2WeatherData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn weatherLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2WeatherData::VT_WEATHERLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn weatherType(&self) -> enum__Torappu_SandboxV2WeatherType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2WeatherType>(
                    clz_Torappu_SandboxV2WeatherData::VT_WEATHERTYPE,
                    Some(enum__Torappu_SandboxV2WeatherType::NORMAL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn weatherTypeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2WeatherData::VT_WEATHERTYPENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn weatherIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2WeatherData::VT_WEATHERICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn functionDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2WeatherData::VT_FUNCTIONDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2WeatherData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn buffId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2WeatherData::VT_BUFFID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2WeatherData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "weatherId",
                Self::VT_WEATHERID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<i32>("weatherLevel", Self::VT_WEATHERLEVEL, false)?
            .visit_field::<enum__Torappu_SandboxV2WeatherType>(
                "weatherType",
                Self::VT_WEATHERTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "weatherTypeName",
                Self::VT_WEATHERTYPENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "weatherIconId",
                Self::VT_WEATHERICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "functionDesc",
                Self::VT_FUNCTIONDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buffId", Self::VT_BUFFID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2WeatherDataArgs<'a> {
    pub weatherId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weatherLevel: i32,
    pub weatherType: enum__Torappu_SandboxV2WeatherType,
    pub weatherTypeName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weatherIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub functionDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2WeatherDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2WeatherDataArgs {
            weatherId: None,
            name: None,
            weatherLevel: 0,
            weatherType: enum__Torappu_SandboxV2WeatherType::NORMAL,
            weatherTypeName: None,
            weatherIconId: None,
            functionDesc: None,
            description: None,
            buffId: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2WeatherData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2WeatherData", 9)?;
        if let Some(f) = self.weatherId() {
            s.serialize_field("weatherId", &f)?;
        } else {
            s.skip_field("weatherId")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        s.serialize_field("weatherLevel", &self.weatherLevel())?;
        s.serialize_field("weatherType", &self.weatherType())?;
        if let Some(f) = self.weatherTypeName() {
            s.serialize_field("weatherTypeName", &f)?;
        } else {
            s.skip_field("weatherTypeName")?;
        }
        if let Some(f) = self.weatherIconId() {
            s.serialize_field("weatherIconId", &f)?;
        } else {
            s.skip_field("weatherIconId")?;
        }
        if let Some(f) = self.functionDesc() {
            s.serialize_field("functionDesc", &f)?;
        } else {
            s.skip_field("functionDesc")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        if let Some(f) = self.buffId() {
            s.serialize_field("buffId", &f)?;
        } else {
            s.skip_field("buffId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2WeatherDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2WeatherDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_weatherId(&mut self, weatherId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2WeatherData::VT_WEATHERID,
            weatherId,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2WeatherData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_weatherLevel(&mut self, weatherLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2WeatherData::VT_WEATHERLEVEL,
            weatherLevel,
            0,
        );
    }
    #[inline]
    pub fn add_weatherType(&mut self, weatherType: enum__Torappu_SandboxV2WeatherType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2WeatherType>(
            clz_Torappu_SandboxV2WeatherData::VT_WEATHERTYPE,
            weatherType,
            enum__Torappu_SandboxV2WeatherType::NORMAL,
        );
    }
    #[inline]
    pub fn add_weatherTypeName(&mut self, weatherTypeName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2WeatherData::VT_WEATHERTYPENAME,
            weatherTypeName,
        );
    }
    #[inline]
    pub fn add_weatherIconId(&mut self, weatherIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2WeatherData::VT_WEATHERICONID,
            weatherIconId,
        );
    }
    #[inline]
    pub fn add_functionDesc(&mut self, functionDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2WeatherData::VT_FUNCTIONDESC,
            functionDesc,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2WeatherData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_buffId(&mut self, buffId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2WeatherData::VT_BUFFID,
            buffId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2WeatherDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2WeatherDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2WeatherData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2WeatherData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2WeatherData");
        ds.field("weatherId", &self.weatherId());
        ds.field("name", &self.name());
        ds.field("weatherLevel", &self.weatherLevel());
        ds.field("weatherType", &self.weatherType());
        ds.field("weatherTypeName", &self.weatherTypeName());
        ds.field("weatherIconId", &self.weatherIconId());
        ds.field("functionDesc", &self.functionDesc());
        ds.field("description", &self.description());
        ds.field("buffId", &self.buffId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2WeatherDataT {
    pub weatherId: Option<String>,
    pub name: Option<String>,
    pub weatherLevel: i32,
    pub weatherType: enum__Torappu_SandboxV2WeatherType,
    pub weatherTypeName: Option<String>,
    pub weatherIconId: Option<String>,
    pub functionDesc: Option<String>,
    pub description: Option<String>,
    pub buffId: Option<String>,
}
impl Default for clz_Torappu_SandboxV2WeatherDataT {
    fn default() -> Self {
        Self {
            weatherId: None,
            name: None,
            weatherLevel: 0,
            weatherType: enum__Torappu_SandboxV2WeatherType::NORMAL,
            weatherTypeName: None,
            weatherIconId: None,
            functionDesc: None,
            description: None,
            buffId: None,
        }
    }
}
impl clz_Torappu_SandboxV2WeatherDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2WeatherData<'b>> {
        let weatherId = self.weatherId.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let weatherLevel = self.weatherLevel;
        let weatherType = self.weatherType;
        let weatherTypeName = self.weatherTypeName.as_ref().map(|x| _fbb.create_string(x));
        let weatherIconId = self.weatherIconId.as_ref().map(|x| _fbb.create_string(x));
        let functionDesc = self.functionDesc.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let buffId = self.buffId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2WeatherData::create(
            _fbb,
            &clz_Torappu_SandboxV2WeatherDataArgs {
                weatherId,
                name,
                weatherLevel,
                weatherType,
                weatherTypeName,
                weatherIconId,
                functionDesc,
                description,
                buffId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2WeatherDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2WeatherData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2WeatherData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2WeatherData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2WeatherData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2WeatherData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2WeatherDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2WeatherData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2WeatherDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2WeatherDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2WeatherDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2WeatherData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2WeatherData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2WeatherData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2WeatherData>>(
                    dict__string__clz_Torappu_SandboxV2WeatherData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2WeatherData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2WeatherData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2WeatherDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2WeatherData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2WeatherDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2WeatherDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2WeatherData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2WeatherData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2WeatherDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2WeatherDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2WeatherData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2WeatherData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2WeatherData>>(
                dict__string__clz_Torappu_SandboxV2WeatherData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2WeatherDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2WeatherDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2WeatherData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2WeatherData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2WeatherData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2WeatherData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2WeatherDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2WeatherDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2WeatherDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2WeatherDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2WeatherData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2WeatherData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2WeatherDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2StageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2StageData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2StageData<'a> {
    type Inner = clz_Torappu_SandboxV2StageData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2StageData<'a> {
    pub const VT_STAGEID: flatbuffers::VOffsetT = 4;
    pub const VT_LEVELID: flatbuffers::VOffsetT = 6;
    pub const VT_CODE: flatbuffers::VOffsetT = 8;
    pub const VT_NAME: flatbuffers::VOffsetT = 10;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 12;
    pub const VT_ACTIONCOST: flatbuffers::VOffsetT = 14;
    pub const VT_ACTIONCOSTENEMYRUSH: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2StageData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2StageDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2StageData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2StageDataBuilder::new(_fbb);
        builder.add_actionCostEnemyRush(args.actionCostEnemyRush);
        builder.add_actionCost(args.actionCost);
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.code {
            builder.add_code(x);
        }
        if let Some(x) = args.levelId {
            builder.add_levelId(x);
        }
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2StageDataT {
        let stageId = self.stageId().map(|x| x.to_string());
        let levelId = self.levelId().map(|x| x.to_string());
        let code = self.code().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let actionCost = self.actionCost();
        let actionCostEnemyRush = self.actionCostEnemyRush();
        clz_Torappu_SandboxV2StageDataT {
            stageId,
            levelId,
            code,
            name,
            description,
            actionCost,
            actionCostEnemyRush,
        }
    }

    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2StageData::VT_STAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn levelId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2StageData::VT_LEVELID,
                None,
            )
        }
    }
    #[inline]
    pub fn code(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2StageData::VT_CODE,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2StageData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2StageData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn actionCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2StageData::VT_ACTIONCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn actionCostEnemyRush(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2StageData::VT_ACTIONCOSTENEMYRUSH,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2StageData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("levelId", Self::VT_LEVELID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("code", Self::VT_CODE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<i32>("actionCost", Self::VT_ACTIONCOST, false)?
            .visit_field::<i32>("actionCostEnemyRush", Self::VT_ACTIONCOSTENEMYRUSH, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2StageDataArgs<'a> {
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub levelId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub code: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub actionCost: i32,
    pub actionCostEnemyRush: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2StageDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2StageDataArgs {
            stageId: None,
            levelId: None,
            code: None,
            name: None,
            description: None,
            actionCost: 0,
            actionCostEnemyRush: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2StageData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2StageData", 7)?;
        if let Some(f) = self.stageId() {
            s.serialize_field("stageId", &f)?;
        } else {
            s.skip_field("stageId")?;
        }
        if let Some(f) = self.levelId() {
            s.serialize_field("levelId", &f)?;
        } else {
            s.skip_field("levelId")?;
        }
        if let Some(f) = self.code() {
            s.serialize_field("code", &f)?;
        } else {
            s.skip_field("code")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        s.serialize_field("actionCost", &self.actionCost())?;
        s.serialize_field("actionCostEnemyRush", &self.actionCostEnemyRush())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2StageDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2StageDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2StageData::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn add_levelId(&mut self, levelId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2StageData::VT_LEVELID,
            levelId,
        );
    }
    #[inline]
    pub fn add_code(&mut self, code: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2StageData::VT_CODE,
            code,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2StageData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2StageData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_actionCost(&mut self, actionCost: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2StageData::VT_ACTIONCOST, actionCost, 0);
    }
    #[inline]
    pub fn add_actionCostEnemyRush(&mut self, actionCostEnemyRush: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2StageData::VT_ACTIONCOSTENEMYRUSH,
            actionCostEnemyRush,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2StageDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2StageDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2StageData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2StageData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2StageData");
        ds.field("stageId", &self.stageId());
        ds.field("levelId", &self.levelId());
        ds.field("code", &self.code());
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.field("actionCost", &self.actionCost());
        ds.field("actionCostEnemyRush", &self.actionCostEnemyRush());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2StageDataT {
    pub stageId: Option<String>,
    pub levelId: Option<String>,
    pub code: Option<String>,
    pub name: Option<String>,
    pub description: Option<String>,
    pub actionCost: i32,
    pub actionCostEnemyRush: i32,
}
impl Default for clz_Torappu_SandboxV2StageDataT {
    fn default() -> Self {
        Self {
            stageId: None,
            levelId: None,
            code: None,
            name: None,
            description: None,
            actionCost: 0,
            actionCostEnemyRush: 0,
        }
    }
}
impl clz_Torappu_SandboxV2StageDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2StageData<'b>> {
        let stageId = self.stageId.as_ref().map(|x| _fbb.create_string(x));
        let levelId = self.levelId.as_ref().map(|x| _fbb.create_string(x));
        let code = self.code.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let actionCost = self.actionCost;
        let actionCostEnemyRush = self.actionCostEnemyRush;
        clz_Torappu_SandboxV2StageData::create(
            _fbb,
            &clz_Torappu_SandboxV2StageDataArgs {
                stageId,
                levelId,
                code,
                name,
                description,
                actionCost,
                actionCostEnemyRush,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2StageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2StageData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2StageData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2StageData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2StageData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2StageData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2StageDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2StageData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2StageDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2StageDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2StageDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2StageData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2StageData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2StageData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2StageData>>(
                    dict__string__clz_Torappu_SandboxV2StageData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2StageData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2StageData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2StageDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2StageData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2StageDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2StageDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2StageData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2StageData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2StageDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2StageDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2StageData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2StageData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2StageData>>(
                dict__string__clz_Torappu_SandboxV2StageData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2StageDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2StageDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2StageData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2StageData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2StageData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2StageData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2StageDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2StageDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2StageDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2StageDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2StageData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2StageData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2StageDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2ZoneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ZoneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ZoneData<'a> {
    type Inner = clz_Torappu_SandboxV2ZoneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ZoneData<'a> {
    pub const VT_ZONEID: flatbuffers::VOffsetT = 4;
    pub const VT_ZONENAME: flatbuffers::VOffsetT = 6;
    pub const VT_DISPLAYNAME: flatbuffers::VOffsetT = 8;
    pub const VT_APPELLATION: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ZoneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ZoneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ZoneData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ZoneDataBuilder::new(_fbb);
        if let Some(x) = args.appellation {
            builder.add_appellation(x);
        }
        if let Some(x) = args.zoneName {
            builder.add_zoneName(x);
        }
        if let Some(x) = args.zoneId {
            builder.add_zoneId(x);
        }
        builder.add_displayName(args.displayName);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2ZoneDataT {
        let zoneId = self.zoneId().map(|x| x.to_string());
        let zoneName = self.zoneName().map(|x| x.to_string());
        let displayName = self.displayName();
        let appellation = self.appellation().map(|x| x.to_string());
        clz_Torappu_SandboxV2ZoneDataT {
            zoneId,
            zoneName,
            displayName,
            appellation,
        }
    }

    #[inline]
    pub fn zoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ZoneData::VT_ZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn zoneName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ZoneData::VT_ZONENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn displayName(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_SandboxV2ZoneData::VT_DISPLAYNAME, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn appellation(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ZoneData::VT_APPELLATION,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ZoneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zoneId", Self::VT_ZONEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "zoneName",
                Self::VT_ZONENAME,
                false,
            )?
            .visit_field::<bool>("displayName", Self::VT_DISPLAYNAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "appellation",
                Self::VT_APPELLATION,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ZoneDataArgs<'a> {
    pub zoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub displayName: bool,
    pub appellation: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ZoneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ZoneDataArgs {
            zoneId: None,
            zoneName: None,
            displayName: false,
            appellation: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2ZoneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2ZoneData", 4)?;
        if let Some(f) = self.zoneId() {
            s.serialize_field("zoneId", &f)?;
        } else {
            s.skip_field("zoneId")?;
        }
        if let Some(f) = self.zoneName() {
            s.serialize_field("zoneName", &f)?;
        } else {
            s.skip_field("zoneName")?;
        }
        s.serialize_field("displayName", &self.displayName())?;
        if let Some(f) = self.appellation() {
            s.serialize_field("appellation", &f)?;
        } else {
            s.skip_field("appellation")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2ZoneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2ZoneDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_zoneId(&mut self, zoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ZoneData::VT_ZONEID,
            zoneId,
        );
    }
    #[inline]
    pub fn add_zoneName(&mut self, zoneName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ZoneData::VT_ZONENAME,
            zoneName,
        );
    }
    #[inline]
    pub fn add_displayName(&mut self, displayName: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SandboxV2ZoneData::VT_DISPLAYNAME,
            displayName,
            false,
        );
    }
    #[inline]
    pub fn add_appellation(&mut self, appellation: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ZoneData::VT_APPELLATION,
            appellation,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ZoneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ZoneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ZoneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ZoneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ZoneData");
        ds.field("zoneId", &self.zoneId());
        ds.field("zoneName", &self.zoneName());
        ds.field("displayName", &self.displayName());
        ds.field("appellation", &self.appellation());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2ZoneDataT {
    pub zoneId: Option<String>,
    pub zoneName: Option<String>,
    pub displayName: bool,
    pub appellation: Option<String>,
}
impl Default for clz_Torappu_SandboxV2ZoneDataT {
    fn default() -> Self {
        Self {
            zoneId: None,
            zoneName: None,
            displayName: false,
            appellation: None,
        }
    }
}
impl clz_Torappu_SandboxV2ZoneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ZoneData<'b>> {
        let zoneId = self.zoneId.as_ref().map(|x| _fbb.create_string(x));
        let zoneName = self.zoneName.as_ref().map(|x| _fbb.create_string(x));
        let displayName = self.displayName;
        let appellation = self.appellation.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2ZoneData::create(
            _fbb,
            &clz_Torappu_SandboxV2ZoneDataArgs {
                zoneId,
                zoneName,
                displayName,
                appellation,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ZoneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ZoneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2ZoneData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2ZoneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ZoneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ZoneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ZoneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ZoneData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2ZoneDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2ZoneDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2ZoneDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ZoneData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2ZoneData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ZoneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ZoneData>>(
                    dict__string__clz_Torappu_SandboxV2ZoneData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ZoneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ZoneData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ZoneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ZoneData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ZoneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ZoneDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2ZoneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2ZoneData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ZoneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ZoneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ZoneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ZoneData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ZoneData>>(
                dict__string__clz_Torappu_SandboxV2ZoneData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ZoneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ZoneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ZoneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ZoneData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ZoneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2ZoneData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2ZoneDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2ZoneDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2ZoneDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2ZoneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ZoneData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2ZoneData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2ZoneDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2NodeBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2NodeBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2NodeBuffData<'a> {
    type Inner = clz_Torappu_SandboxV2NodeBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2NodeBuffData<'a> {
    pub const VT_RUNEID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 8;
    pub const VT_EXTRA: flatbuffers::VOffsetT = 10;
    pub const VT_ICONID: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2NodeBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2NodeBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeBuffData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2NodeBuffDataBuilder::new(_fbb);
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.extra {
            builder.add_extra(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.runeId {
            builder.add_runeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2NodeBuffDataT {
        let runeId = self.runeId().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let extra = self.extra().map(|x| x.to_string());
        let iconId = self.iconId().map(|x| x.to_string());
        clz_Torappu_SandboxV2NodeBuffDataT {
            runeId,
            name,
            description,
            extra,
            iconId,
        }
    }

    #[inline]
    pub fn runeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeBuffData::VT_RUNEID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeBuffData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeBuffData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn extra(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeBuffData::VT_EXTRA,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NodeBuffData::VT_ICONID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2NodeBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("runeId", Self::VT_RUNEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("extra", Self::VT_EXTRA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2NodeBuffDataArgs<'a> {
    pub runeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub extra: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2NodeBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2NodeBuffDataArgs {
            runeId: None,
            name: None,
            description: None,
            extra: None,
            iconId: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2NodeBuffData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2NodeBuffData", 5)?;
        if let Some(f) = self.runeId() {
            s.serialize_field("runeId", &f)?;
        } else {
            s.skip_field("runeId")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        if let Some(f) = self.extra() {
            s.serialize_field("extra", &f)?;
        } else {
            s.skip_field("extra")?;
        }
        if let Some(f) = self.iconId() {
            s.serialize_field("iconId", &f)?;
        } else {
            s.skip_field("iconId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2NodeBuffDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2NodeBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_runeId(&mut self, runeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeBuffData::VT_RUNEID,
            runeId,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeBuffData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeBuffData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_extra(&mut self, extra: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeBuffData::VT_EXTRA,
            extra,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NodeBuffData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2NodeBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2NodeBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2NodeBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2NodeBuffData");
        ds.field("runeId", &self.runeId());
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.field("extra", &self.extra());
        ds.field("iconId", &self.iconId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2NodeBuffDataT {
    pub runeId: Option<String>,
    pub name: Option<String>,
    pub description: Option<String>,
    pub extra: Option<String>,
    pub iconId: Option<String>,
}
impl Default for clz_Torappu_SandboxV2NodeBuffDataT {
    fn default() -> Self {
        Self {
            runeId: None,
            name: None,
            description: None,
            extra: None,
            iconId: None,
        }
    }
}
impl clz_Torappu_SandboxV2NodeBuffDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeBuffData<'b>> {
        let runeId = self.runeId.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let extra = self.extra.as_ref().map(|x| _fbb.create_string(x));
        let iconId = self.iconId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2NodeBuffData::create(
            _fbb,
            &clz_Torappu_SandboxV2NodeBuffDataArgs {
                runeId,
                name,
                description,
                extra,
                iconId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2NodeBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2NodeBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2NodeBuffData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2NodeBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2NodeBuffData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2NodeBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2NodeBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NodeBuffData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2NodeBuffDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2NodeBuffDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2NodeBuffDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2NodeBuffData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2NodeBuffData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2NodeBuffData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2NodeBuffData>>(
                    dict__string__clz_Torappu_SandboxV2NodeBuffData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2NodeBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2NodeBuffData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2NodeBuffDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeBuffData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2NodeBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2NodeBuffDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2NodeBuffData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2NodeBuffData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2NodeBuffDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2NodeBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2NodeBuffData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeBuffData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2NodeBuffData>>(
                dict__string__clz_Torappu_SandboxV2NodeBuffData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2NodeBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2NodeBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NodeBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2NodeBuffData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2NodeBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2NodeBuffData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2NodeBuffDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2NodeBuffDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2NodeBuffDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2NodeBuffDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NodeBuffData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2NodeBuffData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2NodeBuffDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2RewardItemConfigDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RewardItemConfigData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RewardItemConfigData<'a> {
    type Inner = clz_Torappu_SandboxV2RewardItemConfigData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RewardItemConfigData<'a> {
    pub const VT_REWARDITEM: flatbuffers::VOffsetT = 4;
    pub const VT_REWARDTYPE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RewardItemConfigData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RewardItemConfigDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardItemConfigData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RewardItemConfigDataBuilder::new(_fbb);
        builder.add_rewardType(args.rewardType);
        if let Some(x) = args.rewardItem {
            builder.add_rewardItem(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2RewardItemConfigDataT {
        let rewardItem = self.rewardItem().map(|x| x.to_string());
        let rewardType = self.rewardType();
        clz_Torappu_SandboxV2RewardItemConfigDataT {
            rewardItem,
            rewardType,
        }
    }

    #[inline]
    pub fn rewardItem(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RewardItemConfigData::VT_REWARDITEM,
                None,
            )
        }
    }
    #[inline]
    pub fn rewardType(&self) -> enum__Torappu_SandboxPermItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxPermItemType>(
                    clz_Torappu_SandboxV2RewardItemConfigData::VT_REWARDTYPE,
                    Some(enum__Torappu_SandboxPermItemType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RewardItemConfigData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rewardItem",
                Self::VT_REWARDITEM,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxPermItemType>(
                "rewardType",
                Self::VT_REWARDTYPE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RewardItemConfigDataArgs<'a> {
    pub rewardItem: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewardType: enum__Torappu_SandboxPermItemType,
}
impl<'a> Default for clz_Torappu_SandboxV2RewardItemConfigDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RewardItemConfigDataArgs {
            rewardItem: None,
            rewardType: enum__Torappu_SandboxPermItemType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2RewardItemConfigData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2RewardItemConfigData", 2)?;
        if let Some(f) = self.rewardItem() {
            s.serialize_field("rewardItem", &f)?;
        } else {
            s.skip_field("rewardItem")?;
        }
        s.serialize_field("rewardType", &self.rewardType())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2RewardItemConfigDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RewardItemConfigDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_rewardItem(&mut self, rewardItem: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RewardItemConfigData::VT_REWARDITEM,
            rewardItem,
        );
    }
    #[inline]
    pub fn add_rewardType(&mut self, rewardType: enum__Torappu_SandboxPermItemType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxPermItemType>(
            clz_Torappu_SandboxV2RewardItemConfigData::VT_REWARDTYPE,
            rewardType,
            enum__Torappu_SandboxPermItemType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RewardItemConfigDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RewardItemConfigDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardItemConfigData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RewardItemConfigData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RewardItemConfigData");
        ds.field("rewardItem", &self.rewardItem());
        ds.field("rewardType", &self.rewardType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2RewardItemConfigDataT {
    pub rewardItem: Option<String>,
    pub rewardType: enum__Torappu_SandboxPermItemType,
}
impl Default for clz_Torappu_SandboxV2RewardItemConfigDataT {
    fn default() -> Self {
        Self {
            rewardItem: None,
            rewardType: enum__Torappu_SandboxPermItemType::NONE,
        }
    }
}
impl clz_Torappu_SandboxV2RewardItemConfigDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardItemConfigData<'b>> {
        let rewardItem = self.rewardItem.as_ref().map(|x| _fbb.create_string(x));
        let rewardType = self.rewardType;
        clz_Torappu_SandboxV2RewardItemConfigData::create(
            _fbb,
            &clz_Torappu_SandboxV2RewardItemConfigDataArgs {
                rewardItem,
                rewardType,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2RewardDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RewardData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RewardData<'a> {
    type Inner = clz_Torappu_SandboxV2RewardData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RewardData<'a> {
    pub const VT_REWARDLIST: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RewardData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RewardDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RewardDataBuilder::new(_fbb);
        if let Some(x) = args.rewardList {
            builder.add_rewardList(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2RewardDataT {
        let rewardList = self
            .rewardList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_SandboxV2RewardDataT { rewardList }
    }

    #[inline]
    pub fn rewardList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RewardItemConfigData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RewardItemConfigData>,
                >,
            >>(clz_Torappu_SandboxV2RewardData::VT_REWARDLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RewardData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RewardItemConfigData>,
                >,
            >>("rewardList", Self::VT_REWARDLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RewardDataArgs<'a> {
    pub rewardList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RewardItemConfigData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2RewardDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RewardDataArgs { rewardList: None }
    }
}

impl Serialize for clz_Torappu_SandboxV2RewardData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2RewardData", 1)?;
        if let Some(f) = self.rewardList() {
            s.serialize_field("rewardList", &f)?;
        } else {
            s.skip_field("rewardList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2RewardDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2RewardDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_rewardList(
        &mut self,
        rewardList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RewardItemConfigData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RewardData::VT_REWARDLIST,
            rewardList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RewardDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RewardDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RewardData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RewardData");
        ds.field("rewardList", &self.rewardList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2RewardDataT {
    pub rewardList: Option<Vec<clz_Torappu_SandboxV2RewardItemConfigDataT>>,
}
impl Default for clz_Torappu_SandboxV2RewardDataT {
    fn default() -> Self {
        Self { rewardList: None }
    }
}
impl clz_Torappu_SandboxV2RewardDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardData<'b>> {
        let rewardList = self.rewardList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SandboxV2RewardData::create(
            _fbb,
            &clz_Torappu_SandboxV2RewardDataArgs { rewardList },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RewardDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RewardData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RewardData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RewardData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RewardData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RewardData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RewardDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RewardData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2RewardDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2RewardDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2RewardDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RewardData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2RewardData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RewardData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RewardData>>(
                    dict__string__clz_Torappu_SandboxV2RewardData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RewardData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RewardData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RewardDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RewardDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RewardDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2RewardData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2RewardData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RewardDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RewardDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RewardData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardData>>(
                dict__string__clz_Torappu_SandboxV2RewardData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RewardDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RewardDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RewardData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RewardData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RewardData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RewardData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2RewardDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2RewardDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2RewardDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2RewardDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RewardData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2RewardData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2RewardDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2RewardCommonConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RewardCommonConfig<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RewardCommonConfig<'a> {
    type Inner = clz_Torappu_SandboxV2RewardCommonConfig<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RewardCommonConfig<'a> {
    pub const VT_REWARDITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_REWARDITEMTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_COUNT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RewardCommonConfig { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RewardCommonConfigArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardCommonConfig<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RewardCommonConfigBuilder::new(_fbb);
        builder.add_count(args.count);
        builder.add_rewardItemType(args.rewardItemType);
        if let Some(x) = args.rewardItemId {
            builder.add_rewardItemId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2RewardCommonConfigT {
        let rewardItemId = self.rewardItemId().map(|x| x.to_string());
        let rewardItemType = self.rewardItemType();
        let count = self.count();
        clz_Torappu_SandboxV2RewardCommonConfigT {
            rewardItemId,
            rewardItemType,
            count,
        }
    }

    #[inline]
    pub fn rewardItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RewardCommonConfig::VT_REWARDITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn rewardItemType(&self) -> enum__Torappu_SandboxPermItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxPermItemType>(
                    clz_Torappu_SandboxV2RewardCommonConfig::VT_REWARDITEMTYPE,
                    Some(enum__Torappu_SandboxPermItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2RewardCommonConfig::VT_COUNT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RewardCommonConfig<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rewardItemId",
                Self::VT_REWARDITEMID,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxPermItemType>(
                "rewardItemType",
                Self::VT_REWARDITEMTYPE,
                false,
            )?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RewardCommonConfigArgs<'a> {
    pub rewardItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewardItemType: enum__Torappu_SandboxPermItemType,
    pub count: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2RewardCommonConfigArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RewardCommonConfigArgs {
            rewardItemId: None,
            rewardItemType: enum__Torappu_SandboxPermItemType::NONE,
            count: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2RewardCommonConfig<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2RewardCommonConfig", 3)?;
        if let Some(f) = self.rewardItemId() {
            s.serialize_field("rewardItemId", &f)?;
        } else {
            s.skip_field("rewardItemId")?;
        }
        s.serialize_field("rewardItemType", &self.rewardItemType())?;
        s.serialize_field("count", &self.count())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2RewardCommonConfigBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RewardCommonConfigBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_rewardItemId(&mut self, rewardItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RewardCommonConfig::VT_REWARDITEMID,
            rewardItemId,
        );
    }
    #[inline]
    pub fn add_rewardItemType(&mut self, rewardItemType: enum__Torappu_SandboxPermItemType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxPermItemType>(
            clz_Torappu_SandboxV2RewardCommonConfig::VT_REWARDITEMTYPE,
            rewardItemType,
            enum__Torappu_SandboxPermItemType::NONE,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2RewardCommonConfig::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RewardCommonConfigBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RewardCommonConfigBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardCommonConfig<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RewardCommonConfig<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RewardCommonConfig");
        ds.field("rewardItemId", &self.rewardItemId());
        ds.field("rewardItemType", &self.rewardItemType());
        ds.field("count", &self.count());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2RewardCommonConfigT {
    pub rewardItemId: Option<String>,
    pub rewardItemType: enum__Torappu_SandboxPermItemType,
    pub count: i32,
}
impl Default for clz_Torappu_SandboxV2RewardCommonConfigT {
    fn default() -> Self {
        Self {
            rewardItemId: None,
            rewardItemType: enum__Torappu_SandboxPermItemType::NONE,
            count: 0,
        }
    }
}
impl clz_Torappu_SandboxV2RewardCommonConfigT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardCommonConfig<'b>> {
        let rewardItemId = self.rewardItemId.as_ref().map(|x| _fbb.create_string(x));
        let rewardItemType = self.rewardItemType;
        let count = self.count;
        clz_Torappu_SandboxV2RewardCommonConfig::create(
            _fbb,
            &clz_Torappu_SandboxV2RewardCommonConfigArgs {
                rewardItemId,
                rewardItemType,
                count,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RewardCommonConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RewardCommonConfig { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RewardCommonConfigArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2RewardCommonConfigBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2RewardCommonConfigT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2RewardCommonConfigT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RewardCommonConfig::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2RewardCommonConfig,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RewardCommonConfig<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RewardCommonConfig>>(
                    dict__string__clz_Torappu_SandboxV2RewardCommonConfig::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RewardCommonConfig>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RewardCommonConfigArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardCommonConfig<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RewardCommonConfigArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RewardCommonConfigArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_SandboxV2RewardCommonConfig", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RewardCommonConfigBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RewardCommonConfigBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RewardCommonConfig::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardCommonConfig<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardCommonConfig>>(
                dict__string__clz_Torappu_SandboxV2RewardCommonConfig::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RewardCommonConfigBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RewardCommonConfigBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RewardCommonConfig::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RewardCommonConfig");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2RewardCommonConfigT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2RewardCommonConfigT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2RewardCommonConfigT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2RewardCommonConfigT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2RewardCommonConfig::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2RewardCommonConfigArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2RewardConfigGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RewardConfigGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RewardConfigGroupData<'a> {
    type Inner = clz_Torappu_SandboxV2RewardConfigGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RewardConfigGroupData<'a> {
    pub const VT_STAGEMAPPREVIEWREWARDDICT: flatbuffers::VOffsetT = 4;
    pub const VT_STAGEDETAILPREVIEWREWARDDICT: flatbuffers::VOffsetT = 6;
    pub const VT_TRAPREWARDDICT: flatbuffers::VOffsetT = 8;
    pub const VT_ENEMYREWARDDICT: flatbuffers::VOffsetT = 10;
    pub const VT_UNITPREVIEWREWARDDICT: flatbuffers::VOffsetT = 12;
    pub const VT_STAGEREWARDDICT: flatbuffers::VOffsetT = 14;
    pub const VT_RUSHPREVIEWREWARDDICT: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RewardConfigGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RewardConfigGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardConfigGroupData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RewardConfigGroupDataBuilder::new(_fbb);
        if let Some(x) = args.rushPreviewRewardDict {
            builder.add_rushPreviewRewardDict(x);
        }
        if let Some(x) = args.stageRewardDict {
            builder.add_stageRewardDict(x);
        }
        if let Some(x) = args.unitPreviewRewardDict {
            builder.add_unitPreviewRewardDict(x);
        }
        if let Some(x) = args.enemyRewardDict {
            builder.add_enemyRewardDict(x);
        }
        if let Some(x) = args.trapRewardDict {
            builder.add_trapRewardDict(x);
        }
        if let Some(x) = args.stageDetailPreviewRewardDict {
            builder.add_stageDetailPreviewRewardDict(x);
        }
        if let Some(x) = args.stageMapPreviewRewardDict {
            builder.add_stageMapPreviewRewardDict(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2RewardConfigGroupDataT {
        let stageMapPreviewRewardDict = self
            .stageMapPreviewRewardDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let stageDetailPreviewRewardDict = self
            .stageDetailPreviewRewardDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let trapRewardDict = self
            .trapRewardDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let enemyRewardDict = self
            .enemyRewardDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let unitPreviewRewardDict = self
            .unitPreviewRewardDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let stageRewardDict = self
            .stageRewardDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let rushPreviewRewardDict = self
            .rushPreviewRewardDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_SandboxV2RewardConfigGroupDataT {
            stageMapPreviewRewardDict,
            stageDetailPreviewRewardDict,
            trapRewardDict,
            enemyRewardDict,
            unitPreviewRewardDict,
            stageRewardDict,
            rushPreviewRewardDict,
        }
    }

    #[inline]
    pub fn stageMapPreviewRewardDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData>,
                >,
            >>(
                clz_Torappu_SandboxV2RewardConfigGroupData::VT_STAGEMAPPREVIEWREWARDDICT,
                None,
            )
        }
    }
    #[inline]
    pub fn stageDetailPreviewRewardDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData>,
                >,
            >>(
                clz_Torappu_SandboxV2RewardConfigGroupData::VT_STAGEDETAILPREVIEWREWARDDICT,
                None,
            )
        }
    }
    #[inline]
    pub fn trapRewardDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2RewardCommonConfig,
                    >,
                >,
            >>(
                clz_Torappu_SandboxV2RewardConfigGroupData::VT_TRAPREWARDDICT,
                None,
            )
        }
    }
    #[inline]
    pub fn enemyRewardDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2RewardCommonConfig,
                    >,
                >,
            >>(
                clz_Torappu_SandboxV2RewardConfigGroupData::VT_ENEMYREWARDDICT,
                None,
            )
        }
    }
    #[inline]
    pub fn unitPreviewRewardDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData>,
                >,
            >>(
                clz_Torappu_SandboxV2RewardConfigGroupData::VT_UNITPREVIEWREWARDDICT,
                None,
            )
        }
    }
    #[inline]
    pub fn stageRewardDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData>,
                >,
            >>(
                clz_Torappu_SandboxV2RewardConfigGroupData::VT_STAGEREWARDDICT,
                None,
            )
        }
    }
    #[inline]
    pub fn rushPreviewRewardDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData>,
                >,
            >>(
                clz_Torappu_SandboxV2RewardConfigGroupData::VT_RUSHPREVIEWREWARDDICT,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RewardConfigGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData>,
                >,
            >>(
                "stageMapPreviewRewardDict",
                Self::VT_STAGEMAPPREVIEWREWARDDICT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData>,
                >,
            >>(
                "stageDetailPreviewRewardDict",
                Self::VT_STAGEDETAILPREVIEWREWARDDICT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2RewardCommonConfig,
                    >,
                >,
            >>("trapRewardDict", Self::VT_TRAPREWARDDICT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2RewardCommonConfig,
                    >,
                >,
            >>("enemyRewardDict", Self::VT_ENEMYREWARDDICT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData>,
                >,
            >>(
                "unitPreviewRewardDict",
                Self::VT_UNITPREVIEWREWARDDICT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData>,
                >,
            >>("stageRewardDict", Self::VT_STAGEREWARDDICT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData>,
                >,
            >>(
                "rushPreviewRewardDict",
                Self::VT_RUSHPREVIEWREWARDDICT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RewardConfigGroupDataArgs<'a> {
    pub stageMapPreviewRewardDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'a>>,
            >,
        >,
    >,
    pub stageDetailPreviewRewardDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'a>>,
            >,
        >,
    >,
    pub trapRewardDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'a>,
                >,
            >,
        >,
    >,
    pub enemyRewardDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'a>,
                >,
            >,
        >,
    >,
    pub unitPreviewRewardDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'a>>,
            >,
        >,
    >,
    pub stageRewardDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'a>>,
            >,
        >,
    >,
    pub rushPreviewRewardDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2RewardConfigGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RewardConfigGroupDataArgs {
            stageMapPreviewRewardDict: None,
            stageDetailPreviewRewardDict: None,
            trapRewardDict: None,
            enemyRewardDict: None,
            unitPreviewRewardDict: None,
            stageRewardDict: None,
            rushPreviewRewardDict: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2RewardConfigGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2RewardConfigGroupData", 7)?;
        if let Some(f) = self.stageMapPreviewRewardDict() {
            s.serialize_field("stageMapPreviewRewardDict", &f)?;
        } else {
            s.skip_field("stageMapPreviewRewardDict")?;
        }
        if let Some(f) = self.stageDetailPreviewRewardDict() {
            s.serialize_field("stageDetailPreviewRewardDict", &f)?;
        } else {
            s.skip_field("stageDetailPreviewRewardDict")?;
        }
        if let Some(f) = self.trapRewardDict() {
            s.serialize_field("trapRewardDict", &f)?;
        } else {
            s.skip_field("trapRewardDict")?;
        }
        if let Some(f) = self.enemyRewardDict() {
            s.serialize_field("enemyRewardDict", &f)?;
        } else {
            s.skip_field("enemyRewardDict")?;
        }
        if let Some(f) = self.unitPreviewRewardDict() {
            s.serialize_field("unitPreviewRewardDict", &f)?;
        } else {
            s.skip_field("unitPreviewRewardDict")?;
        }
        if let Some(f) = self.stageRewardDict() {
            s.serialize_field("stageRewardDict", &f)?;
        } else {
            s.skip_field("stageRewardDict")?;
        }
        if let Some(f) = self.rushPreviewRewardDict() {
            s.serialize_field("rushPreviewRewardDict", &f)?;
        } else {
            s.skip_field("rushPreviewRewardDict")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2RewardConfigGroupDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RewardConfigGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_stageMapPreviewRewardDict(
        &mut self,
        stageMapPreviewRewardDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RewardConfigGroupData::VT_STAGEMAPPREVIEWREWARDDICT,
            stageMapPreviewRewardDict,
        );
    }
    #[inline]
    pub fn add_stageDetailPreviewRewardDict(
        &mut self,
        stageDetailPreviewRewardDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RewardConfigGroupData::VT_STAGEDETAILPREVIEWREWARDDICT,
            stageDetailPreviewRewardDict,
        );
    }
    #[inline]
    pub fn add_trapRewardDict(
        &mut self,
        trapRewardDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RewardConfigGroupData::VT_TRAPREWARDDICT,
            trapRewardDict,
        );
    }
    #[inline]
    pub fn add_enemyRewardDict(
        &mut self,
        enemyRewardDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RewardCommonConfig<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RewardConfigGroupData::VT_ENEMYREWARDDICT,
            enemyRewardDict,
        );
    }
    #[inline]
    pub fn add_unitPreviewRewardDict(
        &mut self,
        unitPreviewRewardDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RewardConfigGroupData::VT_UNITPREVIEWREWARDDICT,
            unitPreviewRewardDict,
        );
    }
    #[inline]
    pub fn add_stageRewardDict(
        &mut self,
        stageRewardDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RewardConfigGroupData::VT_STAGEREWARDDICT,
            stageRewardDict,
        );
    }
    #[inline]
    pub fn add_rushPreviewRewardDict(
        &mut self,
        rushPreviewRewardDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RewardData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RewardConfigGroupData::VT_RUSHPREVIEWREWARDDICT,
            rushPreviewRewardDict,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RewardConfigGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RewardConfigGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardConfigGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RewardConfigGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RewardConfigGroupData");
        ds.field(
            "stageMapPreviewRewardDict",
            &self.stageMapPreviewRewardDict(),
        );
        ds.field(
            "stageDetailPreviewRewardDict",
            &self.stageDetailPreviewRewardDict(),
        );
        ds.field("trapRewardDict", &self.trapRewardDict());
        ds.field("enemyRewardDict", &self.enemyRewardDict());
        ds.field("unitPreviewRewardDict", &self.unitPreviewRewardDict());
        ds.field("stageRewardDict", &self.stageRewardDict());
        ds.field("rushPreviewRewardDict", &self.rushPreviewRewardDict());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2RewardConfigGroupDataT {
    pub stageMapPreviewRewardDict: Option<Vec<dict__string__clz_Torappu_SandboxV2RewardDataT>>,
    pub stageDetailPreviewRewardDict: Option<Vec<dict__string__clz_Torappu_SandboxV2RewardDataT>>,
    pub trapRewardDict: Option<Vec<dict__string__clz_Torappu_SandboxV2RewardCommonConfigT>>,
    pub enemyRewardDict: Option<Vec<dict__string__clz_Torappu_SandboxV2RewardCommonConfigT>>,
    pub unitPreviewRewardDict: Option<Vec<dict__string__clz_Torappu_SandboxV2RewardDataT>>,
    pub stageRewardDict: Option<Vec<dict__string__clz_Torappu_SandboxV2RewardDataT>>,
    pub rushPreviewRewardDict: Option<Vec<dict__string__clz_Torappu_SandboxV2RewardDataT>>,
}
impl Default for clz_Torappu_SandboxV2RewardConfigGroupDataT {
    fn default() -> Self {
        Self {
            stageMapPreviewRewardDict: None,
            stageDetailPreviewRewardDict: None,
            trapRewardDict: None,
            enemyRewardDict: None,
            unitPreviewRewardDict: None,
            stageRewardDict: None,
            rushPreviewRewardDict: None,
        }
    }
}
impl clz_Torappu_SandboxV2RewardConfigGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardConfigGroupData<'b>> {
        let stageMapPreviewRewardDict = self.stageMapPreviewRewardDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let stageDetailPreviewRewardDict = self.stageDetailPreviewRewardDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let trapRewardDict = self.trapRewardDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let enemyRewardDict = self.enemyRewardDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let unitPreviewRewardDict = self.unitPreviewRewardDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let stageRewardDict = self.stageRewardDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let rushPreviewRewardDict = self.rushPreviewRewardDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SandboxV2RewardConfigGroupData::create(
            _fbb,
            &clz_Torappu_SandboxV2RewardConfigGroupDataArgs {
                stageMapPreviewRewardDict,
                stageDetailPreviewRewardDict,
                trapRewardDict,
                enemyRewardDict,
                unitPreviewRewardDict,
                stageRewardDict,
                rushPreviewRewardDict,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2FloatIconDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2FloatIconData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2FloatIconData<'a> {
    type Inner = clz_Torappu_SandboxV2FloatIconData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2FloatIconData<'a> {
    pub const VT_PICID: flatbuffers::VOffsetT = 4;
    pub const VT_PICNAME: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2FloatIconData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2FloatIconDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FloatIconData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2FloatIconDataBuilder::new(_fbb);
        if let Some(x) = args.picName {
            builder.add_picName(x);
        }
        if let Some(x) = args.picId {
            builder.add_picId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2FloatIconDataT {
        let picId = self.picId().map(|x| x.to_string());
        let picName = self.picName().map(|x| x.to_string());
        clz_Torappu_SandboxV2FloatIconDataT { picId, picName }
    }

    #[inline]
    pub fn picId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2FloatIconData::VT_PICID,
                None,
            )
        }
    }
    #[inline]
    pub fn picName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2FloatIconData::VT_PICNAME,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2FloatIconData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("picId", Self::VT_PICID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("picName", Self::VT_PICNAME, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2FloatIconDataArgs<'a> {
    pub picId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub picName: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2FloatIconDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2FloatIconDataArgs {
            picId: None,
            picName: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2FloatIconData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2FloatIconData", 2)?;
        if let Some(f) = self.picId() {
            s.serialize_field("picId", &f)?;
        } else {
            s.skip_field("picId")?;
        }
        if let Some(f) = self.picName() {
            s.serialize_field("picName", &f)?;
        } else {
            s.skip_field("picName")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2FloatIconDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2FloatIconDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_picId(&mut self, picId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FloatIconData::VT_PICID,
            picId,
        );
    }
    #[inline]
    pub fn add_picName(&mut self, picName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FloatIconData::VT_PICNAME,
            picName,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2FloatIconDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2FloatIconDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FloatIconData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2FloatIconData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2FloatIconData");
        ds.field("picId", &self.picId());
        ds.field("picName", &self.picName());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2FloatIconDataT {
    pub picId: Option<String>,
    pub picName: Option<String>,
}
impl Default for clz_Torappu_SandboxV2FloatIconDataT {
    fn default() -> Self {
        Self {
            picId: None,
            picName: None,
        }
    }
}
impl clz_Torappu_SandboxV2FloatIconDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FloatIconData<'b>> {
        let picId = self.picId.as_ref().map(|x| _fbb.create_string(x));
        let picName = self.picName.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2FloatIconData::create(
            _fbb,
            &clz_Torappu_SandboxV2FloatIconDataArgs { picId, picName },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2FloatIconDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2FloatIconData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2FloatIconData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2FloatIconData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2FloatIconData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2FloatIconData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2FloatIconDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2FloatIconData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2FloatIconDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2FloatIconDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2FloatIconDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2FloatIconData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2FloatIconData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2FloatIconData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FloatIconData>>(
                    dict__string__clz_Torappu_SandboxV2FloatIconData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2FloatIconData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FloatIconData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2FloatIconDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2FloatIconData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2FloatIconDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2FloatIconDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2FloatIconData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2FloatIconData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2FloatIconDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2FloatIconDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2FloatIconData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2FloatIconData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2FloatIconData>>(
                dict__string__clz_Torappu_SandboxV2FloatIconData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2FloatIconDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2FloatIconDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2FloatIconData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2FloatIconData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2FloatIconData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2FloatIconData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2FloatIconDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2FloatIconDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2FloatIconDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2FloatIconDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2FloatIconData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2FloatIconData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2FloatIconDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2EnemyRushTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2EnemyRushTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2EnemyRushTypeData<'a> {
    type Inner = clz_Torappu_SandboxV2EnemyRushTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2EnemyRushTypeData<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
    pub const VT_SORTID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2EnemyRushTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2EnemyRushTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EnemyRushTypeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2EnemyRushTypeDataBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2EnemyRushTypeDataT {
        let type_ = self.type_();
        let description = self.description().map(|x| x.to_string());
        let sortId = self.sortId();
        clz_Torappu_SandboxV2EnemyRushTypeDataT {
            type_,
            description,
            sortId,
        }
    }

    #[inline]
    pub fn type_(&self) -> enum__Torappu_SandboxV2EnemyRushType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2EnemyRushType>(
                    clz_Torappu_SandboxV2EnemyRushTypeData::VT_TYPE_,
                    Some(enum__Torappu_SandboxV2EnemyRushType::NORMAL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EnemyRushTypeData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2EnemyRushTypeData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2EnemyRushTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxV2EnemyRushType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2EnemyRushTypeDataArgs<'a> {
    pub type_: enum__Torappu_SandboxV2EnemyRushType,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2EnemyRushTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2EnemyRushTypeDataArgs {
            type_: enum__Torappu_SandboxV2EnemyRushType::NORMAL,
            description: None,
            sortId: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2EnemyRushTypeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2EnemyRushTypeData", 3)?;
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2EnemyRushTypeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2EnemyRushTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_SandboxV2EnemyRushType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2EnemyRushType>(
            clz_Torappu_SandboxV2EnemyRushTypeData::VT_TYPE_,
            type_,
            enum__Torappu_SandboxV2EnemyRushType::NORMAL,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EnemyRushTypeData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2EnemyRushTypeData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2EnemyRushTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2EnemyRushTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EnemyRushTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2EnemyRushTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2EnemyRushTypeData");
        ds.field("type_", &self.type_());
        ds.field("description", &self.description());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2EnemyRushTypeDataT {
    pub type_: enum__Torappu_SandboxV2EnemyRushType,
    pub description: Option<String>,
    pub sortId: i32,
}
impl Default for clz_Torappu_SandboxV2EnemyRushTypeDataT {
    fn default() -> Self {
        Self {
            type_: enum__Torappu_SandboxV2EnemyRushType::NORMAL,
            description: None,
            sortId: 0,
        }
    }
}
impl clz_Torappu_SandboxV2EnemyRushTypeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EnemyRushTypeData<'b>> {
        let type_ = self.type_;
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        clz_Torappu_SandboxV2EnemyRushTypeData::create(
            _fbb,
            &clz_Torappu_SandboxV2EnemyRushTypeDataArgs {
                type_,
                description,
                sortId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2EnemyRushTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2EnemyRushTypeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2EnemyRushTypeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2EnemyRushTypeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2EnemyRushTypeData>>(
                    dict__string__clz_Torappu_SandboxV2EnemyRushTypeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2EnemyRushTypeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2EnemyRushTypeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_SandboxV2EnemyRushTypeData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2EnemyRushTypeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2EnemyRushTypeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2EnemyRushTypeData>>(
                dict__string__clz_Torappu_SandboxV2EnemyRushTypeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2EnemyRushTypeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2EnemyRushTypeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2EnemyRushTypeDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2EnemyRushTypeData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2BattleRushEnemyConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2BattleRushEnemyConfig<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2BattleRushEnemyConfig<'a> {
    type Inner = clz_Torappu_SandboxV2BattleRushEnemyConfig<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2BattleRushEnemyConfig<'a> {
    pub const VT_ENEMYKEY: flatbuffers::VOffsetT = 4;
    pub const VT_BRANCHID: flatbuffers::VOffsetT = 6;
    pub const VT_COUNT: flatbuffers::VOffsetT = 8;
    pub const VT_INTERVAL: flatbuffers::VOffsetT = 10;
    pub const VT_PREDELAY: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2BattleRushEnemyConfig { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2BattleRushEnemyConfigArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyConfig<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2BattleRushEnemyConfigBuilder::new(_fbb);
        builder.add_preDelay(args.preDelay);
        builder.add_interval(args.interval);
        builder.add_count(args.count);
        if let Some(x) = args.branchId {
            builder.add_branchId(x);
        }
        if let Some(x) = args.enemyKey {
            builder.add_enemyKey(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2BattleRushEnemyConfigT {
        let enemyKey = self.enemyKey().map(|x| x.to_string());
        let branchId = self.branchId().map(|x| x.to_string());
        let count = self.count();
        let interval = self.interval();
        let preDelay = self.preDelay();
        clz_Torappu_SandboxV2BattleRushEnemyConfigT {
            enemyKey,
            branchId,
            count,
            interval,
            preDelay,
        }
    }

    #[inline]
    pub fn enemyKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BattleRushEnemyConfig::VT_ENEMYKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn branchId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BattleRushEnemyConfig::VT_BRANCHID,
                None,
            )
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BattleRushEnemyConfig::VT_COUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn interval(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2BattleRushEnemyConfig::VT_INTERVAL,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn preDelay(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2BattleRushEnemyConfig::VT_PREDELAY,
                    Some(0.0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2BattleRushEnemyConfig<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enemyKey",
                Self::VT_ENEMYKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "branchId",
                Self::VT_BRANCHID,
                false,
            )?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<f32>("interval", Self::VT_INTERVAL, false)?
            .visit_field::<f32>("preDelay", Self::VT_PREDELAY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2BattleRushEnemyConfigArgs<'a> {
    pub enemyKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub branchId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
    pub interval: f32,
    pub preDelay: f32,
}
impl<'a> Default for clz_Torappu_SandboxV2BattleRushEnemyConfigArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2BattleRushEnemyConfigArgs {
            enemyKey: None,
            branchId: None,
            count: 0,
            interval: 0.0,
            preDelay: 0.0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2BattleRushEnemyConfig<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2BattleRushEnemyConfig", 5)?;
        if let Some(f) = self.enemyKey() {
            s.serialize_field("enemyKey", &f)?;
        } else {
            s.skip_field("enemyKey")?;
        }
        if let Some(f) = self.branchId() {
            s.serialize_field("branchId", &f)?;
        } else {
            s.skip_field("branchId")?;
        }
        s.serialize_field("count", &self.count())?;
        s.serialize_field("interval", &self.interval())?;
        s.serialize_field("preDelay", &self.preDelay())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2BattleRushEnemyConfigBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2BattleRushEnemyConfigBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_enemyKey(&mut self, enemyKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BattleRushEnemyConfig::VT_ENEMYKEY,
            enemyKey,
        );
    }
    #[inline]
    pub fn add_branchId(&mut self, branchId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BattleRushEnemyConfig::VT_BRANCHID,
            branchId,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BattleRushEnemyConfig::VT_COUNT,
            count,
            0,
        );
    }
    #[inline]
    pub fn add_interval(&mut self, interval: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2BattleRushEnemyConfig::VT_INTERVAL,
            interval,
            0.0,
        );
    }
    #[inline]
    pub fn add_preDelay(&mut self, preDelay: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2BattleRushEnemyConfig::VT_PREDELAY,
            preDelay,
            0.0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2BattleRushEnemyConfigBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2BattleRushEnemyConfigBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyConfig<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2BattleRushEnemyConfig<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2BattleRushEnemyConfig");
        ds.field("enemyKey", &self.enemyKey());
        ds.field("branchId", &self.branchId());
        ds.field("count", &self.count());
        ds.field("interval", &self.interval());
        ds.field("preDelay", &self.preDelay());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2BattleRushEnemyConfigT {
    pub enemyKey: Option<String>,
    pub branchId: Option<String>,
    pub count: i32,
    pub interval: f32,
    pub preDelay: f32,
}
impl Default for clz_Torappu_SandboxV2BattleRushEnemyConfigT {
    fn default() -> Self {
        Self {
            enemyKey: None,
            branchId: None,
            count: 0,
            interval: 0.0,
            preDelay: 0.0,
        }
    }
}
impl clz_Torappu_SandboxV2BattleRushEnemyConfigT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyConfig<'b>> {
        let enemyKey = self.enemyKey.as_ref().map(|x| _fbb.create_string(x));
        let branchId = self.branchId.as_ref().map(|x| _fbb.create_string(x));
        let count = self.count;
        let interval = self.interval;
        let preDelay = self.preDelay;
        clz_Torappu_SandboxV2BattleRushEnemyConfig::create(
            _fbb,
            &clz_Torappu_SandboxV2BattleRushEnemyConfigArgs {
                enemyKey,
                branchId,
                count,
                interval,
                preDelay,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2BattleRushEnemyGroupConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a> {
    type Inner = clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a> {
    pub const VT_ENEMYGROUPKEY: flatbuffers::VOffsetT = 4;
    pub const VT_ENEMY: flatbuffers::VOffsetT = 6;
    pub const VT_DYNAMICENEMY: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2BattleRushEnemyGroupConfig { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2BattleRushEnemyGroupConfigArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2BattleRushEnemyGroupConfigBuilder::new(_fbb);
        if let Some(x) = args.dynamicEnemy {
            builder.add_dynamicEnemy(x);
        }
        if let Some(x) = args.enemy {
            builder.add_enemy(x);
        }
        if let Some(x) = args.enemyGroupKey {
            builder.add_enemyGroupKey(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2BattleRushEnemyGroupConfigT {
        let enemyGroupKey = self.enemyGroupKey().map(|x| x.to_string());
        let enemy = self.enemy().map(|x| x.iter().map(|t| t.unpack()).collect());
        let dynamicEnemy = self
            .dynamicEnemy()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_SandboxV2BattleRushEnemyGroupConfigT {
            enemyGroupKey,
            enemy,
            dynamicEnemy,
        }
    }

    #[inline]
    pub fn enemyGroupKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BattleRushEnemyGroupConfig::VT_ENEMYGROUPKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn enemy(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyConfig<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyConfig>,
                >,
            >>(
                clz_Torappu_SandboxV2BattleRushEnemyGroupConfig::VT_ENEMY,
                None,
            )
        }
    }
    #[inline]
    pub fn dynamicEnemy(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2BattleRushEnemyGroupConfig::VT_DYNAMICENEMY,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enemyGroupKey",
                Self::VT_ENEMYGROUPKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyConfig>,
                >,
            >>("enemy", Self::VT_ENEMY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("dynamicEnemy", Self::VT_DYNAMICENEMY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2BattleRushEnemyGroupConfigArgs<'a> {
    pub enemyGroupKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub enemy: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyConfig<'a>>,
            >,
        >,
    >,
    pub dynamicEnemy: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2BattleRushEnemyGroupConfigArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2BattleRushEnemyGroupConfigArgs {
            enemyGroupKey: None,
            enemy: None,
            dynamicEnemy: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_SandboxV2BattleRushEnemyGroupConfig", 3)?;
        if let Some(f) = self.enemyGroupKey() {
            s.serialize_field("enemyGroupKey", &f)?;
        } else {
            s.skip_field("enemyGroupKey")?;
        }
        if let Some(f) = self.enemy() {
            s.serialize_field("enemy", &f)?;
        } else {
            s.skip_field("enemy")?;
        }
        if let Some(f) = self.dynamicEnemy() {
            s.serialize_field("dynamicEnemy", &f)?;
        } else {
            s.skip_field("dynamicEnemy")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2BattleRushEnemyGroupConfigBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2BattleRushEnemyGroupConfigBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_enemyGroupKey(&mut self, enemyGroupKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BattleRushEnemyGroupConfig::VT_ENEMYGROUPKEY,
            enemyGroupKey,
        );
    }
    #[inline]
    pub fn add_enemy(
        &mut self,
        enemy: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyConfig<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BattleRushEnemyGroupConfig::VT_ENEMY,
            enemy,
        );
    }
    #[inline]
    pub fn add_dynamicEnemy(
        &mut self,
        dynamicEnemy: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BattleRushEnemyGroupConfig::VT_DYNAMICENEMY,
            dynamicEnemy,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2BattleRushEnemyGroupConfigBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2BattleRushEnemyGroupConfigBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2BattleRushEnemyGroupConfig");
        ds.field("enemyGroupKey", &self.enemyGroupKey());
        ds.field("enemy", &self.enemy());
        ds.field("dynamicEnemy", &self.dynamicEnemy());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2BattleRushEnemyGroupConfigT {
    pub enemyGroupKey: Option<String>,
    pub enemy: Option<Vec<clz_Torappu_SandboxV2BattleRushEnemyConfigT>>,
    pub dynamicEnemy: Option<Vec<String>>,
}
impl Default for clz_Torappu_SandboxV2BattleRushEnemyGroupConfigT {
    fn default() -> Self {
        Self {
            enemyGroupKey: None,
            enemy: None,
            dynamicEnemy: None,
        }
    }
}
impl clz_Torappu_SandboxV2BattleRushEnemyGroupConfigT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'b>> {
        let enemyGroupKey = self.enemyGroupKey.as_ref().map(|x| _fbb.create_string(x));
        let enemy = self.enemy.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let dynamicEnemy = self.dynamicEnemy.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SandboxV2BattleRushEnemyGroupConfig::create(
            _fbb,
            &clz_Torappu_SandboxV2BattleRushEnemyGroupConfigArgs {
                enemyGroupKey,
                enemy,
                dynamicEnemy,
            },
        )
    }
}
pub enum dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigOffset
{}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<
    'a,
> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a> {
  type Inner = dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a>
    dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<
        'a,
    >
{
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig { _tab: table }
    }
    #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigArgs<'args>
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'bldr>>{
        let mut builder = dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigT{
        let key = self.key();
        let value = self.value().map(|x| x.iter().map(|t| t.unpack()).collect());
        dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigT {
      key,
      value,
    }
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_SandboxV2EnemyRushType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<enum__Torappu_SandboxV2EnemyRushType>(dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig::VT_KEY, Some(enum__Torappu_SandboxV2EnemyRushType::NORMAL)).unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_SandboxV2EnemyRushType,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyGroupConfig>>>>(dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<enum__Torappu_SandboxV2EnemyRushType>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyGroupConfig>>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigArgs<
    'a,
> {
    pub key: enum__Torappu_SandboxV2EnemyRushType,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigArgs<'a> {
  #[inline]
  fn default() -> Self {
    dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigArgs {
      key: enum__Torappu_SandboxV2EnemyRushType::NORMAL,
      value: None,
    }
  }
}

impl Serialize for dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig", 2)?;
      s.serialize_field("key", &self.key())?;
      if let Some(f) = self.value() {
        s.serialize_field("value", &f)?;
      } else {
        s.skip_field("value")?;
      }
    s.end()
  }
}

pub struct dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: enum__Torappu_SandboxV2EnemyRushType) {
    self.fbb_.push_slot::<enum__Torappu_SandboxV2EnemyRushType>(dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig::VT_KEY, key, enum__Torappu_SandboxV2EnemyRushType::NORMAL);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigT
{
    pub key: enum__Torappu_SandboxV2EnemyRushType,
    pub value: Option<Vec<clz_Torappu_SandboxV2BattleRushEnemyGroupConfigT>>,
}
impl Default for dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigT {
  fn default() -> Self {
    Self {
      key: enum__Torappu_SandboxV2EnemyRushType::NORMAL,
      value: None,
    }
  }
}
impl dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'b>> {
    let key = self.key;
    let value = self.value.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig::create(_fbb, &dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigArgs{
      key,
      value,
    })
  }
}
pub enum clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'a> {
    type Inner = clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'bldr>>
    {
        let mut builder = clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefBuilder::new(_fbb);
        builder.add_level(args.level);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefT {
        let id = self.id().map(|x| x.to_string());
        let level = self.level();
        clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefT { id, level }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef::VT_LEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub level: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefArgs { id: None, level: 0 }
    }
}

impl Serialize for clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef", 2)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("level", &self.level())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef::VT_LEVEL,
            level,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef");
        ds.field("id", &self.id());
        ds.field("level", &self.level());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefT {
    pub id: Option<String>,
    pub level: i32,
}
impl Default for clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefT {
    fn default() -> Self {
        Self { id: None, level: 0 }
    }
}
impl clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let level = self.level;
        clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef::create(
            _fbb,
            &clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefArgs { id, level },
        )
    }
}
pub enum clz_Torappu_SandboxV2BattleRushEnemyDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2BattleRushEnemyData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2BattleRushEnemyData<'a> {
    type Inner = clz_Torappu_SandboxV2BattleRushEnemyData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2BattleRushEnemyData<'a> {
    pub const VT_RUSHENEMYGROUPCONFIGS: flatbuffers::VOffsetT = 4;
    pub const VT_RUSHENEMYDBREF: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2BattleRushEnemyData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2BattleRushEnemyDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2BattleRushEnemyDataBuilder::new(_fbb);
        if let Some(x) = args.rushEnemyDbRef {
            builder.add_rushEnemyDbRef(x);
        }
        if let Some(x) = args.rushEnemyGroupConfigs {
            builder.add_rushEnemyGroupConfigs(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2BattleRushEnemyDataT {
        let rushEnemyGroupConfigs = self
            .rushEnemyGroupConfigs()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let rushEnemyDbRef = self
            .rushEnemyDbRef()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_SandboxV2BattleRushEnemyDataT {
            rushEnemyGroupConfigs,
            rushEnemyDbRef,
        }
    }

    #[inline]
    pub fn rushEnemyGroupConfigs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a>>>>{
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig>>>>(clz_Torappu_SandboxV2BattleRushEnemyData::VT_RUSHENEMYGROUPCONFIGS, None)
        }
    }
    #[inline]
    pub fn rushEnemyDbRef(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef,
                    >,
                >,
            >>(
                clz_Torappu_SandboxV2BattleRushEnemyData::VT_RUSHENEMYDBREF,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2BattleRushEnemyData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig>>>>("rushEnemyGroupConfigs", Self::VT_RUSHENEMYGROUPCONFIGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef>>>>("rushEnemyDbRef", Self::VT_RUSHENEMYDBREF, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2BattleRushEnemyDataArgs<'a> {
    pub rushEnemyGroupConfigs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'a>>>>>,
    pub rushEnemyDbRef: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'a>>>>>,
}
impl<'a> Default for clz_Torappu_SandboxV2BattleRushEnemyDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2BattleRushEnemyDataArgs {
            rushEnemyGroupConfigs: None,
            rushEnemyDbRef: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2BattleRushEnemyData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2BattleRushEnemyData", 2)?;
        if let Some(f) = self.rushEnemyGroupConfigs() {
            s.serialize_field("rushEnemyGroupConfigs", &f)?;
        } else {
            s.skip_field("rushEnemyGroupConfigs")?;
        }
        if let Some(f) = self.rushEnemyDbRef() {
            s.serialize_field("rushEnemyDbRef", &f)?;
        } else {
            s.skip_field("rushEnemyDbRef")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2BattleRushEnemyDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2BattleRushEnemyDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_rushEnemyGroupConfigs(
        &mut self,
        rushEnemyGroupConfigs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfig<'b >>>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BattleRushEnemyData::VT_RUSHENEMYGROUPCONFIGS,
            rushEnemyGroupConfigs,
        );
    }
    #[inline]
    pub fn add_rushEnemyDbRef(
        &mut self,
        rushEnemyDbRef: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRef<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BattleRushEnemyData::VT_RUSHENEMYDBREF,
            rushEnemyDbRef,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2BattleRushEnemyDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2BattleRushEnemyDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2BattleRushEnemyData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2BattleRushEnemyData");
        ds.field("rushEnemyGroupConfigs", &self.rushEnemyGroupConfigs());
        ds.field("rushEnemyDbRef", &self.rushEnemyDbRef());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2BattleRushEnemyDataT {
  pub rushEnemyGroupConfigs: Option<Vec<dict__enum__Torappu_SandboxV2EnemyRushType__list_clz_Torappu_SandboxV2BattleRushEnemyGroupConfigT>>,
  pub rushEnemyDbRef: Option<Vec<clz_Torappu_SandboxV2BattleRushEnemyData_RushEnemyDBRefT>>,
}
impl Default for clz_Torappu_SandboxV2BattleRushEnemyDataT {
    fn default() -> Self {
        Self {
            rushEnemyGroupConfigs: None,
            rushEnemyDbRef: None,
        }
    }
}
impl clz_Torappu_SandboxV2BattleRushEnemyDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyData<'b>> {
        let rushEnemyGroupConfigs = self.rushEnemyGroupConfigs.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let rushEnemyDbRef = self.rushEnemyDbRef.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SandboxV2BattleRushEnemyData::create(
            _fbb,
            &clz_Torappu_SandboxV2BattleRushEnemyDataArgs {
                rushEnemyGroupConfigs,
                rushEnemyDbRef,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2GameConstOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2GameConst<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2GameConst<'a> {
    type Inner = clz_Torappu_SandboxV2GameConst<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2GameConst<'a> {
    pub const VT_MAINMAPID: flatbuffers::VOffsetT = 4;
    pub const VT_BASETRAPID: flatbuffers::VOffsetT = 6;
    pub const VT_PORTABLETRAPID: flatbuffers::VOffsetT = 8;
    pub const VT_DOORTRAPID: flatbuffers::VOffsetT = 10;
    pub const VT_MINETRAPID: flatbuffers::VOffsetT = 12;
    pub const VT_NEUTRALBOSSENEMYID: flatbuffers::VOffsetT = 14;
    pub const VT_NESTTRAPID: flatbuffers::VOffsetT = 16;
    pub const VT_SHOPNPCNAME: flatbuffers::VOffsetT = 18;
    pub const VT_DAYSBETWEENASSESSMENT: flatbuffers::VOffsetT = 20;
    pub const VT_PORTABLECONSTRUCTUNLOCKLEVEL: flatbuffers::VOffsetT = 22;
    pub const VT_OUTPOSTCONSTRUCTUNLOCKLEVEL: flatbuffers::VOffsetT = 24;
    pub const VT_MAXENEMYCOUNTSAMETIMEINRUSH: flatbuffers::VOffsetT = 26;
    pub const VT_MAXPREDELAYTIMEINRUSH: flatbuffers::VOffsetT = 28;
    pub const VT_MAXSAVECNT: flatbuffers::VOffsetT = 30;
    pub const VT_FIRSTSEASONDURATION: flatbuffers::VOffsetT = 32;
    pub const VT_SEASONTRANSITIONLOOP: flatbuffers::VOffsetT = 34;
    pub const VT_SEASONDURATIONLOOP: flatbuffers::VOffsetT = 36;
    pub const VT_FIRSTSEASONSTARTANGLE: flatbuffers::VOffsetT = 38;
    pub const VT_SEASONTRANSITIONANGLELOOP: flatbuffers::VOffsetT = 40;
    pub const VT_SEASONANGLE: flatbuffers::VOffsetT = 42;
    pub const VT_BATTLEITEMDESC: flatbuffers::VOffsetT = 44;
    pub const VT_FOODDESC: flatbuffers::VOffsetT = 46;
    pub const VT_MULTIPLESURVIVALDAYDESC: flatbuffers::VOffsetT = 48;
    pub const VT_MULTIPLETIPS: flatbuffers::VOffsetT = 50;
    pub const VT_TECHPROGRESSSCORE: flatbuffers::VOffsetT = 52;
    pub const VT_OTHERENEMYRUSHNAME: flatbuffers::VOffsetT = 54;
    pub const VT_SURVIVEDAYTEXT: flatbuffers::VOffsetT = 56;
    pub const VT_SURVIVEPERIODTEXT: flatbuffers::VOffsetT = 58;
    pub const VT_SURVIVESCORETEXT: flatbuffers::VOffsetT = 60;
    pub const VT_ACTIONPOINTSCORETEXT: flatbuffers::VOffsetT = 62;
    pub const VT_NODEEXPLOREDESC: flatbuffers::VOffsetT = 64;
    pub const VT_DUNGEONEXPLOREDESC: flatbuffers::VOffsetT = 66;
    pub const VT_NODECOMPLETEDESC: flatbuffers::VOffsetT = 68;
    pub const VT_NORIFTDUNGEONDESC: flatbuffers::VOffsetT = 70;
    pub const VT_BASERUSHEDDESC: flatbuffers::VOffsetT = 72;
    pub const VT_RIFTBASEDESC: flatbuffers::VOffsetT = 74;
    pub const VT_RIFTBASERUSHEDDESC: flatbuffers::VOffsetT = 76;
    pub const VT_DUNGEONTRIGGEREDGUIDEQUESTLIST: flatbuffers::VOffsetT = 78;
    pub const VT_NOLOGINENEMYSTATSENEMYID: flatbuffers::VOffsetT = 80;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2GameConst { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2GameConstArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2GameConst<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2GameConstBuilder::new(_fbb);
        if let Some(x) = args.noLogInEnemyStatsEnemyId {
            builder.add_noLogInEnemyStatsEnemyId(x);
        }
        if let Some(x) = args.dungeonTriggeredGuideQuestList {
            builder.add_dungeonTriggeredGuideQuestList(x);
        }
        if let Some(x) = args.riftBaseRushedDesc {
            builder.add_riftBaseRushedDesc(x);
        }
        if let Some(x) = args.riftBaseDesc {
            builder.add_riftBaseDesc(x);
        }
        if let Some(x) = args.baseRushedDesc {
            builder.add_baseRushedDesc(x);
        }
        if let Some(x) = args.noRiftDungeonDesc {
            builder.add_noRiftDungeonDesc(x);
        }
        if let Some(x) = args.nodeCompleteDesc {
            builder.add_nodeCompleteDesc(x);
        }
        if let Some(x) = args.dungeonExploreDesc {
            builder.add_dungeonExploreDesc(x);
        }
        if let Some(x) = args.nodeExploreDesc {
            builder.add_nodeExploreDesc(x);
        }
        if let Some(x) = args.actionPointScoreText {
            builder.add_actionPointScoreText(x);
        }
        if let Some(x) = args.surviveScoreText {
            builder.add_surviveScoreText(x);
        }
        if let Some(x) = args.survivePeriodText {
            builder.add_survivePeriodText(x);
        }
        if let Some(x) = args.surviveDayText {
            builder.add_surviveDayText(x);
        }
        if let Some(x) = args.otherEnemyRushName {
            builder.add_otherEnemyRushName(x);
        }
        builder.add_techProgressScore(args.techProgressScore);
        if let Some(x) = args.multipleTips {
            builder.add_multipleTips(x);
        }
        if let Some(x) = args.multipleSurvivalDayDesc {
            builder.add_multipleSurvivalDayDesc(x);
        }
        if let Some(x) = args.foodDesc {
            builder.add_foodDesc(x);
        }
        if let Some(x) = args.battleItemDesc {
            builder.add_battleItemDesc(x);
        }
        builder.add_seasonAngle(args.seasonAngle);
        if let Some(x) = args.seasonTransitionAngleLoop {
            builder.add_seasonTransitionAngleLoop(x);
        }
        builder.add_firstSeasonStartAngle(args.firstSeasonStartAngle);
        if let Some(x) = args.seasonDurationLoop {
            builder.add_seasonDurationLoop(x);
        }
        if let Some(x) = args.seasonTransitionLoop {
            builder.add_seasonTransitionLoop(x);
        }
        builder.add_firstSeasonDuration(args.firstSeasonDuration);
        builder.add_maxSaveCnt(args.maxSaveCnt);
        builder.add_maxPreDelayTimeInRush(args.maxPreDelayTimeInRush);
        builder.add_maxEnemyCountSameTimeInRush(args.maxEnemyCountSameTimeInRush);
        builder.add_outpostConstructUnlockLevel(args.outpostConstructUnlockLevel);
        builder.add_portableConstructUnlockLevel(args.portableConstructUnlockLevel);
        builder.add_daysBetweenAssessment(args.daysBetweenAssessment);
        if let Some(x) = args.shopNpcName {
            builder.add_shopNpcName(x);
        }
        if let Some(x) = args.nestTrapId {
            builder.add_nestTrapId(x);
        }
        if let Some(x) = args.neutralBossEnemyId {
            builder.add_neutralBossEnemyId(x);
        }
        if let Some(x) = args.mineTrapId {
            builder.add_mineTrapId(x);
        }
        if let Some(x) = args.doorTrapId {
            builder.add_doorTrapId(x);
        }
        if let Some(x) = args.portableTrapId {
            builder.add_portableTrapId(x);
        }
        if let Some(x) = args.baseTrapId {
            builder.add_baseTrapId(x);
        }
        if let Some(x) = args.mainMapId {
            builder.add_mainMapId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2GameConstT {
        let mainMapId = self.mainMapId().map(|x| x.to_string());
        let baseTrapId = self.baseTrapId().map(|x| x.to_string());
        let portableTrapId = self.portableTrapId().map(|x| x.to_string());
        let doorTrapId = self.doorTrapId().map(|x| x.to_string());
        let mineTrapId = self.mineTrapId().map(|x| x.to_string());
        let neutralBossEnemyId = self
            .neutralBossEnemyId()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let nestTrapId = self.nestTrapId().map(|x| x.to_string());
        let shopNpcName = self.shopNpcName().map(|x| x.to_string());
        let daysBetweenAssessment = self.daysBetweenAssessment();
        let portableConstructUnlockLevel = self.portableConstructUnlockLevel();
        let outpostConstructUnlockLevel = self.outpostConstructUnlockLevel();
        let maxEnemyCountSameTimeInRush = self.maxEnemyCountSameTimeInRush();
        let maxPreDelayTimeInRush = self.maxPreDelayTimeInRush();
        let maxSaveCnt = self.maxSaveCnt();
        let firstSeasonDuration = self.firstSeasonDuration();
        let seasonTransitionLoop = self.seasonTransitionLoop().map(|x| x.into_iter().collect());
        let seasonDurationLoop = self.seasonDurationLoop().map(|x| x.into_iter().collect());
        let firstSeasonStartAngle = self.firstSeasonStartAngle();
        let seasonTransitionAngleLoop = self
            .seasonTransitionAngleLoop()
            .map(|x| x.into_iter().collect());
        let seasonAngle = self.seasonAngle();
        let battleItemDesc = self.battleItemDesc().map(|x| x.to_string());
        let foodDesc = self.foodDesc().map(|x| x.to_string());
        let multipleSurvivalDayDesc = self.multipleSurvivalDayDesc().map(|x| x.to_string());
        let multipleTips = self.multipleTips().map(|x| x.to_string());
        let techProgressScore = self.techProgressScore();
        let otherEnemyRushName = self.otherEnemyRushName().map(|x| x.to_string());
        let surviveDayText = self.surviveDayText().map(|x| x.to_string());
        let survivePeriodText = self.survivePeriodText().map(|x| x.to_string());
        let surviveScoreText = self.surviveScoreText().map(|x| x.to_string());
        let actionPointScoreText = self.actionPointScoreText().map(|x| x.to_string());
        let nodeExploreDesc = self.nodeExploreDesc().map(|x| x.to_string());
        let dungeonExploreDesc = self.dungeonExploreDesc().map(|x| x.to_string());
        let nodeCompleteDesc = self.nodeCompleteDesc().map(|x| x.to_string());
        let noRiftDungeonDesc = self.noRiftDungeonDesc().map(|x| x.to_string());
        let baseRushedDesc = self.baseRushedDesc().map(|x| x.to_string());
        let riftBaseDesc = self.riftBaseDesc().map(|x| x.to_string());
        let riftBaseRushedDesc = self.riftBaseRushedDesc().map(|x| x.to_string());
        let dungeonTriggeredGuideQuestList = self
            .dungeonTriggeredGuideQuestList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let noLogInEnemyStatsEnemyId = self
            .noLogInEnemyStatsEnemyId()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_SandboxV2GameConstT {
            mainMapId,
            baseTrapId,
            portableTrapId,
            doorTrapId,
            mineTrapId,
            neutralBossEnemyId,
            nestTrapId,
            shopNpcName,
            daysBetweenAssessment,
            portableConstructUnlockLevel,
            outpostConstructUnlockLevel,
            maxEnemyCountSameTimeInRush,
            maxPreDelayTimeInRush,
            maxSaveCnt,
            firstSeasonDuration,
            seasonTransitionLoop,
            seasonDurationLoop,
            firstSeasonStartAngle,
            seasonTransitionAngleLoop,
            seasonAngle,
            battleItemDesc,
            foodDesc,
            multipleSurvivalDayDesc,
            multipleTips,
            techProgressScore,
            otherEnemyRushName,
            surviveDayText,
            survivePeriodText,
            surviveScoreText,
            actionPointScoreText,
            nodeExploreDesc,
            dungeonExploreDesc,
            nodeCompleteDesc,
            noRiftDungeonDesc,
            baseRushedDesc,
            riftBaseDesc,
            riftBaseRushedDesc,
            dungeonTriggeredGuideQuestList,
            noLogInEnemyStatsEnemyId,
        }
    }

    #[inline]
    pub fn mainMapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_MAINMAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn baseTrapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_BASETRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn portableTrapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_PORTABLETRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn doorTrapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_DOORTRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn mineTrapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_MINETRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn neutralBossEnemyId(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxV2GameConst::VT_NEUTRALBOSSENEMYID, None)
        }
    }
    #[inline]
    pub fn nestTrapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_NESTTRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn shopNpcName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_SHOPNPCNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn daysBetweenAssessment(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2GameConst::VT_DAYSBETWEENASSESSMENT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn portableConstructUnlockLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2GameConst::VT_PORTABLECONSTRUCTUNLOCKLEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn outpostConstructUnlockLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2GameConst::VT_OUTPOSTCONSTRUCTUNLOCKLEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxEnemyCountSameTimeInRush(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2GameConst::VT_MAXENEMYCOUNTSAMETIMEINRUSH,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxPreDelayTimeInRush(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2GameConst::VT_MAXPREDELAYTIMEINRUSH,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxSaveCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2GameConst::VT_MAXSAVECNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn firstSeasonDuration(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2GameConst::VT_FIRSTSEASONDURATION,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn seasonTransitionLoop(
        &self,
    ) -> Option<flatbuffers::Vector<'a, enum__Torappu_SandboxV2SeasonType>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_SandboxV2SeasonType>,
            >>(
                clz_Torappu_SandboxV2GameConst::VT_SEASONTRANSITIONLOOP,
                None,
            )
        }
    }
    #[inline]
    pub fn seasonDurationLoop(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    clz_Torappu_SandboxV2GameConst::VT_SEASONDURATIONLOOP,
                    None,
                )
        }
    }
    #[inline]
    pub fn firstSeasonStartAngle(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2GameConst::VT_FIRSTSEASONSTARTANGLE,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn seasonTransitionAngleLoop(&self) -> Option<flatbuffers::Vector<'a, f32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    clz_Torappu_SandboxV2GameConst::VT_SEASONTRANSITIONANGLELOOP,
                    None,
                )
        }
    }
    #[inline]
    pub fn seasonAngle(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_SandboxV2GameConst::VT_SEASONANGLE, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn battleItemDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_BATTLEITEMDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn foodDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_FOODDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn multipleSurvivalDayDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_MULTIPLESURVIVALDAYDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn multipleTips(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_MULTIPLETIPS,
                None,
            )
        }
    }
    #[inline]
    pub fn techProgressScore(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2GameConst::VT_TECHPROGRESSSCORE,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn otherEnemyRushName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_OTHERENEMYRUSHNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn surviveDayText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_SURVIVEDAYTEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn survivePeriodText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_SURVIVEPERIODTEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn surviveScoreText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_SURVIVESCORETEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn actionPointScoreText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_ACTIONPOINTSCORETEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeExploreDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_NODEEXPLOREDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn dungeonExploreDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_DUNGEONEXPLOREDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeCompleteDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_NODECOMPLETEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn noRiftDungeonDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_NORIFTDUNGEONDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn baseRushedDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_BASERUSHEDDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn riftBaseDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_RIFTBASEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn riftBaseRushedDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GameConst::VT_RIFTBASERUSHEDDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn dungeonTriggeredGuideQuestList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2GameConst::VT_DUNGEONTRIGGEREDGUIDEQUESTLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn noLogInEnemyStatsEnemyId(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2GameConst::VT_NOLOGINENEMYSTATSENEMYID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2GameConst<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "mainMapId",
                Self::VT_MAINMAPID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "baseTrapId",
                Self::VT_BASETRAPID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "portableTrapId",
                Self::VT_PORTABLETRAPID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "doorTrapId",
                Self::VT_DOORTRAPID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "mineTrapId",
                Self::VT_MINETRAPID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("neutralBossEnemyId", Self::VT_NEUTRALBOSSENEMYID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nestTrapId",
                Self::VT_NESTTRAPID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "shopNpcName",
                Self::VT_SHOPNPCNAME,
                false,
            )?
            .visit_field::<i32>(
                "daysBetweenAssessment",
                Self::VT_DAYSBETWEENASSESSMENT,
                false,
            )?
            .visit_field::<i32>(
                "portableConstructUnlockLevel",
                Self::VT_PORTABLECONSTRUCTUNLOCKLEVEL,
                false,
            )?
            .visit_field::<i32>(
                "outpostConstructUnlockLevel",
                Self::VT_OUTPOSTCONSTRUCTUNLOCKLEVEL,
                false,
            )?
            .visit_field::<i32>(
                "maxEnemyCountSameTimeInRush",
                Self::VT_MAXENEMYCOUNTSAMETIMEINRUSH,
                false,
            )?
            .visit_field::<f32>(
                "maxPreDelayTimeInRush",
                Self::VT_MAXPREDELAYTIMEINRUSH,
                false,
            )?
            .visit_field::<i32>("maxSaveCnt", Self::VT_MAXSAVECNT, false)?
            .visit_field::<i32>("firstSeasonDuration", Self::VT_FIRSTSEASONDURATION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, enum__Torappu_SandboxV2SeasonType>,
            >>("seasonTransitionLoop", Self::VT_SEASONTRANSITIONLOOP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "seasonDurationLoop",
                Self::VT_SEASONDURATIONLOOP,
                false,
            )?
            .visit_field::<f32>(
                "firstSeasonStartAngle",
                Self::VT_FIRSTSEASONSTARTANGLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "seasonTransitionAngleLoop",
                Self::VT_SEASONTRANSITIONANGLELOOP,
                false,
            )?
            .visit_field::<f32>("seasonAngle", Self::VT_SEASONANGLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "battleItemDesc",
                Self::VT_BATTLEITEMDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "foodDesc",
                Self::VT_FOODDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "multipleSurvivalDayDesc",
                Self::VT_MULTIPLESURVIVALDAYDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "multipleTips",
                Self::VT_MULTIPLETIPS,
                false,
            )?
            .visit_field::<i32>("techProgressScore", Self::VT_TECHPROGRESSSCORE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "otherEnemyRushName",
                Self::VT_OTHERENEMYRUSHNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "surviveDayText",
                Self::VT_SURVIVEDAYTEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "survivePeriodText",
                Self::VT_SURVIVEPERIODTEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "surviveScoreText",
                Self::VT_SURVIVESCORETEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "actionPointScoreText",
                Self::VT_ACTIONPOINTSCORETEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nodeExploreDesc",
                Self::VT_NODEEXPLOREDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dungeonExploreDesc",
                Self::VT_DUNGEONEXPLOREDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nodeCompleteDesc",
                Self::VT_NODECOMPLETEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "noRiftDungeonDesc",
                Self::VT_NORIFTDUNGEONDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "baseRushedDesc",
                Self::VT_BASERUSHEDDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "riftBaseDesc",
                Self::VT_RIFTBASEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "riftBaseRushedDesc",
                Self::VT_RIFTBASERUSHEDDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "dungeonTriggeredGuideQuestList",
                Self::VT_DUNGEONTRIGGEREDGUIDEQUESTLIST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "noLogInEnemyStatsEnemyId",
                Self::VT_NOLOGINENEMYSTATSENEMYID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2GameConstArgs<'a> {
    pub mainMapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub baseTrapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub portableTrapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub doorTrapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mineTrapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub neutralBossEnemyId: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub nestTrapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub shopNpcName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub daysBetweenAssessment: i32,
    pub portableConstructUnlockLevel: i32,
    pub outpostConstructUnlockLevel: i32,
    pub maxEnemyCountSameTimeInRush: i32,
    pub maxPreDelayTimeInRush: f32,
    pub maxSaveCnt: i32,
    pub firstSeasonDuration: i32,
    pub seasonTransitionLoop:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_SandboxV2SeasonType>>>,
    pub seasonDurationLoop: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub firstSeasonStartAngle: f32,
    pub seasonTransitionAngleLoop: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub seasonAngle: f32,
    pub battleItemDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub foodDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub multipleSurvivalDayDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub multipleTips: Option<flatbuffers::WIPOffset<&'a str>>,
    pub techProgressScore: i32,
    pub otherEnemyRushName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub surviveDayText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub survivePeriodText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub surviveScoreText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub actionPointScoreText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nodeExploreDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dungeonExploreDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nodeCompleteDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub noRiftDungeonDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub baseRushedDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub riftBaseDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub riftBaseRushedDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dungeonTriggeredGuideQuestList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub noLogInEnemyStatsEnemyId: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2GameConstArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2GameConstArgs {
            mainMapId: None,
            baseTrapId: None,
            portableTrapId: None,
            doorTrapId: None,
            mineTrapId: None,
            neutralBossEnemyId: None,
            nestTrapId: None,
            shopNpcName: None,
            daysBetweenAssessment: 0,
            portableConstructUnlockLevel: 0,
            outpostConstructUnlockLevel: 0,
            maxEnemyCountSameTimeInRush: 0,
            maxPreDelayTimeInRush: 0.0,
            maxSaveCnt: 0,
            firstSeasonDuration: 0,
            seasonTransitionLoop: None,
            seasonDurationLoop: None,
            firstSeasonStartAngle: 0.0,
            seasonTransitionAngleLoop: None,
            seasonAngle: 0.0,
            battleItemDesc: None,
            foodDesc: None,
            multipleSurvivalDayDesc: None,
            multipleTips: None,
            techProgressScore: 0,
            otherEnemyRushName: None,
            surviveDayText: None,
            survivePeriodText: None,
            surviveScoreText: None,
            actionPointScoreText: None,
            nodeExploreDesc: None,
            dungeonExploreDesc: None,
            nodeCompleteDesc: None,
            noRiftDungeonDesc: None,
            baseRushedDesc: None,
            riftBaseDesc: None,
            riftBaseRushedDesc: None,
            dungeonTriggeredGuideQuestList: None,
            noLogInEnemyStatsEnemyId: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2GameConst<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2GameConst", 39)?;
        if let Some(f) = self.mainMapId() {
            s.serialize_field("mainMapId", &f)?;
        } else {
            s.skip_field("mainMapId")?;
        }
        if let Some(f) = self.baseTrapId() {
            s.serialize_field("baseTrapId", &f)?;
        } else {
            s.skip_field("baseTrapId")?;
        }
        if let Some(f) = self.portableTrapId() {
            s.serialize_field("portableTrapId", &f)?;
        } else {
            s.skip_field("portableTrapId")?;
        }
        if let Some(f) = self.doorTrapId() {
            s.serialize_field("doorTrapId", &f)?;
        } else {
            s.skip_field("doorTrapId")?;
        }
        if let Some(f) = self.mineTrapId() {
            s.serialize_field("mineTrapId", &f)?;
        } else {
            s.skip_field("mineTrapId")?;
        }
        if let Some(f) = self.neutralBossEnemyId() {
            s.serialize_field("neutralBossEnemyId", &f)?;
        } else {
            s.skip_field("neutralBossEnemyId")?;
        }
        if let Some(f) = self.nestTrapId() {
            s.serialize_field("nestTrapId", &f)?;
        } else {
            s.skip_field("nestTrapId")?;
        }
        if let Some(f) = self.shopNpcName() {
            s.serialize_field("shopNpcName", &f)?;
        } else {
            s.skip_field("shopNpcName")?;
        }
        s.serialize_field("daysBetweenAssessment", &self.daysBetweenAssessment())?;
        s.serialize_field(
            "portableConstructUnlockLevel",
            &self.portableConstructUnlockLevel(),
        )?;
        s.serialize_field(
            "outpostConstructUnlockLevel",
            &self.outpostConstructUnlockLevel(),
        )?;
        s.serialize_field(
            "maxEnemyCountSameTimeInRush",
            &self.maxEnemyCountSameTimeInRush(),
        )?;
        s.serialize_field("maxPreDelayTimeInRush", &self.maxPreDelayTimeInRush())?;
        s.serialize_field("maxSaveCnt", &self.maxSaveCnt())?;
        s.serialize_field("firstSeasonDuration", &self.firstSeasonDuration())?;
        if let Some(f) = self.seasonTransitionLoop() {
            s.serialize_field("seasonTransitionLoop", &f)?;
        } else {
            s.skip_field("seasonTransitionLoop")?;
        }
        if let Some(f) = self.seasonDurationLoop() {
            s.serialize_field("seasonDurationLoop", &f)?;
        } else {
            s.skip_field("seasonDurationLoop")?;
        }
        s.serialize_field("firstSeasonStartAngle", &self.firstSeasonStartAngle())?;
        if let Some(f) = self.seasonTransitionAngleLoop() {
            s.serialize_field("seasonTransitionAngleLoop", &f)?;
        } else {
            s.skip_field("seasonTransitionAngleLoop")?;
        }
        s.serialize_field("seasonAngle", &self.seasonAngle())?;
        if let Some(f) = self.battleItemDesc() {
            s.serialize_field("battleItemDesc", &f)?;
        } else {
            s.skip_field("battleItemDesc")?;
        }
        if let Some(f) = self.foodDesc() {
            s.serialize_field("foodDesc", &f)?;
        } else {
            s.skip_field("foodDesc")?;
        }
        if let Some(f) = self.multipleSurvivalDayDesc() {
            s.serialize_field("multipleSurvivalDayDesc", &f)?;
        } else {
            s.skip_field("multipleSurvivalDayDesc")?;
        }
        if let Some(f) = self.multipleTips() {
            s.serialize_field("multipleTips", &f)?;
        } else {
            s.skip_field("multipleTips")?;
        }
        s.serialize_field("techProgressScore", &self.techProgressScore())?;
        if let Some(f) = self.otherEnemyRushName() {
            s.serialize_field("otherEnemyRushName", &f)?;
        } else {
            s.skip_field("otherEnemyRushName")?;
        }
        if let Some(f) = self.surviveDayText() {
            s.serialize_field("surviveDayText", &f)?;
        } else {
            s.skip_field("surviveDayText")?;
        }
        if let Some(f) = self.survivePeriodText() {
            s.serialize_field("survivePeriodText", &f)?;
        } else {
            s.skip_field("survivePeriodText")?;
        }
        if let Some(f) = self.surviveScoreText() {
            s.serialize_field("surviveScoreText", &f)?;
        } else {
            s.skip_field("surviveScoreText")?;
        }
        if let Some(f) = self.actionPointScoreText() {
            s.serialize_field("actionPointScoreText", &f)?;
        } else {
            s.skip_field("actionPointScoreText")?;
        }
        if let Some(f) = self.nodeExploreDesc() {
            s.serialize_field("nodeExploreDesc", &f)?;
        } else {
            s.skip_field("nodeExploreDesc")?;
        }
        if let Some(f) = self.dungeonExploreDesc() {
            s.serialize_field("dungeonExploreDesc", &f)?;
        } else {
            s.skip_field("dungeonExploreDesc")?;
        }
        if let Some(f) = self.nodeCompleteDesc() {
            s.serialize_field("nodeCompleteDesc", &f)?;
        } else {
            s.skip_field("nodeCompleteDesc")?;
        }
        if let Some(f) = self.noRiftDungeonDesc() {
            s.serialize_field("noRiftDungeonDesc", &f)?;
        } else {
            s.skip_field("noRiftDungeonDesc")?;
        }
        if let Some(f) = self.baseRushedDesc() {
            s.serialize_field("baseRushedDesc", &f)?;
        } else {
            s.skip_field("baseRushedDesc")?;
        }
        if let Some(f) = self.riftBaseDesc() {
            s.serialize_field("riftBaseDesc", &f)?;
        } else {
            s.skip_field("riftBaseDesc")?;
        }
        if let Some(f) = self.riftBaseRushedDesc() {
            s.serialize_field("riftBaseRushedDesc", &f)?;
        } else {
            s.skip_field("riftBaseRushedDesc")?;
        }
        if let Some(f) = self.dungeonTriggeredGuideQuestList() {
            s.serialize_field("dungeonTriggeredGuideQuestList", &f)?;
        } else {
            s.skip_field("dungeonTriggeredGuideQuestList")?;
        }
        if let Some(f) = self.noLogInEnemyStatsEnemyId() {
            s.serialize_field("noLogInEnemyStatsEnemyId", &f)?;
        } else {
            s.skip_field("noLogInEnemyStatsEnemyId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2GameConstBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2GameConstBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_mainMapId(&mut self, mainMapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_MAINMAPID,
            mainMapId,
        );
    }
    #[inline]
    pub fn add_baseTrapId(&mut self, baseTrapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_BASETRAPID,
            baseTrapId,
        );
    }
    #[inline]
    pub fn add_portableTrapId(&mut self, portableTrapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_PORTABLETRAPID,
            portableTrapId,
        );
    }
    #[inline]
    pub fn add_doorTrapId(&mut self, doorTrapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_DOORTRAPID,
            doorTrapId,
        );
    }
    #[inline]
    pub fn add_mineTrapId(&mut self, mineTrapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_MINETRAPID,
            mineTrapId,
        );
    }
    #[inline]
    pub fn add_neutralBossEnemyId(
        &mut self,
        neutralBossEnemyId: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_NEUTRALBOSSENEMYID,
            neutralBossEnemyId,
        );
    }
    #[inline]
    pub fn add_nestTrapId(&mut self, nestTrapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_NESTTRAPID,
            nestTrapId,
        );
    }
    #[inline]
    pub fn add_shopNpcName(&mut self, shopNpcName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_SHOPNPCNAME,
            shopNpcName,
        );
    }
    #[inline]
    pub fn add_daysBetweenAssessment(&mut self, daysBetweenAssessment: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2GameConst::VT_DAYSBETWEENASSESSMENT,
            daysBetweenAssessment,
            0,
        );
    }
    #[inline]
    pub fn add_portableConstructUnlockLevel(&mut self, portableConstructUnlockLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2GameConst::VT_PORTABLECONSTRUCTUNLOCKLEVEL,
            portableConstructUnlockLevel,
            0,
        );
    }
    #[inline]
    pub fn add_outpostConstructUnlockLevel(&mut self, outpostConstructUnlockLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2GameConst::VT_OUTPOSTCONSTRUCTUNLOCKLEVEL,
            outpostConstructUnlockLevel,
            0,
        );
    }
    #[inline]
    pub fn add_maxEnemyCountSameTimeInRush(&mut self, maxEnemyCountSameTimeInRush: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2GameConst::VT_MAXENEMYCOUNTSAMETIMEINRUSH,
            maxEnemyCountSameTimeInRush,
            0,
        );
    }
    #[inline]
    pub fn add_maxPreDelayTimeInRush(&mut self, maxPreDelayTimeInRush: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2GameConst::VT_MAXPREDELAYTIMEINRUSH,
            maxPreDelayTimeInRush,
            0.0,
        );
    }
    #[inline]
    pub fn add_maxSaveCnt(&mut self, maxSaveCnt: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2GameConst::VT_MAXSAVECNT, maxSaveCnt, 0);
    }
    #[inline]
    pub fn add_firstSeasonDuration(&mut self, firstSeasonDuration: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2GameConst::VT_FIRSTSEASONDURATION,
            firstSeasonDuration,
            0,
        );
    }
    #[inline]
    pub fn add_seasonTransitionLoop(
        &mut self,
        seasonTransitionLoop: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, enum__Torappu_SandboxV2SeasonType>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_SEASONTRANSITIONLOOP,
            seasonTransitionLoop,
        );
    }
    #[inline]
    pub fn add_seasonDurationLoop(
        &mut self,
        seasonDurationLoop: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_SEASONDURATIONLOOP,
            seasonDurationLoop,
        );
    }
    #[inline]
    pub fn add_firstSeasonStartAngle(&mut self, firstSeasonStartAngle: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2GameConst::VT_FIRSTSEASONSTARTANGLE,
            firstSeasonStartAngle,
            0.0,
        );
    }
    #[inline]
    pub fn add_seasonTransitionAngleLoop(
        &mut self,
        seasonTransitionAngleLoop: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_SEASONTRANSITIONANGLELOOP,
            seasonTransitionAngleLoop,
        );
    }
    #[inline]
    pub fn add_seasonAngle(&mut self, seasonAngle: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2GameConst::VT_SEASONANGLE,
            seasonAngle,
            0.0,
        );
    }
    #[inline]
    pub fn add_battleItemDesc(&mut self, battleItemDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_BATTLEITEMDESC,
            battleItemDesc,
        );
    }
    #[inline]
    pub fn add_foodDesc(&mut self, foodDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_FOODDESC,
            foodDesc,
        );
    }
    #[inline]
    pub fn add_multipleSurvivalDayDesc(
        &mut self,
        multipleSurvivalDayDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_MULTIPLESURVIVALDAYDESC,
            multipleSurvivalDayDesc,
        );
    }
    #[inline]
    pub fn add_multipleTips(&mut self, multipleTips: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_MULTIPLETIPS,
            multipleTips,
        );
    }
    #[inline]
    pub fn add_techProgressScore(&mut self, techProgressScore: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2GameConst::VT_TECHPROGRESSSCORE,
            techProgressScore,
            0,
        );
    }
    #[inline]
    pub fn add_otherEnemyRushName(&mut self, otherEnemyRushName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_OTHERENEMYRUSHNAME,
            otherEnemyRushName,
        );
    }
    #[inline]
    pub fn add_surviveDayText(&mut self, surviveDayText: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_SURVIVEDAYTEXT,
            surviveDayText,
        );
    }
    #[inline]
    pub fn add_survivePeriodText(&mut self, survivePeriodText: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_SURVIVEPERIODTEXT,
            survivePeriodText,
        );
    }
    #[inline]
    pub fn add_surviveScoreText(&mut self, surviveScoreText: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_SURVIVESCORETEXT,
            surviveScoreText,
        );
    }
    #[inline]
    pub fn add_actionPointScoreText(
        &mut self,
        actionPointScoreText: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_ACTIONPOINTSCORETEXT,
            actionPointScoreText,
        );
    }
    #[inline]
    pub fn add_nodeExploreDesc(&mut self, nodeExploreDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_NODEEXPLOREDESC,
            nodeExploreDesc,
        );
    }
    #[inline]
    pub fn add_dungeonExploreDesc(&mut self, dungeonExploreDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_DUNGEONEXPLOREDESC,
            dungeonExploreDesc,
        );
    }
    #[inline]
    pub fn add_nodeCompleteDesc(&mut self, nodeCompleteDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_NODECOMPLETEDESC,
            nodeCompleteDesc,
        );
    }
    #[inline]
    pub fn add_noRiftDungeonDesc(&mut self, noRiftDungeonDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_NORIFTDUNGEONDESC,
            noRiftDungeonDesc,
        );
    }
    #[inline]
    pub fn add_baseRushedDesc(&mut self, baseRushedDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_BASERUSHEDDESC,
            baseRushedDesc,
        );
    }
    #[inline]
    pub fn add_riftBaseDesc(&mut self, riftBaseDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_RIFTBASEDESC,
            riftBaseDesc,
        );
    }
    #[inline]
    pub fn add_riftBaseRushedDesc(&mut self, riftBaseRushedDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_RIFTBASERUSHEDDESC,
            riftBaseRushedDesc,
        );
    }
    #[inline]
    pub fn add_dungeonTriggeredGuideQuestList(
        &mut self,
        dungeonTriggeredGuideQuestList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_DUNGEONTRIGGEREDGUIDEQUESTLIST,
            dungeonTriggeredGuideQuestList,
        );
    }
    #[inline]
    pub fn add_noLogInEnemyStatsEnemyId(
        &mut self,
        noLogInEnemyStatsEnemyId: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GameConst::VT_NOLOGINENEMYSTATSENEMYID,
            noLogInEnemyStatsEnemyId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2GameConstBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2GameConstBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2GameConst<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2GameConst<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2GameConst");
        ds.field("mainMapId", &self.mainMapId());
        ds.field("baseTrapId", &self.baseTrapId());
        ds.field("portableTrapId", &self.portableTrapId());
        ds.field("doorTrapId", &self.doorTrapId());
        ds.field("mineTrapId", &self.mineTrapId());
        ds.field("neutralBossEnemyId", &self.neutralBossEnemyId());
        ds.field("nestTrapId", &self.nestTrapId());
        ds.field("shopNpcName", &self.shopNpcName());
        ds.field("daysBetweenAssessment", &self.daysBetweenAssessment());
        ds.field(
            "portableConstructUnlockLevel",
            &self.portableConstructUnlockLevel(),
        );
        ds.field(
            "outpostConstructUnlockLevel",
            &self.outpostConstructUnlockLevel(),
        );
        ds.field(
            "maxEnemyCountSameTimeInRush",
            &self.maxEnemyCountSameTimeInRush(),
        );
        ds.field("maxPreDelayTimeInRush", &self.maxPreDelayTimeInRush());
        ds.field("maxSaveCnt", &self.maxSaveCnt());
        ds.field("firstSeasonDuration", &self.firstSeasonDuration());
        ds.field("seasonTransitionLoop", &self.seasonTransitionLoop());
        ds.field("seasonDurationLoop", &self.seasonDurationLoop());
        ds.field("firstSeasonStartAngle", &self.firstSeasonStartAngle());
        ds.field(
            "seasonTransitionAngleLoop",
            &self.seasonTransitionAngleLoop(),
        );
        ds.field("seasonAngle", &self.seasonAngle());
        ds.field("battleItemDesc", &self.battleItemDesc());
        ds.field("foodDesc", &self.foodDesc());
        ds.field("multipleSurvivalDayDesc", &self.multipleSurvivalDayDesc());
        ds.field("multipleTips", &self.multipleTips());
        ds.field("techProgressScore", &self.techProgressScore());
        ds.field("otherEnemyRushName", &self.otherEnemyRushName());
        ds.field("surviveDayText", &self.surviveDayText());
        ds.field("survivePeriodText", &self.survivePeriodText());
        ds.field("surviveScoreText", &self.surviveScoreText());
        ds.field("actionPointScoreText", &self.actionPointScoreText());
        ds.field("nodeExploreDesc", &self.nodeExploreDesc());
        ds.field("dungeonExploreDesc", &self.dungeonExploreDesc());
        ds.field("nodeCompleteDesc", &self.nodeCompleteDesc());
        ds.field("noRiftDungeonDesc", &self.noRiftDungeonDesc());
        ds.field("baseRushedDesc", &self.baseRushedDesc());
        ds.field("riftBaseDesc", &self.riftBaseDesc());
        ds.field("riftBaseRushedDesc", &self.riftBaseRushedDesc());
        ds.field(
            "dungeonTriggeredGuideQuestList",
            &self.dungeonTriggeredGuideQuestList(),
        );
        ds.field("noLogInEnemyStatsEnemyId", &self.noLogInEnemyStatsEnemyId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2GameConstT {
    pub mainMapId: Option<String>,
    pub baseTrapId: Option<String>,
    pub portableTrapId: Option<String>,
    pub doorTrapId: Option<String>,
    pub mineTrapId: Option<String>,
    pub neutralBossEnemyId: Option<Vec<String>>,
    pub nestTrapId: Option<String>,
    pub shopNpcName: Option<String>,
    pub daysBetweenAssessment: i32,
    pub portableConstructUnlockLevel: i32,
    pub outpostConstructUnlockLevel: i32,
    pub maxEnemyCountSameTimeInRush: i32,
    pub maxPreDelayTimeInRush: f32,
    pub maxSaveCnt: i32,
    pub firstSeasonDuration: i32,
    pub seasonTransitionLoop: Option<Vec<enum__Torappu_SandboxV2SeasonType>>,
    pub seasonDurationLoop: Option<Vec<i32>>,
    pub firstSeasonStartAngle: f32,
    pub seasonTransitionAngleLoop: Option<Vec<f32>>,
    pub seasonAngle: f32,
    pub battleItemDesc: Option<String>,
    pub foodDesc: Option<String>,
    pub multipleSurvivalDayDesc: Option<String>,
    pub multipleTips: Option<String>,
    pub techProgressScore: i32,
    pub otherEnemyRushName: Option<String>,
    pub surviveDayText: Option<String>,
    pub survivePeriodText: Option<String>,
    pub surviveScoreText: Option<String>,
    pub actionPointScoreText: Option<String>,
    pub nodeExploreDesc: Option<String>,
    pub dungeonExploreDesc: Option<String>,
    pub nodeCompleteDesc: Option<String>,
    pub noRiftDungeonDesc: Option<String>,
    pub baseRushedDesc: Option<String>,
    pub riftBaseDesc: Option<String>,
    pub riftBaseRushedDesc: Option<String>,
    pub dungeonTriggeredGuideQuestList: Option<Vec<String>>,
    pub noLogInEnemyStatsEnemyId: Option<Vec<String>>,
}
impl Default for clz_Torappu_SandboxV2GameConstT {
    fn default() -> Self {
        Self {
            mainMapId: None,
            baseTrapId: None,
            portableTrapId: None,
            doorTrapId: None,
            mineTrapId: None,
            neutralBossEnemyId: None,
            nestTrapId: None,
            shopNpcName: None,
            daysBetweenAssessment: 0,
            portableConstructUnlockLevel: 0,
            outpostConstructUnlockLevel: 0,
            maxEnemyCountSameTimeInRush: 0,
            maxPreDelayTimeInRush: 0.0,
            maxSaveCnt: 0,
            firstSeasonDuration: 0,
            seasonTransitionLoop: None,
            seasonDurationLoop: None,
            firstSeasonStartAngle: 0.0,
            seasonTransitionAngleLoop: None,
            seasonAngle: 0.0,
            battleItemDesc: None,
            foodDesc: None,
            multipleSurvivalDayDesc: None,
            multipleTips: None,
            techProgressScore: 0,
            otherEnemyRushName: None,
            surviveDayText: None,
            survivePeriodText: None,
            surviveScoreText: None,
            actionPointScoreText: None,
            nodeExploreDesc: None,
            dungeonExploreDesc: None,
            nodeCompleteDesc: None,
            noRiftDungeonDesc: None,
            baseRushedDesc: None,
            riftBaseDesc: None,
            riftBaseRushedDesc: None,
            dungeonTriggeredGuideQuestList: None,
            noLogInEnemyStatsEnemyId: None,
        }
    }
}
impl clz_Torappu_SandboxV2GameConstT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2GameConst<'b>> {
        let mainMapId = self.mainMapId.as_ref().map(|x| _fbb.create_string(x));
        let baseTrapId = self.baseTrapId.as_ref().map(|x| _fbb.create_string(x));
        let portableTrapId = self.portableTrapId.as_ref().map(|x| _fbb.create_string(x));
        let doorTrapId = self.doorTrapId.as_ref().map(|x| _fbb.create_string(x));
        let mineTrapId = self.mineTrapId.as_ref().map(|x| _fbb.create_string(x));
        let neutralBossEnemyId = self.neutralBossEnemyId.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let nestTrapId = self.nestTrapId.as_ref().map(|x| _fbb.create_string(x));
        let shopNpcName = self.shopNpcName.as_ref().map(|x| _fbb.create_string(x));
        let daysBetweenAssessment = self.daysBetweenAssessment;
        let portableConstructUnlockLevel = self.portableConstructUnlockLevel;
        let outpostConstructUnlockLevel = self.outpostConstructUnlockLevel;
        let maxEnemyCountSameTimeInRush = self.maxEnemyCountSameTimeInRush;
        let maxPreDelayTimeInRush = self.maxPreDelayTimeInRush;
        let maxSaveCnt = self.maxSaveCnt;
        let firstSeasonDuration = self.firstSeasonDuration;
        let seasonTransitionLoop = self
            .seasonTransitionLoop
            .as_ref()
            .map(|x| _fbb.create_vector(x));
        let seasonDurationLoop = self
            .seasonDurationLoop
            .as_ref()
            .map(|x| _fbb.create_vector(x));
        let firstSeasonStartAngle = self.firstSeasonStartAngle;
        let seasonTransitionAngleLoop = self
            .seasonTransitionAngleLoop
            .as_ref()
            .map(|x| _fbb.create_vector(x));
        let seasonAngle = self.seasonAngle;
        let battleItemDesc = self.battleItemDesc.as_ref().map(|x| _fbb.create_string(x));
        let foodDesc = self.foodDesc.as_ref().map(|x| _fbb.create_string(x));
        let multipleSurvivalDayDesc = self
            .multipleSurvivalDayDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let multipleTips = self.multipleTips.as_ref().map(|x| _fbb.create_string(x));
        let techProgressScore = self.techProgressScore;
        let otherEnemyRushName = self
            .otherEnemyRushName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let surviveDayText = self.surviveDayText.as_ref().map(|x| _fbb.create_string(x));
        let survivePeriodText = self
            .survivePeriodText
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let surviveScoreText = self
            .surviveScoreText
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let actionPointScoreText = self
            .actionPointScoreText
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let nodeExploreDesc = self.nodeExploreDesc.as_ref().map(|x| _fbb.create_string(x));
        let dungeonExploreDesc = self
            .dungeonExploreDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let nodeCompleteDesc = self
            .nodeCompleteDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let noRiftDungeonDesc = self
            .noRiftDungeonDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let baseRushedDesc = self.baseRushedDesc.as_ref().map(|x| _fbb.create_string(x));
        let riftBaseDesc = self.riftBaseDesc.as_ref().map(|x| _fbb.create_string(x));
        let riftBaseRushedDesc = self
            .riftBaseRushedDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let dungeonTriggeredGuideQuestList =
            self.dungeonTriggeredGuideQuestList.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
                _fbb.create_vector(&w)
            });
        let noLogInEnemyStatsEnemyId = self.noLogInEnemyStatsEnemyId.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SandboxV2GameConst::create(
            _fbb,
            &clz_Torappu_SandboxV2GameConstArgs {
                mainMapId,
                baseTrapId,
                portableTrapId,
                doorTrapId,
                mineTrapId,
                neutralBossEnemyId,
                nestTrapId,
                shopNpcName,
                daysBetweenAssessment,
                portableConstructUnlockLevel,
                outpostConstructUnlockLevel,
                maxEnemyCountSameTimeInRush,
                maxPreDelayTimeInRush,
                maxSaveCnt,
                firstSeasonDuration,
                seasonTransitionLoop,
                seasonDurationLoop,
                firstSeasonStartAngle,
                seasonTransitionAngleLoop,
                seasonAngle,
                battleItemDesc,
                foodDesc,
                multipleSurvivalDayDesc,
                multipleTips,
                techProgressScore,
                otherEnemyRushName,
                surviveDayText,
                survivePeriodText,
                surviveScoreText,
                actionPointScoreText,
                nodeExploreDesc,
                dungeonExploreDesc,
                nodeCompleteDesc,
                noRiftDungeonDesc,
                baseRushedDesc,
                riftBaseDesc,
                riftBaseRushedDesc,
                dungeonTriggeredGuideQuestList,
                noLogInEnemyStatsEnemyId,
            },
        )
    }
}
pub enum clz_Torappu_ItemBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ItemBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ItemBundle<'a> {
    type Inner = clz_Torappu_ItemBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ItemBundle<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_COUNT: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ItemBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ItemBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'bldr>> {
        let mut builder = clz_Torappu_ItemBundleBuilder::new(_fbb);
        builder.add_type_(args.type_);
        builder.add_count(args.count);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ItemBundleT {
        let id = self.id().map(|x| x.to_string());
        let count = self.count();
        let type_ = self.type_();
        clz_Torappu_ItemBundleT { id, count, type_ }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_ItemBundle::VT_ID, None)
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ItemBundle::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_ItemBundle::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ItemBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ItemBundleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl<'a> Default for clz_Torappu_ItemBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ItemBundleArgs {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_ItemBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ItemBundle", 3)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("count", &self.count())?;
        s.serialize_field("type_", &self.type_())?;
        s.end()
    }
}

pub struct clz_Torappu_ItemBundleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ItemBundle::VT_ID, id);
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ItemBundle::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_ItemBundle::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ItemBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ItemBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ItemBundle");
        ds.field("id", &self.id());
        ds.field("count", &self.count());
        ds.field("type_", &self.type_());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ItemBundleT {
    pub id: Option<String>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl Default for clz_Torappu_ItemBundleT {
    fn default() -> Self {
        Self {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}
impl clz_Torappu_ItemBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let count = self.count;
        let type_ = self.type_;
        clz_Torappu_ItemBundle::create(_fbb, &clz_Torappu_ItemBundleArgs { id, count, type_ })
    }
}
pub enum dict__string__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__string<'a> {
    type Inner = dict__string__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__string<'bldr>> {
        let mut builder = dict__string__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__stringT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| x.to_string());
        dict__string__stringT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__string::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__string::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__stringArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for dict__string__stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__stringArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__string<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__string", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__stringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__stringBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__string::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__string::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, dict__string__string::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__stringT {
    pub key: String,
    pub value: Option<String>,
}
impl Default for dict__string__stringT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__string<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| _fbb.create_string(x));
        dict__string__string::create(_fbb, &dict__string__stringArgs { key, value })
    }
}
pub enum clz_Torappu_SandboxV2DiffModeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2DiffModeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2DiffModeData<'a> {
    type Inner = clz_Torappu_SandboxV2DiffModeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2DiffModeData<'a> {
    pub const VT_TITLE: flatbuffers::VOffsetT = 4;
    pub const VT_DESC: flatbuffers::VOffsetT = 6;
    pub const VT_BUFFLIST: flatbuffers::VOffsetT = 8;
    pub const VT_DETAILLIST: flatbuffers::VOffsetT = 10;
    pub const VT_SORTID: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2DiffModeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2DiffModeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DiffModeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2DiffModeDataBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.detailList {
            builder.add_detailList(x);
        }
        if let Some(x) = args.buffList {
            builder.add_buffList(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.title {
            builder.add_title(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2DiffModeDataT {
        let title = self.title().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let buffList = self
            .buffList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let detailList = self.detailList().map(|x| x.to_string());
        let sortId = self.sortId();
        clz_Torappu_SandboxV2DiffModeDataT {
            title,
            desc,
            buffList,
            detailList,
            sortId,
        }
    }

    #[inline]
    pub fn title(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DiffModeData::VT_TITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DiffModeData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn buffList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxV2DiffModeData::VT_BUFFLIST, None)
        }
    }
    #[inline]
    pub fn detailList(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DiffModeData::VT_DETAILLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2DiffModeData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2DiffModeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("buffList", Self::VT_BUFFLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "detailList",
                Self::VT_DETAILLIST,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2DiffModeDataArgs<'a> {
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub detailList: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2DiffModeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2DiffModeDataArgs {
            title: None,
            desc: None,
            buffList: None,
            detailList: None,
            sortId: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2DiffModeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2DiffModeData", 5)?;
        if let Some(f) = self.title() {
            s.serialize_field("title", &f)?;
        } else {
            s.skip_field("title")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.buffList() {
            s.serialize_field("buffList", &f)?;
        } else {
            s.skip_field("buffList")?;
        }
        if let Some(f) = self.detailList() {
            s.serialize_field("detailList", &f)?;
        } else {
            s.skip_field("detailList")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2DiffModeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2DiffModeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DiffModeData::VT_TITLE,
            title,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DiffModeData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_buffList(
        &mut self,
        buffList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DiffModeData::VT_BUFFLIST,
            buffList,
        );
    }
    #[inline]
    pub fn add_detailList(&mut self, detailList: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DiffModeData::VT_DETAILLIST,
            detailList,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2DiffModeData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2DiffModeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2DiffModeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DiffModeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2DiffModeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2DiffModeData");
        ds.field("title", &self.title());
        ds.field("desc", &self.desc());
        ds.field("buffList", &self.buffList());
        ds.field("detailList", &self.detailList());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2DiffModeDataT {
    pub title: Option<String>,
    pub desc: Option<String>,
    pub buffList: Option<Vec<String>>,
    pub detailList: Option<String>,
    pub sortId: i32,
}
impl Default for clz_Torappu_SandboxV2DiffModeDataT {
    fn default() -> Self {
        Self {
            title: None,
            desc: None,
            buffList: None,
            detailList: None,
            sortId: 0,
        }
    }
}
impl clz_Torappu_SandboxV2DiffModeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DiffModeData<'b>> {
        let title = self.title.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let buffList = self.buffList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let detailList = self.detailList.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        clz_Torappu_SandboxV2DiffModeData::create(
            _fbb,
            &clz_Torappu_SandboxV2DiffModeDataArgs {
                title,
                desc,
                buffList,
                detailList,
                sortId,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2BasicConstOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2BasicConst<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2BasicConst<'a> {
    type Inner = clz_Torappu_SandboxV2BasicConst<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2BasicConst<'a> {
    pub const VT_STAMINAITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_GOLDITEMID: flatbuffers::VOffsetT = 6;
    pub const VT_DIMENSIONCOINITEMID: flatbuffers::VOffsetT = 8;
    pub const VT_ALWAYSSHOWITEMIDSCONSTRUCT: flatbuffers::VOffsetT = 10;
    pub const VT_ALWAYSSHOWITEMIDS: flatbuffers::VOffsetT = 12;
    pub const VT_BAGBOTTOMBARRESTYPE: flatbuffers::VOffsetT = 14;
    pub const VT_FAILEDCOOKFOOD: flatbuffers::VOffsetT = 16;
    pub const VT_MAXFOODDURATION: flatbuffers::VOffsetT = 18;
    pub const VT_DRINKCOSTONCE: flatbuffers::VOffsetT = 20;
    pub const VT_DRINKMAKELIMIT: flatbuffers::VOffsetT = 22;
    pub const VT_SPECIALMATWATER: flatbuffers::VOffsetT = 24;
    pub const VT_WORKBENCHMAKELIMIT: flatbuffers::VOffsetT = 26;
    pub const VT_LOGISTICSPOSLIMIT: flatbuffers::VOffsetT = 28;
    pub const VT_LOGISTICSUNLOCKLEVEL: flatbuffers::VOffsetT = 30;
    pub const VT_LOGISTICSDRINKCOST: flatbuffers::VOffsetT = 32;
    pub const VT_LOGISTICSEVACUATETIPS: flatbuffers::VOffsetT = 34;
    pub const VT_LOGISTICSEVACUATEWARNING: flatbuffers::VOffsetT = 36;
    pub const VT_BASEREPAIRCOST: flatbuffers::VOffsetT = 38;
    pub const VT_PORTREPAIRCOST: flatbuffers::VOffsetT = 40;
    pub const VT_UNITFENCELIMIT: flatbuffers::VOffsetT = 42;
    pub const VT_UNITRAREFENCELIMIT: flatbuffers::VOffsetT = 44;
    pub const VT_CAGEID: flatbuffers::VOffsetT = 46;
    pub const VT_FENCEID: flatbuffers::VOffsetT = 48;
    pub const VT_RAREFENCEID: flatbuffers::VOffsetT = 50;
    pub const VT_MONTHLYRUSHENTRYTEXT1: flatbuffers::VOffsetT = 52;
    pub const VT_MONTHLYENTRYUNLOCKTEXT: flatbuffers::VOffsetT = 54;
    pub const VT_MONTHLYENTRYRIFTTEXT: flatbuffers::VOffsetT = 56;
    pub const VT_MONTHLYRUSHINTRO: flatbuffers::VOffsetT = 58;
    pub const VT_MONTHLYCOIN: flatbuffers::VOffsetT = 60;
    pub const VT_CHARRARITYCOLORLIST: flatbuffers::VOffsetT = 62;
    pub const VT_SQUADCHARCAPACITY: flatbuffers::VOffsetT = 64;
    pub const VT_TOTALSQUADCNT: flatbuffers::VOffsetT = 66;
    pub const VT_TOOLBOXCAPACITY: flatbuffers::VOffsetT = 68;
    pub const VT_TOOLCNTLIMITINSQUAD: flatbuffers::VOffsetT = 70;
    pub const VT_MINISQUADCHARCAPACITY: flatbuffers::VOffsetT = 72;
    pub const VT_MINISQUADDRINKCOST: flatbuffers::VOffsetT = 74;
    pub const VT_NORMALSQUADDRINKCOST: flatbuffers::VOffsetT = 76;
    pub const VT_EMPTYSQUADDRINKCOST: flatbuffers::VOffsetT = 78;
    pub const VT_ACHIEVETYPEALL: flatbuffers::VOffsetT = 80;
    pub const VT_CONSTRUCTMODEBGMHOME: flatbuffers::VOffsetT = 82;
    pub const VT_BATTLEBGMCOLLECT: flatbuffers::VOffsetT = 84;
    pub const VT_BATTLEBGMHUNT: flatbuffers::VOffsetT = 86;
    pub const VT_BATTLEBGMENEMYRUSH: flatbuffers::VOffsetT = 88;
    pub const VT_BATTLEBGMBOSSRUSH: flatbuffers::VOffsetT = 90;
    pub const VT_IMGLOADINGNORMALNAME: flatbuffers::VOffsetT = 92;
    pub const VT_IMGLOADINGBASENAME: flatbuffers::VOffsetT = 94;
    pub const VT_IMGUNLOADINGBASENAME: flatbuffers::VOffsetT = 96;
    pub const VT_ISCHALLENGEOPEN: flatbuffers::VOffsetT = 98;
    pub const VT_ISRACINGOPEN: flatbuffers::VOffsetT = 100;
    pub const VT_HASEXPLOREMODE: flatbuffers::VOffsetT = 102;
    pub const VT_EXPLOREMODEBUFFDESCS: flatbuffers::VOffsetT = 104;
    pub const VT_MODESELECTTIPS: flatbuffers::VOffsetT = 106;
    pub const VT_STRINGRES: flatbuffers::VOffsetT = 108;
    pub const VT_DIFFLIST: flatbuffers::VOffsetT = 110;
    pub const VT_BATTLEPRELOADENEMIES: flatbuffers::VOffsetT = 112;
    pub const VT_BATTLEEXCLUDEDTRAPSINRUSH: flatbuffers::VOffsetT = 114;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2BasicConst { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2BasicConstArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BasicConst<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2BasicConstBuilder::new(_fbb);
        if let Some(x) = args.battleExcludedTrapsInRush {
            builder.add_battleExcludedTrapsInRush(x);
        }
        if let Some(x) = args.battlePreloadEnemies {
            builder.add_battlePreloadEnemies(x);
        }
        if let Some(x) = args.diffList {
            builder.add_diffList(x);
        }
        if let Some(x) = args.stringRes {
            builder.add_stringRes(x);
        }
        if let Some(x) = args.modeSelectTips {
            builder.add_modeSelectTips(x);
        }
        if let Some(x) = args.exploreModeBuffDescs {
            builder.add_exploreModeBuffDescs(x);
        }
        if let Some(x) = args.imgUnloadingBaseName {
            builder.add_imgUnloadingBaseName(x);
        }
        if let Some(x) = args.imgLoadingBaseName {
            builder.add_imgLoadingBaseName(x);
        }
        if let Some(x) = args.imgLoadingNormalName {
            builder.add_imgLoadingNormalName(x);
        }
        if let Some(x) = args.battleBgmBossRush {
            builder.add_battleBgmBossRush(x);
        }
        if let Some(x) = args.battleBgmEnemyRush {
            builder.add_battleBgmEnemyRush(x);
        }
        if let Some(x) = args.battleBgmHunt {
            builder.add_battleBgmHunt(x);
        }
        if let Some(x) = args.battleBgmCollect {
            builder.add_battleBgmCollect(x);
        }
        if let Some(x) = args.constructModeBgmHome {
            builder.add_constructModeBgmHome(x);
        }
        if let Some(x) = args.achieveTypeAll {
            builder.add_achieveTypeAll(x);
        }
        builder.add_emptySquadDrinkCost(args.emptySquadDrinkCost);
        builder.add_normalSquadDrinkCost(args.normalSquadDrinkCost);
        builder.add_miniSquadDrinkCost(args.miniSquadDrinkCost);
        builder.add_miniSquadCharCapacity(args.miniSquadCharCapacity);
        builder.add_toolCntLimitInSquad(args.toolCntLimitInSquad);
        builder.add_toolboxCapacity(args.toolboxCapacity);
        builder.add_totalSquadCnt(args.totalSquadCnt);
        builder.add_squadCharCapacity(args.squadCharCapacity);
        if let Some(x) = args.charRarityColorList {
            builder.add_charRarityColorList(x);
        }
        if let Some(x) = args.monthlyCoin {
            builder.add_monthlyCoin(x);
        }
        if let Some(x) = args.monthlyRushIntro {
            builder.add_monthlyRushIntro(x);
        }
        if let Some(x) = args.monthlyEntryRiftText {
            builder.add_monthlyEntryRiftText(x);
        }
        if let Some(x) = args.monthlyEntryUnlockText {
            builder.add_monthlyEntryUnlockText(x);
        }
        if let Some(x) = args.monthlyRushEntryText1 {
            builder.add_monthlyRushEntryText1(x);
        }
        if let Some(x) = args.rareFenceId {
            builder.add_rareFenceId(x);
        }
        if let Some(x) = args.fenceId {
            builder.add_fenceId(x);
        }
        if let Some(x) = args.cageId {
            builder.add_cageId(x);
        }
        builder.add_unitRareFenceLimit(args.unitRareFenceLimit);
        builder.add_unitFenceLimit(args.unitFenceLimit);
        builder.add_portRepairCost(args.portRepairCost);
        builder.add_baseRepairCost(args.baseRepairCost);
        if let Some(x) = args.logisticsEvacuateWarning {
            builder.add_logisticsEvacuateWarning(x);
        }
        if let Some(x) = args.logisticsEvacuateTips {
            builder.add_logisticsEvacuateTips(x);
        }
        builder.add_logisticsDrinkCost(args.logisticsDrinkCost);
        builder.add_logisticsUnlockLevel(args.logisticsUnlockLevel);
        builder.add_logisticsPosLimit(args.logisticsPosLimit);
        builder.add_workbenchMakeLimit(args.workbenchMakeLimit);
        if let Some(x) = args.specialMatWater {
            builder.add_specialMatWater(x);
        }
        builder.add_drinkMakeLimit(args.drinkMakeLimit);
        builder.add_drinkCostOnce(args.drinkCostOnce);
        builder.add_maxFoodDuration(args.maxFoodDuration);
        if let Some(x) = args.failedCookFood {
            builder.add_failedCookFood(x);
        }
        if let Some(x) = args.bagBottomBarResType {
            builder.add_bagBottomBarResType(x);
        }
        if let Some(x) = args.alwaysShowItemIds {
            builder.add_alwaysShowItemIds(x);
        }
        if let Some(x) = args.alwaysShowItemIdsConstruct {
            builder.add_alwaysShowItemIdsConstruct(x);
        }
        if let Some(x) = args.dimensioncoinItemId {
            builder.add_dimensioncoinItemId(x);
        }
        if let Some(x) = args.goldItemId {
            builder.add_goldItemId(x);
        }
        if let Some(x) = args.staminaItemId {
            builder.add_staminaItemId(x);
        }
        builder.add_hasExploreMode(args.hasExploreMode);
        builder.add_isRacingOpen(args.isRacingOpen);
        builder.add_isChallengeOpen(args.isChallengeOpen);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2BasicConstT {
        let staminaItemId = self.staminaItemId().map(|x| x.to_string());
        let goldItemId = self.goldItemId().map(|x| x.to_string());
        let dimensioncoinItemId = self.dimensioncoinItemId().map(|x| x.to_string());
        let alwaysShowItemIdsConstruct = self
            .alwaysShowItemIdsConstruct()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let alwaysShowItemIds = self
            .alwaysShowItemIds()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let bagBottomBarResType = self
            .bagBottomBarResType()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let failedCookFood = self.failedCookFood().map(|x| x.to_string());
        let maxFoodDuration = self.maxFoodDuration();
        let drinkCostOnce = self.drinkCostOnce();
        let drinkMakeLimit = self.drinkMakeLimit();
        let specialMatWater = self.specialMatWater().map(|x| x.to_string());
        let workbenchMakeLimit = self.workbenchMakeLimit();
        let logisticsPosLimit = self.logisticsPosLimit();
        let logisticsUnlockLevel = self.logisticsUnlockLevel();
        let logisticsDrinkCost = self.logisticsDrinkCost();
        let logisticsEvacuateTips = self.logisticsEvacuateTips().map(|x| x.to_string());
        let logisticsEvacuateWarning = self.logisticsEvacuateWarning().map(|x| x.to_string());
        let baseRepairCost = self.baseRepairCost();
        let portRepairCost = self.portRepairCost();
        let unitFenceLimit = self.unitFenceLimit();
        let unitRareFenceLimit = self.unitRareFenceLimit();
        let cageId = self.cageId().map(|x| x.to_string());
        let fenceId = self.fenceId().map(|x| x.to_string());
        let rareFenceId = self.rareFenceId().map(|x| x.to_string());
        let monthlyRushEntryText1 = self.monthlyRushEntryText1().map(|x| x.to_string());
        let monthlyEntryUnlockText = self.monthlyEntryUnlockText().map(|x| x.to_string());
        let monthlyEntryRiftText = self.monthlyEntryRiftText().map(|x| x.to_string());
        let monthlyRushIntro = self.monthlyRushIntro().map(|x| x.to_string());
        let monthlyCoin = self.monthlyCoin().map(|x| Box::new(x.unpack()));
        let charRarityColorList = self
            .charRarityColorList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let squadCharCapacity = self.squadCharCapacity();
        let totalSquadCnt = self.totalSquadCnt();
        let toolboxCapacity = self.toolboxCapacity();
        let toolCntLimitInSquad = self.toolCntLimitInSquad();
        let miniSquadCharCapacity = self.miniSquadCharCapacity();
        let miniSquadDrinkCost = self.miniSquadDrinkCost();
        let normalSquadDrinkCost = self.normalSquadDrinkCost();
        let emptySquadDrinkCost = self.emptySquadDrinkCost();
        let achieveTypeAll = self.achieveTypeAll().map(|x| x.to_string());
        let constructModeBgmHome = self.constructModeBgmHome().map(|x| x.to_string());
        let battleBgmCollect = self.battleBgmCollect().map(|x| x.to_string());
        let battleBgmHunt = self.battleBgmHunt().map(|x| x.to_string());
        let battleBgmEnemyRush = self.battleBgmEnemyRush().map(|x| x.to_string());
        let battleBgmBossRush = self.battleBgmBossRush().map(|x| x.to_string());
        let imgLoadingNormalName = self.imgLoadingNormalName().map(|x| x.to_string());
        let imgLoadingBaseName = self.imgLoadingBaseName().map(|x| x.to_string());
        let imgUnloadingBaseName = self.imgUnloadingBaseName().map(|x| x.to_string());
        let isChallengeOpen = self.isChallengeOpen();
        let isRacingOpen = self.isRacingOpen();
        let hasExploreMode = self.hasExploreMode();
        let exploreModeBuffDescs = self
            .exploreModeBuffDescs()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let modeSelectTips = self.modeSelectTips().map(|x| x.to_string());
        let stringRes = self
            .stringRes()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let diffList = self
            .diffList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let battlePreloadEnemies = self
            .battlePreloadEnemies()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let battleExcludedTrapsInRush = self
            .battleExcludedTrapsInRush()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_SandboxV2BasicConstT {
            staminaItemId,
            goldItemId,
            dimensioncoinItemId,
            alwaysShowItemIdsConstruct,
            alwaysShowItemIds,
            bagBottomBarResType,
            failedCookFood,
            maxFoodDuration,
            drinkCostOnce,
            drinkMakeLimit,
            specialMatWater,
            workbenchMakeLimit,
            logisticsPosLimit,
            logisticsUnlockLevel,
            logisticsDrinkCost,
            logisticsEvacuateTips,
            logisticsEvacuateWarning,
            baseRepairCost,
            portRepairCost,
            unitFenceLimit,
            unitRareFenceLimit,
            cageId,
            fenceId,
            rareFenceId,
            monthlyRushEntryText1,
            monthlyEntryUnlockText,
            monthlyEntryRiftText,
            monthlyRushIntro,
            monthlyCoin,
            charRarityColorList,
            squadCharCapacity,
            totalSquadCnt,
            toolboxCapacity,
            toolCntLimitInSquad,
            miniSquadCharCapacity,
            miniSquadDrinkCost,
            normalSquadDrinkCost,
            emptySquadDrinkCost,
            achieveTypeAll,
            constructModeBgmHome,
            battleBgmCollect,
            battleBgmHunt,
            battleBgmEnemyRush,
            battleBgmBossRush,
            imgLoadingNormalName,
            imgLoadingBaseName,
            imgUnloadingBaseName,
            isChallengeOpen,
            isRacingOpen,
            hasExploreMode,
            exploreModeBuffDescs,
            modeSelectTips,
            stringRes,
            diffList,
            battlePreloadEnemies,
            battleExcludedTrapsInRush,
        }
    }

    #[inline]
    pub fn staminaItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_STAMINAITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn goldItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_GOLDITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn dimensioncoinItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_DIMENSIONCOINITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn alwaysShowItemIdsConstruct(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2BasicConst::VT_ALWAYSSHOWITEMIDSCONSTRUCT,
                None,
            )
        }
    }
    #[inline]
    pub fn alwaysShowItemIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxV2BasicConst::VT_ALWAYSSHOWITEMIDS, None)
        }
    }
    #[inline]
    pub fn bagBottomBarResType(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2BasicConst::VT_BAGBOTTOMBARRESTYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn failedCookFood(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_FAILEDCOOKFOOD,
                None,
            )
        }
    }
    #[inline]
    pub fn maxFoodDuration(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2BasicConst::VT_MAXFOODDURATION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn drinkCostOnce(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2BasicConst::VT_DRINKCOSTONCE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn drinkMakeLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2BasicConst::VT_DRINKMAKELIMIT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn specialMatWater(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_SPECIALMATWATER,
                None,
            )
        }
    }
    #[inline]
    pub fn workbenchMakeLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BasicConst::VT_WORKBENCHMAKELIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn logisticsPosLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BasicConst::VT_LOGISTICSPOSLIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn logisticsUnlockLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BasicConst::VT_LOGISTICSUNLOCKLEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn logisticsDrinkCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BasicConst::VT_LOGISTICSDRINKCOST,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn logisticsEvacuateTips(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_LOGISTICSEVACUATETIPS,
                None,
            )
        }
    }
    #[inline]
    pub fn logisticsEvacuateWarning(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_LOGISTICSEVACUATEWARNING,
                None,
            )
        }
    }
    #[inline]
    pub fn baseRepairCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2BasicConst::VT_BASEREPAIRCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn portRepairCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2BasicConst::VT_PORTREPAIRCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn unitFenceLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2BasicConst::VT_UNITFENCELIMIT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn unitRareFenceLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BasicConst::VT_UNITRAREFENCELIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn cageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_CAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn fenceId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_FENCEID,
                None,
            )
        }
    }
    #[inline]
    pub fn rareFenceId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_RAREFENCEID,
                None,
            )
        }
    }
    #[inline]
    pub fn monthlyRushEntryText1(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_MONTHLYRUSHENTRYTEXT1,
                None,
            )
        }
    }
    #[inline]
    pub fn monthlyEntryUnlockText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_MONTHLYENTRYUNLOCKTEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn monthlyEntryRiftText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_MONTHLYENTRYRIFTTEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn monthlyRushIntro(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_MONTHLYRUSHINTRO,
                None,
            )
        }
    }
    #[inline]
    pub fn monthlyCoin(&self) -> Option<clz_Torappu_ItemBundle<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>(
                    clz_Torappu_SandboxV2BasicConst::VT_MONTHLYCOIN,
                    None,
                )
        }
    }
    #[inline]
    pub fn charRarityColorList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2BasicConst::VT_CHARRARITYCOLORLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn squadCharCapacity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BasicConst::VT_SQUADCHARCAPACITY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn totalSquadCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2BasicConst::VT_TOTALSQUADCNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn toolboxCapacity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2BasicConst::VT_TOOLBOXCAPACITY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn toolCntLimitInSquad(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BasicConst::VT_TOOLCNTLIMITINSQUAD,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn miniSquadCharCapacity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BasicConst::VT_MINISQUADCHARCAPACITY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn miniSquadDrinkCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BasicConst::VT_MINISQUADDRINKCOST,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn normalSquadDrinkCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BasicConst::VT_NORMALSQUADDRINKCOST,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn emptySquadDrinkCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BasicConst::VT_EMPTYSQUADDRINKCOST,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn achieveTypeAll(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_ACHIEVETYPEALL,
                None,
            )
        }
    }
    #[inline]
    pub fn constructModeBgmHome(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_CONSTRUCTMODEBGMHOME,
                None,
            )
        }
    }
    #[inline]
    pub fn battleBgmCollect(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_BATTLEBGMCOLLECT,
                None,
            )
        }
    }
    #[inline]
    pub fn battleBgmHunt(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_BATTLEBGMHUNT,
                None,
            )
        }
    }
    #[inline]
    pub fn battleBgmEnemyRush(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_BATTLEBGMENEMYRUSH,
                None,
            )
        }
    }
    #[inline]
    pub fn battleBgmBossRush(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_BATTLEBGMBOSSRUSH,
                None,
            )
        }
    }
    #[inline]
    pub fn imgLoadingNormalName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_IMGLOADINGNORMALNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn imgLoadingBaseName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_IMGLOADINGBASENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn imgUnloadingBaseName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_IMGUNLOADINGBASENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn isChallengeOpen(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_SandboxV2BasicConst::VT_ISCHALLENGEOPEN,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn isRacingOpen(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_SandboxV2BasicConst::VT_ISRACINGOPEN,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn hasExploreMode(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_SandboxV2BasicConst::VT_HASEXPLOREMODE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn exploreModeBuffDescs(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2BasicConst::VT_EXPLOREMODEBUFFDESCS,
                None,
            )
        }
    }
    #[inline]
    pub fn modeSelectTips(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BasicConst::VT_MODESELECTTIPS,
                None,
            )
        }
    }
    #[inline]
    pub fn stringRes(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(clz_Torappu_SandboxV2BasicConst::VT_STRINGRES, None)
        }
    }
    #[inline]
    pub fn diffList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DiffModeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DiffModeData>,
                >,
            >>(clz_Torappu_SandboxV2BasicConst::VT_DIFFLIST, None)
        }
    }
    #[inline]
    pub fn battlePreloadEnemies(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2BasicConst::VT_BATTLEPRELOADENEMIES,
                None,
            )
        }
    }
    #[inline]
    pub fn battleExcludedTrapsInRush(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2BasicConst::VT_BATTLEEXCLUDEDTRAPSINRUSH,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2BasicConst<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "staminaItemId",
                Self::VT_STAMINAITEMID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "goldItemId",
                Self::VT_GOLDITEMID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dimensioncoinItemId",
                Self::VT_DIMENSIONCOINITEMID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "alwaysShowItemIdsConstruct",
                Self::VT_ALWAYSSHOWITEMIDSCONSTRUCT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("alwaysShowItemIds", Self::VT_ALWAYSSHOWITEMIDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("bagBottomBarResType", Self::VT_BAGBOTTOMBARRESTYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "failedCookFood",
                Self::VT_FAILEDCOOKFOOD,
                false,
            )?
            .visit_field::<i32>("maxFoodDuration", Self::VT_MAXFOODDURATION, false)?
            .visit_field::<i32>("drinkCostOnce", Self::VT_DRINKCOSTONCE, false)?
            .visit_field::<i32>("drinkMakeLimit", Self::VT_DRINKMAKELIMIT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "specialMatWater",
                Self::VT_SPECIALMATWATER,
                false,
            )?
            .visit_field::<i32>("workbenchMakeLimit", Self::VT_WORKBENCHMAKELIMIT, false)?
            .visit_field::<i32>("logisticsPosLimit", Self::VT_LOGISTICSPOSLIMIT, false)?
            .visit_field::<i32>("logisticsUnlockLevel", Self::VT_LOGISTICSUNLOCKLEVEL, false)?
            .visit_field::<i32>("logisticsDrinkCost", Self::VT_LOGISTICSDRINKCOST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "logisticsEvacuateTips",
                Self::VT_LOGISTICSEVACUATETIPS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "logisticsEvacuateWarning",
                Self::VT_LOGISTICSEVACUATEWARNING,
                false,
            )?
            .visit_field::<i32>("baseRepairCost", Self::VT_BASEREPAIRCOST, false)?
            .visit_field::<i32>("portRepairCost", Self::VT_PORTREPAIRCOST, false)?
            .visit_field::<i32>("unitFenceLimit", Self::VT_UNITFENCELIMIT, false)?
            .visit_field::<i32>("unitRareFenceLimit", Self::VT_UNITRAREFENCELIMIT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cageId", Self::VT_CAGEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fenceId", Self::VT_FENCEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rareFenceId",
                Self::VT_RAREFENCEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "monthlyRushEntryText1",
                Self::VT_MONTHLYRUSHENTRYTEXT1,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "monthlyEntryUnlockText",
                Self::VT_MONTHLYENTRYUNLOCKTEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "monthlyEntryRiftText",
                Self::VT_MONTHLYENTRYRIFTTEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "monthlyRushIntro",
                Self::VT_MONTHLYRUSHINTRO,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>(
                "monthlyCoin",
                Self::VT_MONTHLYCOIN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("charRarityColorList", Self::VT_CHARRARITYCOLORLIST, false)?
            .visit_field::<i32>("squadCharCapacity", Self::VT_SQUADCHARCAPACITY, false)?
            .visit_field::<i32>("totalSquadCnt", Self::VT_TOTALSQUADCNT, false)?
            .visit_field::<i32>("toolboxCapacity", Self::VT_TOOLBOXCAPACITY, false)?
            .visit_field::<i32>("toolCntLimitInSquad", Self::VT_TOOLCNTLIMITINSQUAD, false)?
            .visit_field::<i32>(
                "miniSquadCharCapacity",
                Self::VT_MINISQUADCHARCAPACITY,
                false,
            )?
            .visit_field::<i32>("miniSquadDrinkCost", Self::VT_MINISQUADDRINKCOST, false)?
            .visit_field::<i32>("normalSquadDrinkCost", Self::VT_NORMALSQUADDRINKCOST, false)?
            .visit_field::<i32>("emptySquadDrinkCost", Self::VT_EMPTYSQUADDRINKCOST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "achieveTypeAll",
                Self::VT_ACHIEVETYPEALL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "constructModeBgmHome",
                Self::VT_CONSTRUCTMODEBGMHOME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "battleBgmCollect",
                Self::VT_BATTLEBGMCOLLECT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "battleBgmHunt",
                Self::VT_BATTLEBGMHUNT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "battleBgmEnemyRush",
                Self::VT_BATTLEBGMENEMYRUSH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "battleBgmBossRush",
                Self::VT_BATTLEBGMBOSSRUSH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "imgLoadingNormalName",
                Self::VT_IMGLOADINGNORMALNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "imgLoadingBaseName",
                Self::VT_IMGLOADINGBASENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "imgUnloadingBaseName",
                Self::VT_IMGUNLOADINGBASENAME,
                false,
            )?
            .visit_field::<bool>("isChallengeOpen", Self::VT_ISCHALLENGEOPEN, false)?
            .visit_field::<bool>("isRacingOpen", Self::VT_ISRACINGOPEN, false)?
            .visit_field::<bool>("hasExploreMode", Self::VT_HASEXPLOREMODE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("exploreModeBuffDescs", Self::VT_EXPLOREMODEBUFFDESCS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "modeSelectTips",
                Self::VT_MODESELECTTIPS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>("stringRes", Self::VT_STRINGRES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DiffModeData>,
                >,
            >>("diffList", Self::VT_DIFFLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("battlePreloadEnemies", Self::VT_BATTLEPRELOADENEMIES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "battleExcludedTrapsInRush",
                Self::VT_BATTLEEXCLUDEDTRAPSINRUSH,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2BasicConstArgs<'a> {
    pub staminaItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub goldItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dimensioncoinItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub alwaysShowItemIdsConstruct: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub alwaysShowItemIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub bagBottomBarResType: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub failedCookFood: Option<flatbuffers::WIPOffset<&'a str>>,
    pub maxFoodDuration: i32,
    pub drinkCostOnce: i32,
    pub drinkMakeLimit: i32,
    pub specialMatWater: Option<flatbuffers::WIPOffset<&'a str>>,
    pub workbenchMakeLimit: i32,
    pub logisticsPosLimit: i32,
    pub logisticsUnlockLevel: i32,
    pub logisticsDrinkCost: i32,
    pub logisticsEvacuateTips: Option<flatbuffers::WIPOffset<&'a str>>,
    pub logisticsEvacuateWarning: Option<flatbuffers::WIPOffset<&'a str>>,
    pub baseRepairCost: i32,
    pub portRepairCost: i32,
    pub unitFenceLimit: i32,
    pub unitRareFenceLimit: i32,
    pub cageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub fenceId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rareFenceId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub monthlyRushEntryText1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub monthlyEntryUnlockText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub monthlyEntryRiftText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub monthlyRushIntro: Option<flatbuffers::WIPOffset<&'a str>>,
    pub monthlyCoin: Option<flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'a>>>,
    pub charRarityColorList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub squadCharCapacity: i32,
    pub totalSquadCnt: i32,
    pub toolboxCapacity: i32,
    pub toolCntLimitInSquad: i32,
    pub miniSquadCharCapacity: i32,
    pub miniSquadDrinkCost: i32,
    pub normalSquadDrinkCost: i32,
    pub emptySquadDrinkCost: i32,
    pub achieveTypeAll: Option<flatbuffers::WIPOffset<&'a str>>,
    pub constructModeBgmHome: Option<flatbuffers::WIPOffset<&'a str>>,
    pub battleBgmCollect: Option<flatbuffers::WIPOffset<&'a str>>,
    pub battleBgmHunt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub battleBgmEnemyRush: Option<flatbuffers::WIPOffset<&'a str>>,
    pub battleBgmBossRush: Option<flatbuffers::WIPOffset<&'a str>>,
    pub imgLoadingNormalName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub imgLoadingBaseName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub imgUnloadingBaseName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isChallengeOpen: bool,
    pub isRacingOpen: bool,
    pub hasExploreMode: bool,
    pub exploreModeBuffDescs: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub modeSelectTips: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stringRes: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>,
        >,
    >,
    pub diffList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DiffModeData<'a>>,
            >,
        >,
    >,
    pub battlePreloadEnemies: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub battleExcludedTrapsInRush: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2BasicConstArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2BasicConstArgs {
            staminaItemId: None,
            goldItemId: None,
            dimensioncoinItemId: None,
            alwaysShowItemIdsConstruct: None,
            alwaysShowItemIds: None,
            bagBottomBarResType: None,
            failedCookFood: None,
            maxFoodDuration: 0,
            drinkCostOnce: 0,
            drinkMakeLimit: 0,
            specialMatWater: None,
            workbenchMakeLimit: 0,
            logisticsPosLimit: 0,
            logisticsUnlockLevel: 0,
            logisticsDrinkCost: 0,
            logisticsEvacuateTips: None,
            logisticsEvacuateWarning: None,
            baseRepairCost: 0,
            portRepairCost: 0,
            unitFenceLimit: 0,
            unitRareFenceLimit: 0,
            cageId: None,
            fenceId: None,
            rareFenceId: None,
            monthlyRushEntryText1: None,
            monthlyEntryUnlockText: None,
            monthlyEntryRiftText: None,
            monthlyRushIntro: None,
            monthlyCoin: None,
            charRarityColorList: None,
            squadCharCapacity: 0,
            totalSquadCnt: 0,
            toolboxCapacity: 0,
            toolCntLimitInSquad: 0,
            miniSquadCharCapacity: 0,
            miniSquadDrinkCost: 0,
            normalSquadDrinkCost: 0,
            emptySquadDrinkCost: 0,
            achieveTypeAll: None,
            constructModeBgmHome: None,
            battleBgmCollect: None,
            battleBgmHunt: None,
            battleBgmEnemyRush: None,
            battleBgmBossRush: None,
            imgLoadingNormalName: None,
            imgLoadingBaseName: None,
            imgUnloadingBaseName: None,
            isChallengeOpen: false,
            isRacingOpen: false,
            hasExploreMode: false,
            exploreModeBuffDescs: None,
            modeSelectTips: None,
            stringRes: None,
            diffList: None,
            battlePreloadEnemies: None,
            battleExcludedTrapsInRush: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2BasicConst<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2BasicConst", 56)?;
        if let Some(f) = self.staminaItemId() {
            s.serialize_field("staminaItemId", &f)?;
        } else {
            s.skip_field("staminaItemId")?;
        }
        if let Some(f) = self.goldItemId() {
            s.serialize_field("goldItemId", &f)?;
        } else {
            s.skip_field("goldItemId")?;
        }
        if let Some(f) = self.dimensioncoinItemId() {
            s.serialize_field("dimensioncoinItemId", &f)?;
        } else {
            s.skip_field("dimensioncoinItemId")?;
        }
        if let Some(f) = self.alwaysShowItemIdsConstruct() {
            s.serialize_field("alwaysShowItemIdsConstruct", &f)?;
        } else {
            s.skip_field("alwaysShowItemIdsConstruct")?;
        }
        if let Some(f) = self.alwaysShowItemIds() {
            s.serialize_field("alwaysShowItemIds", &f)?;
        } else {
            s.skip_field("alwaysShowItemIds")?;
        }
        if let Some(f) = self.bagBottomBarResType() {
            s.serialize_field("bagBottomBarResType", &f)?;
        } else {
            s.skip_field("bagBottomBarResType")?;
        }
        if let Some(f) = self.failedCookFood() {
            s.serialize_field("failedCookFood", &f)?;
        } else {
            s.skip_field("failedCookFood")?;
        }
        s.serialize_field("maxFoodDuration", &self.maxFoodDuration())?;
        s.serialize_field("drinkCostOnce", &self.drinkCostOnce())?;
        s.serialize_field("drinkMakeLimit", &self.drinkMakeLimit())?;
        if let Some(f) = self.specialMatWater() {
            s.serialize_field("specialMatWater", &f)?;
        } else {
            s.skip_field("specialMatWater")?;
        }
        s.serialize_field("workbenchMakeLimit", &self.workbenchMakeLimit())?;
        s.serialize_field("logisticsPosLimit", &self.logisticsPosLimit())?;
        s.serialize_field("logisticsUnlockLevel", &self.logisticsUnlockLevel())?;
        s.serialize_field("logisticsDrinkCost", &self.logisticsDrinkCost())?;
        if let Some(f) = self.logisticsEvacuateTips() {
            s.serialize_field("logisticsEvacuateTips", &f)?;
        } else {
            s.skip_field("logisticsEvacuateTips")?;
        }
        if let Some(f) = self.logisticsEvacuateWarning() {
            s.serialize_field("logisticsEvacuateWarning", &f)?;
        } else {
            s.skip_field("logisticsEvacuateWarning")?;
        }
        s.serialize_field("baseRepairCost", &self.baseRepairCost())?;
        s.serialize_field("portRepairCost", &self.portRepairCost())?;
        s.serialize_field("unitFenceLimit", &self.unitFenceLimit())?;
        s.serialize_field("unitRareFenceLimit", &self.unitRareFenceLimit())?;
        if let Some(f) = self.cageId() {
            s.serialize_field("cageId", &f)?;
        } else {
            s.skip_field("cageId")?;
        }
        if let Some(f) = self.fenceId() {
            s.serialize_field("fenceId", &f)?;
        } else {
            s.skip_field("fenceId")?;
        }
        if let Some(f) = self.rareFenceId() {
            s.serialize_field("rareFenceId", &f)?;
        } else {
            s.skip_field("rareFenceId")?;
        }
        if let Some(f) = self.monthlyRushEntryText1() {
            s.serialize_field("monthlyRushEntryText1", &f)?;
        } else {
            s.skip_field("monthlyRushEntryText1")?;
        }
        if let Some(f) = self.monthlyEntryUnlockText() {
            s.serialize_field("monthlyEntryUnlockText", &f)?;
        } else {
            s.skip_field("monthlyEntryUnlockText")?;
        }
        if let Some(f) = self.monthlyEntryRiftText() {
            s.serialize_field("monthlyEntryRiftText", &f)?;
        } else {
            s.skip_field("monthlyEntryRiftText")?;
        }
        if let Some(f) = self.monthlyRushIntro() {
            s.serialize_field("monthlyRushIntro", &f)?;
        } else {
            s.skip_field("monthlyRushIntro")?;
        }
        if let Some(f) = self.monthlyCoin() {
            s.serialize_field("monthlyCoin", &f)?;
        } else {
            s.skip_field("monthlyCoin")?;
        }
        if let Some(f) = self.charRarityColorList() {
            s.serialize_field("charRarityColorList", &f)?;
        } else {
            s.skip_field("charRarityColorList")?;
        }
        s.serialize_field("squadCharCapacity", &self.squadCharCapacity())?;
        s.serialize_field("totalSquadCnt", &self.totalSquadCnt())?;
        s.serialize_field("toolboxCapacity", &self.toolboxCapacity())?;
        s.serialize_field("toolCntLimitInSquad", &self.toolCntLimitInSquad())?;
        s.serialize_field("miniSquadCharCapacity", &self.miniSquadCharCapacity())?;
        s.serialize_field("miniSquadDrinkCost", &self.miniSquadDrinkCost())?;
        s.serialize_field("normalSquadDrinkCost", &self.normalSquadDrinkCost())?;
        s.serialize_field("emptySquadDrinkCost", &self.emptySquadDrinkCost())?;
        if let Some(f) = self.achieveTypeAll() {
            s.serialize_field("achieveTypeAll", &f)?;
        } else {
            s.skip_field("achieveTypeAll")?;
        }
        if let Some(f) = self.constructModeBgmHome() {
            s.serialize_field("constructModeBgmHome", &f)?;
        } else {
            s.skip_field("constructModeBgmHome")?;
        }
        if let Some(f) = self.battleBgmCollect() {
            s.serialize_field("battleBgmCollect", &f)?;
        } else {
            s.skip_field("battleBgmCollect")?;
        }
        if let Some(f) = self.battleBgmHunt() {
            s.serialize_field("battleBgmHunt", &f)?;
        } else {
            s.skip_field("battleBgmHunt")?;
        }
        if let Some(f) = self.battleBgmEnemyRush() {
            s.serialize_field("battleBgmEnemyRush", &f)?;
        } else {
            s.skip_field("battleBgmEnemyRush")?;
        }
        if let Some(f) = self.battleBgmBossRush() {
            s.serialize_field("battleBgmBossRush", &f)?;
        } else {
            s.skip_field("battleBgmBossRush")?;
        }
        if let Some(f) = self.imgLoadingNormalName() {
            s.serialize_field("imgLoadingNormalName", &f)?;
        } else {
            s.skip_field("imgLoadingNormalName")?;
        }
        if let Some(f) = self.imgLoadingBaseName() {
            s.serialize_field("imgLoadingBaseName", &f)?;
        } else {
            s.skip_field("imgLoadingBaseName")?;
        }
        if let Some(f) = self.imgUnloadingBaseName() {
            s.serialize_field("imgUnloadingBaseName", &f)?;
        } else {
            s.skip_field("imgUnloadingBaseName")?;
        }
        s.serialize_field("isChallengeOpen", &self.isChallengeOpen())?;
        s.serialize_field("isRacingOpen", &self.isRacingOpen())?;
        s.serialize_field("hasExploreMode", &self.hasExploreMode())?;
        if let Some(f) = self.exploreModeBuffDescs() {
            s.serialize_field("exploreModeBuffDescs", &f)?;
        } else {
            s.skip_field("exploreModeBuffDescs")?;
        }
        if let Some(f) = self.modeSelectTips() {
            s.serialize_field("modeSelectTips", &f)?;
        } else {
            s.skip_field("modeSelectTips")?;
        }
        if let Some(f) = self.stringRes() {
            s.serialize_field("stringRes", &f)?;
        } else {
            s.skip_field("stringRes")?;
        }
        if let Some(f) = self.diffList() {
            s.serialize_field("diffList", &f)?;
        } else {
            s.skip_field("diffList")?;
        }
        if let Some(f) = self.battlePreloadEnemies() {
            s.serialize_field("battlePreloadEnemies", &f)?;
        } else {
            s.skip_field("battlePreloadEnemies")?;
        }
        if let Some(f) = self.battleExcludedTrapsInRush() {
            s.serialize_field("battleExcludedTrapsInRush", &f)?;
        } else {
            s.skip_field("battleExcludedTrapsInRush")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2BasicConstBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2BasicConstBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_staminaItemId(&mut self, staminaItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_STAMINAITEMID,
            staminaItemId,
        );
    }
    #[inline]
    pub fn add_goldItemId(&mut self, goldItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_GOLDITEMID,
            goldItemId,
        );
    }
    #[inline]
    pub fn add_dimensioncoinItemId(
        &mut self,
        dimensioncoinItemId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_DIMENSIONCOINITEMID,
            dimensioncoinItemId,
        );
    }
    #[inline]
    pub fn add_alwaysShowItemIdsConstruct(
        &mut self,
        alwaysShowItemIdsConstruct: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_ALWAYSSHOWITEMIDSCONSTRUCT,
            alwaysShowItemIdsConstruct,
        );
    }
    #[inline]
    pub fn add_alwaysShowItemIds(
        &mut self,
        alwaysShowItemIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_ALWAYSSHOWITEMIDS,
            alwaysShowItemIds,
        );
    }
    #[inline]
    pub fn add_bagBottomBarResType(
        &mut self,
        bagBottomBarResType: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_BAGBOTTOMBARRESTYPE,
            bagBottomBarResType,
        );
    }
    #[inline]
    pub fn add_failedCookFood(&mut self, failedCookFood: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_FAILEDCOOKFOOD,
            failedCookFood,
        );
    }
    #[inline]
    pub fn add_maxFoodDuration(&mut self, maxFoodDuration: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_MAXFOODDURATION,
            maxFoodDuration,
            0,
        );
    }
    #[inline]
    pub fn add_drinkCostOnce(&mut self, drinkCostOnce: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_DRINKCOSTONCE,
            drinkCostOnce,
            0,
        );
    }
    #[inline]
    pub fn add_drinkMakeLimit(&mut self, drinkMakeLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_DRINKMAKELIMIT,
            drinkMakeLimit,
            0,
        );
    }
    #[inline]
    pub fn add_specialMatWater(&mut self, specialMatWater: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_SPECIALMATWATER,
            specialMatWater,
        );
    }
    #[inline]
    pub fn add_workbenchMakeLimit(&mut self, workbenchMakeLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_WORKBENCHMAKELIMIT,
            workbenchMakeLimit,
            0,
        );
    }
    #[inline]
    pub fn add_logisticsPosLimit(&mut self, logisticsPosLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_LOGISTICSPOSLIMIT,
            logisticsPosLimit,
            0,
        );
    }
    #[inline]
    pub fn add_logisticsUnlockLevel(&mut self, logisticsUnlockLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_LOGISTICSUNLOCKLEVEL,
            logisticsUnlockLevel,
            0,
        );
    }
    #[inline]
    pub fn add_logisticsDrinkCost(&mut self, logisticsDrinkCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_LOGISTICSDRINKCOST,
            logisticsDrinkCost,
            0,
        );
    }
    #[inline]
    pub fn add_logisticsEvacuateTips(
        &mut self,
        logisticsEvacuateTips: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_LOGISTICSEVACUATETIPS,
            logisticsEvacuateTips,
        );
    }
    #[inline]
    pub fn add_logisticsEvacuateWarning(
        &mut self,
        logisticsEvacuateWarning: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_LOGISTICSEVACUATEWARNING,
            logisticsEvacuateWarning,
        );
    }
    #[inline]
    pub fn add_baseRepairCost(&mut self, baseRepairCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_BASEREPAIRCOST,
            baseRepairCost,
            0,
        );
    }
    #[inline]
    pub fn add_portRepairCost(&mut self, portRepairCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_PORTREPAIRCOST,
            portRepairCost,
            0,
        );
    }
    #[inline]
    pub fn add_unitFenceLimit(&mut self, unitFenceLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_UNITFENCELIMIT,
            unitFenceLimit,
            0,
        );
    }
    #[inline]
    pub fn add_unitRareFenceLimit(&mut self, unitRareFenceLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_UNITRAREFENCELIMIT,
            unitRareFenceLimit,
            0,
        );
    }
    #[inline]
    pub fn add_cageId(&mut self, cageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_CAGEID,
            cageId,
        );
    }
    #[inline]
    pub fn add_fenceId(&mut self, fenceId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_FENCEID,
            fenceId,
        );
    }
    #[inline]
    pub fn add_rareFenceId(&mut self, rareFenceId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_RAREFENCEID,
            rareFenceId,
        );
    }
    #[inline]
    pub fn add_monthlyRushEntryText1(
        &mut self,
        monthlyRushEntryText1: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_MONTHLYRUSHENTRYTEXT1,
            monthlyRushEntryText1,
        );
    }
    #[inline]
    pub fn add_monthlyEntryUnlockText(
        &mut self,
        monthlyEntryUnlockText: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_MONTHLYENTRYUNLOCKTEXT,
            monthlyEntryUnlockText,
        );
    }
    #[inline]
    pub fn add_monthlyEntryRiftText(
        &mut self,
        monthlyEntryRiftText: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_MONTHLYENTRYRIFTTEXT,
            monthlyEntryRiftText,
        );
    }
    #[inline]
    pub fn add_monthlyRushIntro(&mut self, monthlyRushIntro: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_MONTHLYRUSHINTRO,
            monthlyRushIntro,
        );
    }
    #[inline]
    pub fn add_monthlyCoin(
        &mut self,
        monthlyCoin: flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ItemBundle>>(
                clz_Torappu_SandboxV2BasicConst::VT_MONTHLYCOIN,
                monthlyCoin,
            );
    }
    #[inline]
    pub fn add_charRarityColorList(
        &mut self,
        charRarityColorList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_CHARRARITYCOLORLIST,
            charRarityColorList,
        );
    }
    #[inline]
    pub fn add_squadCharCapacity(&mut self, squadCharCapacity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_SQUADCHARCAPACITY,
            squadCharCapacity,
            0,
        );
    }
    #[inline]
    pub fn add_totalSquadCnt(&mut self, totalSquadCnt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_TOTALSQUADCNT,
            totalSquadCnt,
            0,
        );
    }
    #[inline]
    pub fn add_toolboxCapacity(&mut self, toolboxCapacity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_TOOLBOXCAPACITY,
            toolboxCapacity,
            0,
        );
    }
    #[inline]
    pub fn add_toolCntLimitInSquad(&mut self, toolCntLimitInSquad: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_TOOLCNTLIMITINSQUAD,
            toolCntLimitInSquad,
            0,
        );
    }
    #[inline]
    pub fn add_miniSquadCharCapacity(&mut self, miniSquadCharCapacity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_MINISQUADCHARCAPACITY,
            miniSquadCharCapacity,
            0,
        );
    }
    #[inline]
    pub fn add_miniSquadDrinkCost(&mut self, miniSquadDrinkCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_MINISQUADDRINKCOST,
            miniSquadDrinkCost,
            0,
        );
    }
    #[inline]
    pub fn add_normalSquadDrinkCost(&mut self, normalSquadDrinkCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_NORMALSQUADDRINKCOST,
            normalSquadDrinkCost,
            0,
        );
    }
    #[inline]
    pub fn add_emptySquadDrinkCost(&mut self, emptySquadDrinkCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BasicConst::VT_EMPTYSQUADDRINKCOST,
            emptySquadDrinkCost,
            0,
        );
    }
    #[inline]
    pub fn add_achieveTypeAll(&mut self, achieveTypeAll: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_ACHIEVETYPEALL,
            achieveTypeAll,
        );
    }
    #[inline]
    pub fn add_constructModeBgmHome(
        &mut self,
        constructModeBgmHome: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_CONSTRUCTMODEBGMHOME,
            constructModeBgmHome,
        );
    }
    #[inline]
    pub fn add_battleBgmCollect(&mut self, battleBgmCollect: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_BATTLEBGMCOLLECT,
            battleBgmCollect,
        );
    }
    #[inline]
    pub fn add_battleBgmHunt(&mut self, battleBgmHunt: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_BATTLEBGMHUNT,
            battleBgmHunt,
        );
    }
    #[inline]
    pub fn add_battleBgmEnemyRush(&mut self, battleBgmEnemyRush: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_BATTLEBGMENEMYRUSH,
            battleBgmEnemyRush,
        );
    }
    #[inline]
    pub fn add_battleBgmBossRush(&mut self, battleBgmBossRush: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_BATTLEBGMBOSSRUSH,
            battleBgmBossRush,
        );
    }
    #[inline]
    pub fn add_imgLoadingNormalName(
        &mut self,
        imgLoadingNormalName: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_IMGLOADINGNORMALNAME,
            imgLoadingNormalName,
        );
    }
    #[inline]
    pub fn add_imgLoadingBaseName(&mut self, imgLoadingBaseName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_IMGLOADINGBASENAME,
            imgLoadingBaseName,
        );
    }
    #[inline]
    pub fn add_imgUnloadingBaseName(
        &mut self,
        imgUnloadingBaseName: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_IMGUNLOADINGBASENAME,
            imgUnloadingBaseName,
        );
    }
    #[inline]
    pub fn add_isChallengeOpen(&mut self, isChallengeOpen: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SandboxV2BasicConst::VT_ISCHALLENGEOPEN,
            isChallengeOpen,
            false,
        );
    }
    #[inline]
    pub fn add_isRacingOpen(&mut self, isRacingOpen: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SandboxV2BasicConst::VT_ISRACINGOPEN,
            isRacingOpen,
            false,
        );
    }
    #[inline]
    pub fn add_hasExploreMode(&mut self, hasExploreMode: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SandboxV2BasicConst::VT_HASEXPLOREMODE,
            hasExploreMode,
            false,
        );
    }
    #[inline]
    pub fn add_exploreModeBuffDescs(
        &mut self,
        exploreModeBuffDescs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_EXPLOREMODEBUFFDESCS,
            exploreModeBuffDescs,
        );
    }
    #[inline]
    pub fn add_modeSelectTips(&mut self, modeSelectTips: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_MODESELECTTIPS,
            modeSelectTips,
        );
    }
    #[inline]
    pub fn add_stringRes(
        &mut self,
        stringRes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_STRINGRES,
            stringRes,
        );
    }
    #[inline]
    pub fn add_diffList(
        &mut self,
        diffList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DiffModeData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_DIFFLIST,
            diffList,
        );
    }
    #[inline]
    pub fn add_battlePreloadEnemies(
        &mut self,
        battlePreloadEnemies: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_BATTLEPRELOADENEMIES,
            battlePreloadEnemies,
        );
    }
    #[inline]
    pub fn add_battleExcludedTrapsInRush(
        &mut self,
        battleExcludedTrapsInRush: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BasicConst::VT_BATTLEEXCLUDEDTRAPSINRUSH,
            battleExcludedTrapsInRush,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2BasicConstBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2BasicConstBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BasicConst<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2BasicConst<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2BasicConst");
        ds.field("staminaItemId", &self.staminaItemId());
        ds.field("goldItemId", &self.goldItemId());
        ds.field("dimensioncoinItemId", &self.dimensioncoinItemId());
        ds.field(
            "alwaysShowItemIdsConstruct",
            &self.alwaysShowItemIdsConstruct(),
        );
        ds.field("alwaysShowItemIds", &self.alwaysShowItemIds());
        ds.field("bagBottomBarResType", &self.bagBottomBarResType());
        ds.field("failedCookFood", &self.failedCookFood());
        ds.field("maxFoodDuration", &self.maxFoodDuration());
        ds.field("drinkCostOnce", &self.drinkCostOnce());
        ds.field("drinkMakeLimit", &self.drinkMakeLimit());
        ds.field("specialMatWater", &self.specialMatWater());
        ds.field("workbenchMakeLimit", &self.workbenchMakeLimit());
        ds.field("logisticsPosLimit", &self.logisticsPosLimit());
        ds.field("logisticsUnlockLevel", &self.logisticsUnlockLevel());
        ds.field("logisticsDrinkCost", &self.logisticsDrinkCost());
        ds.field("logisticsEvacuateTips", &self.logisticsEvacuateTips());
        ds.field("logisticsEvacuateWarning", &self.logisticsEvacuateWarning());
        ds.field("baseRepairCost", &self.baseRepairCost());
        ds.field("portRepairCost", &self.portRepairCost());
        ds.field("unitFenceLimit", &self.unitFenceLimit());
        ds.field("unitRareFenceLimit", &self.unitRareFenceLimit());
        ds.field("cageId", &self.cageId());
        ds.field("fenceId", &self.fenceId());
        ds.field("rareFenceId", &self.rareFenceId());
        ds.field("monthlyRushEntryText1", &self.monthlyRushEntryText1());
        ds.field("monthlyEntryUnlockText", &self.monthlyEntryUnlockText());
        ds.field("monthlyEntryRiftText", &self.monthlyEntryRiftText());
        ds.field("monthlyRushIntro", &self.monthlyRushIntro());
        ds.field("monthlyCoin", &self.monthlyCoin());
        ds.field("charRarityColorList", &self.charRarityColorList());
        ds.field("squadCharCapacity", &self.squadCharCapacity());
        ds.field("totalSquadCnt", &self.totalSquadCnt());
        ds.field("toolboxCapacity", &self.toolboxCapacity());
        ds.field("toolCntLimitInSquad", &self.toolCntLimitInSquad());
        ds.field("miniSquadCharCapacity", &self.miniSquadCharCapacity());
        ds.field("miniSquadDrinkCost", &self.miniSquadDrinkCost());
        ds.field("normalSquadDrinkCost", &self.normalSquadDrinkCost());
        ds.field("emptySquadDrinkCost", &self.emptySquadDrinkCost());
        ds.field("achieveTypeAll", &self.achieveTypeAll());
        ds.field("constructModeBgmHome", &self.constructModeBgmHome());
        ds.field("battleBgmCollect", &self.battleBgmCollect());
        ds.field("battleBgmHunt", &self.battleBgmHunt());
        ds.field("battleBgmEnemyRush", &self.battleBgmEnemyRush());
        ds.field("battleBgmBossRush", &self.battleBgmBossRush());
        ds.field("imgLoadingNormalName", &self.imgLoadingNormalName());
        ds.field("imgLoadingBaseName", &self.imgLoadingBaseName());
        ds.field("imgUnloadingBaseName", &self.imgUnloadingBaseName());
        ds.field("isChallengeOpen", &self.isChallengeOpen());
        ds.field("isRacingOpen", &self.isRacingOpen());
        ds.field("hasExploreMode", &self.hasExploreMode());
        ds.field("exploreModeBuffDescs", &self.exploreModeBuffDescs());
        ds.field("modeSelectTips", &self.modeSelectTips());
        ds.field("stringRes", &self.stringRes());
        ds.field("diffList", &self.diffList());
        ds.field("battlePreloadEnemies", &self.battlePreloadEnemies());
        ds.field(
            "battleExcludedTrapsInRush",
            &self.battleExcludedTrapsInRush(),
        );
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2BasicConstT {
    pub staminaItemId: Option<String>,
    pub goldItemId: Option<String>,
    pub dimensioncoinItemId: Option<String>,
    pub alwaysShowItemIdsConstruct: Option<Vec<String>>,
    pub alwaysShowItemIds: Option<Vec<String>>,
    pub bagBottomBarResType: Option<Vec<String>>,
    pub failedCookFood: Option<String>,
    pub maxFoodDuration: i32,
    pub drinkCostOnce: i32,
    pub drinkMakeLimit: i32,
    pub specialMatWater: Option<String>,
    pub workbenchMakeLimit: i32,
    pub logisticsPosLimit: i32,
    pub logisticsUnlockLevel: i32,
    pub logisticsDrinkCost: i32,
    pub logisticsEvacuateTips: Option<String>,
    pub logisticsEvacuateWarning: Option<String>,
    pub baseRepairCost: i32,
    pub portRepairCost: i32,
    pub unitFenceLimit: i32,
    pub unitRareFenceLimit: i32,
    pub cageId: Option<String>,
    pub fenceId: Option<String>,
    pub rareFenceId: Option<String>,
    pub monthlyRushEntryText1: Option<String>,
    pub monthlyEntryUnlockText: Option<String>,
    pub monthlyEntryRiftText: Option<String>,
    pub monthlyRushIntro: Option<String>,
    pub monthlyCoin: Option<Box<clz_Torappu_ItemBundleT>>,
    pub charRarityColorList: Option<Vec<String>>,
    pub squadCharCapacity: i32,
    pub totalSquadCnt: i32,
    pub toolboxCapacity: i32,
    pub toolCntLimitInSquad: i32,
    pub miniSquadCharCapacity: i32,
    pub miniSquadDrinkCost: i32,
    pub normalSquadDrinkCost: i32,
    pub emptySquadDrinkCost: i32,
    pub achieveTypeAll: Option<String>,
    pub constructModeBgmHome: Option<String>,
    pub battleBgmCollect: Option<String>,
    pub battleBgmHunt: Option<String>,
    pub battleBgmEnemyRush: Option<String>,
    pub battleBgmBossRush: Option<String>,
    pub imgLoadingNormalName: Option<String>,
    pub imgLoadingBaseName: Option<String>,
    pub imgUnloadingBaseName: Option<String>,
    pub isChallengeOpen: bool,
    pub isRacingOpen: bool,
    pub hasExploreMode: bool,
    pub exploreModeBuffDescs: Option<Vec<String>>,
    pub modeSelectTips: Option<String>,
    pub stringRes: Option<Vec<dict__string__stringT>>,
    pub diffList: Option<Vec<clz_Torappu_SandboxV2DiffModeDataT>>,
    pub battlePreloadEnemies: Option<Vec<String>>,
    pub battleExcludedTrapsInRush: Option<Vec<String>>,
}
impl Default for clz_Torappu_SandboxV2BasicConstT {
    fn default() -> Self {
        Self {
            staminaItemId: None,
            goldItemId: None,
            dimensioncoinItemId: None,
            alwaysShowItemIdsConstruct: None,
            alwaysShowItemIds: None,
            bagBottomBarResType: None,
            failedCookFood: None,
            maxFoodDuration: 0,
            drinkCostOnce: 0,
            drinkMakeLimit: 0,
            specialMatWater: None,
            workbenchMakeLimit: 0,
            logisticsPosLimit: 0,
            logisticsUnlockLevel: 0,
            logisticsDrinkCost: 0,
            logisticsEvacuateTips: None,
            logisticsEvacuateWarning: None,
            baseRepairCost: 0,
            portRepairCost: 0,
            unitFenceLimit: 0,
            unitRareFenceLimit: 0,
            cageId: None,
            fenceId: None,
            rareFenceId: None,
            monthlyRushEntryText1: None,
            monthlyEntryUnlockText: None,
            monthlyEntryRiftText: None,
            monthlyRushIntro: None,
            monthlyCoin: None,
            charRarityColorList: None,
            squadCharCapacity: 0,
            totalSquadCnt: 0,
            toolboxCapacity: 0,
            toolCntLimitInSquad: 0,
            miniSquadCharCapacity: 0,
            miniSquadDrinkCost: 0,
            normalSquadDrinkCost: 0,
            emptySquadDrinkCost: 0,
            achieveTypeAll: None,
            constructModeBgmHome: None,
            battleBgmCollect: None,
            battleBgmHunt: None,
            battleBgmEnemyRush: None,
            battleBgmBossRush: None,
            imgLoadingNormalName: None,
            imgLoadingBaseName: None,
            imgUnloadingBaseName: None,
            isChallengeOpen: false,
            isRacingOpen: false,
            hasExploreMode: false,
            exploreModeBuffDescs: None,
            modeSelectTips: None,
            stringRes: None,
            diffList: None,
            battlePreloadEnemies: None,
            battleExcludedTrapsInRush: None,
        }
    }
}
impl clz_Torappu_SandboxV2BasicConstT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BasicConst<'b>> {
        let staminaItemId = self.staminaItemId.as_ref().map(|x| _fbb.create_string(x));
        let goldItemId = self.goldItemId.as_ref().map(|x| _fbb.create_string(x));
        let dimensioncoinItemId = self
            .dimensioncoinItemId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let alwaysShowItemIdsConstruct = self.alwaysShowItemIdsConstruct.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let alwaysShowItemIds = self.alwaysShowItemIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let bagBottomBarResType = self.bagBottomBarResType.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let failedCookFood = self.failedCookFood.as_ref().map(|x| _fbb.create_string(x));
        let maxFoodDuration = self.maxFoodDuration;
        let drinkCostOnce = self.drinkCostOnce;
        let drinkMakeLimit = self.drinkMakeLimit;
        let specialMatWater = self.specialMatWater.as_ref().map(|x| _fbb.create_string(x));
        let workbenchMakeLimit = self.workbenchMakeLimit;
        let logisticsPosLimit = self.logisticsPosLimit;
        let logisticsUnlockLevel = self.logisticsUnlockLevel;
        let logisticsDrinkCost = self.logisticsDrinkCost;
        let logisticsEvacuateTips = self
            .logisticsEvacuateTips
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let logisticsEvacuateWarning = self
            .logisticsEvacuateWarning
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let baseRepairCost = self.baseRepairCost;
        let portRepairCost = self.portRepairCost;
        let unitFenceLimit = self.unitFenceLimit;
        let unitRareFenceLimit = self.unitRareFenceLimit;
        let cageId = self.cageId.as_ref().map(|x| _fbb.create_string(x));
        let fenceId = self.fenceId.as_ref().map(|x| _fbb.create_string(x));
        let rareFenceId = self.rareFenceId.as_ref().map(|x| _fbb.create_string(x));
        let monthlyRushEntryText1 = self
            .monthlyRushEntryText1
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let monthlyEntryUnlockText = self
            .monthlyEntryUnlockText
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let monthlyEntryRiftText = self
            .monthlyEntryRiftText
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let monthlyRushIntro = self
            .monthlyRushIntro
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let monthlyCoin = self.monthlyCoin.as_ref().map(|x| x.pack(_fbb));
        let charRarityColorList = self.charRarityColorList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let squadCharCapacity = self.squadCharCapacity;
        let totalSquadCnt = self.totalSquadCnt;
        let toolboxCapacity = self.toolboxCapacity;
        let toolCntLimitInSquad = self.toolCntLimitInSquad;
        let miniSquadCharCapacity = self.miniSquadCharCapacity;
        let miniSquadDrinkCost = self.miniSquadDrinkCost;
        let normalSquadDrinkCost = self.normalSquadDrinkCost;
        let emptySquadDrinkCost = self.emptySquadDrinkCost;
        let achieveTypeAll = self.achieveTypeAll.as_ref().map(|x| _fbb.create_string(x));
        let constructModeBgmHome = self
            .constructModeBgmHome
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let battleBgmCollect = self
            .battleBgmCollect
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let battleBgmHunt = self.battleBgmHunt.as_ref().map(|x| _fbb.create_string(x));
        let battleBgmEnemyRush = self
            .battleBgmEnemyRush
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let battleBgmBossRush = self
            .battleBgmBossRush
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let imgLoadingNormalName = self
            .imgLoadingNormalName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let imgLoadingBaseName = self
            .imgLoadingBaseName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let imgUnloadingBaseName = self
            .imgUnloadingBaseName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let isChallengeOpen = self.isChallengeOpen;
        let isRacingOpen = self.isRacingOpen;
        let hasExploreMode = self.hasExploreMode;
        let exploreModeBuffDescs = self.exploreModeBuffDescs.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let modeSelectTips = self.modeSelectTips.as_ref().map(|x| _fbb.create_string(x));
        let stringRes = self.stringRes.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let diffList = self.diffList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let battlePreloadEnemies = self.battlePreloadEnemies.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let battleExcludedTrapsInRush = self.battleExcludedTrapsInRush.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SandboxV2BasicConst::create(
            _fbb,
            &clz_Torappu_SandboxV2BasicConstArgs {
                staminaItemId,
                goldItemId,
                dimensioncoinItemId,
                alwaysShowItemIdsConstruct,
                alwaysShowItemIds,
                bagBottomBarResType,
                failedCookFood,
                maxFoodDuration,
                drinkCostOnce,
                drinkMakeLimit,
                specialMatWater,
                workbenchMakeLimit,
                logisticsPosLimit,
                logisticsUnlockLevel,
                logisticsDrinkCost,
                logisticsEvacuateTips,
                logisticsEvacuateWarning,
                baseRepairCost,
                portRepairCost,
                unitFenceLimit,
                unitRareFenceLimit,
                cageId,
                fenceId,
                rareFenceId,
                monthlyRushEntryText1,
                monthlyEntryUnlockText,
                monthlyEntryRiftText,
                monthlyRushIntro,
                monthlyCoin,
                charRarityColorList,
                squadCharCapacity,
                totalSquadCnt,
                toolboxCapacity,
                toolCntLimitInSquad,
                miniSquadCharCapacity,
                miniSquadDrinkCost,
                normalSquadDrinkCost,
                emptySquadDrinkCost,
                achieveTypeAll,
                constructModeBgmHome,
                battleBgmCollect,
                battleBgmHunt,
                battleBgmEnemyRush,
                battleBgmBossRush,
                imgLoadingNormalName,
                imgLoadingBaseName,
                imgUnloadingBaseName,
                isChallengeOpen,
                isRacingOpen,
                hasExploreMode,
                exploreModeBuffDescs,
                modeSelectTips,
                stringRes,
                diffList,
                battlePreloadEnemies,
                battleExcludedTrapsInRush,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2RiftConstOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RiftConst<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RiftConst<'a> {
    type Inner = clz_Torappu_SandboxV2RiftConst<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RiftConst<'a> {
    pub const VT_REFRESHRATE: flatbuffers::VOffsetT = 4;
    pub const VT_RANDOMDUNGEONID: flatbuffers::VOffsetT = 6;
    pub const VT_HUNTDUNGEONID: flatbuffers::VOffsetT = 8;
    pub const VT_SUBTARGETREWARDID: flatbuffers::VOffsetT = 10;
    pub const VT_PREYQUESTREWARDID: flatbuffers::VOffsetT = 12;
    pub const VT_DUNGEONSEASONID: flatbuffers::VOffsetT = 14;
    pub const VT_FIXEDDUNGEONTYPENAME: flatbuffers::VOffsetT = 16;
    pub const VT_RANDOMDUNGEONTYPENAME: flatbuffers::VOffsetT = 18;
    pub const VT_PREYDUNGEONTYPENAME: flatbuffers::VOffsetT = 20;
    pub const VT_NOTEAMDESCRIPTION: flatbuffers::VOffsetT = 22;
    pub const VT_NOTEAMNAME: flatbuffers::VOffsetT = 24;
    pub const VT_NOTEAMBACKGROUNDID: flatbuffers::VOffsetT = 26;
    pub const VT_NOTEAMSMALLICONID: flatbuffers::VOffsetT = 28;
    pub const VT_NOTEAMBIGICONID: flatbuffers::VOffsetT = 30;
    pub const VT_MESSENGERENEMYID: flatbuffers::VOffsetT = 32;
    pub const VT_RIFTRUSHENEMYGROUPLIMIT: flatbuffers::VOffsetT = 34;
    pub const VT_RIFTRUSHSPAWNCD: flatbuffers::VOffsetT = 36;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RiftConst { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RiftConstArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftConst<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RiftConstBuilder::new(_fbb);
        builder.add_riftRushSpawnCd(args.riftRushSpawnCd);
        builder.add_riftRushEnemyGroupLimit(args.riftRushEnemyGroupLimit);
        if let Some(x) = args.messengerEnemyId {
            builder.add_messengerEnemyId(x);
        }
        if let Some(x) = args.noTeamBigIconId {
            builder.add_noTeamBigIconId(x);
        }
        if let Some(x) = args.noTeamSmallIconId {
            builder.add_noTeamSmallIconId(x);
        }
        if let Some(x) = args.noTeamBackgroundId {
            builder.add_noTeamBackgroundId(x);
        }
        if let Some(x) = args.noTeamName {
            builder.add_noTeamName(x);
        }
        if let Some(x) = args.noTeamDescription {
            builder.add_noTeamDescription(x);
        }
        if let Some(x) = args.preyDungeonTypeName {
            builder.add_preyDungeonTypeName(x);
        }
        if let Some(x) = args.randomDungeonTypeName {
            builder.add_randomDungeonTypeName(x);
        }
        if let Some(x) = args.fixedDungeonTypeName {
            builder.add_fixedDungeonTypeName(x);
        }
        builder.add_dungeonSeasonId(args.dungeonSeasonId);
        if let Some(x) = args.preyQuestRewardId {
            builder.add_preyQuestRewardId(x);
        }
        if let Some(x) = args.subTargetRewardId {
            builder.add_subTargetRewardId(x);
        }
        if let Some(x) = args.huntDungeonId {
            builder.add_huntDungeonId(x);
        }
        if let Some(x) = args.randomDungeonId {
            builder.add_randomDungeonId(x);
        }
        builder.add_refreshRate(args.refreshRate);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2RiftConstT {
        let refreshRate = self.refreshRate();
        let randomDungeonId = self.randomDungeonId().map(|x| x.to_string());
        let huntDungeonId = self.huntDungeonId().map(|x| x.to_string());
        let subTargetRewardId = self.subTargetRewardId().map(|x| x.to_string());
        let preyQuestRewardId = self.preyQuestRewardId().map(|x| x.to_string());
        let dungeonSeasonId = self.dungeonSeasonId();
        let fixedDungeonTypeName = self.fixedDungeonTypeName().map(|x| x.to_string());
        let randomDungeonTypeName = self.randomDungeonTypeName().map(|x| x.to_string());
        let preyDungeonTypeName = self.preyDungeonTypeName().map(|x| x.to_string());
        let noTeamDescription = self.noTeamDescription().map(|x| x.to_string());
        let noTeamName = self.noTeamName().map(|x| x.to_string());
        let noTeamBackgroundId = self.noTeamBackgroundId().map(|x| x.to_string());
        let noTeamSmallIconId = self.noTeamSmallIconId().map(|x| x.to_string());
        let noTeamBigIconId = self.noTeamBigIconId().map(|x| x.to_string());
        let messengerEnemyId = self.messengerEnemyId().map(|x| x.to_string());
        let riftRushEnemyGroupLimit = self.riftRushEnemyGroupLimit();
        let riftRushSpawnCd = self.riftRushSpawnCd();
        clz_Torappu_SandboxV2RiftConstT {
            refreshRate,
            randomDungeonId,
            huntDungeonId,
            subTargetRewardId,
            preyQuestRewardId,
            dungeonSeasonId,
            fixedDungeonTypeName,
            randomDungeonTypeName,
            preyDungeonTypeName,
            noTeamDescription,
            noTeamName,
            noTeamBackgroundId,
            noTeamSmallIconId,
            noTeamBigIconId,
            messengerEnemyId,
            riftRushEnemyGroupLimit,
            riftRushSpawnCd,
        }
    }

    #[inline]
    pub fn refreshRate(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2RiftConst::VT_REFRESHRATE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn randomDungeonId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_RANDOMDUNGEONID,
                None,
            )
        }
    }
    #[inline]
    pub fn huntDungeonId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_HUNTDUNGEONID,
                None,
            )
        }
    }
    #[inline]
    pub fn subTargetRewardId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_SUBTARGETREWARDID,
                None,
            )
        }
    }
    #[inline]
    pub fn preyQuestRewardId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_PREYQUESTREWARDID,
                None,
            )
        }
    }
    #[inline]
    pub fn dungeonSeasonId(&self) -> enum__Torappu_SandboxV2SeasonType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2SeasonType>(
                    clz_Torappu_SandboxV2RiftConst::VT_DUNGEONSEASONID,
                    Some(enum__Torappu_SandboxV2SeasonType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn fixedDungeonTypeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_FIXEDDUNGEONTYPENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn randomDungeonTypeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_RANDOMDUNGEONTYPENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn preyDungeonTypeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_PREYDUNGEONTYPENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn noTeamDescription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_NOTEAMDESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn noTeamName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_NOTEAMNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn noTeamBackgroundId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_NOTEAMBACKGROUNDID,
                None,
            )
        }
    }
    #[inline]
    pub fn noTeamSmallIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_NOTEAMSMALLICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn noTeamBigIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_NOTEAMBIGICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn messengerEnemyId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftConst::VT_MESSENGERENEMYID,
                None,
            )
        }
    }
    #[inline]
    pub fn riftRushEnemyGroupLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2RiftConst::VT_RIFTRUSHENEMYGROUPLIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn riftRushSpawnCd(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2RiftConst::VT_RIFTRUSHSPAWNCD, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RiftConst<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("refreshRate", Self::VT_REFRESHRATE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "randomDungeonId",
                Self::VT_RANDOMDUNGEONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "huntDungeonId",
                Self::VT_HUNTDUNGEONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "subTargetRewardId",
                Self::VT_SUBTARGETREWARDID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "preyQuestRewardId",
                Self::VT_PREYQUESTREWARDID,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxV2SeasonType>(
                "dungeonSeasonId",
                Self::VT_DUNGEONSEASONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "fixedDungeonTypeName",
                Self::VT_FIXEDDUNGEONTYPENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "randomDungeonTypeName",
                Self::VT_RANDOMDUNGEONTYPENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "preyDungeonTypeName",
                Self::VT_PREYDUNGEONTYPENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "noTeamDescription",
                Self::VT_NOTEAMDESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "noTeamName",
                Self::VT_NOTEAMNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "noTeamBackgroundId",
                Self::VT_NOTEAMBACKGROUNDID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "noTeamSmallIconId",
                Self::VT_NOTEAMSMALLICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "noTeamBigIconId",
                Self::VT_NOTEAMBIGICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "messengerEnemyId",
                Self::VT_MESSENGERENEMYID,
                false,
            )?
            .visit_field::<i32>(
                "riftRushEnemyGroupLimit",
                Self::VT_RIFTRUSHENEMYGROUPLIMIT,
                false,
            )?
            .visit_field::<i32>("riftRushSpawnCd", Self::VT_RIFTRUSHSPAWNCD, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RiftConstArgs<'a> {
    pub refreshRate: i32,
    pub randomDungeonId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub huntDungeonId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub subTargetRewardId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub preyQuestRewardId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dungeonSeasonId: enum__Torappu_SandboxV2SeasonType,
    pub fixedDungeonTypeName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub randomDungeonTypeName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub preyDungeonTypeName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub noTeamDescription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub noTeamName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub noTeamBackgroundId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub noTeamSmallIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub noTeamBigIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub messengerEnemyId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub riftRushEnemyGroupLimit: i32,
    pub riftRushSpawnCd: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2RiftConstArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RiftConstArgs {
            refreshRate: 0,
            randomDungeonId: None,
            huntDungeonId: None,
            subTargetRewardId: None,
            preyQuestRewardId: None,
            dungeonSeasonId: enum__Torappu_SandboxV2SeasonType::NONE,
            fixedDungeonTypeName: None,
            randomDungeonTypeName: None,
            preyDungeonTypeName: None,
            noTeamDescription: None,
            noTeamName: None,
            noTeamBackgroundId: None,
            noTeamSmallIconId: None,
            noTeamBigIconId: None,
            messengerEnemyId: None,
            riftRushEnemyGroupLimit: 0,
            riftRushSpawnCd: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2RiftConst<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2RiftConst", 17)?;
        s.serialize_field("refreshRate", &self.refreshRate())?;
        if let Some(f) = self.randomDungeonId() {
            s.serialize_field("randomDungeonId", &f)?;
        } else {
            s.skip_field("randomDungeonId")?;
        }
        if let Some(f) = self.huntDungeonId() {
            s.serialize_field("huntDungeonId", &f)?;
        } else {
            s.skip_field("huntDungeonId")?;
        }
        if let Some(f) = self.subTargetRewardId() {
            s.serialize_field("subTargetRewardId", &f)?;
        } else {
            s.skip_field("subTargetRewardId")?;
        }
        if let Some(f) = self.preyQuestRewardId() {
            s.serialize_field("preyQuestRewardId", &f)?;
        } else {
            s.skip_field("preyQuestRewardId")?;
        }
        s.serialize_field("dungeonSeasonId", &self.dungeonSeasonId())?;
        if let Some(f) = self.fixedDungeonTypeName() {
            s.serialize_field("fixedDungeonTypeName", &f)?;
        } else {
            s.skip_field("fixedDungeonTypeName")?;
        }
        if let Some(f) = self.randomDungeonTypeName() {
            s.serialize_field("randomDungeonTypeName", &f)?;
        } else {
            s.skip_field("randomDungeonTypeName")?;
        }
        if let Some(f) = self.preyDungeonTypeName() {
            s.serialize_field("preyDungeonTypeName", &f)?;
        } else {
            s.skip_field("preyDungeonTypeName")?;
        }
        if let Some(f) = self.noTeamDescription() {
            s.serialize_field("noTeamDescription", &f)?;
        } else {
            s.skip_field("noTeamDescription")?;
        }
        if let Some(f) = self.noTeamName() {
            s.serialize_field("noTeamName", &f)?;
        } else {
            s.skip_field("noTeamName")?;
        }
        if let Some(f) = self.noTeamBackgroundId() {
            s.serialize_field("noTeamBackgroundId", &f)?;
        } else {
            s.skip_field("noTeamBackgroundId")?;
        }
        if let Some(f) = self.noTeamSmallIconId() {
            s.serialize_field("noTeamSmallIconId", &f)?;
        } else {
            s.skip_field("noTeamSmallIconId")?;
        }
        if let Some(f) = self.noTeamBigIconId() {
            s.serialize_field("noTeamBigIconId", &f)?;
        } else {
            s.skip_field("noTeamBigIconId")?;
        }
        if let Some(f) = self.messengerEnemyId() {
            s.serialize_field("messengerEnemyId", &f)?;
        } else {
            s.skip_field("messengerEnemyId")?;
        }
        s.serialize_field("riftRushEnemyGroupLimit", &self.riftRushEnemyGroupLimit())?;
        s.serialize_field("riftRushSpawnCd", &self.riftRushSpawnCd())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2RiftConstBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2RiftConstBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_refreshRate(&mut self, refreshRate: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2RiftConst::VT_REFRESHRATE,
            refreshRate,
            0,
        );
    }
    #[inline]
    pub fn add_randomDungeonId(&mut self, randomDungeonId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_RANDOMDUNGEONID,
            randomDungeonId,
        );
    }
    #[inline]
    pub fn add_huntDungeonId(&mut self, huntDungeonId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_HUNTDUNGEONID,
            huntDungeonId,
        );
    }
    #[inline]
    pub fn add_subTargetRewardId(&mut self, subTargetRewardId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_SUBTARGETREWARDID,
            subTargetRewardId,
        );
    }
    #[inline]
    pub fn add_preyQuestRewardId(&mut self, preyQuestRewardId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_PREYQUESTREWARDID,
            preyQuestRewardId,
        );
    }
    #[inline]
    pub fn add_dungeonSeasonId(&mut self, dungeonSeasonId: enum__Torappu_SandboxV2SeasonType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2SeasonType>(
            clz_Torappu_SandboxV2RiftConst::VT_DUNGEONSEASONID,
            dungeonSeasonId,
            enum__Torappu_SandboxV2SeasonType::NONE,
        );
    }
    #[inline]
    pub fn add_fixedDungeonTypeName(
        &mut self,
        fixedDungeonTypeName: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_FIXEDDUNGEONTYPENAME,
            fixedDungeonTypeName,
        );
    }
    #[inline]
    pub fn add_randomDungeonTypeName(
        &mut self,
        randomDungeonTypeName: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_RANDOMDUNGEONTYPENAME,
            randomDungeonTypeName,
        );
    }
    #[inline]
    pub fn add_preyDungeonTypeName(
        &mut self,
        preyDungeonTypeName: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_PREYDUNGEONTYPENAME,
            preyDungeonTypeName,
        );
    }
    #[inline]
    pub fn add_noTeamDescription(&mut self, noTeamDescription: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_NOTEAMDESCRIPTION,
            noTeamDescription,
        );
    }
    #[inline]
    pub fn add_noTeamName(&mut self, noTeamName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_NOTEAMNAME,
            noTeamName,
        );
    }
    #[inline]
    pub fn add_noTeamBackgroundId(&mut self, noTeamBackgroundId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_NOTEAMBACKGROUNDID,
            noTeamBackgroundId,
        );
    }
    #[inline]
    pub fn add_noTeamSmallIconId(&mut self, noTeamSmallIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_NOTEAMSMALLICONID,
            noTeamSmallIconId,
        );
    }
    #[inline]
    pub fn add_noTeamBigIconId(&mut self, noTeamBigIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_NOTEAMBIGICONID,
            noTeamBigIconId,
        );
    }
    #[inline]
    pub fn add_messengerEnemyId(&mut self, messengerEnemyId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftConst::VT_MESSENGERENEMYID,
            messengerEnemyId,
        );
    }
    #[inline]
    pub fn add_riftRushEnemyGroupLimit(&mut self, riftRushEnemyGroupLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2RiftConst::VT_RIFTRUSHENEMYGROUPLIMIT,
            riftRushEnemyGroupLimit,
            0,
        );
    }
    #[inline]
    pub fn add_riftRushSpawnCd(&mut self, riftRushSpawnCd: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2RiftConst::VT_RIFTRUSHSPAWNCD,
            riftRushSpawnCd,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RiftConstBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RiftConstBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftConst<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RiftConst<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RiftConst");
        ds.field("refreshRate", &self.refreshRate());
        ds.field("randomDungeonId", &self.randomDungeonId());
        ds.field("huntDungeonId", &self.huntDungeonId());
        ds.field("subTargetRewardId", &self.subTargetRewardId());
        ds.field("preyQuestRewardId", &self.preyQuestRewardId());
        ds.field("dungeonSeasonId", &self.dungeonSeasonId());
        ds.field("fixedDungeonTypeName", &self.fixedDungeonTypeName());
        ds.field("randomDungeonTypeName", &self.randomDungeonTypeName());
        ds.field("preyDungeonTypeName", &self.preyDungeonTypeName());
        ds.field("noTeamDescription", &self.noTeamDescription());
        ds.field("noTeamName", &self.noTeamName());
        ds.field("noTeamBackgroundId", &self.noTeamBackgroundId());
        ds.field("noTeamSmallIconId", &self.noTeamSmallIconId());
        ds.field("noTeamBigIconId", &self.noTeamBigIconId());
        ds.field("messengerEnemyId", &self.messengerEnemyId());
        ds.field("riftRushEnemyGroupLimit", &self.riftRushEnemyGroupLimit());
        ds.field("riftRushSpawnCd", &self.riftRushSpawnCd());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2RiftConstT {
    pub refreshRate: i32,
    pub randomDungeonId: Option<String>,
    pub huntDungeonId: Option<String>,
    pub subTargetRewardId: Option<String>,
    pub preyQuestRewardId: Option<String>,
    pub dungeonSeasonId: enum__Torappu_SandboxV2SeasonType,
    pub fixedDungeonTypeName: Option<String>,
    pub randomDungeonTypeName: Option<String>,
    pub preyDungeonTypeName: Option<String>,
    pub noTeamDescription: Option<String>,
    pub noTeamName: Option<String>,
    pub noTeamBackgroundId: Option<String>,
    pub noTeamSmallIconId: Option<String>,
    pub noTeamBigIconId: Option<String>,
    pub messengerEnemyId: Option<String>,
    pub riftRushEnemyGroupLimit: i32,
    pub riftRushSpawnCd: i32,
}
impl Default for clz_Torappu_SandboxV2RiftConstT {
    fn default() -> Self {
        Self {
            refreshRate: 0,
            randomDungeonId: None,
            huntDungeonId: None,
            subTargetRewardId: None,
            preyQuestRewardId: None,
            dungeonSeasonId: enum__Torappu_SandboxV2SeasonType::NONE,
            fixedDungeonTypeName: None,
            randomDungeonTypeName: None,
            preyDungeonTypeName: None,
            noTeamDescription: None,
            noTeamName: None,
            noTeamBackgroundId: None,
            noTeamSmallIconId: None,
            noTeamBigIconId: None,
            messengerEnemyId: None,
            riftRushEnemyGroupLimit: 0,
            riftRushSpawnCd: 0,
        }
    }
}
impl clz_Torappu_SandboxV2RiftConstT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftConst<'b>> {
        let refreshRate = self.refreshRate;
        let randomDungeonId = self.randomDungeonId.as_ref().map(|x| _fbb.create_string(x));
        let huntDungeonId = self.huntDungeonId.as_ref().map(|x| _fbb.create_string(x));
        let subTargetRewardId = self
            .subTargetRewardId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let preyQuestRewardId = self
            .preyQuestRewardId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let dungeonSeasonId = self.dungeonSeasonId;
        let fixedDungeonTypeName = self
            .fixedDungeonTypeName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let randomDungeonTypeName = self
            .randomDungeonTypeName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let preyDungeonTypeName = self
            .preyDungeonTypeName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let noTeamDescription = self
            .noTeamDescription
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let noTeamName = self.noTeamName.as_ref().map(|x| _fbb.create_string(x));
        let noTeamBackgroundId = self
            .noTeamBackgroundId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let noTeamSmallIconId = self
            .noTeamSmallIconId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let noTeamBigIconId = self.noTeamBigIconId.as_ref().map(|x| _fbb.create_string(x));
        let messengerEnemyId = self
            .messengerEnemyId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let riftRushEnemyGroupLimit = self.riftRushEnemyGroupLimit;
        let riftRushSpawnCd = self.riftRushSpawnCd;
        clz_Torappu_SandboxV2RiftConst::create(
            _fbb,
            &clz_Torappu_SandboxV2RiftConstArgs {
                refreshRate,
                randomDungeonId,
                huntDungeonId,
                subTargetRewardId,
                preyQuestRewardId,
                dungeonSeasonId,
                fixedDungeonTypeName,
                randomDungeonTypeName,
                preyDungeonTypeName,
                noTeamDescription,
                noTeamName,
                noTeamBackgroundId,
                noTeamSmallIconId,
                noTeamBigIconId,
                messengerEnemyId,
                riftRushEnemyGroupLimit,
                riftRushSpawnCd,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2DevelopmentConstOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2DevelopmentConst<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2DevelopmentConst<'a> {
    type Inner = clz_Torappu_SandboxV2DevelopmentConst<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2DevelopmentConst<'a> {
    pub const VT_TECHPOINTSTOTAL: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2DevelopmentConst { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2DevelopmentConstArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentConst<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2DevelopmentConstBuilder::new(_fbb);
        builder.add_techPointsTotal(args.techPointsTotal);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2DevelopmentConstT {
        let techPointsTotal = self.techPointsTotal();
        clz_Torappu_SandboxV2DevelopmentConstT { techPointsTotal }
    }

    #[inline]
    pub fn techPointsTotal(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2DevelopmentConst::VT_TECHPOINTSTOTAL,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2DevelopmentConst<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("techPointsTotal", Self::VT_TECHPOINTSTOTAL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2DevelopmentConstArgs {
    pub techPointsTotal: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2DevelopmentConstArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2DevelopmentConstArgs { techPointsTotal: 0 }
    }
}

impl Serialize for clz_Torappu_SandboxV2DevelopmentConst<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2DevelopmentConst", 1)?;
        s.serialize_field("techPointsTotal", &self.techPointsTotal())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2DevelopmentConstBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2DevelopmentConstBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_techPointsTotal(&mut self, techPointsTotal: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2DevelopmentConst::VT_TECHPOINTSTOTAL,
            techPointsTotal,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2DevelopmentConstBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2DevelopmentConstBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentConst<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2DevelopmentConst<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2DevelopmentConst");
        ds.field("techPointsTotal", &self.techPointsTotal());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2DevelopmentConstT {
    pub techPointsTotal: i32,
}
impl Default for clz_Torappu_SandboxV2DevelopmentConstT {
    fn default() -> Self {
        Self { techPointsTotal: 0 }
    }
}
impl clz_Torappu_SandboxV2DevelopmentConstT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentConst<'b>> {
        let techPointsTotal = self.techPointsTotal;
        clz_Torappu_SandboxV2DevelopmentConst::create(
            _fbb,
            &clz_Torappu_SandboxV2DevelopmentConstArgs { techPointsTotal },
        )
    }
}
pub enum clz_Torappu_TipDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_TipData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_TipData<'a> {
    type Inner = clz_Torappu_TipData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_TipData<'a> {
    pub const VT_TIP: flatbuffers::VOffsetT = 4;
    pub const VT_WEIGHT: flatbuffers::VOffsetT = 6;
    pub const VT_CATEGORY: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_TipData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_TipDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TipData<'bldr>> {
        let mut builder = clz_Torappu_TipDataBuilder::new(_fbb);
        builder.add_category(args.category);
        builder.add_weight(args.weight);
        if let Some(x) = args.tip {
            builder.add_tip(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_TipDataT {
        let tip = self.tip().map(|x| x.to_string());
        let weight = self.weight();
        let category = self.category();
        clz_Torappu_TipDataT {
            tip,
            weight,
            category,
        }
    }

    #[inline]
    pub fn tip(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_TipData::VT_TIP, None)
        }
    }
    #[inline]
    pub fn weight(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_TipData::VT_WEIGHT, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn category(&self) -> enum__Torappu_TipData_Category {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_TipData_Category>(
                    clz_Torappu_TipData::VT_CATEGORY,
                    Some(enum__Torappu_TipData_Category::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_TipData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tip", Self::VT_TIP, false)?
            .visit_field::<f32>("weight", Self::VT_WEIGHT, false)?
            .visit_field::<enum__Torappu_TipData_Category>("category", Self::VT_CATEGORY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_TipDataArgs<'a> {
    pub tip: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weight: f32,
    pub category: enum__Torappu_TipData_Category,
}
impl<'a> Default for clz_Torappu_TipDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_TipDataArgs {
            tip: None,
            weight: 0.0,
            category: enum__Torappu_TipData_Category::NONE,
        }
    }
}

impl Serialize for clz_Torappu_TipData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_TipData", 3)?;
        if let Some(f) = self.tip() {
            s.serialize_field("tip", &f)?;
        } else {
            s.skip_field("tip")?;
        }
        s.serialize_field("weight", &self.weight())?;
        s.serialize_field("category", &self.category())?;
        s.end()
    }
}

pub struct clz_Torappu_TipDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_TipDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_tip(&mut self, tip: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_TipData::VT_TIP, tip);
    }
    #[inline]
    pub fn add_weight(&mut self, weight: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_TipData::VT_WEIGHT, weight, 0.0);
    }
    #[inline]
    pub fn add_category(&mut self, category: enum__Torappu_TipData_Category) {
        self.fbb_.push_slot::<enum__Torappu_TipData_Category>(
            clz_Torappu_TipData::VT_CATEGORY,
            category,
            enum__Torappu_TipData_Category::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_TipDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_TipDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_TipData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_TipData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_TipData");
        ds.field("tip", &self.tip());
        ds.field("weight", &self.weight());
        ds.field("category", &self.category());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_TipDataT {
    pub tip: Option<String>,
    pub weight: f32,
    pub category: enum__Torappu_TipData_Category,
}
impl Default for clz_Torappu_TipDataT {
    fn default() -> Self {
        Self {
            tip: None,
            weight: 0.0,
            category: enum__Torappu_TipData_Category::NONE,
        }
    }
}
impl clz_Torappu_TipDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TipData<'b>> {
        let tip = self.tip.as_ref().map(|x| _fbb.create_string(x));
        let weight = self.weight;
        let category = self.category;
        clz_Torappu_TipData::create(
            _fbb,
            &clz_Torappu_TipDataArgs {
                tip,
                weight,
                category,
            },
        )
    }
}
pub enum clz_Torappu_RuneData_SelectorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RuneData_Selector<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RuneData_Selector<'a> {
    type Inner = clz_Torappu_RuneData_Selector<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RuneData_Selector<'a> {
    pub const VT_PROFESSIONMASK: flatbuffers::VOffsetT = 4;
    pub const VT_BUILDABLEMASK: flatbuffers::VOffsetT = 6;
    pub const VT_PLAYERSIDEMASK: flatbuffers::VOffsetT = 8;
    pub const VT_SIDETYPE: flatbuffers::VOffsetT = 10;
    pub const VT_CHARIDFILTER: flatbuffers::VOffsetT = 12;
    pub const VT_ENEMYIDFILTER: flatbuffers::VOffsetT = 14;
    pub const VT_ENEMYIDEXCLUDEFILTER: flatbuffers::VOffsetT = 16;
    pub const VT_ENEMYLEVELTYPEFILTER: flatbuffers::VOffsetT = 18;
    pub const VT_ENEMYACTIONHIDDENGROUPFILTER: flatbuffers::VOffsetT = 20;
    pub const VT_SKILLIDFILTER: flatbuffers::VOffsetT = 22;
    pub const VT_TILEKEYFILTER: flatbuffers::VOffsetT = 24;
    pub const VT_GROUPTAGFILTER: flatbuffers::VOffsetT = 26;
    pub const VT_FILTERTAGFILTER: flatbuffers::VOffsetT = 28;
    pub const VT_FILTERTAGEXCLUDEFILTER: flatbuffers::VOffsetT = 30;
    pub const VT_SUBPROFESSIONEXCLUDEFILTER: flatbuffers::VOffsetT = 32;
    pub const VT_MAPTAGFILTER: flatbuffers::VOffsetT = 34;
    pub const VT_HEIGHTTYPEMASK: flatbuffers::VOffsetT = 36;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RuneData_Selector { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RuneData_SelectorArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'bldr>> {
        let mut builder = clz_Torappu_RuneData_SelectorBuilder::new(_fbb);
        builder.add_heightTypeMask(args.heightTypeMask);
        if let Some(x) = args.mapTagFilter {
            builder.add_mapTagFilter(x);
        }
        if let Some(x) = args.subProfessionExcludeFilter {
            builder.add_subProfessionExcludeFilter(x);
        }
        if let Some(x) = args.filterTagExcludeFilter {
            builder.add_filterTagExcludeFilter(x);
        }
        if let Some(x) = args.filterTagFilter {
            builder.add_filterTagFilter(x);
        }
        if let Some(x) = args.groupTagFilter {
            builder.add_groupTagFilter(x);
        }
        if let Some(x) = args.tileKeyFilter {
            builder.add_tileKeyFilter(x);
        }
        if let Some(x) = args.skillIdFilter {
            builder.add_skillIdFilter(x);
        }
        if let Some(x) = args.enemyActionHiddenGroupFilter {
            builder.add_enemyActionHiddenGroupFilter(x);
        }
        if let Some(x) = args.enemyLevelTypeFilter {
            builder.add_enemyLevelTypeFilter(x);
        }
        if let Some(x) = args.enemyIdExcludeFilter {
            builder.add_enemyIdExcludeFilter(x);
        }
        if let Some(x) = args.enemyIdFilter {
            builder.add_enemyIdFilter(x);
        }
        if let Some(x) = args.charIdFilter {
            builder.add_charIdFilter(x);
        }
        builder.add_sideType(args.sideType);
        builder.add_buildableMask(args.buildableMask);
        builder.add_professionMask(args.professionMask);
        builder.add_playerSideMask(args.playerSideMask);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RuneData_SelectorT {
        let professionMask = self.professionMask();
        let buildableMask = self.buildableMask();
        let playerSideMask = self.playerSideMask();
        let sideType = self.sideType();
        let charIdFilter = self
            .charIdFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let enemyIdFilter = self
            .enemyIdFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let enemyIdExcludeFilter = self
            .enemyIdExcludeFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let enemyLevelTypeFilter = self
            .enemyLevelTypeFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let enemyActionHiddenGroupFilter = self
            .enemyActionHiddenGroupFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let skillIdFilter = self
            .skillIdFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let tileKeyFilter = self
            .tileKeyFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let groupTagFilter = self
            .groupTagFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let filterTagFilter = self
            .filterTagFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let filterTagExcludeFilter = self
            .filterTagExcludeFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let subProfessionExcludeFilter = self
            .subProfessionExcludeFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let mapTagFilter = self
            .mapTagFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let heightTypeMask = self.heightTypeMask();
        clz_Torappu_RuneData_SelectorT {
            professionMask,
            buildableMask,
            playerSideMask,
            sideType,
            charIdFilter,
            enemyIdFilter,
            enemyIdExcludeFilter,
            enemyLevelTypeFilter,
            enemyActionHiddenGroupFilter,
            skillIdFilter,
            tileKeyFilter,
            groupTagFilter,
            filterTagFilter,
            filterTagExcludeFilter,
            subProfessionExcludeFilter,
            mapTagFilter,
            heightTypeMask,
        }
    }

    #[inline]
    pub fn professionMask(&self) -> enum__Torappu_ProfessionCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ProfessionCategory>(
                    clz_Torappu_RuneData_Selector::VT_PROFESSIONMASK,
                    Some(enum__Torappu_ProfessionCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn buildableMask(&self) -> enum__Torappu_BuildableType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildableType>(
                    clz_Torappu_RuneData_Selector::VT_BUILDABLEMASK,
                    Some(enum__Torappu_BuildableType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn playerSideMask(&self) -> enum__Torappu_PlayerSideMask {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_PlayerSideMask>(
                    clz_Torappu_RuneData_Selector::VT_PLAYERSIDEMASK,
                    Some(enum__Torappu_PlayerSideMask::ALL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sideType(&self) -> enum__Torappu_Battle_SideType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_Battle_SideType>(
                    clz_Torappu_RuneData_Selector::VT_SIDETYPE,
                    Some(enum__Torappu_Battle_SideType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn charIdFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_CHARIDFILTER, None)
        }
    }
    #[inline]
    pub fn enemyIdFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_ENEMYIDFILTER, None)
        }
    }
    #[inline]
    pub fn enemyIdExcludeFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_ENEMYIDEXCLUDEFILTER, None)
        }
    }
    #[inline]
    pub fn enemyLevelTypeFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_ENEMYLEVELTYPEFILTER, None)
        }
    }
    #[inline]
    pub fn enemyActionHiddenGroupFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RuneData_Selector::VT_ENEMYACTIONHIDDENGROUPFILTER,
                None,
            )
        }
    }
    #[inline]
    pub fn skillIdFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_SKILLIDFILTER, None)
        }
    }
    #[inline]
    pub fn tileKeyFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_TILEKEYFILTER, None)
        }
    }
    #[inline]
    pub fn groupTagFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_GROUPTAGFILTER, None)
        }
    }
    #[inline]
    pub fn filterTagFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_FILTERTAGFILTER, None)
        }
    }
    #[inline]
    pub fn filterTagExcludeFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RuneData_Selector::VT_FILTERTAGEXCLUDEFILTER,
                None,
            )
        }
    }
    #[inline]
    pub fn subProfessionExcludeFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RuneData_Selector::VT_SUBPROFESSIONEXCLUDEFILTER,
                None,
            )
        }
    }
    #[inline]
    pub fn mapTagFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_MAPTAGFILTER, None)
        }
    }
    #[inline]
    pub fn heightTypeMask(&self) -> enum__Torappu_TileData_HeightTypeMask {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_TileData_HeightTypeMask>(
                    clz_Torappu_RuneData_Selector::VT_HEIGHTTYPEMASK,
                    Some(enum__Torappu_TileData_HeightTypeMask::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RuneData_Selector<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_ProfessionCategory>(
                "professionMask",
                Self::VT_PROFESSIONMASK,
                false,
            )?
            .visit_field::<enum__Torappu_BuildableType>(
                "buildableMask",
                Self::VT_BUILDABLEMASK,
                false,
            )?
            .visit_field::<enum__Torappu_PlayerSideMask>(
                "playerSideMask",
                Self::VT_PLAYERSIDEMASK,
                false,
            )?
            .visit_field::<enum__Torappu_Battle_SideType>("sideType", Self::VT_SIDETYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("charIdFilter", Self::VT_CHARIDFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("enemyIdFilter", Self::VT_ENEMYIDFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("enemyIdExcludeFilter", Self::VT_ENEMYIDEXCLUDEFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("enemyLevelTypeFilter", Self::VT_ENEMYLEVELTYPEFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "enemyActionHiddenGroupFilter",
                Self::VT_ENEMYACTIONHIDDENGROUPFILTER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("skillIdFilter", Self::VT_SKILLIDFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("tileKeyFilter", Self::VT_TILEKEYFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("groupTagFilter", Self::VT_GROUPTAGFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("filterTagFilter", Self::VT_FILTERTAGFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "filterTagExcludeFilter",
                Self::VT_FILTERTAGEXCLUDEFILTER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "subProfessionExcludeFilter",
                Self::VT_SUBPROFESSIONEXCLUDEFILTER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("mapTagFilter", Self::VT_MAPTAGFILTER, false)?
            .visit_field::<enum__Torappu_TileData_HeightTypeMask>(
                "heightTypeMask",
                Self::VT_HEIGHTTYPEMASK,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RuneData_SelectorArgs<'a> {
    pub professionMask: enum__Torappu_ProfessionCategory,
    pub buildableMask: enum__Torappu_BuildableType,
    pub playerSideMask: enum__Torappu_PlayerSideMask,
    pub sideType: enum__Torappu_Battle_SideType,
    pub charIdFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub enemyIdFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub enemyIdExcludeFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub enemyLevelTypeFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub enemyActionHiddenGroupFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub skillIdFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub tileKeyFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub groupTagFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub filterTagFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub filterTagExcludeFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub subProfessionExcludeFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub mapTagFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub heightTypeMask: enum__Torappu_TileData_HeightTypeMask,
}
impl<'a> Default for clz_Torappu_RuneData_SelectorArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RuneData_SelectorArgs {
            professionMask: enum__Torappu_ProfessionCategory::NONE,
            buildableMask: enum__Torappu_BuildableType::NONE,
            playerSideMask: enum__Torappu_PlayerSideMask::ALL,
            sideType: enum__Torappu_Battle_SideType::NONE,
            charIdFilter: None,
            enemyIdFilter: None,
            enemyIdExcludeFilter: None,
            enemyLevelTypeFilter: None,
            enemyActionHiddenGroupFilter: None,
            skillIdFilter: None,
            tileKeyFilter: None,
            groupTagFilter: None,
            filterTagFilter: None,
            filterTagExcludeFilter: None,
            subProfessionExcludeFilter: None,
            mapTagFilter: None,
            heightTypeMask: enum__Torappu_TileData_HeightTypeMask::NONE,
        }
    }
}

impl Serialize for clz_Torappu_RuneData_Selector<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RuneData_Selector", 17)?;
        s.serialize_field("professionMask", &self.professionMask())?;
        s.serialize_field("buildableMask", &self.buildableMask())?;
        s.serialize_field("playerSideMask", &self.playerSideMask())?;
        s.serialize_field("sideType", &self.sideType())?;
        if let Some(f) = self.charIdFilter() {
            s.serialize_field("charIdFilter", &f)?;
        } else {
            s.skip_field("charIdFilter")?;
        }
        if let Some(f) = self.enemyIdFilter() {
            s.serialize_field("enemyIdFilter", &f)?;
        } else {
            s.skip_field("enemyIdFilter")?;
        }
        if let Some(f) = self.enemyIdExcludeFilter() {
            s.serialize_field("enemyIdExcludeFilter", &f)?;
        } else {
            s.skip_field("enemyIdExcludeFilter")?;
        }
        if let Some(f) = self.enemyLevelTypeFilter() {
            s.serialize_field("enemyLevelTypeFilter", &f)?;
        } else {
            s.skip_field("enemyLevelTypeFilter")?;
        }
        if let Some(f) = self.enemyActionHiddenGroupFilter() {
            s.serialize_field("enemyActionHiddenGroupFilter", &f)?;
        } else {
            s.skip_field("enemyActionHiddenGroupFilter")?;
        }
        if let Some(f) = self.skillIdFilter() {
            s.serialize_field("skillIdFilter", &f)?;
        } else {
            s.skip_field("skillIdFilter")?;
        }
        if let Some(f) = self.tileKeyFilter() {
            s.serialize_field("tileKeyFilter", &f)?;
        } else {
            s.skip_field("tileKeyFilter")?;
        }
        if let Some(f) = self.groupTagFilter() {
            s.serialize_field("groupTagFilter", &f)?;
        } else {
            s.skip_field("groupTagFilter")?;
        }
        if let Some(f) = self.filterTagFilter() {
            s.serialize_field("filterTagFilter", &f)?;
        } else {
            s.skip_field("filterTagFilter")?;
        }
        if let Some(f) = self.filterTagExcludeFilter() {
            s.serialize_field("filterTagExcludeFilter", &f)?;
        } else {
            s.skip_field("filterTagExcludeFilter")?;
        }
        if let Some(f) = self.subProfessionExcludeFilter() {
            s.serialize_field("subProfessionExcludeFilter", &f)?;
        } else {
            s.skip_field("subProfessionExcludeFilter")?;
        }
        if let Some(f) = self.mapTagFilter() {
            s.serialize_field("mapTagFilter", &f)?;
        } else {
            s.skip_field("mapTagFilter")?;
        }
        s.serialize_field("heightTypeMask", &self.heightTypeMask())?;
        s.end()
    }
}

pub struct clz_Torappu_RuneData_SelectorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RuneData_SelectorBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_professionMask(&mut self, professionMask: enum__Torappu_ProfessionCategory) {
        self.fbb_.push_slot::<enum__Torappu_ProfessionCategory>(
            clz_Torappu_RuneData_Selector::VT_PROFESSIONMASK,
            professionMask,
            enum__Torappu_ProfessionCategory::NONE,
        );
    }
    #[inline]
    pub fn add_buildableMask(&mut self, buildableMask: enum__Torappu_BuildableType) {
        self.fbb_.push_slot::<enum__Torappu_BuildableType>(
            clz_Torappu_RuneData_Selector::VT_BUILDABLEMASK,
            buildableMask,
            enum__Torappu_BuildableType::NONE,
        );
    }
    #[inline]
    pub fn add_playerSideMask(&mut self, playerSideMask: enum__Torappu_PlayerSideMask) {
        self.fbb_.push_slot::<enum__Torappu_PlayerSideMask>(
            clz_Torappu_RuneData_Selector::VT_PLAYERSIDEMASK,
            playerSideMask,
            enum__Torappu_PlayerSideMask::ALL,
        );
    }
    #[inline]
    pub fn add_sideType(&mut self, sideType: enum__Torappu_Battle_SideType) {
        self.fbb_.push_slot::<enum__Torappu_Battle_SideType>(
            clz_Torappu_RuneData_Selector::VT_SIDETYPE,
            sideType,
            enum__Torappu_Battle_SideType::NONE,
        );
    }
    #[inline]
    pub fn add_charIdFilter(
        &mut self,
        charIdFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_CHARIDFILTER,
            charIdFilter,
        );
    }
    #[inline]
    pub fn add_enemyIdFilter(
        &mut self,
        enemyIdFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_ENEMYIDFILTER,
            enemyIdFilter,
        );
    }
    #[inline]
    pub fn add_enemyIdExcludeFilter(
        &mut self,
        enemyIdExcludeFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_ENEMYIDEXCLUDEFILTER,
            enemyIdExcludeFilter,
        );
    }
    #[inline]
    pub fn add_enemyLevelTypeFilter(
        &mut self,
        enemyLevelTypeFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_ENEMYLEVELTYPEFILTER,
            enemyLevelTypeFilter,
        );
    }
    #[inline]
    pub fn add_enemyActionHiddenGroupFilter(
        &mut self,
        enemyActionHiddenGroupFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_ENEMYACTIONHIDDENGROUPFILTER,
            enemyActionHiddenGroupFilter,
        );
    }
    #[inline]
    pub fn add_skillIdFilter(
        &mut self,
        skillIdFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_SKILLIDFILTER,
            skillIdFilter,
        );
    }
    #[inline]
    pub fn add_tileKeyFilter(
        &mut self,
        tileKeyFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_TILEKEYFILTER,
            tileKeyFilter,
        );
    }
    #[inline]
    pub fn add_groupTagFilter(
        &mut self,
        groupTagFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_GROUPTAGFILTER,
            groupTagFilter,
        );
    }
    #[inline]
    pub fn add_filterTagFilter(
        &mut self,
        filterTagFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_FILTERTAGFILTER,
            filterTagFilter,
        );
    }
    #[inline]
    pub fn add_filterTagExcludeFilter(
        &mut self,
        filterTagExcludeFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_FILTERTAGEXCLUDEFILTER,
            filterTagExcludeFilter,
        );
    }
    #[inline]
    pub fn add_subProfessionExcludeFilter(
        &mut self,
        subProfessionExcludeFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_SUBPROFESSIONEXCLUDEFILTER,
            subProfessionExcludeFilter,
        );
    }
    #[inline]
    pub fn add_mapTagFilter(
        &mut self,
        mapTagFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_MAPTAGFILTER,
            mapTagFilter,
        );
    }
    #[inline]
    pub fn add_heightTypeMask(&mut self, heightTypeMask: enum__Torappu_TileData_HeightTypeMask) {
        self.fbb_
            .push_slot::<enum__Torappu_TileData_HeightTypeMask>(
                clz_Torappu_RuneData_Selector::VT_HEIGHTTYPEMASK,
                heightTypeMask,
                enum__Torappu_TileData_HeightTypeMask::NONE,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RuneData_SelectorBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RuneData_SelectorBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RuneData_Selector<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RuneData_Selector");
        ds.field("professionMask", &self.professionMask());
        ds.field("buildableMask", &self.buildableMask());
        ds.field("playerSideMask", &self.playerSideMask());
        ds.field("sideType", &self.sideType());
        ds.field("charIdFilter", &self.charIdFilter());
        ds.field("enemyIdFilter", &self.enemyIdFilter());
        ds.field("enemyIdExcludeFilter", &self.enemyIdExcludeFilter());
        ds.field("enemyLevelTypeFilter", &self.enemyLevelTypeFilter());
        ds.field(
            "enemyActionHiddenGroupFilter",
            &self.enemyActionHiddenGroupFilter(),
        );
        ds.field("skillIdFilter", &self.skillIdFilter());
        ds.field("tileKeyFilter", &self.tileKeyFilter());
        ds.field("groupTagFilter", &self.groupTagFilter());
        ds.field("filterTagFilter", &self.filterTagFilter());
        ds.field("filterTagExcludeFilter", &self.filterTagExcludeFilter());
        ds.field(
            "subProfessionExcludeFilter",
            &self.subProfessionExcludeFilter(),
        );
        ds.field("mapTagFilter", &self.mapTagFilter());
        ds.field("heightTypeMask", &self.heightTypeMask());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RuneData_SelectorT {
    pub professionMask: enum__Torappu_ProfessionCategory,
    pub buildableMask: enum__Torappu_BuildableType,
    pub playerSideMask: enum__Torappu_PlayerSideMask,
    pub sideType: enum__Torappu_Battle_SideType,
    pub charIdFilter: Option<Vec<String>>,
    pub enemyIdFilter: Option<Vec<String>>,
    pub enemyIdExcludeFilter: Option<Vec<String>>,
    pub enemyLevelTypeFilter: Option<Vec<String>>,
    pub enemyActionHiddenGroupFilter: Option<Vec<String>>,
    pub skillIdFilter: Option<Vec<String>>,
    pub tileKeyFilter: Option<Vec<String>>,
    pub groupTagFilter: Option<Vec<String>>,
    pub filterTagFilter: Option<Vec<String>>,
    pub filterTagExcludeFilter: Option<Vec<String>>,
    pub subProfessionExcludeFilter: Option<Vec<String>>,
    pub mapTagFilter: Option<Vec<String>>,
    pub heightTypeMask: enum__Torappu_TileData_HeightTypeMask,
}
impl Default for clz_Torappu_RuneData_SelectorT {
    fn default() -> Self {
        Self {
            professionMask: enum__Torappu_ProfessionCategory::NONE,
            buildableMask: enum__Torappu_BuildableType::NONE,
            playerSideMask: enum__Torappu_PlayerSideMask::ALL,
            sideType: enum__Torappu_Battle_SideType::NONE,
            charIdFilter: None,
            enemyIdFilter: None,
            enemyIdExcludeFilter: None,
            enemyLevelTypeFilter: None,
            enemyActionHiddenGroupFilter: None,
            skillIdFilter: None,
            tileKeyFilter: None,
            groupTagFilter: None,
            filterTagFilter: None,
            filterTagExcludeFilter: None,
            subProfessionExcludeFilter: None,
            mapTagFilter: None,
            heightTypeMask: enum__Torappu_TileData_HeightTypeMask::NONE,
        }
    }
}
impl clz_Torappu_RuneData_SelectorT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'b>> {
        let professionMask = self.professionMask;
        let buildableMask = self.buildableMask;
        let playerSideMask = self.playerSideMask;
        let sideType = self.sideType;
        let charIdFilter = self.charIdFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let enemyIdFilter = self.enemyIdFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let enemyIdExcludeFilter = self.enemyIdExcludeFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let enemyLevelTypeFilter = self.enemyLevelTypeFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let enemyActionHiddenGroupFilter = self.enemyActionHiddenGroupFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let skillIdFilter = self.skillIdFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let tileKeyFilter = self.tileKeyFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let groupTagFilter = self.groupTagFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let filterTagFilter = self.filterTagFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let filterTagExcludeFilter = self.filterTagExcludeFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let subProfessionExcludeFilter = self.subProfessionExcludeFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let mapTagFilter = self.mapTagFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let heightTypeMask = self.heightTypeMask;
        clz_Torappu_RuneData_Selector::create(
            _fbb,
            &clz_Torappu_RuneData_SelectorArgs {
                professionMask,
                buildableMask,
                playerSideMask,
                sideType,
                charIdFilter,
                enemyIdFilter,
                enemyIdExcludeFilter,
                enemyLevelTypeFilter,
                enemyActionHiddenGroupFilter,
                skillIdFilter,
                tileKeyFilter,
                groupTagFilter,
                filterTagFilter,
                filterTagExcludeFilter,
                subProfessionExcludeFilter,
                mapTagFilter,
                heightTypeMask,
            },
        )
    }
}
pub enum clz_Torappu_Blackboard_DataPairOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Blackboard_DataPair<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Blackboard_DataPair<'a> {
    type Inner = clz_Torappu_Blackboard_DataPair<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Blackboard_DataPair<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;
    pub const VT_VALUESTR: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Blackboard_DataPair { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Blackboard_DataPairArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'bldr>> {
        let mut builder = clz_Torappu_Blackboard_DataPairBuilder::new(_fbb);
        if let Some(x) = args.valueStr {
            builder.add_valueStr(x);
        }
        builder.add_value(args.value);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Blackboard_DataPairT {
        let key = self.key().map(|x| x.to_string());
        let value = self.value();
        let valueStr = self.valueStr().map(|x| x.to_string());
        clz_Torappu_Blackboard_DataPairT {
            key,
            value,
            valueStr,
        }
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_KEY,
                None,
            )
        }
    }
    #[inline]
    pub fn value(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn valueStr(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Blackboard_DataPair<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<f32>("value", Self::VT_VALUE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "valueStr",
                Self::VT_VALUESTR,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Blackboard_DataPairArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: f32,
    pub valueStr: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Blackboard_DataPairArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Blackboard_DataPairArgs {
            key: None,
            value: 0.0,
            valueStr: None,
        }
    }
}

impl Serialize for clz_Torappu_Blackboard_DataPair<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Blackboard_DataPair", 3)?;
        if let Some(f) = self.key() {
            s.serialize_field("key", &f)?;
        } else {
            s.skip_field("key")?;
        }
        s.serialize_field("value", &self.value())?;
        if let Some(f) = self.valueStr() {
            s.serialize_field("valueStr", &f)?;
        } else {
            s.skip_field("valueStr")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Blackboard_DataPairBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, value, 0.0);
    }
    #[inline]
    pub fn add_valueStr(&mut self, valueStr: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
            valueStr,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Blackboard_DataPairBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Blackboard_DataPair<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Blackboard_DataPair");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.field("valueStr", &self.valueStr());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Blackboard_DataPairT {
    pub key: Option<String>,
    pub value: f32,
    pub valueStr: Option<String>,
}
impl Default for clz_Torappu_Blackboard_DataPairT {
    fn default() -> Self {
        Self {
            key: None,
            value: 0.0,
            valueStr: None,
        }
    }
}
impl clz_Torappu_Blackboard_DataPairT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'b>> {
        let key = self.key.as_ref().map(|x| _fbb.create_string(x));
        let value = self.value;
        let valueStr = self.valueStr.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Blackboard_DataPair::create(
            _fbb,
            &clz_Torappu_Blackboard_DataPairArgs {
                key,
                value,
                valueStr,
            },
        )
    }
}
pub enum clz_Torappu_RuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RuneData<'a> {
    type Inner = clz_Torappu_RuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RuneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_SELECTOR: flatbuffers::VOffsetT = 6;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneData<'bldr>> {
        let mut builder = clz_Torappu_RuneDataBuilder::new(_fbb);
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        if let Some(x) = args.selector {
            builder.add_selector(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RuneDataT {
        let key = self.key().map(|x| x.to_string());
        let selector = self.selector().map(|x| Box::new(x.unpack()));
        let blackboard = self
            .blackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RuneDataT {
            key,
            selector,
            blackboard,
        }
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_RuneData::VT_KEY, None)
        }
    }
    #[inline]
    pub fn selector(&self) -> Option<clz_Torappu_RuneData_Selector<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneData_Selector>>(
                    clz_Torappu_RuneData::VT_SELECTOR,
                    None,
                )
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(clz_Torappu_RuneData::VT_BLACKBOARD, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneData_Selector>>(
                "selector",
                Self::VT_SELECTOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RuneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub selector: Option<flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'a>>>,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RuneDataArgs {
            key: None,
            selector: None,
            blackboard: None,
        }
    }
}

impl Serialize for clz_Torappu_RuneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RuneData", 3)?;
        if let Some(f) = self.key() {
            s.serialize_field("key", &f)?;
        } else {
            s.skip_field("key")?;
        }
        if let Some(f) = self.selector() {
            s.serialize_field("selector", &f)?;
        } else {
            s.skip_field("selector")?;
        }
        if let Some(f) = self.blackboard() {
            s.serialize_field("blackboard", &f)?;
        } else {
            s.skip_field("blackboard")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RuneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RuneDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_RuneData::VT_KEY, key);
    }
    #[inline]
    pub fn add_selector(
        &mut self,
        selector: flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector>>(
                clz_Torappu_RuneData::VT_SELECTOR,
                selector,
            );
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RuneData");
        ds.field("key", &self.key());
        ds.field("selector", &self.selector());
        ds.field("blackboard", &self.blackboard());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RuneDataT {
    pub key: Option<String>,
    pub selector: Option<Box<clz_Torappu_RuneData_SelectorT>>,
    pub blackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
}
impl Default for clz_Torappu_RuneDataT {
    fn default() -> Self {
        Self {
            key: None,
            selector: None,
            blackboard: None,
        }
    }
}
impl clz_Torappu_RuneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneData<'b>> {
        let key = self.key.as_ref().map(|x| _fbb.create_string(x));
        let selector = self.selector.as_ref().map(|x| x.pack(_fbb));
        let blackboard = self.blackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RuneData::create(
            _fbb,
            &clz_Torappu_RuneDataArgs {
                key,
                selector,
                blackboard,
            },
        )
    }
}
pub enum clz_Torappu_RuneTable_PackedRuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RuneTable_PackedRuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RuneTable_PackedRuneData<'a> {
    type Inner = clz_Torappu_RuneTable_PackedRuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RuneTable_PackedRuneData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_POINTS: flatbuffers::VOffsetT = 6;
    pub const VT_MUTEXGROUPKEY: flatbuffers::VOffsetT = 8;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
    pub const VT_RUNES: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RuneTable_PackedRuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RuneTable_PackedRuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'bldr>> {
        let mut builder = clz_Torappu_RuneTable_PackedRuneDataBuilder::new(_fbb);
        if let Some(x) = args.runes {
            builder.add_runes(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.mutexGroupKey {
            builder.add_mutexGroupKey(x);
        }
        builder.add_points(args.points);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RuneTable_PackedRuneDataT {
        let id = self.id().map(|x| x.to_string());
        let points = self.points();
        let mutexGroupKey = self.mutexGroupKey().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let runes = self.runes().map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RuneTable_PackedRuneDataT {
            id,
            points,
            mutexGroupKey,
            description,
            runes,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RuneTable_PackedRuneData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn points(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_RuneTable_PackedRuneData::VT_POINTS, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn mutexGroupKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RuneTable_PackedRuneData::VT_MUTEXGROUPKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RuneTable_PackedRuneData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn runes(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData>>,
            >>(clz_Torappu_RuneTable_PackedRuneData::VT_RUNES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RuneTable_PackedRuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<f32>("points", Self::VT_POINTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "mutexGroupKey",
                Self::VT_MUTEXGROUPKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData>>,
            >>("runes", Self::VT_RUNES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RuneTable_PackedRuneDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub points: f32,
    pub mutexGroupKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub runes: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RuneTable_PackedRuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RuneTable_PackedRuneDataArgs {
            id: None,
            points: 0.0,
            mutexGroupKey: None,
            description: None,
            runes: None,
        }
    }
}

impl Serialize for clz_Torappu_RuneTable_PackedRuneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RuneTable_PackedRuneData", 5)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("points", &self.points())?;
        if let Some(f) = self.mutexGroupKey() {
            s.serialize_field("mutexGroupKey", &f)?;
        } else {
            s.skip_field("mutexGroupKey")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        if let Some(f) = self.runes() {
            s.serialize_field("runes", &f)?;
        } else {
            s.skip_field("runes")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RuneTable_PackedRuneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RuneTable_PackedRuneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneTable_PackedRuneData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_points(&mut self, points: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_RuneTable_PackedRuneData::VT_POINTS, points, 0.0);
    }
    #[inline]
    pub fn add_mutexGroupKey(&mut self, mutexGroupKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneTable_PackedRuneData::VT_MUTEXGROUPKEY,
            mutexGroupKey,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneTable_PackedRuneData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_runes(
        &mut self,
        runes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneTable_PackedRuneData::VT_RUNES,
            runes,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RuneTable_PackedRuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RuneTable_PackedRuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RuneTable_PackedRuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RuneTable_PackedRuneData");
        ds.field("id", &self.id());
        ds.field("points", &self.points());
        ds.field("mutexGroupKey", &self.mutexGroupKey());
        ds.field("description", &self.description());
        ds.field("runes", &self.runes());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RuneTable_PackedRuneDataT {
    pub id: Option<String>,
    pub points: f32,
    pub mutexGroupKey: Option<String>,
    pub description: Option<String>,
    pub runes: Option<Vec<clz_Torappu_RuneDataT>>,
}
impl Default for clz_Torappu_RuneTable_PackedRuneDataT {
    fn default() -> Self {
        Self {
            id: None,
            points: 0.0,
            mutexGroupKey: None,
            description: None,
            runes: None,
        }
    }
}
impl clz_Torappu_RuneTable_PackedRuneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let points = self.points;
        let mutexGroupKey = self.mutexGroupKey.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let runes = self.runes.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RuneTable_PackedRuneData::create(
            _fbb,
            &clz_Torappu_RuneTable_PackedRuneDataArgs {
                id,
                points,
                mutexGroupKey,
                description,
                runes,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RuneTable_PackedRuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RuneTable_PackedRuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RuneTable_PackedRuneData<'a> {
    type Inner = dict__string__clz_Torappu_RuneTable_PackedRuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RuneTable_PackedRuneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RuneTable_PackedRuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RuneTable_PackedRuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RuneTable_PackedRuneData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RuneTable_PackedRuneDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RuneTable_PackedRuneDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RuneTable_PackedRuneDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RuneTable_PackedRuneData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RuneTable_PackedRuneData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RuneTable_PackedRuneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneTable_PackedRuneData>>(
                    dict__string__clz_Torappu_RuneTable_PackedRuneData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RuneTable_PackedRuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneTable_PackedRuneData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RuneTable_PackedRuneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RuneTable_PackedRuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RuneTable_PackedRuneDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RuneTable_PackedRuneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RuneTable_PackedRuneData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RuneTable_PackedRuneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RuneTable_PackedRuneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RuneTable_PackedRuneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData>>(
                dict__string__clz_Torappu_RuneTable_PackedRuneData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RuneTable_PackedRuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RuneTable_PackedRuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RuneTable_PackedRuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RuneTable_PackedRuneData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RuneTable_PackedRuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RuneTable_PackedRuneData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RuneTable_PackedRuneDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RuneTable_PackedRuneDataT>>,
}
impl Default for dict__string__clz_Torappu_RuneTable_PackedRuneDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RuneTable_PackedRuneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RuneTable_PackedRuneData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RuneTable_PackedRuneData::create(
            _fbb,
            &dict__string__clz_Torappu_RuneTable_PackedRuneDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_LegacyInLevelRuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LegacyInLevelRuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LegacyInLevelRuneData<'a> {
    type Inner = clz_Torappu_LegacyInLevelRuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_LegacyInLevelRuneData<'a> {
    pub const VT_DIFFICULTYMASK: flatbuffers::VOffsetT = 4;
    pub const VT_KEY: flatbuffers::VOffsetT = 6;
    pub const VT_PROFESSIONMASK: flatbuffers::VOffsetT = 8;
    pub const VT_BUILDABLEMASK: flatbuffers::VOffsetT = 10;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LegacyInLevelRuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LegacyInLevelRuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LegacyInLevelRuneData<'bldr>> {
        let mut builder = clz_Torappu_LegacyInLevelRuneDataBuilder::new(_fbb);
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        builder.add_buildableMask(args.buildableMask);
        builder.add_professionMask(args.professionMask);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.add_difficultyMask(args.difficultyMask);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_LegacyInLevelRuneDataT {
        let difficultyMask = self.difficultyMask();
        let key = self.key().map(|x| x.to_string());
        let professionMask = self.professionMask();
        let buildableMask = self.buildableMask();
        let blackboard = self
            .blackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_LegacyInLevelRuneDataT {
            difficultyMask,
            key,
            professionMask,
            buildableMask,
            blackboard,
        }
    }

    #[inline]
    pub fn difficultyMask(&self) -> enum__Torappu_LevelData_Difficulty {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_LevelData_Difficulty>(
                    clz_Torappu_LegacyInLevelRuneData::VT_DIFFICULTYMASK,
                    Some(enum__Torappu_LevelData_Difficulty::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LegacyInLevelRuneData::VT_KEY,
                None,
            )
        }
    }
    #[inline]
    pub fn professionMask(&self) -> enum__Torappu_ProfessionCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ProfessionCategory>(
                    clz_Torappu_LegacyInLevelRuneData::VT_PROFESSIONMASK,
                    Some(enum__Torappu_ProfessionCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn buildableMask(&self) -> enum__Torappu_BuildableType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildableType>(
                    clz_Torappu_LegacyInLevelRuneData::VT_BUILDABLEMASK,
                    Some(enum__Torappu_BuildableType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(clz_Torappu_LegacyInLevelRuneData::VT_BLACKBOARD, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LegacyInLevelRuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_LevelData_Difficulty>(
                "difficultyMask",
                Self::VT_DIFFICULTYMASK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<enum__Torappu_ProfessionCategory>(
                "professionMask",
                Self::VT_PROFESSIONMASK,
                false,
            )?
            .visit_field::<enum__Torappu_BuildableType>(
                "buildableMask",
                Self::VT_BUILDABLEMASK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LegacyInLevelRuneDataArgs<'a> {
    pub difficultyMask: enum__Torappu_LevelData_Difficulty,
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub professionMask: enum__Torappu_ProfessionCategory,
    pub buildableMask: enum__Torappu_BuildableType,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_LegacyInLevelRuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LegacyInLevelRuneDataArgs {
            difficultyMask: enum__Torappu_LevelData_Difficulty::NONE,
            key: None,
            professionMask: enum__Torappu_ProfessionCategory::NONE,
            buildableMask: enum__Torappu_BuildableType::NONE,
            blackboard: None,
        }
    }
}

impl Serialize for clz_Torappu_LegacyInLevelRuneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_LegacyInLevelRuneData", 5)?;
        s.serialize_field("difficultyMask", &self.difficultyMask())?;
        if let Some(f) = self.key() {
            s.serialize_field("key", &f)?;
        } else {
            s.skip_field("key")?;
        }
        s.serialize_field("professionMask", &self.professionMask())?;
        s.serialize_field("buildableMask", &self.buildableMask())?;
        if let Some(f) = self.blackboard() {
            s.serialize_field("blackboard", &f)?;
        } else {
            s.skip_field("blackboard")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_LegacyInLevelRuneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_LegacyInLevelRuneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_difficultyMask(&mut self, difficultyMask: enum__Torappu_LevelData_Difficulty) {
        self.fbb_.push_slot::<enum__Torappu_LevelData_Difficulty>(
            clz_Torappu_LegacyInLevelRuneData::VT_DIFFICULTYMASK,
            difficultyMask,
            enum__Torappu_LevelData_Difficulty::NONE,
        );
    }
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LegacyInLevelRuneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_professionMask(&mut self, professionMask: enum__Torappu_ProfessionCategory) {
        self.fbb_.push_slot::<enum__Torappu_ProfessionCategory>(
            clz_Torappu_LegacyInLevelRuneData::VT_PROFESSIONMASK,
            professionMask,
            enum__Torappu_ProfessionCategory::NONE,
        );
    }
    #[inline]
    pub fn add_buildableMask(&mut self, buildableMask: enum__Torappu_BuildableType) {
        self.fbb_.push_slot::<enum__Torappu_BuildableType>(
            clz_Torappu_LegacyInLevelRuneData::VT_BUILDABLEMASK,
            buildableMask,
            enum__Torappu_BuildableType::NONE,
        );
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LegacyInLevelRuneData::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LegacyInLevelRuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LegacyInLevelRuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_LegacyInLevelRuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LegacyInLevelRuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LegacyInLevelRuneData");
        ds.field("difficultyMask", &self.difficultyMask());
        ds.field("key", &self.key());
        ds.field("professionMask", &self.professionMask());
        ds.field("buildableMask", &self.buildableMask());
        ds.field("blackboard", &self.blackboard());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_LegacyInLevelRuneDataT {
    pub difficultyMask: enum__Torappu_LevelData_Difficulty,
    pub key: Option<String>,
    pub professionMask: enum__Torappu_ProfessionCategory,
    pub buildableMask: enum__Torappu_BuildableType,
    pub blackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
}
impl Default for clz_Torappu_LegacyInLevelRuneDataT {
    fn default() -> Self {
        Self {
            difficultyMask: enum__Torappu_LevelData_Difficulty::NONE,
            key: None,
            professionMask: enum__Torappu_ProfessionCategory::NONE,
            buildableMask: enum__Torappu_BuildableType::NONE,
            blackboard: None,
        }
    }
}
impl clz_Torappu_LegacyInLevelRuneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LegacyInLevelRuneData<'b>> {
        let difficultyMask = self.difficultyMask;
        let key = self.key.as_ref().map(|x| _fbb.create_string(x));
        let professionMask = self.professionMask;
        let buildableMask = self.buildableMask;
        let blackboard = self.blackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_LegacyInLevelRuneData::create(
            _fbb,
            &clz_Torappu_LegacyInLevelRuneDataArgs {
                difficultyMask,
                key,
                professionMask,
                buildableMask,
                blackboard,
            },
        )
    }
}
pub enum dict__string__list_clz_Torappu_LegacyInLevelRuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a> {
    type Inner = dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_clz_Torappu_LegacyInLevelRuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_clz_Torappu_LegacyInLevelRuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_LegacyInLevelRuneData<'bldr>> {
        let mut builder = dict__string__list_clz_Torappu_LegacyInLevelRuneDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__list_clz_Torappu_LegacyInLevelRuneDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| x.iter().map(|t| t.unpack()).collect());
        dict__string__list_clz_Torappu_LegacyInLevelRuneDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__list_clz_Torappu_LegacyInLevelRuneData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__list_clz_Torappu_LegacyInLevelRuneData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData>,
                >,
            >>(
                dict__string__list_clz_Torappu_LegacyInLevelRuneData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__list_clz_Torappu_LegacyInLevelRuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData>,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_clz_Torappu_LegacyInLevelRuneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for dict__string__list_clz_Torappu_LegacyInLevelRuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__list_clz_Torappu_LegacyInLevelRuneDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__list_clz_Torappu_LegacyInLevelRuneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__list_clz_Torappu_LegacyInLevelRuneData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__list_clz_Torappu_LegacyInLevelRuneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__list_clz_Torappu_LegacyInLevelRuneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_clz_Torappu_LegacyInLevelRuneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_clz_Torappu_LegacyInLevelRuneData::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__list_clz_Torappu_LegacyInLevelRuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__list_clz_Torappu_LegacyInLevelRuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__list_clz_Torappu_LegacyInLevelRuneData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__list_clz_Torappu_LegacyInLevelRuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__list_clz_Torappu_LegacyInLevelRuneData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__list_clz_Torappu_LegacyInLevelRuneDataT {
    pub key: String,
    pub value: Option<Vec<clz_Torappu_LegacyInLevelRuneDataT>>,
}
impl Default for dict__string__list_clz_Torappu_LegacyInLevelRuneDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__list_clz_Torappu_LegacyInLevelRuneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_LegacyInLevelRuneData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        dict__string__list_clz_Torappu_LegacyInLevelRuneData::create(
            _fbb,
            &dict__string__list_clz_Torappu_LegacyInLevelRuneDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2QuestDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2QuestData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2QuestData<'a> {
    type Inner = clz_Torappu_SandboxV2QuestData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2QuestData<'a> {
    pub const VT_QUESTID: flatbuffers::VOffsetT = 4;
    pub const VT_QUESTLINE: flatbuffers::VOffsetT = 6;
    pub const VT_QUESTTITLE: flatbuffers::VOffsetT = 8;
    pub const VT_QUESTDESC: flatbuffers::VOffsetT = 10;
    pub const VT_QUESTTARGETDESC: flatbuffers::VOffsetT = 12;
    pub const VT_ISDISPLAY: flatbuffers::VOffsetT = 14;
    pub const VT_QUESTROUTETYPE: flatbuffers::VOffsetT = 16;
    pub const VT_QUESTLINETYPE: flatbuffers::VOffsetT = 18;
    pub const VT_QUESTROUTEPARAM: flatbuffers::VOffsetT = 20;
    pub const VT_SHOWPROGRESSINDEX: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2QuestData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2QuestDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2QuestData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2QuestDataBuilder::new(_fbb);
        builder.add_showProgressIndex(args.showProgressIndex);
        if let Some(x) = args.questRouteParam {
            builder.add_questRouteParam(x);
        }
        builder.add_questLineType(args.questLineType);
        builder.add_questRouteType(args.questRouteType);
        if let Some(x) = args.questTargetDesc {
            builder.add_questTargetDesc(x);
        }
        if let Some(x) = args.questDesc {
            builder.add_questDesc(x);
        }
        if let Some(x) = args.questTitle {
            builder.add_questTitle(x);
        }
        if let Some(x) = args.questLine {
            builder.add_questLine(x);
        }
        if let Some(x) = args.questId {
            builder.add_questId(x);
        }
        builder.add_isDisplay(args.isDisplay);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2QuestDataT {
        let questId = self.questId().map(|x| x.to_string());
        let questLine = self.questLine().map(|x| x.to_string());
        let questTitle = self.questTitle().map(|x| x.to_string());
        let questDesc = self.questDesc().map(|x| x.to_string());
        let questTargetDesc = self.questTargetDesc().map(|x| x.to_string());
        let isDisplay = self.isDisplay();
        let questRouteType = self.questRouteType();
        let questLineType = self.questLineType();
        let questRouteParam = self.questRouteParam().map(|x| x.to_string());
        let showProgressIndex = self.showProgressIndex();
        clz_Torappu_SandboxV2QuestDataT {
            questId,
            questLine,
            questTitle,
            questDesc,
            questTargetDesc,
            isDisplay,
            questRouteType,
            questLineType,
            questRouteParam,
            showProgressIndex,
        }
    }

    #[inline]
    pub fn questId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2QuestData::VT_QUESTID,
                None,
            )
        }
    }
    #[inline]
    pub fn questLine(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2QuestData::VT_QUESTLINE,
                None,
            )
        }
    }
    #[inline]
    pub fn questTitle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2QuestData::VT_QUESTTITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn questDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2QuestData::VT_QUESTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn questTargetDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2QuestData::VT_QUESTTARGETDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn isDisplay(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_SandboxV2QuestData::VT_ISDISPLAY, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn questRouteType(&self) -> enum__Torappu_SandboxV2QuestRouteType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2QuestRouteType>(
                    clz_Torappu_SandboxV2QuestData::VT_QUESTROUTETYPE,
                    Some(enum__Torappu_SandboxV2QuestRouteType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn questLineType(&self) -> enum__Torappu_SandboxV2QuestLineType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2QuestLineType>(
                    clz_Torappu_SandboxV2QuestData::VT_QUESTLINETYPE,
                    Some(enum__Torappu_SandboxV2QuestLineType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn questRouteParam(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2QuestData::VT_QUESTROUTEPARAM,
                None,
            )
        }
    }
    #[inline]
    pub fn showProgressIndex(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2QuestData::VT_SHOWPROGRESSINDEX,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2QuestData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("questId", Self::VT_QUESTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "questLine",
                Self::VT_QUESTLINE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "questTitle",
                Self::VT_QUESTTITLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "questDesc",
                Self::VT_QUESTDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "questTargetDesc",
                Self::VT_QUESTTARGETDESC,
                false,
            )?
            .visit_field::<bool>("isDisplay", Self::VT_ISDISPLAY, false)?
            .visit_field::<enum__Torappu_SandboxV2QuestRouteType>(
                "questRouteType",
                Self::VT_QUESTROUTETYPE,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxV2QuestLineType>(
                "questLineType",
                Self::VT_QUESTLINETYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "questRouteParam",
                Self::VT_QUESTROUTEPARAM,
                false,
            )?
            .visit_field::<i32>("showProgressIndex", Self::VT_SHOWPROGRESSINDEX, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2QuestDataArgs<'a> {
    pub questId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub questLine: Option<flatbuffers::WIPOffset<&'a str>>,
    pub questTitle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub questDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub questTargetDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isDisplay: bool,
    pub questRouteType: enum__Torappu_SandboxV2QuestRouteType,
    pub questLineType: enum__Torappu_SandboxV2QuestLineType,
    pub questRouteParam: Option<flatbuffers::WIPOffset<&'a str>>,
    pub showProgressIndex: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2QuestDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2QuestDataArgs {
            questId: None,
            questLine: None,
            questTitle: None,
            questDesc: None,
            questTargetDesc: None,
            isDisplay: false,
            questRouteType: enum__Torappu_SandboxV2QuestRouteType::NONE,
            questLineType: enum__Torappu_SandboxV2QuestLineType::NONE,
            questRouteParam: None,
            showProgressIndex: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2QuestData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2QuestData", 10)?;
        if let Some(f) = self.questId() {
            s.serialize_field("questId", &f)?;
        } else {
            s.skip_field("questId")?;
        }
        if let Some(f) = self.questLine() {
            s.serialize_field("questLine", &f)?;
        } else {
            s.skip_field("questLine")?;
        }
        if let Some(f) = self.questTitle() {
            s.serialize_field("questTitle", &f)?;
        } else {
            s.skip_field("questTitle")?;
        }
        if let Some(f) = self.questDesc() {
            s.serialize_field("questDesc", &f)?;
        } else {
            s.skip_field("questDesc")?;
        }
        if let Some(f) = self.questTargetDesc() {
            s.serialize_field("questTargetDesc", &f)?;
        } else {
            s.skip_field("questTargetDesc")?;
        }
        s.serialize_field("isDisplay", &self.isDisplay())?;
        s.serialize_field("questRouteType", &self.questRouteType())?;
        s.serialize_field("questLineType", &self.questLineType())?;
        if let Some(f) = self.questRouteParam() {
            s.serialize_field("questRouteParam", &f)?;
        } else {
            s.skip_field("questRouteParam")?;
        }
        s.serialize_field("showProgressIndex", &self.showProgressIndex())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2QuestDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2QuestDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_questId(&mut self, questId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2QuestData::VT_QUESTID,
            questId,
        );
    }
    #[inline]
    pub fn add_questLine(&mut self, questLine: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2QuestData::VT_QUESTLINE,
            questLine,
        );
    }
    #[inline]
    pub fn add_questTitle(&mut self, questTitle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2QuestData::VT_QUESTTITLE,
            questTitle,
        );
    }
    #[inline]
    pub fn add_questDesc(&mut self, questDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2QuestData::VT_QUESTDESC,
            questDesc,
        );
    }
    #[inline]
    pub fn add_questTargetDesc(&mut self, questTargetDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2QuestData::VT_QUESTTARGETDESC,
            questTargetDesc,
        );
    }
    #[inline]
    pub fn add_isDisplay(&mut self, isDisplay: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SandboxV2QuestData::VT_ISDISPLAY,
            isDisplay,
            false,
        );
    }
    #[inline]
    pub fn add_questRouteType(&mut self, questRouteType: enum__Torappu_SandboxV2QuestRouteType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2QuestRouteType>(
                clz_Torappu_SandboxV2QuestData::VT_QUESTROUTETYPE,
                questRouteType,
                enum__Torappu_SandboxV2QuestRouteType::NONE,
            );
    }
    #[inline]
    pub fn add_questLineType(&mut self, questLineType: enum__Torappu_SandboxV2QuestLineType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2QuestLineType>(
            clz_Torappu_SandboxV2QuestData::VT_QUESTLINETYPE,
            questLineType,
            enum__Torappu_SandboxV2QuestLineType::NONE,
        );
    }
    #[inline]
    pub fn add_questRouteParam(&mut self, questRouteParam: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2QuestData::VT_QUESTROUTEPARAM,
            questRouteParam,
        );
    }
    #[inline]
    pub fn add_showProgressIndex(&mut self, showProgressIndex: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2QuestData::VT_SHOWPROGRESSINDEX,
            showProgressIndex,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2QuestDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2QuestDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2QuestData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2QuestData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2QuestData");
        ds.field("questId", &self.questId());
        ds.field("questLine", &self.questLine());
        ds.field("questTitle", &self.questTitle());
        ds.field("questDesc", &self.questDesc());
        ds.field("questTargetDesc", &self.questTargetDesc());
        ds.field("isDisplay", &self.isDisplay());
        ds.field("questRouteType", &self.questRouteType());
        ds.field("questLineType", &self.questLineType());
        ds.field("questRouteParam", &self.questRouteParam());
        ds.field("showProgressIndex", &self.showProgressIndex());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2QuestDataT {
    pub questId: Option<String>,
    pub questLine: Option<String>,
    pub questTitle: Option<String>,
    pub questDesc: Option<String>,
    pub questTargetDesc: Option<String>,
    pub isDisplay: bool,
    pub questRouteType: enum__Torappu_SandboxV2QuestRouteType,
    pub questLineType: enum__Torappu_SandboxV2QuestLineType,
    pub questRouteParam: Option<String>,
    pub showProgressIndex: i32,
}
impl Default for clz_Torappu_SandboxV2QuestDataT {
    fn default() -> Self {
        Self {
            questId: None,
            questLine: None,
            questTitle: None,
            questDesc: None,
            questTargetDesc: None,
            isDisplay: false,
            questRouteType: enum__Torappu_SandboxV2QuestRouteType::NONE,
            questLineType: enum__Torappu_SandboxV2QuestLineType::NONE,
            questRouteParam: None,
            showProgressIndex: 0,
        }
    }
}
impl clz_Torappu_SandboxV2QuestDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2QuestData<'b>> {
        let questId = self.questId.as_ref().map(|x| _fbb.create_string(x));
        let questLine = self.questLine.as_ref().map(|x| _fbb.create_string(x));
        let questTitle = self.questTitle.as_ref().map(|x| _fbb.create_string(x));
        let questDesc = self.questDesc.as_ref().map(|x| _fbb.create_string(x));
        let questTargetDesc = self.questTargetDesc.as_ref().map(|x| _fbb.create_string(x));
        let isDisplay = self.isDisplay;
        let questRouteType = self.questRouteType;
        let questLineType = self.questLineType;
        let questRouteParam = self.questRouteParam.as_ref().map(|x| _fbb.create_string(x));
        let showProgressIndex = self.showProgressIndex;
        clz_Torappu_SandboxV2QuestData::create(
            _fbb,
            &clz_Torappu_SandboxV2QuestDataArgs {
                questId,
                questLine,
                questTitle,
                questDesc,
                questTargetDesc,
                isDisplay,
                questRouteType,
                questLineType,
                questRouteParam,
                showProgressIndex,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2QuestDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2QuestData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2QuestData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2QuestData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2QuestData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2QuestData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2QuestDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2QuestData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2QuestDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2QuestDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2QuestDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2QuestData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2QuestData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2QuestData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2QuestData>>(
                    dict__string__clz_Torappu_SandboxV2QuestData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2QuestData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2QuestData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2QuestDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2QuestData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2QuestDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2QuestDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2QuestData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2QuestData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2QuestDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2QuestDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2QuestData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2QuestData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2QuestData>>(
                dict__string__clz_Torappu_SandboxV2QuestData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2QuestDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2QuestDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2QuestData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2QuestData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2QuestData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2QuestData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2QuestDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2QuestDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2QuestDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2QuestDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2QuestData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2QuestData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2QuestDataArgs { key, value },
        )
    }
}
pub enum dict__enum__Torappu_BattleDialogType__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_BattleDialogType__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__enum__Torappu_BattleDialogType__string<'a> {
    type Inner = dict__enum__Torappu_BattleDialogType__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__enum__Torappu_BattleDialogType__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_BattleDialogType__string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__enum__Torappu_BattleDialogType__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_BattleDialogType__string<'bldr>> {
        let mut builder = dict__enum__Torappu_BattleDialogType__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__enum__Torappu_BattleDialogType__stringT {
        let key = self.key();
        let value = self.value().map(|x| x.to_string());
        dict__enum__Torappu_BattleDialogType__stringT { key, value }
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_BattleDialogType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BattleDialogType>(
                    dict__enum__Torappu_BattleDialogType__string::VT_KEY,
                    Some(enum__Torappu_BattleDialogType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__enum__Torappu_BattleDialogType__string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_BattleDialogType,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                dict__enum__Torappu_BattleDialogType__string::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for dict__enum__Torappu_BattleDialogType__string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_BattleDialogType>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__enum__Torappu_BattleDialogType__stringArgs<'a> {
    pub key: enum__Torappu_BattleDialogType,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for dict__enum__Torappu_BattleDialogType__stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__enum__Torappu_BattleDialogType__stringArgs {
            key: enum__Torappu_BattleDialogType::NONE,
            value: None,
        }
    }
}

impl Serialize for dict__enum__Torappu_BattleDialogType__string<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__enum__Torappu_BattleDialogType__string", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__enum__Torappu_BattleDialogType__stringBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__enum__Torappu_BattleDialogType__stringBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: enum__Torappu_BattleDialogType) {
        self.fbb_.push_slot::<enum__Torappu_BattleDialogType>(
            dict__enum__Torappu_BattleDialogType__string::VT_KEY,
            key,
            enum__Torappu_BattleDialogType::NONE,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__enum__Torappu_BattleDialogType__string::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__enum__Torappu_BattleDialogType__stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__enum__Torappu_BattleDialogType__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_BattleDialogType__string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__enum__Torappu_BattleDialogType__string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__enum__Torappu_BattleDialogType__string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__enum__Torappu_BattleDialogType__stringT {
    pub key: enum__Torappu_BattleDialogType,
    pub value: Option<String>,
}
impl Default for dict__enum__Torappu_BattleDialogType__stringT {
    fn default() -> Self {
        Self {
            key: enum__Torappu_BattleDialogType::NONE,
            value: None,
        }
    }
}
impl dict__enum__Torappu_BattleDialogType__stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_BattleDialogType__string<'b>> {
        let key = self.key;
        let value = self.value.as_ref().map(|x| _fbb.create_string(x));
        dict__enum__Torappu_BattleDialogType__string::create(
            _fbb,
            &dict__enum__Torappu_BattleDialogType__stringArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2NpcDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2NpcData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2NpcData<'a> {
    type Inner = clz_Torappu_SandboxV2NpcData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2NpcData<'a> {
    pub const VT_NPCID: flatbuffers::VOffsetT = 4;
    pub const VT_TRAPID: flatbuffers::VOffsetT = 6;
    pub const VT_NPCTYPE: flatbuffers::VOffsetT = 8;
    pub const VT_DIALOGIDS: flatbuffers::VOffsetT = 10;
    pub const VT_NPCLOCATION: flatbuffers::VOffsetT = 12;
    pub const VT_NPCORIENTATION: flatbuffers::VOffsetT = 14;
    pub const VT_PICID: flatbuffers::VOffsetT = 16;
    pub const VT_PICNAME: flatbuffers::VOffsetT = 18;
    pub const VT_SHOWPIC: flatbuffers::VOffsetT = 20;
    pub const VT_REACTSKILLINDEX: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2NpcData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2NpcDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NpcData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2NpcDataBuilder::new(_fbb);
        builder.add_reactSkillIndex(args.reactSkillIndex);
        if let Some(x) = args.picName {
            builder.add_picName(x);
        }
        if let Some(x) = args.picId {
            builder.add_picId(x);
        }
        builder.add_npcOrientation(args.npcOrientation);
        if let Some(x) = args.npcLocation {
            builder.add_npcLocation(x);
        }
        if let Some(x) = args.dialogIds {
            builder.add_dialogIds(x);
        }
        builder.add_npcType(args.npcType);
        if let Some(x) = args.trapId {
            builder.add_trapId(x);
        }
        if let Some(x) = args.npcId {
            builder.add_npcId(x);
        }
        builder.add_showPic(args.showPic);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2NpcDataT {
        let npcId = self.npcId().map(|x| x.to_string());
        let trapId = self.trapId().map(|x| x.to_string());
        let npcType = self.npcType();
        let dialogIds = self
            .dialogIds()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let npcLocation = self.npcLocation().map(|x| x.into_iter().collect());
        let npcOrientation = self.npcOrientation();
        let picId = self.picId().map(|x| x.to_string());
        let picName = self.picName().map(|x| x.to_string());
        let showPic = self.showPic();
        let reactSkillIndex = self.reactSkillIndex();
        clz_Torappu_SandboxV2NpcDataT {
            npcId,
            trapId,
            npcType,
            dialogIds,
            npcLocation,
            npcOrientation,
            picId,
            picName,
            showPic,
            reactSkillIndex,
        }
    }

    #[inline]
    pub fn npcId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NpcData::VT_NPCID,
                None,
            )
        }
    }
    #[inline]
    pub fn trapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NpcData::VT_TRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn npcType(&self) -> enum__Torappu_SandboxV2NpcType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2NpcType>(
                    clz_Torappu_SandboxV2NpcData::VT_NPCTYPE,
                    Some(enum__Torappu_SandboxV2NpcType::NORMAL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn dialogIds(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__enum__Torappu_BattleDialogType__string<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__enum__Torappu_BattleDialogType__string>,
                >,
            >>(clz_Torappu_SandboxV2NpcData::VT_DIALOGIDS, None)
        }
    }
    #[inline]
    pub fn npcLocation(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    clz_Torappu_SandboxV2NpcData::VT_NPCLOCATION,
                    None,
                )
        }
    }
    #[inline]
    pub fn npcOrientation(&self) -> enum__Torappu_SharedConsts_Direction {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SharedConsts_Direction>(
                    clz_Torappu_SandboxV2NpcData::VT_NPCORIENTATION,
                    Some(enum__Torappu_SharedConsts_Direction::UP),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn picId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NpcData::VT_PICID,
                None,
            )
        }
    }
    #[inline]
    pub fn picName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2NpcData::VT_PICNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn showPic(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_SandboxV2NpcData::VT_SHOWPIC, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn reactSkillIndex(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2NpcData::VT_REACTSKILLINDEX, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2NpcData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("npcId", Self::VT_NPCID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("trapId", Self::VT_TRAPID, false)?
            .visit_field::<enum__Torappu_SandboxV2NpcType>("npcType", Self::VT_NPCTYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__enum__Torappu_BattleDialogType__string>,
                >,
            >>("dialogIds", Self::VT_DIALOGIDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "npcLocation",
                Self::VT_NPCLOCATION,
                false,
            )?
            .visit_field::<enum__Torappu_SharedConsts_Direction>(
                "npcOrientation",
                Self::VT_NPCORIENTATION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("picId", Self::VT_PICID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("picName", Self::VT_PICNAME, false)?
            .visit_field::<bool>("showPic", Self::VT_SHOWPIC, false)?
            .visit_field::<i32>("reactSkillIndex", Self::VT_REACTSKILLINDEX, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2NpcDataArgs<'a> {
    pub npcId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub npcType: enum__Torappu_SandboxV2NpcType,
    pub dialogIds: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__enum__Torappu_BattleDialogType__string<'a>>,
            >,
        >,
    >,
    pub npcLocation: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub npcOrientation: enum__Torappu_SharedConsts_Direction,
    pub picId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub picName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub showPic: bool,
    pub reactSkillIndex: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2NpcDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2NpcDataArgs {
            npcId: None,
            trapId: None,
            npcType: enum__Torappu_SandboxV2NpcType::NORMAL,
            dialogIds: None,
            npcLocation: None,
            npcOrientation: enum__Torappu_SharedConsts_Direction::UP,
            picId: None,
            picName: None,
            showPic: false,
            reactSkillIndex: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2NpcData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2NpcData", 10)?;
        if let Some(f) = self.npcId() {
            s.serialize_field("npcId", &f)?;
        } else {
            s.skip_field("npcId")?;
        }
        if let Some(f) = self.trapId() {
            s.serialize_field("trapId", &f)?;
        } else {
            s.skip_field("trapId")?;
        }
        s.serialize_field("npcType", &self.npcType())?;
        if let Some(f) = self.dialogIds() {
            s.serialize_field("dialogIds", &f)?;
        } else {
            s.skip_field("dialogIds")?;
        }
        if let Some(f) = self.npcLocation() {
            s.serialize_field("npcLocation", &f)?;
        } else {
            s.skip_field("npcLocation")?;
        }
        s.serialize_field("npcOrientation", &self.npcOrientation())?;
        if let Some(f) = self.picId() {
            s.serialize_field("picId", &f)?;
        } else {
            s.skip_field("picId")?;
        }
        if let Some(f) = self.picName() {
            s.serialize_field("picName", &f)?;
        } else {
            s.skip_field("picName")?;
        }
        s.serialize_field("showPic", &self.showPic())?;
        s.serialize_field("reactSkillIndex", &self.reactSkillIndex())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2NpcDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2NpcDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_npcId(&mut self, npcId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NpcData::VT_NPCID,
            npcId,
        );
    }
    #[inline]
    pub fn add_trapId(&mut self, trapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NpcData::VT_TRAPID,
            trapId,
        );
    }
    #[inline]
    pub fn add_npcType(&mut self, npcType: enum__Torappu_SandboxV2NpcType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2NpcType>(
            clz_Torappu_SandboxV2NpcData::VT_NPCTYPE,
            npcType,
            enum__Torappu_SandboxV2NpcType::NORMAL,
        );
    }
    #[inline]
    pub fn add_dialogIds(
        &mut self,
        dialogIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__enum__Torappu_BattleDialogType__string<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NpcData::VT_DIALOGIDS,
            dialogIds,
        );
    }
    #[inline]
    pub fn add_npcLocation(
        &mut self,
        npcLocation: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NpcData::VT_NPCLOCATION,
            npcLocation,
        );
    }
    #[inline]
    pub fn add_npcOrientation(&mut self, npcOrientation: enum__Torappu_SharedConsts_Direction) {
        self.fbb_.push_slot::<enum__Torappu_SharedConsts_Direction>(
            clz_Torappu_SandboxV2NpcData::VT_NPCORIENTATION,
            npcOrientation,
            enum__Torappu_SharedConsts_Direction::UP,
        );
    }
    #[inline]
    pub fn add_picId(&mut self, picId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NpcData::VT_PICID,
            picId,
        );
    }
    #[inline]
    pub fn add_picName(&mut self, picName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2NpcData::VT_PICNAME,
            picName,
        );
    }
    #[inline]
    pub fn add_showPic(&mut self, showPic: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_SandboxV2NpcData::VT_SHOWPIC, showPic, false);
    }
    #[inline]
    pub fn add_reactSkillIndex(&mut self, reactSkillIndex: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2NpcData::VT_REACTSKILLINDEX,
            reactSkillIndex,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2NpcDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2NpcDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NpcData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2NpcData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2NpcData");
        ds.field("npcId", &self.npcId());
        ds.field("trapId", &self.trapId());
        ds.field("npcType", &self.npcType());
        ds.field("dialogIds", &self.dialogIds());
        ds.field("npcLocation", &self.npcLocation());
        ds.field("npcOrientation", &self.npcOrientation());
        ds.field("picId", &self.picId());
        ds.field("picName", &self.picName());
        ds.field("showPic", &self.showPic());
        ds.field("reactSkillIndex", &self.reactSkillIndex());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2NpcDataT {
    pub npcId: Option<String>,
    pub trapId: Option<String>,
    pub npcType: enum__Torappu_SandboxV2NpcType,
    pub dialogIds: Option<Vec<dict__enum__Torappu_BattleDialogType__stringT>>,
    pub npcLocation: Option<Vec<i32>>,
    pub npcOrientation: enum__Torappu_SharedConsts_Direction,
    pub picId: Option<String>,
    pub picName: Option<String>,
    pub showPic: bool,
    pub reactSkillIndex: i32,
}
impl Default for clz_Torappu_SandboxV2NpcDataT {
    fn default() -> Self {
        Self {
            npcId: None,
            trapId: None,
            npcType: enum__Torappu_SandboxV2NpcType::NORMAL,
            dialogIds: None,
            npcLocation: None,
            npcOrientation: enum__Torappu_SharedConsts_Direction::UP,
            picId: None,
            picName: None,
            showPic: false,
            reactSkillIndex: 0,
        }
    }
}
impl clz_Torappu_SandboxV2NpcDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2NpcData<'b>> {
        let npcId = self.npcId.as_ref().map(|x| _fbb.create_string(x));
        let trapId = self.trapId.as_ref().map(|x| _fbb.create_string(x));
        let npcType = self.npcType;
        let dialogIds = self.dialogIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let npcLocation = self.npcLocation.as_ref().map(|x| _fbb.create_vector(x));
        let npcOrientation = self.npcOrientation;
        let picId = self.picId.as_ref().map(|x| _fbb.create_string(x));
        let picName = self.picName.as_ref().map(|x| _fbb.create_string(x));
        let showPic = self.showPic;
        let reactSkillIndex = self.reactSkillIndex;
        clz_Torappu_SandboxV2NpcData::create(
            _fbb,
            &clz_Torappu_SandboxV2NpcDataArgs {
                npcId,
                trapId,
                npcType,
                dialogIds,
                npcLocation,
                npcOrientation,
                picId,
                picName,
                showPic,
                reactSkillIndex,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2NpcDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2NpcData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2NpcData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2NpcData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2NpcData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2NpcData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2NpcDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NpcData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2NpcDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2NpcDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2NpcDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2NpcData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2NpcData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2NpcData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2NpcData>>(
                    dict__string__clz_Torappu_SandboxV2NpcData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2NpcData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2NpcData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2NpcDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2NpcData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2NpcDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2NpcDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2NpcData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2NpcData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2NpcDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2NpcDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2NpcData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2NpcData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2NpcData>>(
                dict__string__clz_Torappu_SandboxV2NpcData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2NpcDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2NpcDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NpcData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_SandboxV2NpcData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2NpcData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2NpcData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2NpcDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2NpcDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2NpcDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2NpcDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2NpcData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2NpcData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2NpcDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2DialogDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2DialogData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2DialogData<'a> {
    type Inner = clz_Torappu_SandboxV2DialogData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2DialogData<'a> {
    pub const VT_DIALOGID: flatbuffers::VOffsetT = 4;
    pub const VT_AVGID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2DialogData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2DialogDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DialogData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2DialogDataBuilder::new(_fbb);
        if let Some(x) = args.avgId {
            builder.add_avgId(x);
        }
        if let Some(x) = args.dialogId {
            builder.add_dialogId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2DialogDataT {
        let dialogId = self.dialogId().map(|x| x.to_string());
        let avgId = self.avgId().map(|x| x.to_string());
        clz_Torappu_SandboxV2DialogDataT { dialogId, avgId }
    }

    #[inline]
    pub fn dialogId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DialogData::VT_DIALOGID,
                None,
            )
        }
    }
    #[inline]
    pub fn avgId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DialogData::VT_AVGID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2DialogData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dialogId",
                Self::VT_DIALOGID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("avgId", Self::VT_AVGID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2DialogDataArgs<'a> {
    pub dialogId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub avgId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2DialogDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2DialogDataArgs {
            dialogId: None,
            avgId: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2DialogData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2DialogData", 2)?;
        if let Some(f) = self.dialogId() {
            s.serialize_field("dialogId", &f)?;
        } else {
            s.skip_field("dialogId")?;
        }
        if let Some(f) = self.avgId() {
            s.serialize_field("avgId", &f)?;
        } else {
            s.skip_field("avgId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2DialogDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2DialogDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_dialogId(&mut self, dialogId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DialogData::VT_DIALOGID,
            dialogId,
        );
    }
    #[inline]
    pub fn add_avgId(&mut self, avgId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DialogData::VT_AVGID,
            avgId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2DialogDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2DialogDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DialogData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2DialogData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2DialogData");
        ds.field("dialogId", &self.dialogId());
        ds.field("avgId", &self.avgId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2DialogDataT {
    pub dialogId: Option<String>,
    pub avgId: Option<String>,
}
impl Default for clz_Torappu_SandboxV2DialogDataT {
    fn default() -> Self {
        Self {
            dialogId: None,
            avgId: None,
        }
    }
}
impl clz_Torappu_SandboxV2DialogDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DialogData<'b>> {
        let dialogId = self.dialogId.as_ref().map(|x| _fbb.create_string(x));
        let avgId = self.avgId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2DialogData::create(
            _fbb,
            &clz_Torappu_SandboxV2DialogDataArgs { dialogId, avgId },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2DialogDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2DialogData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2DialogData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2DialogData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2DialogData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2DialogData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2DialogDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2DialogData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2DialogDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2DialogDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2DialogDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2DialogData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2DialogData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2DialogData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DialogData>>(
                    dict__string__clz_Torappu_SandboxV2DialogData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2DialogData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DialogData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2DialogDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2DialogData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2DialogDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2DialogDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2DialogData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2DialogData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2DialogDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2DialogDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2DialogData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2DialogData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2DialogData>>(
                dict__string__clz_Torappu_SandboxV2DialogData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2DialogDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2DialogDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2DialogData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2DialogData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2DialogData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2DialogData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2DialogDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2DialogDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2DialogDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2DialogDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2DialogData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2DialogData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2DialogDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2QuestLineDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2QuestLineData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2QuestLineData<'a> {
    type Inner = clz_Torappu_SandboxV2QuestLineData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2QuestLineData<'a> {
    pub const VT_QUESTLINEID: flatbuffers::VOffsetT = 4;
    pub const VT_QUESTLINETITLE: flatbuffers::VOffsetT = 6;
    pub const VT_QUESTLINETYPE: flatbuffers::VOffsetT = 8;
    pub const VT_QUESTLINEBADGETYPE: flatbuffers::VOffsetT = 10;
    pub const VT_QUESTLINESCOPETYPE: flatbuffers::VOffsetT = 12;
    pub const VT_QUESTLINEDESC: flatbuffers::VOffsetT = 14;
    pub const VT_SORTID: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2QuestLineData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2QuestLineDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2QuestLineData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2QuestLineDataBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.questLineDesc {
            builder.add_questLineDesc(x);
        }
        builder.add_questLineScopeType(args.questLineScopeType);
        builder.add_questLineBadgeType(args.questLineBadgeType);
        builder.add_questLineType(args.questLineType);
        if let Some(x) = args.questLineTitle {
            builder.add_questLineTitle(x);
        }
        if let Some(x) = args.questLineId {
            builder.add_questLineId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2QuestLineDataT {
        let questLineId = self.questLineId().map(|x| x.to_string());
        let questLineTitle = self.questLineTitle().map(|x| x.to_string());
        let questLineType = self.questLineType();
        let questLineBadgeType = self.questLineBadgeType();
        let questLineScopeType = self.questLineScopeType();
        let questLineDesc = self.questLineDesc().map(|x| x.to_string());
        let sortId = self.sortId();
        clz_Torappu_SandboxV2QuestLineDataT {
            questLineId,
            questLineTitle,
            questLineType,
            questLineBadgeType,
            questLineScopeType,
            questLineDesc,
            sortId,
        }
    }

    #[inline]
    pub fn questLineId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINEID,
                None,
            )
        }
    }
    #[inline]
    pub fn questLineTitle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINETITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn questLineType(&self) -> enum__Torappu_SandboxV2QuestLineType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2QuestLineType>(
                    clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINETYPE,
                    Some(enum__Torappu_SandboxV2QuestLineType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn questLineBadgeType(&self) -> enum__Torappu_SandboxV2QuestLineBadgeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2QuestLineBadgeType>(
                    clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINEBADGETYPE,
                    Some(enum__Torappu_SandboxV2QuestLineBadgeType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn questLineScopeType(&self) -> enum__Torappu_SandboxV2QuestLineScopeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2QuestLineScopeType>(
                    clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINESCOPETYPE,
                    Some(enum__Torappu_SandboxV2QuestLineScopeType::MAIN),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn questLineDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2QuestLineData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2QuestLineData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "questLineId",
                Self::VT_QUESTLINEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "questLineTitle",
                Self::VT_QUESTLINETITLE,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxV2QuestLineType>(
                "questLineType",
                Self::VT_QUESTLINETYPE,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxV2QuestLineBadgeType>(
                "questLineBadgeType",
                Self::VT_QUESTLINEBADGETYPE,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxV2QuestLineScopeType>(
                "questLineScopeType",
                Self::VT_QUESTLINESCOPETYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "questLineDesc",
                Self::VT_QUESTLINEDESC,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2QuestLineDataArgs<'a> {
    pub questLineId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub questLineTitle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub questLineType: enum__Torappu_SandboxV2QuestLineType,
    pub questLineBadgeType: enum__Torappu_SandboxV2QuestLineBadgeType,
    pub questLineScopeType: enum__Torappu_SandboxV2QuestLineScopeType,
    pub questLineDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2QuestLineDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2QuestLineDataArgs {
            questLineId: None,
            questLineTitle: None,
            questLineType: enum__Torappu_SandboxV2QuestLineType::NONE,
            questLineBadgeType: enum__Torappu_SandboxV2QuestLineBadgeType::NONE,
            questLineScopeType: enum__Torappu_SandboxV2QuestLineScopeType::MAIN,
            questLineDesc: None,
            sortId: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2QuestLineData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2QuestLineData", 7)?;
        if let Some(f) = self.questLineId() {
            s.serialize_field("questLineId", &f)?;
        } else {
            s.skip_field("questLineId")?;
        }
        if let Some(f) = self.questLineTitle() {
            s.serialize_field("questLineTitle", &f)?;
        } else {
            s.skip_field("questLineTitle")?;
        }
        s.serialize_field("questLineType", &self.questLineType())?;
        s.serialize_field("questLineBadgeType", &self.questLineBadgeType())?;
        s.serialize_field("questLineScopeType", &self.questLineScopeType())?;
        if let Some(f) = self.questLineDesc() {
            s.serialize_field("questLineDesc", &f)?;
        } else {
            s.skip_field("questLineDesc")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2QuestLineDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2QuestLineDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_questLineId(&mut self, questLineId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINEID,
            questLineId,
        );
    }
    #[inline]
    pub fn add_questLineTitle(&mut self, questLineTitle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINETITLE,
            questLineTitle,
        );
    }
    #[inline]
    pub fn add_questLineType(&mut self, questLineType: enum__Torappu_SandboxV2QuestLineType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2QuestLineType>(
            clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINETYPE,
            questLineType,
            enum__Torappu_SandboxV2QuestLineType::NONE,
        );
    }
    #[inline]
    pub fn add_questLineBadgeType(
        &mut self,
        questLineBadgeType: enum__Torappu_SandboxV2QuestLineBadgeType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2QuestLineBadgeType>(
                clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINEBADGETYPE,
                questLineBadgeType,
                enum__Torappu_SandboxV2QuestLineBadgeType::NONE,
            );
    }
    #[inline]
    pub fn add_questLineScopeType(
        &mut self,
        questLineScopeType: enum__Torappu_SandboxV2QuestLineScopeType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2QuestLineScopeType>(
                clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINESCOPETYPE,
                questLineScopeType,
                enum__Torappu_SandboxV2QuestLineScopeType::MAIN,
            );
    }
    #[inline]
    pub fn add_questLineDesc(&mut self, questLineDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2QuestLineData::VT_QUESTLINEDESC,
            questLineDesc,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2QuestLineData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2QuestLineDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2QuestLineDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2QuestLineData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2QuestLineData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2QuestLineData");
        ds.field("questLineId", &self.questLineId());
        ds.field("questLineTitle", &self.questLineTitle());
        ds.field("questLineType", &self.questLineType());
        ds.field("questLineBadgeType", &self.questLineBadgeType());
        ds.field("questLineScopeType", &self.questLineScopeType());
        ds.field("questLineDesc", &self.questLineDesc());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2QuestLineDataT {
    pub questLineId: Option<String>,
    pub questLineTitle: Option<String>,
    pub questLineType: enum__Torappu_SandboxV2QuestLineType,
    pub questLineBadgeType: enum__Torappu_SandboxV2QuestLineBadgeType,
    pub questLineScopeType: enum__Torappu_SandboxV2QuestLineScopeType,
    pub questLineDesc: Option<String>,
    pub sortId: i32,
}
impl Default for clz_Torappu_SandboxV2QuestLineDataT {
    fn default() -> Self {
        Self {
            questLineId: None,
            questLineTitle: None,
            questLineType: enum__Torappu_SandboxV2QuestLineType::NONE,
            questLineBadgeType: enum__Torappu_SandboxV2QuestLineBadgeType::NONE,
            questLineScopeType: enum__Torappu_SandboxV2QuestLineScopeType::MAIN,
            questLineDesc: None,
            sortId: 0,
        }
    }
}
impl clz_Torappu_SandboxV2QuestLineDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2QuestLineData<'b>> {
        let questLineId = self.questLineId.as_ref().map(|x| _fbb.create_string(x));
        let questLineTitle = self.questLineTitle.as_ref().map(|x| _fbb.create_string(x));
        let questLineType = self.questLineType;
        let questLineBadgeType = self.questLineBadgeType;
        let questLineScopeType = self.questLineScopeType;
        let questLineDesc = self.questLineDesc.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        clz_Torappu_SandboxV2QuestLineData::create(
            _fbb,
            &clz_Torappu_SandboxV2QuestLineDataArgs {
                questLineId,
                questLineTitle,
                questLineType,
                questLineBadgeType,
                questLineScopeType,
                questLineDesc,
                sortId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2QuestLineDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2QuestLineData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2QuestLineData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2QuestLineData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2QuestLineData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2QuestLineData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2QuestLineDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2QuestLineData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2QuestLineDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2QuestLineDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2QuestLineDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2QuestLineData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2QuestLineData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2QuestLineData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2QuestLineData>>(
                    dict__string__clz_Torappu_SandboxV2QuestLineData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2QuestLineData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2QuestLineData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2QuestLineDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2QuestLineData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2QuestLineDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2QuestLineDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2QuestLineData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2QuestLineData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2QuestLineDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2QuestLineDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2QuestLineData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2QuestLineData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2QuestLineData>>(
                dict__string__clz_Torappu_SandboxV2QuestLineData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2QuestLineDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2QuestLineDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2QuestLineData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2QuestLineData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2QuestLineData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2QuestLineData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2QuestLineDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2QuestLineDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2QuestLineDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2QuestLineDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2QuestLineData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2QuestLineData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2QuestLineDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2GuideQuestDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2GuideQuestData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2GuideQuestData<'a> {
    type Inner = clz_Torappu_SandboxV2GuideQuestData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2GuideQuestData<'a> {
    pub const VT_QUESTID: flatbuffers::VOffsetT = 4;
    pub const VT_STORYID: flatbuffers::VOffsetT = 6;
    pub const VT_TRIGGERKEY: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2GuideQuestData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2GuideQuestDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2GuideQuestData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2GuideQuestDataBuilder::new(_fbb);
        if let Some(x) = args.triggerKey {
            builder.add_triggerKey(x);
        }
        if let Some(x) = args.storyId {
            builder.add_storyId(x);
        }
        if let Some(x) = args.questId {
            builder.add_questId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2GuideQuestDataT {
        let questId = self.questId().map(|x| x.to_string());
        let storyId = self.storyId().map(|x| x.to_string());
        let triggerKey = self.triggerKey().map(|x| x.to_string());
        clz_Torappu_SandboxV2GuideQuestDataT {
            questId,
            storyId,
            triggerKey,
        }
    }

    #[inline]
    pub fn questId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GuideQuestData::VT_QUESTID,
                None,
            )
        }
    }
    #[inline]
    pub fn storyId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GuideQuestData::VT_STORYID,
                None,
            )
        }
    }
    #[inline]
    pub fn triggerKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2GuideQuestData::VT_TRIGGERKEY,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2GuideQuestData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("questId", Self::VT_QUESTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("storyId", Self::VT_STORYID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "triggerKey",
                Self::VT_TRIGGERKEY,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2GuideQuestDataArgs<'a> {
    pub questId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub storyId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub triggerKey: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2GuideQuestDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2GuideQuestDataArgs {
            questId: None,
            storyId: None,
            triggerKey: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2GuideQuestData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2GuideQuestData", 3)?;
        if let Some(f) = self.questId() {
            s.serialize_field("questId", &f)?;
        } else {
            s.skip_field("questId")?;
        }
        if let Some(f) = self.storyId() {
            s.serialize_field("storyId", &f)?;
        } else {
            s.skip_field("storyId")?;
        }
        if let Some(f) = self.triggerKey() {
            s.serialize_field("triggerKey", &f)?;
        } else {
            s.skip_field("triggerKey")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2GuideQuestDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2GuideQuestDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_questId(&mut self, questId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GuideQuestData::VT_QUESTID,
            questId,
        );
    }
    #[inline]
    pub fn add_storyId(&mut self, storyId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GuideQuestData::VT_STORYID,
            storyId,
        );
    }
    #[inline]
    pub fn add_triggerKey(&mut self, triggerKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2GuideQuestData::VT_TRIGGERKEY,
            triggerKey,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2GuideQuestDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2GuideQuestDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2GuideQuestData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2GuideQuestData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2GuideQuestData");
        ds.field("questId", &self.questId());
        ds.field("storyId", &self.storyId());
        ds.field("triggerKey", &self.triggerKey());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2GuideQuestDataT {
    pub questId: Option<String>,
    pub storyId: Option<String>,
    pub triggerKey: Option<String>,
}
impl Default for clz_Torappu_SandboxV2GuideQuestDataT {
    fn default() -> Self {
        Self {
            questId: None,
            storyId: None,
            triggerKey: None,
        }
    }
}
impl clz_Torappu_SandboxV2GuideQuestDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2GuideQuestData<'b>> {
        let questId = self.questId.as_ref().map(|x| _fbb.create_string(x));
        let storyId = self.storyId.as_ref().map(|x| _fbb.create_string(x));
        let triggerKey = self.triggerKey.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2GuideQuestData::create(
            _fbb,
            &clz_Torappu_SandboxV2GuideQuestDataArgs {
                questId,
                storyId,
                triggerKey,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2GuideQuestDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2GuideQuestData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2GuideQuestData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2GuideQuestData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2GuideQuestData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2GuideQuestData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2GuideQuestDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2GuideQuestDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2GuideQuestDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2GuideQuestDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2GuideQuestData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2GuideQuestData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2GuideQuestData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2GuideQuestData>>(
                    dict__string__clz_Torappu_SandboxV2GuideQuestData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2GuideQuestData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2GuideQuestData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2GuideQuestDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2GuideQuestData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2GuideQuestDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2GuideQuestDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2GuideQuestData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2GuideQuestData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2GuideQuestDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2GuideQuestDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2GuideQuestData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2GuideQuestData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2GuideQuestData>>(
                dict__string__clz_Torappu_SandboxV2GuideQuestData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2GuideQuestDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2GuideQuestDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2GuideQuestData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2GuideQuestData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2GuideQuestData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2GuideQuestDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2GuideQuestDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2GuideQuestDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2GuideQuestDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2GuideQuestData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2GuideQuestDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2DevelopmentDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2DevelopmentData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2DevelopmentData<'a> {
    type Inner = clz_Torappu_SandboxV2DevelopmentData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2DevelopmentData<'a> {
    pub const VT_TECHID: flatbuffers::VOffsetT = 4;
    pub const VT_TECHTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_POSITIONX: flatbuffers::VOffsetT = 8;
    pub const VT_POSITIONY: flatbuffers::VOffsetT = 10;
    pub const VT_FRONTNODEID: flatbuffers::VOffsetT = 12;
    pub const VT_NEXTNODEIDS: flatbuffers::VOffsetT = 14;
    pub const VT_LIMITBASELEVEL: flatbuffers::VOffsetT = 16;
    pub const VT_TOKENCOST: flatbuffers::VOffsetT = 18;
    pub const VT_TECHNAME: flatbuffers::VOffsetT = 20;
    pub const VT_TECHICONID: flatbuffers::VOffsetT = 22;
    pub const VT_NODETITLE: flatbuffers::VOffsetT = 24;
    pub const VT_RAWDESC: flatbuffers::VOffsetT = 26;
    pub const VT_CANBUFFRESERCH: flatbuffers::VOffsetT = 28;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2DevelopmentData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2DevelopmentDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2DevelopmentDataBuilder::new(_fbb);
        if let Some(x) = args.rawDesc {
            builder.add_rawDesc(x);
        }
        if let Some(x) = args.nodeTitle {
            builder.add_nodeTitle(x);
        }
        if let Some(x) = args.techIconId {
            builder.add_techIconId(x);
        }
        if let Some(x) = args.techName {
            builder.add_techName(x);
        }
        builder.add_tokenCost(args.tokenCost);
        builder.add_limitBaseLevel(args.limitBaseLevel);
        if let Some(x) = args.nextNodeIds {
            builder.add_nextNodeIds(x);
        }
        if let Some(x) = args.frontNodeId {
            builder.add_frontNodeId(x);
        }
        builder.add_positionY(args.positionY);
        builder.add_positionX(args.positionX);
        builder.add_techType(args.techType);
        if let Some(x) = args.techId {
            builder.add_techId(x);
        }
        builder.add_canBuffReserch(args.canBuffReserch);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2DevelopmentDataT {
        let techId = self.techId().map(|x| x.to_string());
        let techType = self.techType();
        let positionX = self.positionX();
        let positionY = self.positionY();
        let frontNodeId = self.frontNodeId().map(|x| x.to_string());
        let nextNodeIds = self
            .nextNodeIds()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let limitBaseLevel = self.limitBaseLevel();
        let tokenCost = self.tokenCost();
        let techName = self.techName().map(|x| x.to_string());
        let techIconId = self.techIconId().map(|x| x.to_string());
        let nodeTitle = self.nodeTitle().map(|x| x.to_string());
        let rawDesc = self.rawDesc().map(|x| x.to_string());
        let canBuffReserch = self.canBuffReserch();
        clz_Torappu_SandboxV2DevelopmentDataT {
            techId,
            techType,
            positionX,
            positionY,
            frontNodeId,
            nextNodeIds,
            limitBaseLevel,
            tokenCost,
            techName,
            techIconId,
            nodeTitle,
            rawDesc,
            canBuffReserch,
        }
    }

    #[inline]
    pub fn techId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DevelopmentData::VT_TECHID,
                None,
            )
        }
    }
    #[inline]
    pub fn techType(&self) -> enum__Torappu_SandboxV2DevelopmentType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2DevelopmentType>(
                    clz_Torappu_SandboxV2DevelopmentData::VT_TECHTYPE,
                    Some(enum__Torappu_SandboxV2DevelopmentType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn positionX(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2DevelopmentData::VT_POSITIONX, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn positionY(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2DevelopmentData::VT_POSITIONY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn frontNodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DevelopmentData::VT_FRONTNODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn nextNodeIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxV2DevelopmentData::VT_NEXTNODEIDS, None)
        }
    }
    #[inline]
    pub fn limitBaseLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2DevelopmentData::VT_LIMITBASELEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn tokenCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2DevelopmentData::VT_TOKENCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn techName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DevelopmentData::VT_TECHNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn techIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DevelopmentData::VT_TECHICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeTitle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DevelopmentData::VT_NODETITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn rawDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DevelopmentData::VT_RAWDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn canBuffReserch(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_SandboxV2DevelopmentData::VT_CANBUFFRESERCH,
                    Some(false),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2DevelopmentData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("techId", Self::VT_TECHID, false)?
            .visit_field::<enum__Torappu_SandboxV2DevelopmentType>(
                "techType",
                Self::VT_TECHTYPE,
                false,
            )?
            .visit_field::<i32>("positionX", Self::VT_POSITIONX, false)?
            .visit_field::<i32>("positionY", Self::VT_POSITIONY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "frontNodeId",
                Self::VT_FRONTNODEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("nextNodeIds", Self::VT_NEXTNODEIDS, false)?
            .visit_field::<i32>("limitBaseLevel", Self::VT_LIMITBASELEVEL, false)?
            .visit_field::<i32>("tokenCost", Self::VT_TOKENCOST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "techName",
                Self::VT_TECHNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "techIconId",
                Self::VT_TECHICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nodeTitle",
                Self::VT_NODETITLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rawDesc", Self::VT_RAWDESC, false)?
            .visit_field::<bool>("canBuffReserch", Self::VT_CANBUFFRESERCH, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2DevelopmentDataArgs<'a> {
    pub techId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub techType: enum__Torappu_SandboxV2DevelopmentType,
    pub positionX: i32,
    pub positionY: i32,
    pub frontNodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nextNodeIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub limitBaseLevel: i32,
    pub tokenCost: i32,
    pub techName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub techIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nodeTitle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rawDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub canBuffReserch: bool,
}
impl<'a> Default for clz_Torappu_SandboxV2DevelopmentDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2DevelopmentDataArgs {
            techId: None,
            techType: enum__Torappu_SandboxV2DevelopmentType::NONE,
            positionX: 0,
            positionY: 0,
            frontNodeId: None,
            nextNodeIds: None,
            limitBaseLevel: 0,
            tokenCost: 0,
            techName: None,
            techIconId: None,
            nodeTitle: None,
            rawDesc: None,
            canBuffReserch: false,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2DevelopmentData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2DevelopmentData", 13)?;
        if let Some(f) = self.techId() {
            s.serialize_field("techId", &f)?;
        } else {
            s.skip_field("techId")?;
        }
        s.serialize_field("techType", &self.techType())?;
        s.serialize_field("positionX", &self.positionX())?;
        s.serialize_field("positionY", &self.positionY())?;
        if let Some(f) = self.frontNodeId() {
            s.serialize_field("frontNodeId", &f)?;
        } else {
            s.skip_field("frontNodeId")?;
        }
        if let Some(f) = self.nextNodeIds() {
            s.serialize_field("nextNodeIds", &f)?;
        } else {
            s.skip_field("nextNodeIds")?;
        }
        s.serialize_field("limitBaseLevel", &self.limitBaseLevel())?;
        s.serialize_field("tokenCost", &self.tokenCost())?;
        if let Some(f) = self.techName() {
            s.serialize_field("techName", &f)?;
        } else {
            s.skip_field("techName")?;
        }
        if let Some(f) = self.techIconId() {
            s.serialize_field("techIconId", &f)?;
        } else {
            s.skip_field("techIconId")?;
        }
        if let Some(f) = self.nodeTitle() {
            s.serialize_field("nodeTitle", &f)?;
        } else {
            s.skip_field("nodeTitle")?;
        }
        if let Some(f) = self.rawDesc() {
            s.serialize_field("rawDesc", &f)?;
        } else {
            s.skip_field("rawDesc")?;
        }
        s.serialize_field("canBuffReserch", &self.canBuffReserch())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2DevelopmentDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2DevelopmentDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_techId(&mut self, techId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DevelopmentData::VT_TECHID,
            techId,
        );
    }
    #[inline]
    pub fn add_techType(&mut self, techType: enum__Torappu_SandboxV2DevelopmentType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2DevelopmentType>(
                clz_Torappu_SandboxV2DevelopmentData::VT_TECHTYPE,
                techType,
                enum__Torappu_SandboxV2DevelopmentType::NONE,
            );
    }
    #[inline]
    pub fn add_positionX(&mut self, positionX: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2DevelopmentData::VT_POSITIONX,
            positionX,
            0,
        );
    }
    #[inline]
    pub fn add_positionY(&mut self, positionY: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2DevelopmentData::VT_POSITIONY,
            positionY,
            0,
        );
    }
    #[inline]
    pub fn add_frontNodeId(&mut self, frontNodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DevelopmentData::VT_FRONTNODEID,
            frontNodeId,
        );
    }
    #[inline]
    pub fn add_nextNodeIds(
        &mut self,
        nextNodeIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DevelopmentData::VT_NEXTNODEIDS,
            nextNodeIds,
        );
    }
    #[inline]
    pub fn add_limitBaseLevel(&mut self, limitBaseLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2DevelopmentData::VT_LIMITBASELEVEL,
            limitBaseLevel,
            0,
        );
    }
    #[inline]
    pub fn add_tokenCost(&mut self, tokenCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2DevelopmentData::VT_TOKENCOST,
            tokenCost,
            0,
        );
    }
    #[inline]
    pub fn add_techName(&mut self, techName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DevelopmentData::VT_TECHNAME,
            techName,
        );
    }
    #[inline]
    pub fn add_techIconId(&mut self, techIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DevelopmentData::VT_TECHICONID,
            techIconId,
        );
    }
    #[inline]
    pub fn add_nodeTitle(&mut self, nodeTitle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DevelopmentData::VT_NODETITLE,
            nodeTitle,
        );
    }
    #[inline]
    pub fn add_rawDesc(&mut self, rawDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DevelopmentData::VT_RAWDESC,
            rawDesc,
        );
    }
    #[inline]
    pub fn add_canBuffReserch(&mut self, canBuffReserch: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SandboxV2DevelopmentData::VT_CANBUFFRESERCH,
            canBuffReserch,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2DevelopmentDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2DevelopmentDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2DevelopmentData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2DevelopmentData");
        ds.field("techId", &self.techId());
        ds.field("techType", &self.techType());
        ds.field("positionX", &self.positionX());
        ds.field("positionY", &self.positionY());
        ds.field("frontNodeId", &self.frontNodeId());
        ds.field("nextNodeIds", &self.nextNodeIds());
        ds.field("limitBaseLevel", &self.limitBaseLevel());
        ds.field("tokenCost", &self.tokenCost());
        ds.field("techName", &self.techName());
        ds.field("techIconId", &self.techIconId());
        ds.field("nodeTitle", &self.nodeTitle());
        ds.field("rawDesc", &self.rawDesc());
        ds.field("canBuffReserch", &self.canBuffReserch());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2DevelopmentDataT {
    pub techId: Option<String>,
    pub techType: enum__Torappu_SandboxV2DevelopmentType,
    pub positionX: i32,
    pub positionY: i32,
    pub frontNodeId: Option<String>,
    pub nextNodeIds: Option<Vec<String>>,
    pub limitBaseLevel: i32,
    pub tokenCost: i32,
    pub techName: Option<String>,
    pub techIconId: Option<String>,
    pub nodeTitle: Option<String>,
    pub rawDesc: Option<String>,
    pub canBuffReserch: bool,
}
impl Default for clz_Torappu_SandboxV2DevelopmentDataT {
    fn default() -> Self {
        Self {
            techId: None,
            techType: enum__Torappu_SandboxV2DevelopmentType::NONE,
            positionX: 0,
            positionY: 0,
            frontNodeId: None,
            nextNodeIds: None,
            limitBaseLevel: 0,
            tokenCost: 0,
            techName: None,
            techIconId: None,
            nodeTitle: None,
            rawDesc: None,
            canBuffReserch: false,
        }
    }
}
impl clz_Torappu_SandboxV2DevelopmentDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentData<'b>> {
        let techId = self.techId.as_ref().map(|x| _fbb.create_string(x));
        let techType = self.techType;
        let positionX = self.positionX;
        let positionY = self.positionY;
        let frontNodeId = self.frontNodeId.as_ref().map(|x| _fbb.create_string(x));
        let nextNodeIds = self.nextNodeIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let limitBaseLevel = self.limitBaseLevel;
        let tokenCost = self.tokenCost;
        let techName = self.techName.as_ref().map(|x| _fbb.create_string(x));
        let techIconId = self.techIconId.as_ref().map(|x| _fbb.create_string(x));
        let nodeTitle = self.nodeTitle.as_ref().map(|x| _fbb.create_string(x));
        let rawDesc = self.rawDesc.as_ref().map(|x| _fbb.create_string(x));
        let canBuffReserch = self.canBuffReserch;
        clz_Torappu_SandboxV2DevelopmentData::create(
            _fbb,
            &clz_Torappu_SandboxV2DevelopmentDataArgs {
                techId,
                techType,
                positionX,
                positionY,
                frontNodeId,
                nextNodeIds,
                limitBaseLevel,
                tokenCost,
                techName,
                techIconId,
                nodeTitle,
                rawDesc,
                canBuffReserch,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2DevelopmentDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2DevelopmentData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2DevelopmentData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2DevelopmentData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2DevelopmentData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2DevelopmentData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2DevelopmentDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2DevelopmentData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2DevelopmentDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2DevelopmentDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2DevelopmentDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2DevelopmentData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2DevelopmentData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2DevelopmentData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DevelopmentData>>(
                    dict__string__clz_Torappu_SandboxV2DevelopmentData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2DevelopmentData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DevelopmentData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2DevelopmentDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2DevelopmentDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2DevelopmentDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2DevelopmentData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2DevelopmentData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2DevelopmentDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2DevelopmentDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2DevelopmentData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentData>>(
                dict__string__clz_Torappu_SandboxV2DevelopmentData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2DevelopmentDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2DevelopmentDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2DevelopmentData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2DevelopmentData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2DevelopmentData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2DevelopmentData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2DevelopmentDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2DevelopmentDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2DevelopmentDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2DevelopmentDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2DevelopmentData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2DevelopmentData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2DevelopmentDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2EventDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2EventData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2EventData<'a> {
    type Inner = clz_Torappu_SandboxV2EventData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2EventData<'a> {
    pub const VT_EVENTID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_ICONID: flatbuffers::VOffsetT = 8;
    pub const VT_ICONNAME: flatbuffers::VOffsetT = 10;
    pub const VT_ENTERSCENEID: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2EventData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2EventDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2EventDataBuilder::new(_fbb);
        if let Some(x) = args.enterSceneId {
            builder.add_enterSceneId(x);
        }
        if let Some(x) = args.iconName {
            builder.add_iconName(x);
        }
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        builder.add_type_(args.type_);
        if let Some(x) = args.eventId {
            builder.add_eventId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2EventDataT {
        let eventId = self.eventId().map(|x| x.to_string());
        let type_ = self.type_();
        let iconId = self.iconId().map(|x| x.to_string());
        let iconName = self.iconName().map(|x| x.to_string());
        let enterSceneId = self.enterSceneId().map(|x| x.to_string());
        clz_Torappu_SandboxV2EventDataT {
            eventId,
            type_,
            iconId,
            iconName,
            enterSceneId,
        }
    }

    #[inline]
    pub fn eventId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventData::VT_EVENTID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_SandboxV2EventType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2EventType>(
                    clz_Torappu_SandboxV2EventData::VT_TYPE_,
                    Some(enum__Torappu_SandboxV2EventType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventData::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn iconName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventData::VT_ICONNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn enterSceneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventData::VT_ENTERSCENEID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2EventData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("eventId", Self::VT_EVENTID, false)?
            .visit_field::<enum__Torappu_SandboxV2EventType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "iconName",
                Self::VT_ICONNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enterSceneId",
                Self::VT_ENTERSCENEID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2EventDataArgs<'a> {
    pub eventId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_SandboxV2EventType,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub enterSceneId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2EventDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2EventDataArgs {
            eventId: None,
            type_: enum__Torappu_SandboxV2EventType::NONE,
            iconId: None,
            iconName: None,
            enterSceneId: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2EventData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2EventData", 5)?;
        if let Some(f) = self.eventId() {
            s.serialize_field("eventId", &f)?;
        } else {
            s.skip_field("eventId")?;
        }
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.iconId() {
            s.serialize_field("iconId", &f)?;
        } else {
            s.skip_field("iconId")?;
        }
        if let Some(f) = self.iconName() {
            s.serialize_field("iconName", &f)?;
        } else {
            s.skip_field("iconName")?;
        }
        if let Some(f) = self.enterSceneId() {
            s.serialize_field("enterSceneId", &f)?;
        } else {
            s.skip_field("enterSceneId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2EventDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2EventDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_eventId(&mut self, eventId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventData::VT_EVENTID,
            eventId,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_SandboxV2EventType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2EventType>(
            clz_Torappu_SandboxV2EventData::VT_TYPE_,
            type_,
            enum__Torappu_SandboxV2EventType::NONE,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_iconName(&mut self, iconName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventData::VT_ICONNAME,
            iconName,
        );
    }
    #[inline]
    pub fn add_enterSceneId(&mut self, enterSceneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventData::VT_ENTERSCENEID,
            enterSceneId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2EventDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2EventDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2EventData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2EventData");
        ds.field("eventId", &self.eventId());
        ds.field("type_", &self.type_());
        ds.field("iconId", &self.iconId());
        ds.field("iconName", &self.iconName());
        ds.field("enterSceneId", &self.enterSceneId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2EventDataT {
    pub eventId: Option<String>,
    pub type_: enum__Torappu_SandboxV2EventType,
    pub iconId: Option<String>,
    pub iconName: Option<String>,
    pub enterSceneId: Option<String>,
}
impl Default for clz_Torappu_SandboxV2EventDataT {
    fn default() -> Self {
        Self {
            eventId: None,
            type_: enum__Torappu_SandboxV2EventType::NONE,
            iconId: None,
            iconName: None,
            enterSceneId: None,
        }
    }
}
impl clz_Torappu_SandboxV2EventDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventData<'b>> {
        let eventId = self.eventId.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let iconId = self.iconId.as_ref().map(|x| _fbb.create_string(x));
        let iconName = self.iconName.as_ref().map(|x| _fbb.create_string(x));
        let enterSceneId = self.enterSceneId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2EventData::create(
            _fbb,
            &clz_Torappu_SandboxV2EventDataArgs {
                eventId,
                type_,
                iconId,
                iconName,
                enterSceneId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2EventDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2EventData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2EventData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2EventData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2EventData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2EventData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2EventDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EventData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2EventDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2EventDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2EventDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2EventData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2EventData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2EventData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2EventData>>(
                    dict__string__clz_Torappu_SandboxV2EventData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2EventData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2EventData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2EventDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2EventDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2EventDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2EventData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2EventData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2EventDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2EventDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2EventData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventData>>(
                dict__string__clz_Torappu_SandboxV2EventData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2EventDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2EventDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EventData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2EventData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2EventData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2EventData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2EventDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2EventDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2EventDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2EventDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EventData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2EventData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2EventDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2EventSceneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2EventSceneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2EventSceneData<'a> {
    type Inner = clz_Torappu_SandboxV2EventSceneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2EventSceneData<'a> {
    pub const VT_EVENTSCENEID: flatbuffers::VOffsetT = 4;
    pub const VT_TITLE: flatbuffers::VOffsetT = 6;
    pub const VT_DESC: flatbuffers::VOffsetT = 8;
    pub const VT_CHOICEIDS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2EventSceneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2EventSceneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventSceneData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2EventSceneDataBuilder::new(_fbb);
        if let Some(x) = args.choiceIds {
            builder.add_choiceIds(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.title {
            builder.add_title(x);
        }
        if let Some(x) = args.eventSceneId {
            builder.add_eventSceneId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2EventSceneDataT {
        let eventSceneId = self.eventSceneId().map(|x| x.to_string());
        let title = self.title().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let choiceIds = self
            .choiceIds()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_SandboxV2EventSceneDataT {
            eventSceneId,
            title,
            desc,
            choiceIds,
        }
    }

    #[inline]
    pub fn eventSceneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventSceneData::VT_EVENTSCENEID,
                None,
            )
        }
    }
    #[inline]
    pub fn title(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventSceneData::VT_TITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventSceneData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn choiceIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxV2EventSceneData::VT_CHOICEIDS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2EventSceneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "eventSceneId",
                Self::VT_EVENTSCENEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("choiceIds", Self::VT_CHOICEIDS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2EventSceneDataArgs<'a> {
    pub eventSceneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub choiceIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2EventSceneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2EventSceneDataArgs {
            eventSceneId: None,
            title: None,
            desc: None,
            choiceIds: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2EventSceneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2EventSceneData", 4)?;
        if let Some(f) = self.eventSceneId() {
            s.serialize_field("eventSceneId", &f)?;
        } else {
            s.skip_field("eventSceneId")?;
        }
        if let Some(f) = self.title() {
            s.serialize_field("title", &f)?;
        } else {
            s.skip_field("title")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.choiceIds() {
            s.serialize_field("choiceIds", &f)?;
        } else {
            s.skip_field("choiceIds")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2EventSceneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2EventSceneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_eventSceneId(&mut self, eventSceneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventSceneData::VT_EVENTSCENEID,
            eventSceneId,
        );
    }
    #[inline]
    pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventSceneData::VT_TITLE,
            title,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventSceneData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_choiceIds(
        &mut self,
        choiceIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventSceneData::VT_CHOICEIDS,
            choiceIds,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2EventSceneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2EventSceneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventSceneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2EventSceneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2EventSceneData");
        ds.field("eventSceneId", &self.eventSceneId());
        ds.field("title", &self.title());
        ds.field("desc", &self.desc());
        ds.field("choiceIds", &self.choiceIds());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2EventSceneDataT {
    pub eventSceneId: Option<String>,
    pub title: Option<String>,
    pub desc: Option<String>,
    pub choiceIds: Option<Vec<String>>,
}
impl Default for clz_Torappu_SandboxV2EventSceneDataT {
    fn default() -> Self {
        Self {
            eventSceneId: None,
            title: None,
            desc: None,
            choiceIds: None,
        }
    }
}
impl clz_Torappu_SandboxV2EventSceneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventSceneData<'b>> {
        let eventSceneId = self.eventSceneId.as_ref().map(|x| _fbb.create_string(x));
        let title = self.title.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let choiceIds = self.choiceIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SandboxV2EventSceneData::create(
            _fbb,
            &clz_Torappu_SandboxV2EventSceneDataArgs {
                eventSceneId,
                title,
                desc,
                choiceIds,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2EventSceneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2EventSceneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2EventSceneData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2EventSceneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2EventSceneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2EventSceneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2EventSceneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EventSceneData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2EventSceneDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2EventSceneDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2EventSceneDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2EventSceneData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2EventSceneData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2EventSceneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2EventSceneData>>(
                    dict__string__clz_Torappu_SandboxV2EventSceneData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2EventSceneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2EventSceneData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2EventSceneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventSceneData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2EventSceneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2EventSceneDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2EventSceneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2EventSceneData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2EventSceneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2EventSceneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2EventSceneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventSceneData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventSceneData>>(
                dict__string__clz_Torappu_SandboxV2EventSceneData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2EventSceneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2EventSceneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EventSceneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2EventSceneData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2EventSceneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2EventSceneData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2EventSceneDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2EventSceneDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2EventSceneDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2EventSceneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EventSceneData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2EventSceneData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2EventSceneDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2EventChoiceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2EventChoiceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2EventChoiceData<'a> {
    type Inner = clz_Torappu_SandboxV2EventChoiceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2EventChoiceData<'a> {
    pub const VT_CHOICEID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_COSTACTION: flatbuffers::VOffsetT = 8;
    pub const VT_TITLE: flatbuffers::VOffsetT = 10;
    pub const VT_DESC: flatbuffers::VOffsetT = 12;
    pub const VT_EXPEDITIONID: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2EventChoiceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2EventChoiceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventChoiceData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2EventChoiceDataBuilder::new(_fbb);
        if let Some(x) = args.expeditionId {
            builder.add_expeditionId(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.title {
            builder.add_title(x);
        }
        builder.add_costAction(args.costAction);
        builder.add_type_(args.type_);
        if let Some(x) = args.choiceId {
            builder.add_choiceId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2EventChoiceDataT {
        let choiceId = self.choiceId().map(|x| x.to_string());
        let type_ = self.type_();
        let costAction = self.costAction();
        let title = self.title().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let expeditionId = self.expeditionId().map(|x| x.to_string());
        clz_Torappu_SandboxV2EventChoiceDataT {
            choiceId,
            type_,
            costAction,
            title,
            desc,
            expeditionId,
        }
    }

    #[inline]
    pub fn choiceId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventChoiceData::VT_CHOICEID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_SandboxV2EventChoiceType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2EventChoiceType>(
                    clz_Torappu_SandboxV2EventChoiceData::VT_TYPE_,
                    Some(enum__Torappu_SandboxV2EventChoiceType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn costAction(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2EventChoiceData::VT_COSTACTION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn title(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventChoiceData::VT_TITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventChoiceData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn expeditionId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventChoiceData::VT_EXPEDITIONID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2EventChoiceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "choiceId",
                Self::VT_CHOICEID,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxV2EventChoiceType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<i32>("costAction", Self::VT_COSTACTION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "expeditionId",
                Self::VT_EXPEDITIONID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2EventChoiceDataArgs<'a> {
    pub choiceId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_SandboxV2EventChoiceType,
    pub costAction: i32,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub expeditionId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2EventChoiceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2EventChoiceDataArgs {
            choiceId: None,
            type_: enum__Torappu_SandboxV2EventChoiceType::NONE,
            costAction: 0,
            title: None,
            desc: None,
            expeditionId: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2EventChoiceData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2EventChoiceData", 6)?;
        if let Some(f) = self.choiceId() {
            s.serialize_field("choiceId", &f)?;
        } else {
            s.skip_field("choiceId")?;
        }
        s.serialize_field("type_", &self.type_())?;
        s.serialize_field("costAction", &self.costAction())?;
        if let Some(f) = self.title() {
            s.serialize_field("title", &f)?;
        } else {
            s.skip_field("title")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.expeditionId() {
            s.serialize_field("expeditionId", &f)?;
        } else {
            s.skip_field("expeditionId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2EventChoiceDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2EventChoiceDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_choiceId(&mut self, choiceId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventChoiceData::VT_CHOICEID,
            choiceId,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_SandboxV2EventChoiceType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2EventChoiceType>(
                clz_Torappu_SandboxV2EventChoiceData::VT_TYPE_,
                type_,
                enum__Torappu_SandboxV2EventChoiceType::NONE,
            );
    }
    #[inline]
    pub fn add_costAction(&mut self, costAction: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2EventChoiceData::VT_COSTACTION,
            costAction,
            0,
        );
    }
    #[inline]
    pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventChoiceData::VT_TITLE,
            title,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventChoiceData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_expeditionId(&mut self, expeditionId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventChoiceData::VT_EXPEDITIONID,
            expeditionId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2EventChoiceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2EventChoiceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventChoiceData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2EventChoiceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2EventChoiceData");
        ds.field("choiceId", &self.choiceId());
        ds.field("type_", &self.type_());
        ds.field("costAction", &self.costAction());
        ds.field("title", &self.title());
        ds.field("desc", &self.desc());
        ds.field("expeditionId", &self.expeditionId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2EventChoiceDataT {
    pub choiceId: Option<String>,
    pub type_: enum__Torappu_SandboxV2EventChoiceType,
    pub costAction: i32,
    pub title: Option<String>,
    pub desc: Option<String>,
    pub expeditionId: Option<String>,
}
impl Default for clz_Torappu_SandboxV2EventChoiceDataT {
    fn default() -> Self {
        Self {
            choiceId: None,
            type_: enum__Torappu_SandboxV2EventChoiceType::NONE,
            costAction: 0,
            title: None,
            desc: None,
            expeditionId: None,
        }
    }
}
impl clz_Torappu_SandboxV2EventChoiceDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventChoiceData<'b>> {
        let choiceId = self.choiceId.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let costAction = self.costAction;
        let title = self.title.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let expeditionId = self.expeditionId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2EventChoiceData::create(
            _fbb,
            &clz_Torappu_SandboxV2EventChoiceDataArgs {
                choiceId,
                type_,
                costAction,
                title,
                desc,
                expeditionId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2EventChoiceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2EventChoiceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2EventChoiceData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2EventChoiceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2EventChoiceData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2EventChoiceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2EventChoiceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EventChoiceData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2EventChoiceDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2EventChoiceDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2EventChoiceDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2EventChoiceData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2EventChoiceData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2EventChoiceData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2EventChoiceData>>(
                    dict__string__clz_Torappu_SandboxV2EventChoiceData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2EventChoiceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2EventChoiceData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2EventChoiceDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventChoiceData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2EventChoiceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2EventChoiceDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2EventChoiceData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2EventChoiceData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2EventChoiceDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2EventChoiceDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2EventChoiceData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventChoiceData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventChoiceData>>(
                dict__string__clz_Torappu_SandboxV2EventChoiceData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2EventChoiceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2EventChoiceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EventChoiceData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2EventChoiceData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2EventChoiceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2EventChoiceData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2EventChoiceDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2EventChoiceDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2EventChoiceDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2EventChoiceDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EventChoiceData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2EventChoiceData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2EventChoiceDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2ExpeditionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ExpeditionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ExpeditionData<'a> {
    type Inner = clz_Torappu_SandboxV2ExpeditionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ExpeditionData<'a> {
    pub const VT_EXPEDITIONID: flatbuffers::VOffsetT = 4;
    pub const VT_DESC: flatbuffers::VOffsetT = 6;
    pub const VT_EFFECTDESC: flatbuffers::VOffsetT = 8;
    pub const VT_COSTACTION: flatbuffers::VOffsetT = 10;
    pub const VT_COSTDRINK: flatbuffers::VOffsetT = 12;
    pub const VT_CHARCNT: flatbuffers::VOffsetT = 14;
    pub const VT_PROFESSION: flatbuffers::VOffsetT = 16;
    pub const VT_PROFESSIONS: flatbuffers::VOffsetT = 18;
    pub const VT_MINELITERANK: flatbuffers::VOffsetT = 20;
    pub const VT_DURATION: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ExpeditionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ExpeditionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ExpeditionData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ExpeditionDataBuilder::new(_fbb);
        builder.add_duration(args.duration);
        builder.add_minEliteRank(args.minEliteRank);
        if let Some(x) = args.professions {
            builder.add_professions(x);
        }
        builder.add_profession(args.profession);
        builder.add_charCnt(args.charCnt);
        builder.add_costDrink(args.costDrink);
        builder.add_costAction(args.costAction);
        if let Some(x) = args.effectDesc {
            builder.add_effectDesc(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.expeditionId {
            builder.add_expeditionId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2ExpeditionDataT {
        let expeditionId = self.expeditionId().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let effectDesc = self.effectDesc().map(|x| x.to_string());
        let costAction = self.costAction();
        let costDrink = self.costDrink();
        let charCnt = self.charCnt();
        let profession = self.profession();
        let professions = self.professions().map(|x| x.into_iter().collect());
        let minEliteRank = self.minEliteRank();
        let duration = self.duration();
        clz_Torappu_SandboxV2ExpeditionDataT {
            expeditionId,
            desc,
            effectDesc,
            costAction,
            costDrink,
            charCnt,
            profession,
            professions,
            minEliteRank,
            duration,
        }
    }

    #[inline]
    pub fn expeditionId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ExpeditionData::VT_EXPEDITIONID,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ExpeditionData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn effectDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ExpeditionData::VT_EFFECTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn costAction(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ExpeditionData::VT_COSTACTION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn costDrink(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ExpeditionData::VT_COSTDRINK, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn charCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ExpeditionData::VT_CHARCNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn profession(&self) -> enum__Torappu_ProfessionCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ProfessionCategory>(
                    clz_Torappu_SandboxV2ExpeditionData::VT_PROFESSION,
                    Some(enum__Torappu_ProfessionCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn professions(&self) -> Option<flatbuffers::Vector<'a, enum__Torappu_ProfessionID>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_ProfessionID>,
            >>(clz_Torappu_SandboxV2ExpeditionData::VT_PROFESSIONS, None)
        }
    }
    #[inline]
    pub fn minEliteRank(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2ExpeditionData::VT_MINELITERANK,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn duration(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ExpeditionData::VT_DURATION, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ExpeditionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("expeditionId", Self::VT_EXPEDITIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("effectDesc", Self::VT_EFFECTDESC, false)?
     .visit_field::<i32>("costAction", Self::VT_COSTACTION, false)?
     .visit_field::<i32>("costDrink", Self::VT_COSTDRINK, false)?
     .visit_field::<i32>("charCnt", Self::VT_CHARCNT, false)?
     .visit_field::<enum__Torappu_ProfessionCategory>("profession", Self::VT_PROFESSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_ProfessionID>>>("professions", Self::VT_PROFESSIONS, false)?
     .visit_field::<i32>("minEliteRank", Self::VT_MINELITERANK, false)?
     .visit_field::<i32>("duration", Self::VT_DURATION, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ExpeditionDataArgs<'a> {
    pub expeditionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub effectDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub costAction: i32,
    pub costDrink: i32,
    pub charCnt: i32,
    pub profession: enum__Torappu_ProfessionCategory,
    pub professions:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_ProfessionID>>>,
    pub minEliteRank: i32,
    pub duration: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2ExpeditionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ExpeditionDataArgs {
            expeditionId: None,
            desc: None,
            effectDesc: None,
            costAction: 0,
            costDrink: 0,
            charCnt: 0,
            profession: enum__Torappu_ProfessionCategory::NONE,
            professions: None,
            minEliteRank: 0,
            duration: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2ExpeditionData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2ExpeditionData", 10)?;
        if let Some(f) = self.expeditionId() {
            s.serialize_field("expeditionId", &f)?;
        } else {
            s.skip_field("expeditionId")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.effectDesc() {
            s.serialize_field("effectDesc", &f)?;
        } else {
            s.skip_field("effectDesc")?;
        }
        s.serialize_field("costAction", &self.costAction())?;
        s.serialize_field("costDrink", &self.costDrink())?;
        s.serialize_field("charCnt", &self.charCnt())?;
        s.serialize_field("profession", &self.profession())?;
        if let Some(f) = self.professions() {
            s.serialize_field("professions", &f)?;
        } else {
            s.skip_field("professions")?;
        }
        s.serialize_field("minEliteRank", &self.minEliteRank())?;
        s.serialize_field("duration", &self.duration())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2ExpeditionDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ExpeditionDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_expeditionId(&mut self, expeditionId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ExpeditionData::VT_EXPEDITIONID,
            expeditionId,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ExpeditionData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_effectDesc(&mut self, effectDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ExpeditionData::VT_EFFECTDESC,
            effectDesc,
        );
    }
    #[inline]
    pub fn add_costAction(&mut self, costAction: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ExpeditionData::VT_COSTACTION,
            costAction,
            0,
        );
    }
    #[inline]
    pub fn add_costDrink(&mut self, costDrink: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ExpeditionData::VT_COSTDRINK,
            costDrink,
            0,
        );
    }
    #[inline]
    pub fn add_charCnt(&mut self, charCnt: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2ExpeditionData::VT_CHARCNT, charCnt, 0);
    }
    #[inline]
    pub fn add_profession(&mut self, profession: enum__Torappu_ProfessionCategory) {
        self.fbb_.push_slot::<enum__Torappu_ProfessionCategory>(
            clz_Torappu_SandboxV2ExpeditionData::VT_PROFESSION,
            profession,
            enum__Torappu_ProfessionCategory::NONE,
        );
    }
    #[inline]
    pub fn add_professions(
        &mut self,
        professions: flatbuffers::WIPOffset<flatbuffers::Vector<'b, enum__Torappu_ProfessionID>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ExpeditionData::VT_PROFESSIONS,
            professions,
        );
    }
    #[inline]
    pub fn add_minEliteRank(&mut self, minEliteRank: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ExpeditionData::VT_MINELITERANK,
            minEliteRank,
            0,
        );
    }
    #[inline]
    pub fn add_duration(&mut self, duration: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ExpeditionData::VT_DURATION,
            duration,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ExpeditionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ExpeditionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ExpeditionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ExpeditionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ExpeditionData");
        ds.field("expeditionId", &self.expeditionId());
        ds.field("desc", &self.desc());
        ds.field("effectDesc", &self.effectDesc());
        ds.field("costAction", &self.costAction());
        ds.field("costDrink", &self.costDrink());
        ds.field("charCnt", &self.charCnt());
        ds.field("profession", &self.profession());
        ds.field("professions", &self.professions());
        ds.field("minEliteRank", &self.minEliteRank());
        ds.field("duration", &self.duration());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2ExpeditionDataT {
    pub expeditionId: Option<String>,
    pub desc: Option<String>,
    pub effectDesc: Option<String>,
    pub costAction: i32,
    pub costDrink: i32,
    pub charCnt: i32,
    pub profession: enum__Torappu_ProfessionCategory,
    pub professions: Option<Vec<enum__Torappu_ProfessionID>>,
    pub minEliteRank: i32,
    pub duration: i32,
}
impl Default for clz_Torappu_SandboxV2ExpeditionDataT {
    fn default() -> Self {
        Self {
            expeditionId: None,
            desc: None,
            effectDesc: None,
            costAction: 0,
            costDrink: 0,
            charCnt: 0,
            profession: enum__Torappu_ProfessionCategory::NONE,
            professions: None,
            minEliteRank: 0,
            duration: 0,
        }
    }
}
impl clz_Torappu_SandboxV2ExpeditionDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ExpeditionData<'b>> {
        let expeditionId = self.expeditionId.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let effectDesc = self.effectDesc.as_ref().map(|x| _fbb.create_string(x));
        let costAction = self.costAction;
        let costDrink = self.costDrink;
        let charCnt = self.charCnt;
        let profession = self.profession;
        let professions = self.professions.as_ref().map(|x| _fbb.create_vector(x));
        let minEliteRank = self.minEliteRank;
        let duration = self.duration;
        clz_Torappu_SandboxV2ExpeditionData::create(
            _fbb,
            &clz_Torappu_SandboxV2ExpeditionDataArgs {
                expeditionId,
                desc,
                effectDesc,
                costAction,
                costDrink,
                charCnt,
                profession,
                professions,
                minEliteRank,
                duration,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ExpeditionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ExpeditionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2ExpeditionData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2ExpeditionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ExpeditionData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ExpeditionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ExpeditionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ExpeditionData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2ExpeditionDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2ExpeditionDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2ExpeditionDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ExpeditionData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2ExpeditionData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ExpeditionData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ExpeditionData>>(
                    dict__string__clz_Torappu_SandboxV2ExpeditionData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ExpeditionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ExpeditionData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ExpeditionDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ExpeditionData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ExpeditionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ExpeditionDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2ExpeditionData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2ExpeditionData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ExpeditionDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ExpeditionDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ExpeditionData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ExpeditionData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ExpeditionData>>(
                dict__string__clz_Torappu_SandboxV2ExpeditionData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ExpeditionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ExpeditionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ExpeditionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ExpeditionData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ExpeditionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2ExpeditionData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2ExpeditionDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2ExpeditionDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2ExpeditionDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2ExpeditionDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ExpeditionData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2ExpeditionData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2ExpeditionDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2EventEffectDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2EventEffectData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2EventEffectData<'a> {
    type Inner = clz_Torappu_SandboxV2EventEffectData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2EventEffectData<'a> {
    pub const VT_EVENTEFFECTID: flatbuffers::VOffsetT = 4;
    pub const VT_BUFFID: flatbuffers::VOffsetT = 6;
    pub const VT_DURATION: flatbuffers::VOffsetT = 8;
    pub const VT_DESC: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2EventEffectData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2EventEffectDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventEffectData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2EventEffectDataBuilder::new(_fbb);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        builder.add_duration(args.duration);
        if let Some(x) = args.buffId {
            builder.add_buffId(x);
        }
        if let Some(x) = args.eventEffectId {
            builder.add_eventEffectId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2EventEffectDataT {
        let eventEffectId = self.eventEffectId().map(|x| x.to_string());
        let buffId = self.buffId().map(|x| x.to_string());
        let duration = self.duration();
        let desc = self.desc().map(|x| x.to_string());
        clz_Torappu_SandboxV2EventEffectDataT {
            eventEffectId,
            buffId,
            duration,
            desc,
        }
    }

    #[inline]
    pub fn eventEffectId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventEffectData::VT_EVENTEFFECTID,
                None,
            )
        }
    }
    #[inline]
    pub fn buffId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventEffectData::VT_BUFFID,
                None,
            )
        }
    }
    #[inline]
    pub fn duration(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2EventEffectData::VT_DURATION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2EventEffectData::VT_DESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2EventEffectData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "eventEffectId",
                Self::VT_EVENTEFFECTID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buffId", Self::VT_BUFFID, false)?
            .visit_field::<i32>("duration", Self::VT_DURATION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2EventEffectDataArgs<'a> {
    pub eventEffectId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub duration: i32,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2EventEffectDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2EventEffectDataArgs {
            eventEffectId: None,
            buffId: None,
            duration: 0,
            desc: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2EventEffectData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2EventEffectData", 4)?;
        if let Some(f) = self.eventEffectId() {
            s.serialize_field("eventEffectId", &f)?;
        } else {
            s.skip_field("eventEffectId")?;
        }
        if let Some(f) = self.buffId() {
            s.serialize_field("buffId", &f)?;
        } else {
            s.skip_field("buffId")?;
        }
        s.serialize_field("duration", &self.duration())?;
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2EventEffectDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2EventEffectDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_eventEffectId(&mut self, eventEffectId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventEffectData::VT_EVENTEFFECTID,
            eventEffectId,
        );
    }
    #[inline]
    pub fn add_buffId(&mut self, buffId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventEffectData::VT_BUFFID,
            buffId,
        );
    }
    #[inline]
    pub fn add_duration(&mut self, duration: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2EventEffectData::VT_DURATION,
            duration,
            0,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2EventEffectData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2EventEffectDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2EventEffectDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventEffectData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2EventEffectData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2EventEffectData");
        ds.field("eventEffectId", &self.eventEffectId());
        ds.field("buffId", &self.buffId());
        ds.field("duration", &self.duration());
        ds.field("desc", &self.desc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2EventEffectDataT {
    pub eventEffectId: Option<String>,
    pub buffId: Option<String>,
    pub duration: i32,
    pub desc: Option<String>,
}
impl Default for clz_Torappu_SandboxV2EventEffectDataT {
    fn default() -> Self {
        Self {
            eventEffectId: None,
            buffId: None,
            duration: 0,
            desc: None,
        }
    }
}
impl clz_Torappu_SandboxV2EventEffectDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventEffectData<'b>> {
        let eventEffectId = self.eventEffectId.as_ref().map(|x| _fbb.create_string(x));
        let buffId = self.buffId.as_ref().map(|x| _fbb.create_string(x));
        let duration = self.duration;
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2EventEffectData::create(
            _fbb,
            &clz_Torappu_SandboxV2EventEffectDataArgs {
                eventEffectId,
                buffId,
                duration,
                desc,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2EventEffectDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2EventEffectData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2EventEffectData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2EventEffectData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2EventEffectData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2EventEffectData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2EventEffectDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EventEffectData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2EventEffectDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2EventEffectDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2EventEffectDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2EventEffectData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2EventEffectData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2EventEffectData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2EventEffectData>>(
                    dict__string__clz_Torappu_SandboxV2EventEffectData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2EventEffectData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2EventEffectData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2EventEffectDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventEffectData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2EventEffectDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2EventEffectDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2EventEffectData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2EventEffectData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2EventEffectDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2EventEffectDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2EventEffectData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventEffectData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2EventEffectData>>(
                dict__string__clz_Torappu_SandboxV2EventEffectData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2EventEffectDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2EventEffectDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EventEffectData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2EventEffectData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2EventEffectData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2EventEffectData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2EventEffectDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2EventEffectDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2EventEffectDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2EventEffectDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2EventEffectData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2EventEffectData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2EventEffectDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2ShopGoodDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ShopGoodData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ShopGoodData<'a> {
    type Inner = clz_Torappu_SandboxV2ShopGoodData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ShopGoodData<'a> {
    pub const VT_GOODID: flatbuffers::VOffsetT = 4;
    pub const VT_ITEMID: flatbuffers::VOffsetT = 6;
    pub const VT_COUNT: flatbuffers::VOffsetT = 8;
    pub const VT_COINTYPE: flatbuffers::VOffsetT = 10;
    pub const VT_VALUE: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ShopGoodData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ShopGoodDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ShopGoodData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ShopGoodDataBuilder::new(_fbb);
        builder.add_value(args.value);
        builder.add_coinType(args.coinType);
        builder.add_count(args.count);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        if let Some(x) = args.goodId {
            builder.add_goodId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2ShopGoodDataT {
        let goodId = self.goodId().map(|x| x.to_string());
        let itemId = self.itemId().map(|x| x.to_string());
        let count = self.count();
        let coinType = self.coinType();
        let value = self.value();
        clz_Torappu_SandboxV2ShopGoodDataT {
            goodId,
            itemId,
            count,
            coinType,
            value,
        }
    }

    #[inline]
    pub fn goodId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ShopGoodData::VT_GOODID,
                None,
            )
        }
    }
    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ShopGoodData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ShopGoodData::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn coinType(&self) -> enum__Torappu_SandboxV2CoinType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2CoinType>(
                    clz_Torappu_SandboxV2ShopGoodData::VT_COINTYPE,
                    Some(enum__Torappu_SandboxV2CoinType::DIMENSION_COIN),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn value(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ShopGoodData::VT_VALUE, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ShopGoodData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("goodId", Self::VT_GOODID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<enum__Torappu_SandboxV2CoinType>("coinType", Self::VT_COINTYPE, false)?
            .visit_field::<i32>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ShopGoodDataArgs<'a> {
    pub goodId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
    pub coinType: enum__Torappu_SandboxV2CoinType,
    pub value: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2ShopGoodDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ShopGoodDataArgs {
            goodId: None,
            itemId: None,
            count: 0,
            coinType: enum__Torappu_SandboxV2CoinType::DIMENSION_COIN,
            value: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2ShopGoodData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2ShopGoodData", 5)?;
        if let Some(f) = self.goodId() {
            s.serialize_field("goodId", &f)?;
        } else {
            s.skip_field("goodId")?;
        }
        if let Some(f) = self.itemId() {
            s.serialize_field("itemId", &f)?;
        } else {
            s.skip_field("itemId")?;
        }
        s.serialize_field("count", &self.count())?;
        s.serialize_field("coinType", &self.coinType())?;
        s.serialize_field("value", &self.value())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2ShopGoodDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ShopGoodDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_goodId(&mut self, goodId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ShopGoodData::VT_GOODID,
            goodId,
        );
    }
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ShopGoodData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2ShopGoodData::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_coinType(&mut self, coinType: enum__Torappu_SandboxV2CoinType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2CoinType>(
            clz_Torappu_SandboxV2ShopGoodData::VT_COINTYPE,
            coinType,
            enum__Torappu_SandboxV2CoinType::DIMENSION_COIN,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2ShopGoodData::VT_VALUE, value, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ShopGoodDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ShopGoodDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ShopGoodData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ShopGoodData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ShopGoodData");
        ds.field("goodId", &self.goodId());
        ds.field("itemId", &self.itemId());
        ds.field("count", &self.count());
        ds.field("coinType", &self.coinType());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2ShopGoodDataT {
    pub goodId: Option<String>,
    pub itemId: Option<String>,
    pub count: i32,
    pub coinType: enum__Torappu_SandboxV2CoinType,
    pub value: i32,
}
impl Default for clz_Torappu_SandboxV2ShopGoodDataT {
    fn default() -> Self {
        Self {
            goodId: None,
            itemId: None,
            count: 0,
            coinType: enum__Torappu_SandboxV2CoinType::DIMENSION_COIN,
            value: 0,
        }
    }
}
impl clz_Torappu_SandboxV2ShopGoodDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ShopGoodData<'b>> {
        let goodId = self.goodId.as_ref().map(|x| _fbb.create_string(x));
        let itemId = self.itemId.as_ref().map(|x| _fbb.create_string(x));
        let count = self.count;
        let coinType = self.coinType;
        let value = self.value;
        clz_Torappu_SandboxV2ShopGoodData::create(
            _fbb,
            &clz_Torappu_SandboxV2ShopGoodDataArgs {
                goodId,
                itemId,
                count,
                coinType,
                value,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ShopGoodDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ShopGoodData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2ShopGoodData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2ShopGoodData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ShopGoodData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ShopGoodData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ShopGoodDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ShopGoodData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2ShopGoodDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2ShopGoodDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2ShopGoodDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ShopGoodData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2ShopGoodData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ShopGoodData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ShopGoodData>>(
                    dict__string__clz_Torappu_SandboxV2ShopGoodData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ShopGoodData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ShopGoodData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ShopGoodDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ShopGoodData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ShopGoodDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ShopGoodDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2ShopGoodData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2ShopGoodData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ShopGoodDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ShopGoodDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ShopGoodData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ShopGoodData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ShopGoodData>>(
                dict__string__clz_Torappu_SandboxV2ShopGoodData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ShopGoodDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ShopGoodDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ShopGoodData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ShopGoodData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ShopGoodData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2ShopGoodData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2ShopGoodDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2ShopGoodDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2ShopGoodDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2ShopGoodDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ShopGoodData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2ShopGoodData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2ShopGoodDataArgs { key, value },
        )
    }
}
pub enum dict__string__list_stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__list_string<'a> {
    type Inner = dict__string__list_string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__list_string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__list_string<'bldr>> {
        let mut builder = dict__string__list_stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__list_stringT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self
            .value()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        dict__string__list_stringT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__list_string::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__list_string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(dict__string__list_string::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__list_string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_stringArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for dict__string__list_stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__list_stringArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__list_string<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__list_string", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__list_stringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__list_stringBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__list_string::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_string::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__list_stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__list_stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__list_string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__list_string::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__list_string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__list_string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__list_stringT {
    pub key: String,
    pub value: Option<Vec<String>>,
}
impl Default for dict__string__list_stringT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__list_stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__list_string<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        dict__string__list_string::create(_fbb, &dict__string__list_stringArgs { key, value })
    }
}
pub enum clz_Torappu_SandboxV2ShopDialogDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ShopDialogData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ShopDialogData<'a> {
    type Inner = clz_Torappu_SandboxV2ShopDialogData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ShopDialogData<'a> {
    pub const VT_SEASONDIALOGS: flatbuffers::VOffsetT = 4;
    pub const VT_AFTERBUYDIALOGS: flatbuffers::VOffsetT = 6;
    pub const VT_SHOPEMPTYDIALOGS: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ShopDialogData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ShopDialogDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ShopDialogData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ShopDialogDataBuilder::new(_fbb);
        if let Some(x) = args.shopEmptyDialogs {
            builder.add_shopEmptyDialogs(x);
        }
        if let Some(x) = args.afterBuyDialogs {
            builder.add_afterBuyDialogs(x);
        }
        if let Some(x) = args.seasonDialogs {
            builder.add_seasonDialogs(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2ShopDialogDataT {
        let seasonDialogs = self
            .seasonDialogs()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let afterBuyDialogs = self
            .afterBuyDialogs()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let shopEmptyDialogs = self
            .shopEmptyDialogs()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_SandboxV2ShopDialogDataT {
            seasonDialogs,
            afterBuyDialogs,
            shopEmptyDialogs,
        }
    }

    #[inline]
    pub fn seasonDialogs(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string>>,
            >>(clz_Torappu_SandboxV2ShopDialogData::VT_SEASONDIALOGS, None)
        }
    }
    #[inline]
    pub fn afterBuyDialogs(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2ShopDialogData::VT_AFTERBUYDIALOGS,
                None,
            )
        }
    }
    #[inline]
    pub fn shopEmptyDialogs(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2ShopDialogData::VT_SHOPEMPTYDIALOGS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ShopDialogData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__list_string>>,
            >>("seasonDialogs", Self::VT_SEASONDIALOGS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("afterBuyDialogs", Self::VT_AFTERBUYDIALOGS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("shopEmptyDialogs", Self::VT_SHOPEMPTYDIALOGS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ShopDialogDataArgs<'a> {
    pub seasonDialogs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string<'a>>>,
        >,
    >,
    pub afterBuyDialogs: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub shopEmptyDialogs: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2ShopDialogDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ShopDialogDataArgs {
            seasonDialogs: None,
            afterBuyDialogs: None,
            shopEmptyDialogs: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2ShopDialogData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2ShopDialogData", 3)?;
        if let Some(f) = self.seasonDialogs() {
            s.serialize_field("seasonDialogs", &f)?;
        } else {
            s.skip_field("seasonDialogs")?;
        }
        if let Some(f) = self.afterBuyDialogs() {
            s.serialize_field("afterBuyDialogs", &f)?;
        } else {
            s.skip_field("afterBuyDialogs")?;
        }
        if let Some(f) = self.shopEmptyDialogs() {
            s.serialize_field("shopEmptyDialogs", &f)?;
        } else {
            s.skip_field("shopEmptyDialogs")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2ShopDialogDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ShopDialogDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_seasonDialogs(
        &mut self,
        seasonDialogs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__list_string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ShopDialogData::VT_SEASONDIALOGS,
            seasonDialogs,
        );
    }
    #[inline]
    pub fn add_afterBuyDialogs(
        &mut self,
        afterBuyDialogs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ShopDialogData::VT_AFTERBUYDIALOGS,
            afterBuyDialogs,
        );
    }
    #[inline]
    pub fn add_shopEmptyDialogs(
        &mut self,
        shopEmptyDialogs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ShopDialogData::VT_SHOPEMPTYDIALOGS,
            shopEmptyDialogs,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ShopDialogDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ShopDialogDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ShopDialogData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ShopDialogData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ShopDialogData");
        ds.field("seasonDialogs", &self.seasonDialogs());
        ds.field("afterBuyDialogs", &self.afterBuyDialogs());
        ds.field("shopEmptyDialogs", &self.shopEmptyDialogs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2ShopDialogDataT {
    pub seasonDialogs: Option<Vec<dict__string__list_stringT>>,
    pub afterBuyDialogs: Option<Vec<String>>,
    pub shopEmptyDialogs: Option<Vec<String>>,
}
impl Default for clz_Torappu_SandboxV2ShopDialogDataT {
    fn default() -> Self {
        Self {
            seasonDialogs: None,
            afterBuyDialogs: None,
            shopEmptyDialogs: None,
        }
    }
}
impl clz_Torappu_SandboxV2ShopDialogDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ShopDialogData<'b>> {
        let seasonDialogs = self.seasonDialogs.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let afterBuyDialogs = self.afterBuyDialogs.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let shopEmptyDialogs = self.shopEmptyDialogs.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SandboxV2ShopDialogData::create(
            _fbb,
            &clz_Torappu_SandboxV2ShopDialogDataArgs {
                seasonDialogs,
                afterBuyDialogs,
                shopEmptyDialogs,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2LogisticsDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2LogisticsData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2LogisticsData<'a> {
    type Inner = clz_Torappu_SandboxV2LogisticsData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2LogisticsData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DESC: flatbuffers::VOffsetT = 6;
    pub const VT_NOBUFFDESC: flatbuffers::VOffsetT = 8;
    pub const VT_ICONID: flatbuffers::VOffsetT = 10;
    pub const VT_PROFESSION: flatbuffers::VOffsetT = 12;
    pub const VT_SORTID: flatbuffers::VOffsetT = 14;
    pub const VT_LEVELPARAMS: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2LogisticsData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2LogisticsDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2LogisticsData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2LogisticsDataBuilder::new(_fbb);
        if let Some(x) = args.levelParams {
            builder.add_levelParams(x);
        }
        builder.add_sortId(args.sortId);
        builder.add_profession(args.profession);
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.noBuffDesc {
            builder.add_noBuffDesc(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2LogisticsDataT {
        let id = self.id().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let noBuffDesc = self.noBuffDesc().map(|x| x.to_string());
        let iconId = self.iconId().map(|x| x.to_string());
        let profession = self.profession();
        let sortId = self.sortId();
        let levelParams = self
            .levelParams()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_SandboxV2LogisticsDataT {
            id,
            desc,
            noBuffDesc,
            iconId,
            profession,
            sortId,
            levelParams,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2LogisticsData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2LogisticsData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn noBuffDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2LogisticsData::VT_NOBUFFDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2LogisticsData::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn profession(&self) -> enum__Torappu_ProfessionCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ProfessionCategory>(
                    clz_Torappu_SandboxV2LogisticsData::VT_PROFESSION,
                    Some(enum__Torappu_ProfessionCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2LogisticsData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn levelParams(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxV2LogisticsData::VT_LEVELPARAMS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2LogisticsData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "noBuffDesc",
                Self::VT_NOBUFFDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<enum__Torappu_ProfessionCategory>(
                "profession",
                Self::VT_PROFESSION,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("levelParams", Self::VT_LEVELPARAMS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2LogisticsDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub noBuffDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub profession: enum__Torappu_ProfessionCategory,
    pub sortId: i32,
    pub levelParams: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2LogisticsDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2LogisticsDataArgs {
            id: None,
            desc: None,
            noBuffDesc: None,
            iconId: None,
            profession: enum__Torappu_ProfessionCategory::NONE,
            sortId: 0,
            levelParams: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2LogisticsData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2LogisticsData", 7)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.noBuffDesc() {
            s.serialize_field("noBuffDesc", &f)?;
        } else {
            s.skip_field("noBuffDesc")?;
        }
        if let Some(f) = self.iconId() {
            s.serialize_field("iconId", &f)?;
        } else {
            s.skip_field("iconId")?;
        }
        s.serialize_field("profession", &self.profession())?;
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.levelParams() {
            s.serialize_field("levelParams", &f)?;
        } else {
            s.skip_field("levelParams")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2LogisticsDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2LogisticsDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2LogisticsData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2LogisticsData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_noBuffDesc(&mut self, noBuffDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2LogisticsData::VT_NOBUFFDESC,
            noBuffDesc,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2LogisticsData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_profession(&mut self, profession: enum__Torappu_ProfessionCategory) {
        self.fbb_.push_slot::<enum__Torappu_ProfessionCategory>(
            clz_Torappu_SandboxV2LogisticsData::VT_PROFESSION,
            profession,
            enum__Torappu_ProfessionCategory::NONE,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2LogisticsData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_levelParams(
        &mut self,
        levelParams: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2LogisticsData::VT_LEVELPARAMS,
            levelParams,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2LogisticsDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2LogisticsDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2LogisticsData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2LogisticsData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2LogisticsData");
        ds.field("id", &self.id());
        ds.field("desc", &self.desc());
        ds.field("noBuffDesc", &self.noBuffDesc());
        ds.field("iconId", &self.iconId());
        ds.field("profession", &self.profession());
        ds.field("sortId", &self.sortId());
        ds.field("levelParams", &self.levelParams());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2LogisticsDataT {
    pub id: Option<String>,
    pub desc: Option<String>,
    pub noBuffDesc: Option<String>,
    pub iconId: Option<String>,
    pub profession: enum__Torappu_ProfessionCategory,
    pub sortId: i32,
    pub levelParams: Option<Vec<String>>,
}
impl Default for clz_Torappu_SandboxV2LogisticsDataT {
    fn default() -> Self {
        Self {
            id: None,
            desc: None,
            noBuffDesc: None,
            iconId: None,
            profession: enum__Torappu_ProfessionCategory::NONE,
            sortId: 0,
            levelParams: None,
        }
    }
}
impl clz_Torappu_SandboxV2LogisticsDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2LogisticsData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let noBuffDesc = self.noBuffDesc.as_ref().map(|x| _fbb.create_string(x));
        let iconId = self.iconId.as_ref().map(|x| _fbb.create_string(x));
        let profession = self.profession;
        let sortId = self.sortId;
        let levelParams = self.levelParams.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SandboxV2LogisticsData::create(
            _fbb,
            &clz_Torappu_SandboxV2LogisticsDataArgs {
                id,
                desc,
                noBuffDesc,
                iconId,
                profession,
                sortId,
                levelParams,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2LogisticsCharDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2LogisticsCharData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2LogisticsCharData<'a> {
    type Inner = clz_Torappu_SandboxV2LogisticsCharData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2LogisticsCharData<'a> {
    pub const VT_LEVELUPPERLIMIT: flatbuffers::VOffsetT = 4;
    pub const VT_CHARUPPERLIMIT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2LogisticsCharData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2LogisticsCharDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2LogisticsCharData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2LogisticsCharDataBuilder::new(_fbb);
        builder.add_charUpperLimit(args.charUpperLimit);
        builder.add_levelUpperLimit(args.levelUpperLimit);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2LogisticsCharDataT {
        let levelUpperLimit = self.levelUpperLimit();
        let charUpperLimit = self.charUpperLimit();
        clz_Torappu_SandboxV2LogisticsCharDataT {
            levelUpperLimit,
            charUpperLimit,
        }
    }

    #[inline]
    pub fn levelUpperLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2LogisticsCharData::VT_LEVELUPPERLIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn charUpperLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2LogisticsCharData::VT_CHARUPPERLIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2LogisticsCharData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("levelUpperLimit", Self::VT_LEVELUPPERLIMIT, false)?
            .visit_field::<i32>("charUpperLimit", Self::VT_CHARUPPERLIMIT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2LogisticsCharDataArgs {
    pub levelUpperLimit: i32,
    pub charUpperLimit: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2LogisticsCharDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2LogisticsCharDataArgs {
            levelUpperLimit: 0,
            charUpperLimit: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2LogisticsCharData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2LogisticsCharData", 2)?;
        s.serialize_field("levelUpperLimit", &self.levelUpperLimit())?;
        s.serialize_field("charUpperLimit", &self.charUpperLimit())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2LogisticsCharDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2LogisticsCharDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_levelUpperLimit(&mut self, levelUpperLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2LogisticsCharData::VT_LEVELUPPERLIMIT,
            levelUpperLimit,
            0,
        );
    }
    #[inline]
    pub fn add_charUpperLimit(&mut self, charUpperLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2LogisticsCharData::VT_CHARUPPERLIMIT,
            charUpperLimit,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2LogisticsCharDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2LogisticsCharDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2LogisticsCharData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2LogisticsCharData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2LogisticsCharData");
        ds.field("levelUpperLimit", &self.levelUpperLimit());
        ds.field("charUpperLimit", &self.charUpperLimit());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2LogisticsCharDataT {
    pub levelUpperLimit: i32,
    pub charUpperLimit: i32,
}
impl Default for clz_Torappu_SandboxV2LogisticsCharDataT {
    fn default() -> Self {
        Self {
            levelUpperLimit: 0,
            charUpperLimit: 0,
        }
    }
}
impl clz_Torappu_SandboxV2LogisticsCharDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2LogisticsCharData<'b>> {
        let levelUpperLimit = self.levelUpperLimit;
        let charUpperLimit = self.charUpperLimit;
        clz_Torappu_SandboxV2LogisticsCharData::create(
            _fbb,
            &clz_Torappu_SandboxV2LogisticsCharDataArgs {
                levelUpperLimit,
                charUpperLimit,
            },
        )
    }
}
pub enum dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a> {
    type Inner = dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__list_clz_Torappu_SandboxV2LogisticsCharData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'bldr>> {
        let mut builder = dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataT {
        let key = self.key();
        let value = self.value().map(|x| x.iter().map(|t| t.unpack()).collect());
        dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    dict__int__list_clz_Torappu_SandboxV2LogisticsCharData::VT_KEY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__int__list_clz_Torappu_SandboxV2LogisticsCharData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LogisticsCharData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LogisticsCharData>,
                >,
            >>(
                dict__int__list_clz_Torappu_SandboxV2LogisticsCharData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LogisticsCharData>,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataArgs<'a> {
    pub key: i32,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LogisticsCharData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataArgs {
            key: 0,
            value: None,
        }
    }
}

impl Serialize for dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__int__list_clz_Torappu_SandboxV2LogisticsCharData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_.push_slot::<i32>(
            dict__int__list_clz_Torappu_SandboxV2LogisticsCharData::VT_KEY,
            key,
            0,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LogisticsCharData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__int__list_clz_Torappu_SandboxV2LogisticsCharData::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__int__list_clz_Torappu_SandboxV2LogisticsCharData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataT {
    pub key: i32,
    pub value: Option<Vec<clz_Torappu_SandboxV2LogisticsCharDataT>>,
}
impl Default for dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataT {
    fn default() -> Self {
        Self {
            key: 0,
            value: None,
        }
    }
}
impl dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'b>> {
        let key = self.key;
        let value = self.value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        dict__int__list_clz_Torappu_SandboxV2LogisticsCharData::create(
            _fbb,
            &dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataArgs { key, value },
        )
    }
}
pub enum dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a>
{
    type Inner = dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataArgs<
            'args,
        >,
    ) -> flatbuffers::WIPOffset<
        dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'bldr>,
    > {
        let mut builder =
            dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataBuilder::new(
                _fbb,
            );
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(
        &self,
    ) -> dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataT {
        let key = self.key();
        let value = self.value().map(|x| x.iter().map(|t| t.unpack()).collect());
        dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData::VT_KEY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__int__list_clz_Torappu_SandboxV2LogisticsCharData,
                    >,
                >,
            >>(
                dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__int__list_clz_Torappu_SandboxV2LogisticsCharData,
                    >,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataArgs<'a> {
    pub key: i32,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default
    for dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataArgs<'a>
{
    #[inline]
    fn default() -> Self {
        dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataArgs {
            key: 0,
            value: None,
        }
    }
}

impl Serialize for dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_.push_slot::<i32>(
            dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData::VT_KEY,
            key,
            0,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataBuilder<'a, 'b, A>
    {
        let start = _fbb.start_table();
        dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f
            .debug_struct("dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataT {
    pub key: i32,
    pub value: Option<Vec<dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataT>>,
}
impl Default for dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataT {
    fn default() -> Self {
        Self {
            key: 0,
            value: None,
        }
    }
}
impl dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<
        dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'b>,
    > {
        let key = self.key;
        let value = self.value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData::create(
            _fbb,
            &dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataArgs {
                key,
                value,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2MonthRushDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2MonthRushData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2MonthRushData<'a> {
    type Inner = clz_Torappu_SandboxV2MonthRushData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2MonthRushData<'a> {
    pub const VT_MONTHLYRUSHID: flatbuffers::VOffsetT = 4;
    pub const VT_STARTTIME: flatbuffers::VOffsetT = 6;
    pub const VT_ENDTIME: flatbuffers::VOffsetT = 8;
    pub const VT_ISLAST: flatbuffers::VOffsetT = 10;
    pub const VT_SORTID: flatbuffers::VOffsetT = 12;
    pub const VT_RUSHGROUPKEY: flatbuffers::VOffsetT = 14;
    pub const VT_MONTHLYRUSHNAME: flatbuffers::VOffsetT = 16;
    pub const VT_MONTHLYRUSHDES: flatbuffers::VOffsetT = 18;
    pub const VT_WEATHERID: flatbuffers::VOffsetT = 20;
    pub const VT_NODEID: flatbuffers::VOffsetT = 22;
    pub const VT_CONDITIONGROUP: flatbuffers::VOffsetT = 24;
    pub const VT_CONDITIONDESC: flatbuffers::VOffsetT = 26;
    pub const VT_REWARDITEMLIST: flatbuffers::VOffsetT = 28;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2MonthRushData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2MonthRushDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2MonthRushData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2MonthRushDataBuilder::new(_fbb);
        builder.add_endTime(args.endTime);
        builder.add_startTime(args.startTime);
        if let Some(x) = args.rewardItemList {
            builder.add_rewardItemList(x);
        }
        if let Some(x) = args.conditionDesc {
            builder.add_conditionDesc(x);
        }
        if let Some(x) = args.conditionGroup {
            builder.add_conditionGroup(x);
        }
        if let Some(x) = args.nodeId {
            builder.add_nodeId(x);
        }
        if let Some(x) = args.weatherId {
            builder.add_weatherId(x);
        }
        if let Some(x) = args.monthlyRushDes {
            builder.add_monthlyRushDes(x);
        }
        if let Some(x) = args.monthlyRushName {
            builder.add_monthlyRushName(x);
        }
        if let Some(x) = args.rushGroupKey {
            builder.add_rushGroupKey(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.monthlyRushId {
            builder.add_monthlyRushId(x);
        }
        builder.add_isLast(args.isLast);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2MonthRushDataT {
        let monthlyRushId = self.monthlyRushId().map(|x| x.to_string());
        let startTime = self.startTime();
        let endTime = self.endTime();
        let isLast = self.isLast();
        let sortId = self.sortId();
        let rushGroupKey = self.rushGroupKey().map(|x| x.to_string());
        let monthlyRushName = self.monthlyRushName().map(|x| x.to_string());
        let monthlyRushDes = self.monthlyRushDes().map(|x| x.to_string());
        let weatherId = self.weatherId().map(|x| x.to_string());
        let nodeId = self.nodeId().map(|x| x.to_string());
        let conditionGroup = self.conditionGroup().map(|x| x.to_string());
        let conditionDesc = self.conditionDesc().map(|x| x.to_string());
        let rewardItemList = self
            .rewardItemList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_SandboxV2MonthRushDataT {
            monthlyRushId,
            startTime,
            endTime,
            isLast,
            sortId,
            rushGroupKey,
            monthlyRushName,
            monthlyRushDes,
            weatherId,
            nodeId,
            conditionGroup,
            conditionDesc,
            rewardItemList,
        }
    }

    #[inline]
    pub fn monthlyRushId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MonthRushData::VT_MONTHLYRUSHID,
                None,
            )
        }
    }
    #[inline]
    pub fn startTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_SandboxV2MonthRushData::VT_STARTTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_SandboxV2MonthRushData::VT_ENDTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn isLast(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_SandboxV2MonthRushData::VT_ISLAST, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2MonthRushData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn rushGroupKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MonthRushData::VT_RUSHGROUPKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn monthlyRushName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MonthRushData::VT_MONTHLYRUSHNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn monthlyRushDes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MonthRushData::VT_MONTHLYRUSHDES,
                None,
            )
        }
    }
    #[inline]
    pub fn weatherId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MonthRushData::VT_WEATHERID,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MonthRushData::VT_NODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn conditionGroup(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MonthRushData::VT_CONDITIONGROUP,
                None,
            )
        }
    }
    #[inline]
    pub fn conditionDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2MonthRushData::VT_CONDITIONDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn rewardItemList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(clz_Torappu_SandboxV2MonthRushData::VT_REWARDITEMLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2MonthRushData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "monthlyRushId",
                Self::VT_MONTHLYRUSHID,
                false,
            )?
            .visit_field::<i64>("startTime", Self::VT_STARTTIME, false)?
            .visit_field::<i64>("endTime", Self::VT_ENDTIME, false)?
            .visit_field::<bool>("isLast", Self::VT_ISLAST, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rushGroupKey",
                Self::VT_RUSHGROUPKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "monthlyRushName",
                Self::VT_MONTHLYRUSHNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "monthlyRushDes",
                Self::VT_MONTHLYRUSHDES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "weatherId",
                Self::VT_WEATHERID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nodeId", Self::VT_NODEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "conditionGroup",
                Self::VT_CONDITIONGROUP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "conditionDesc",
                Self::VT_CONDITIONDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("rewardItemList", Self::VT_REWARDITEMLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2MonthRushDataArgs<'a> {
    pub monthlyRushId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub startTime: i64,
    pub endTime: i64,
    pub isLast: bool,
    pub sortId: i32,
    pub rushGroupKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub monthlyRushName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub monthlyRushDes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weatherId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub conditionGroup: Option<flatbuffers::WIPOffset<&'a str>>,
    pub conditionDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewardItemList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2MonthRushDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2MonthRushDataArgs {
            monthlyRushId: None,
            startTime: 0,
            endTime: 0,
            isLast: false,
            sortId: 0,
            rushGroupKey: None,
            monthlyRushName: None,
            monthlyRushDes: None,
            weatherId: None,
            nodeId: None,
            conditionGroup: None,
            conditionDesc: None,
            rewardItemList: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2MonthRushData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2MonthRushData", 13)?;
        if let Some(f) = self.monthlyRushId() {
            s.serialize_field("monthlyRushId", &f)?;
        } else {
            s.skip_field("monthlyRushId")?;
        }
        s.serialize_field("startTime", &self.startTime())?;
        s.serialize_field("endTime", &self.endTime())?;
        s.serialize_field("isLast", &self.isLast())?;
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.rushGroupKey() {
            s.serialize_field("rushGroupKey", &f)?;
        } else {
            s.skip_field("rushGroupKey")?;
        }
        if let Some(f) = self.monthlyRushName() {
            s.serialize_field("monthlyRushName", &f)?;
        } else {
            s.skip_field("monthlyRushName")?;
        }
        if let Some(f) = self.monthlyRushDes() {
            s.serialize_field("monthlyRushDes", &f)?;
        } else {
            s.skip_field("monthlyRushDes")?;
        }
        if let Some(f) = self.weatherId() {
            s.serialize_field("weatherId", &f)?;
        } else {
            s.skip_field("weatherId")?;
        }
        if let Some(f) = self.nodeId() {
            s.serialize_field("nodeId", &f)?;
        } else {
            s.skip_field("nodeId")?;
        }
        if let Some(f) = self.conditionGroup() {
            s.serialize_field("conditionGroup", &f)?;
        } else {
            s.skip_field("conditionGroup")?;
        }
        if let Some(f) = self.conditionDesc() {
            s.serialize_field("conditionDesc", &f)?;
        } else {
            s.skip_field("conditionDesc")?;
        }
        if let Some(f) = self.rewardItemList() {
            s.serialize_field("rewardItemList", &f)?;
        } else {
            s.skip_field("rewardItemList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2MonthRushDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2MonthRushDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_monthlyRushId(&mut self, monthlyRushId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MonthRushData::VT_MONTHLYRUSHID,
            monthlyRushId,
        );
    }
    #[inline]
    pub fn add_startTime(&mut self, startTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_SandboxV2MonthRushData::VT_STARTTIME,
            startTime,
            0,
        );
    }
    #[inline]
    pub fn add_endTime(&mut self, endTime: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_SandboxV2MonthRushData::VT_ENDTIME, endTime, 0);
    }
    #[inline]
    pub fn add_isLast(&mut self, isLast: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_SandboxV2MonthRushData::VT_ISLAST, isLast, false);
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2MonthRushData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_rushGroupKey(&mut self, rushGroupKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MonthRushData::VT_RUSHGROUPKEY,
            rushGroupKey,
        );
    }
    #[inline]
    pub fn add_monthlyRushName(&mut self, monthlyRushName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MonthRushData::VT_MONTHLYRUSHNAME,
            monthlyRushName,
        );
    }
    #[inline]
    pub fn add_monthlyRushDes(&mut self, monthlyRushDes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MonthRushData::VT_MONTHLYRUSHDES,
            monthlyRushDes,
        );
    }
    #[inline]
    pub fn add_weatherId(&mut self, weatherId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MonthRushData::VT_WEATHERID,
            weatherId,
        );
    }
    #[inline]
    pub fn add_nodeId(&mut self, nodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MonthRushData::VT_NODEID,
            nodeId,
        );
    }
    #[inline]
    pub fn add_conditionGroup(&mut self, conditionGroup: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MonthRushData::VT_CONDITIONGROUP,
            conditionGroup,
        );
    }
    #[inline]
    pub fn add_conditionDesc(&mut self, conditionDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MonthRushData::VT_CONDITIONDESC,
            conditionDesc,
        );
    }
    #[inline]
    pub fn add_rewardItemList(
        &mut self,
        rewardItemList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2MonthRushData::VT_REWARDITEMLIST,
            rewardItemList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2MonthRushDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2MonthRushDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2MonthRushData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2MonthRushData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2MonthRushData");
        ds.field("monthlyRushId", &self.monthlyRushId());
        ds.field("startTime", &self.startTime());
        ds.field("endTime", &self.endTime());
        ds.field("isLast", &self.isLast());
        ds.field("sortId", &self.sortId());
        ds.field("rushGroupKey", &self.rushGroupKey());
        ds.field("monthlyRushName", &self.monthlyRushName());
        ds.field("monthlyRushDes", &self.monthlyRushDes());
        ds.field("weatherId", &self.weatherId());
        ds.field("nodeId", &self.nodeId());
        ds.field("conditionGroup", &self.conditionGroup());
        ds.field("conditionDesc", &self.conditionDesc());
        ds.field("rewardItemList", &self.rewardItemList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2MonthRushDataT {
    pub monthlyRushId: Option<String>,
    pub startTime: i64,
    pub endTime: i64,
    pub isLast: bool,
    pub sortId: i32,
    pub rushGroupKey: Option<String>,
    pub monthlyRushName: Option<String>,
    pub monthlyRushDes: Option<String>,
    pub weatherId: Option<String>,
    pub nodeId: Option<String>,
    pub conditionGroup: Option<String>,
    pub conditionDesc: Option<String>,
    pub rewardItemList: Option<Vec<clz_Torappu_ItemBundleT>>,
}
impl Default for clz_Torappu_SandboxV2MonthRushDataT {
    fn default() -> Self {
        Self {
            monthlyRushId: None,
            startTime: 0,
            endTime: 0,
            isLast: false,
            sortId: 0,
            rushGroupKey: None,
            monthlyRushName: None,
            monthlyRushDes: None,
            weatherId: None,
            nodeId: None,
            conditionGroup: None,
            conditionDesc: None,
            rewardItemList: None,
        }
    }
}
impl clz_Torappu_SandboxV2MonthRushDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2MonthRushData<'b>> {
        let monthlyRushId = self.monthlyRushId.as_ref().map(|x| _fbb.create_string(x));
        let startTime = self.startTime;
        let endTime = self.endTime;
        let isLast = self.isLast;
        let sortId = self.sortId;
        let rushGroupKey = self.rushGroupKey.as_ref().map(|x| _fbb.create_string(x));
        let monthlyRushName = self.monthlyRushName.as_ref().map(|x| _fbb.create_string(x));
        let monthlyRushDes = self.monthlyRushDes.as_ref().map(|x| _fbb.create_string(x));
        let weatherId = self.weatherId.as_ref().map(|x| _fbb.create_string(x));
        let nodeId = self.nodeId.as_ref().map(|x| _fbb.create_string(x));
        let conditionGroup = self.conditionGroup.as_ref().map(|x| _fbb.create_string(x));
        let conditionDesc = self.conditionDesc.as_ref().map(|x| _fbb.create_string(x));
        let rewardItemList = self.rewardItemList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SandboxV2MonthRushData::create(
            _fbb,
            &clz_Torappu_SandboxV2MonthRushDataArgs {
                monthlyRushId,
                startTime,
                endTime,
                isLast,
                sortId,
                rushGroupKey,
                monthlyRushName,
                monthlyRushDes,
                weatherId,
                nodeId,
                conditionGroup,
                conditionDesc,
                rewardItemList,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2RiftParamDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RiftParamData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RiftParamData<'a> {
    type Inner = clz_Torappu_SandboxV2RiftParamData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RiftParamData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DESC: flatbuffers::VOffsetT = 6;
    pub const VT_ICONID: flatbuffers::VOffsetT = 8;
    pub const VT_BKCOLOR: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RiftParamData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RiftParamDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftParamData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RiftParamDataBuilder::new(_fbb);
        if let Some(x) = args.bkColor {
            builder.add_bkColor(x);
        }
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2RiftParamDataT {
        let id = self.id().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let iconId = self.iconId().map(|x| x.to_string());
        let bkColor = self.bkColor().map(|x| x.to_string());
        clz_Torappu_SandboxV2RiftParamDataT {
            id,
            desc,
            iconId,
            bkColor,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftParamData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftParamData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftParamData::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn bkColor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftParamData::VT_BKCOLOR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RiftParamData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bkColor", Self::VT_BKCOLOR, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RiftParamDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bkColor: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2RiftParamDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RiftParamDataArgs {
            id: None,
            desc: None,
            iconId: None,
            bkColor: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2RiftParamData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2RiftParamData", 4)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.iconId() {
            s.serialize_field("iconId", &f)?;
        } else {
            s.skip_field("iconId")?;
        }
        if let Some(f) = self.bkColor() {
            s.serialize_field("bkColor", &f)?;
        } else {
            s.skip_field("bkColor")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2RiftParamDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RiftParamDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftParamData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftParamData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftParamData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_bkColor(&mut self, bkColor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftParamData::VT_BKCOLOR,
            bkColor,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RiftParamDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RiftParamDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftParamData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RiftParamData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RiftParamData");
        ds.field("id", &self.id());
        ds.field("desc", &self.desc());
        ds.field("iconId", &self.iconId());
        ds.field("bkColor", &self.bkColor());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2RiftParamDataT {
    pub id: Option<String>,
    pub desc: Option<String>,
    pub iconId: Option<String>,
    pub bkColor: Option<String>,
}
impl Default for clz_Torappu_SandboxV2RiftParamDataT {
    fn default() -> Self {
        Self {
            id: None,
            desc: None,
            iconId: None,
            bkColor: None,
        }
    }
}
impl clz_Torappu_SandboxV2RiftParamDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftParamData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let iconId = self.iconId.as_ref().map(|x| _fbb.create_string(x));
        let bkColor = self.bkColor.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2RiftParamData::create(
            _fbb,
            &clz_Torappu_SandboxV2RiftParamDataArgs {
                id,
                desc,
                iconId,
                bkColor,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RiftParamDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RiftParamData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RiftParamData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RiftParamData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RiftParamData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RiftParamData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RiftParamDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2RiftParamDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2RiftParamDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2RiftParamDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RiftParamData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2RiftParamData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RiftParamData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftParamData>>(
                    dict__string__clz_Torappu_SandboxV2RiftParamData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RiftParamData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftParamData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RiftParamDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftParamData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RiftParamDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RiftParamDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2RiftParamData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2RiftParamData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RiftParamDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RiftParamDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RiftParamData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftParamData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftParamData>>(
                dict__string__clz_Torappu_SandboxV2RiftParamData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RiftParamDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RiftParamDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RiftParamData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RiftParamData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RiftParamData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2RiftParamDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2RiftParamDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2RiftParamDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2RiftParamDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2RiftParamData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2RiftParamDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2RiftSubTargetDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RiftSubTargetData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RiftSubTargetData<'a> {
    type Inner = clz_Torappu_SandboxV2RiftSubTargetData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RiftSubTargetData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_DESC: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RiftSubTargetData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RiftSubTargetDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftSubTargetData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RiftSubTargetDataBuilder::new(_fbb);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2RiftSubTargetDataT {
        let id = self.id().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        clz_Torappu_SandboxV2RiftSubTargetDataT { id, name, desc }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftSubTargetData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftSubTargetData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftSubTargetData::VT_DESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RiftSubTargetData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RiftSubTargetDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2RiftSubTargetDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RiftSubTargetDataArgs {
            id: None,
            name: None,
            desc: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2RiftSubTargetData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2RiftSubTargetData", 3)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2RiftSubTargetDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RiftSubTargetDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftSubTargetData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftSubTargetData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftSubTargetData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RiftSubTargetDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RiftSubTargetDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftSubTargetData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RiftSubTargetData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RiftSubTargetData");
        ds.field("id", &self.id());
        ds.field("name", &self.name());
        ds.field("desc", &self.desc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2RiftSubTargetDataT {
    pub id: Option<String>,
    pub name: Option<String>,
    pub desc: Option<String>,
}
impl Default for clz_Torappu_SandboxV2RiftSubTargetDataT {
    fn default() -> Self {
        Self {
            id: None,
            name: None,
            desc: None,
        }
    }
}
impl clz_Torappu_SandboxV2RiftSubTargetDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftSubTargetData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2RiftSubTargetData::create(
            _fbb,
            &clz_Torappu_SandboxV2RiftSubTargetDataArgs { id, name, desc },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RiftSubTargetDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RiftSubTargetData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RiftSubTargetDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2RiftSubTargetDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2RiftSubTargetDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2RiftSubTargetDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RiftSubTargetData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2RiftSubTargetData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RiftSubTargetData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftSubTargetData>>(
                    dict__string__clz_Torappu_SandboxV2RiftSubTargetData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftSubTargetData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RiftSubTargetDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftSubTargetData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RiftSubTargetDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RiftSubTargetDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_SandboxV2RiftSubTargetData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RiftSubTargetDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RiftSubTargetDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RiftSubTargetData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftSubTargetData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftSubTargetData>>(
                dict__string__clz_Torappu_SandboxV2RiftSubTargetData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RiftSubTargetDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RiftSubTargetDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RiftSubTargetData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RiftSubTargetData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2RiftSubTargetDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2RiftSubTargetDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2RiftSubTargetDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2RiftSubTargetDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2RiftSubTargetData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2RiftSubTargetDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2RiftMainTargetDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RiftMainTargetData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RiftMainTargetData<'a> {
    type Inner = clz_Torappu_SandboxV2RiftMainTargetData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RiftMainTargetData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TITLE: flatbuffers::VOffsetT = 6;
    pub const VT_DESC: flatbuffers::VOffsetT = 8;
    pub const VT_STORYDESC: flatbuffers::VOffsetT = 10;
    pub const VT_TARGETDAYCOUNT: flatbuffers::VOffsetT = 12;
    pub const VT_TARGETTYPE: flatbuffers::VOffsetT = 14;
    pub const VT_QUESTICONID: flatbuffers::VOffsetT = 16;
    pub const VT_QUESTICONNAME: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RiftMainTargetData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RiftMainTargetDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftMainTargetData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RiftMainTargetDataBuilder::new(_fbb);
        if let Some(x) = args.questIconName {
            builder.add_questIconName(x);
        }
        if let Some(x) = args.questIconId {
            builder.add_questIconId(x);
        }
        builder.add_targetType(args.targetType);
        builder.add_targetDayCount(args.targetDayCount);
        if let Some(x) = args.storyDesc {
            builder.add_storyDesc(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.title {
            builder.add_title(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2RiftMainTargetDataT {
        let id = self.id().map(|x| x.to_string());
        let title = self.title().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let storyDesc = self.storyDesc().map(|x| x.to_string());
        let targetDayCount = self.targetDayCount();
        let targetType = self.targetType();
        let questIconId = self.questIconId().map(|x| x.to_string());
        let questIconName = self.questIconName().map(|x| x.to_string());
        clz_Torappu_SandboxV2RiftMainTargetDataT {
            id,
            title,
            desc,
            storyDesc,
            targetDayCount,
            targetType,
            questIconId,
            questIconName,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftMainTargetData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn title(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftMainTargetData::VT_TITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftMainTargetData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn storyDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftMainTargetData::VT_STORYDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn targetDayCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2RiftMainTargetData::VT_TARGETDAYCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn targetType(&self) -> enum__Torappu_SandboxV2RiftMainTargetType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2RiftMainTargetType>(
                    clz_Torappu_SandboxV2RiftMainTargetData::VT_TARGETTYPE,
                    Some(enum__Torappu_SandboxV2RiftMainTargetType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn questIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftMainTargetData::VT_QUESTICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn questIconName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftMainTargetData::VT_QUESTICONNAME,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RiftMainTargetData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "storyDesc",
                Self::VT_STORYDESC,
                false,
            )?
            .visit_field::<i32>("targetDayCount", Self::VT_TARGETDAYCOUNT, false)?
            .visit_field::<enum__Torappu_SandboxV2RiftMainTargetType>(
                "targetType",
                Self::VT_TARGETTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "questIconId",
                Self::VT_QUESTICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "questIconName",
                Self::VT_QUESTICONNAME,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RiftMainTargetDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub storyDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub targetDayCount: i32,
    pub targetType: enum__Torappu_SandboxV2RiftMainTargetType,
    pub questIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub questIconName: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2RiftMainTargetDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RiftMainTargetDataArgs {
            id: None,
            title: None,
            desc: None,
            storyDesc: None,
            targetDayCount: 0,
            targetType: enum__Torappu_SandboxV2RiftMainTargetType::NONE,
            questIconId: None,
            questIconName: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2RiftMainTargetData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2RiftMainTargetData", 8)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.title() {
            s.serialize_field("title", &f)?;
        } else {
            s.skip_field("title")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.storyDesc() {
            s.serialize_field("storyDesc", &f)?;
        } else {
            s.skip_field("storyDesc")?;
        }
        s.serialize_field("targetDayCount", &self.targetDayCount())?;
        s.serialize_field("targetType", &self.targetType())?;
        if let Some(f) = self.questIconId() {
            s.serialize_field("questIconId", &f)?;
        } else {
            s.skip_field("questIconId")?;
        }
        if let Some(f) = self.questIconName() {
            s.serialize_field("questIconName", &f)?;
        } else {
            s.skip_field("questIconName")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2RiftMainTargetDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RiftMainTargetDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftMainTargetData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftMainTargetData::VT_TITLE,
            title,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftMainTargetData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_storyDesc(&mut self, storyDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftMainTargetData::VT_STORYDESC,
            storyDesc,
        );
    }
    #[inline]
    pub fn add_targetDayCount(&mut self, targetDayCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2RiftMainTargetData::VT_TARGETDAYCOUNT,
            targetDayCount,
            0,
        );
    }
    #[inline]
    pub fn add_targetType(&mut self, targetType: enum__Torappu_SandboxV2RiftMainTargetType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2RiftMainTargetType>(
                clz_Torappu_SandboxV2RiftMainTargetData::VT_TARGETTYPE,
                targetType,
                enum__Torappu_SandboxV2RiftMainTargetType::NONE,
            );
    }
    #[inline]
    pub fn add_questIconId(&mut self, questIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftMainTargetData::VT_QUESTICONID,
            questIconId,
        );
    }
    #[inline]
    pub fn add_questIconName(&mut self, questIconName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftMainTargetData::VT_QUESTICONNAME,
            questIconName,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RiftMainTargetDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RiftMainTargetDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftMainTargetData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RiftMainTargetData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RiftMainTargetData");
        ds.field("id", &self.id());
        ds.field("title", &self.title());
        ds.field("desc", &self.desc());
        ds.field("storyDesc", &self.storyDesc());
        ds.field("targetDayCount", &self.targetDayCount());
        ds.field("targetType", &self.targetType());
        ds.field("questIconId", &self.questIconId());
        ds.field("questIconName", &self.questIconName());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2RiftMainTargetDataT {
    pub id: Option<String>,
    pub title: Option<String>,
    pub desc: Option<String>,
    pub storyDesc: Option<String>,
    pub targetDayCount: i32,
    pub targetType: enum__Torappu_SandboxV2RiftMainTargetType,
    pub questIconId: Option<String>,
    pub questIconName: Option<String>,
}
impl Default for clz_Torappu_SandboxV2RiftMainTargetDataT {
    fn default() -> Self {
        Self {
            id: None,
            title: None,
            desc: None,
            storyDesc: None,
            targetDayCount: 0,
            targetType: enum__Torappu_SandboxV2RiftMainTargetType::NONE,
            questIconId: None,
            questIconName: None,
        }
    }
}
impl clz_Torappu_SandboxV2RiftMainTargetDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftMainTargetData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let title = self.title.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let storyDesc = self.storyDesc.as_ref().map(|x| _fbb.create_string(x));
        let targetDayCount = self.targetDayCount;
        let targetType = self.targetType;
        let questIconId = self.questIconId.as_ref().map(|x| _fbb.create_string(x));
        let questIconName = self.questIconName.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2RiftMainTargetData::create(
            _fbb,
            &clz_Torappu_SandboxV2RiftMainTargetDataArgs {
                id,
                title,
                desc,
                storyDesc,
                targetDayCount,
                targetType,
                questIconId,
                questIconName,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RiftMainTargetDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RiftMainTargetData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RiftMainTargetDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2RiftMainTargetDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2RiftMainTargetDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2RiftMainTargetDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RiftMainTargetData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2RiftMainTargetData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RiftMainTargetData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftMainTargetData>>(
                    dict__string__clz_Torappu_SandboxV2RiftMainTargetData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftMainTargetData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RiftMainTargetDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftMainTargetData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RiftMainTargetDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RiftMainTargetDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_SandboxV2RiftMainTargetData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RiftMainTargetDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RiftMainTargetDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RiftMainTargetData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftMainTargetData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftMainTargetData>>(
                dict__string__clz_Torappu_SandboxV2RiftMainTargetData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RiftMainTargetDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RiftMainTargetDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RiftMainTargetData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RiftMainTargetData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2RiftMainTargetDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2RiftMainTargetDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2RiftMainTargetDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2RiftMainTargetDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2RiftMainTargetData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2RiftMainTargetDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2RiftGlobalEffectDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RiftGlobalEffectData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RiftGlobalEffectData<'a> {
    type Inner = clz_Torappu_SandboxV2RiftGlobalEffectData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RiftGlobalEffectData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DESC: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RiftGlobalEffectData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RiftGlobalEffectDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftGlobalEffectData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RiftGlobalEffectDataBuilder::new(_fbb);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2RiftGlobalEffectDataT {
        let id = self.id().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        clz_Torappu_SandboxV2RiftGlobalEffectDataT { id, desc }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftGlobalEffectData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftGlobalEffectData::VT_DESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RiftGlobalEffectData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RiftGlobalEffectDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2RiftGlobalEffectDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RiftGlobalEffectDataArgs {
            id: None,
            desc: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2RiftGlobalEffectData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2RiftGlobalEffectData", 2)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2RiftGlobalEffectDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RiftGlobalEffectDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftGlobalEffectData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftGlobalEffectData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RiftGlobalEffectDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RiftGlobalEffectDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftGlobalEffectData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RiftGlobalEffectData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RiftGlobalEffectData");
        ds.field("id", &self.id());
        ds.field("desc", &self.desc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2RiftGlobalEffectDataT {
    pub id: Option<String>,
    pub desc: Option<String>,
}
impl Default for clz_Torappu_SandboxV2RiftGlobalEffectDataT {
    fn default() -> Self {
        Self {
            id: None,
            desc: None,
        }
    }
}
impl clz_Torappu_SandboxV2RiftGlobalEffectDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftGlobalEffectData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2RiftGlobalEffectData::create(
            _fbb,
            &clz_Torappu_SandboxV2RiftGlobalEffectDataArgs { id, desc },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'bldr>>
    {
        let mut builder = dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RiftGlobalEffectData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftGlobalEffectData>>(
                    dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftGlobalEffectData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftGlobalEffectData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftGlobalEffectData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftGlobalEffectData>>(
                dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2RiftGlobalEffectDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2FixedRiftDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2FixedRiftData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2FixedRiftData<'a> {
    type Inner = clz_Torappu_SandboxV2FixedRiftData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2FixedRiftData<'a> {
    pub const VT_RIFTID: flatbuffers::VOffsetT = 4;
    pub const VT_RIFTNAME: flatbuffers::VOffsetT = 6;
    pub const VT_REWARDGROUPID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2FixedRiftData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2FixedRiftDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FixedRiftData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2FixedRiftDataBuilder::new(_fbb);
        if let Some(x) = args.rewardGroupId {
            builder.add_rewardGroupId(x);
        }
        if let Some(x) = args.riftName {
            builder.add_riftName(x);
        }
        if let Some(x) = args.riftId {
            builder.add_riftId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2FixedRiftDataT {
        let riftId = self.riftId().map(|x| x.to_string());
        let riftName = self.riftName().map(|x| x.to_string());
        let rewardGroupId = self.rewardGroupId().map(|x| x.to_string());
        clz_Torappu_SandboxV2FixedRiftDataT {
            riftId,
            riftName,
            rewardGroupId,
        }
    }

    #[inline]
    pub fn riftId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2FixedRiftData::VT_RIFTID,
                None,
            )
        }
    }
    #[inline]
    pub fn riftName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2FixedRiftData::VT_RIFTNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn rewardGroupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2FixedRiftData::VT_REWARDGROUPID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2FixedRiftData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("riftId", Self::VT_RIFTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "riftName",
                Self::VT_RIFTNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rewardGroupId",
                Self::VT_REWARDGROUPID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2FixedRiftDataArgs<'a> {
    pub riftId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub riftName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewardGroupId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2FixedRiftDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2FixedRiftDataArgs {
            riftId: None,
            riftName: None,
            rewardGroupId: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2FixedRiftData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2FixedRiftData", 3)?;
        if let Some(f) = self.riftId() {
            s.serialize_field("riftId", &f)?;
        } else {
            s.skip_field("riftId")?;
        }
        if let Some(f) = self.riftName() {
            s.serialize_field("riftName", &f)?;
        } else {
            s.skip_field("riftName")?;
        }
        if let Some(f) = self.rewardGroupId() {
            s.serialize_field("rewardGroupId", &f)?;
        } else {
            s.skip_field("rewardGroupId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2FixedRiftDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2FixedRiftDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_riftId(&mut self, riftId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FixedRiftData::VT_RIFTID,
            riftId,
        );
    }
    #[inline]
    pub fn add_riftName(&mut self, riftName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FixedRiftData::VT_RIFTNAME,
            riftName,
        );
    }
    #[inline]
    pub fn add_rewardGroupId(&mut self, rewardGroupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2FixedRiftData::VT_REWARDGROUPID,
            rewardGroupId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2FixedRiftDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2FixedRiftDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FixedRiftData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2FixedRiftData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2FixedRiftData");
        ds.field("riftId", &self.riftId());
        ds.field("riftName", &self.riftName());
        ds.field("rewardGroupId", &self.rewardGroupId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2FixedRiftDataT {
    pub riftId: Option<String>,
    pub riftName: Option<String>,
    pub rewardGroupId: Option<String>,
}
impl Default for clz_Torappu_SandboxV2FixedRiftDataT {
    fn default() -> Self {
        Self {
            riftId: None,
            riftName: None,
            rewardGroupId: None,
        }
    }
}
impl clz_Torappu_SandboxV2FixedRiftDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2FixedRiftData<'b>> {
        let riftId = self.riftId.as_ref().map(|x| _fbb.create_string(x));
        let riftName = self.riftName.as_ref().map(|x| _fbb.create_string(x));
        let rewardGroupId = self.rewardGroupId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2FixedRiftData::create(
            _fbb,
            &clz_Torappu_SandboxV2FixedRiftDataArgs {
                riftId,
                riftName,
                rewardGroupId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2FixedRiftDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2FixedRiftData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2FixedRiftData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2FixedRiftData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2FixedRiftData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2FixedRiftData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2FixedRiftDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2FixedRiftData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2FixedRiftDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2FixedRiftDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2FixedRiftDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2FixedRiftData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2FixedRiftData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2FixedRiftData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FixedRiftData>>(
                    dict__string__clz_Torappu_SandboxV2FixedRiftData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2FixedRiftData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2FixedRiftData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2FixedRiftDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2FixedRiftData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2FixedRiftDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2FixedRiftDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2FixedRiftData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2FixedRiftData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2FixedRiftDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2FixedRiftDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2FixedRiftData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2FixedRiftData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2FixedRiftData>>(
                dict__string__clz_Torappu_SandboxV2FixedRiftData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2FixedRiftDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2FixedRiftDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2FixedRiftData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2FixedRiftData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2FixedRiftData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2FixedRiftData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2FixedRiftDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2FixedRiftDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2FixedRiftDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2FixedRiftDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2FixedRiftData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2FixedRiftData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2FixedRiftDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2RiftTeamBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RiftTeamBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RiftTeamBuffData<'a> {
    type Inner = clz_Torappu_SandboxV2RiftTeamBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RiftTeamBuffData<'a> {
    pub const VT_TEAMID: flatbuffers::VOffsetT = 4;
    pub const VT_TEAMNAME: flatbuffers::VOffsetT = 6;
    pub const VT_BUFFLEVEL: flatbuffers::VOffsetT = 8;
    pub const VT_BUFFDESC: flatbuffers::VOffsetT = 10;
    pub const VT_TEAMSMALLICONID: flatbuffers::VOffsetT = 12;
    pub const VT_TEAMBIGICONID: flatbuffers::VOffsetT = 14;
    pub const VT_TEAMDESC: flatbuffers::VOffsetT = 16;
    pub const VT_TEAMBGID: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RiftTeamBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RiftTeamBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftTeamBuffData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RiftTeamBuffDataBuilder::new(_fbb);
        if let Some(x) = args.teamBgId {
            builder.add_teamBgId(x);
        }
        if let Some(x) = args.teamDesc {
            builder.add_teamDesc(x);
        }
        if let Some(x) = args.teamBigIconId {
            builder.add_teamBigIconId(x);
        }
        if let Some(x) = args.teamSmallIconId {
            builder.add_teamSmallIconId(x);
        }
        if let Some(x) = args.buffDesc {
            builder.add_buffDesc(x);
        }
        builder.add_buffLevel(args.buffLevel);
        if let Some(x) = args.teamName {
            builder.add_teamName(x);
        }
        if let Some(x) = args.teamId {
            builder.add_teamId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2RiftTeamBuffDataT {
        let teamId = self.teamId().map(|x| x.to_string());
        let teamName = self.teamName().map(|x| x.to_string());
        let buffLevel = self.buffLevel();
        let buffDesc = self.buffDesc().map(|x| x.to_string());
        let teamSmallIconId = self.teamSmallIconId().map(|x| x.to_string());
        let teamBigIconId = self.teamBigIconId().map(|x| x.to_string());
        let teamDesc = self.teamDesc().map(|x| x.to_string());
        let teamBgId = self.teamBgId().map(|x| x.to_string());
        clz_Torappu_SandboxV2RiftTeamBuffDataT {
            teamId,
            teamName,
            buffLevel,
            buffDesc,
            teamSmallIconId,
            teamBigIconId,
            teamDesc,
            teamBgId,
        }
    }

    #[inline]
    pub fn teamId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMID,
                None,
            )
        }
    }
    #[inline]
    pub fn teamName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn buffLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2RiftTeamBuffData::VT_BUFFLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn buffDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftTeamBuffData::VT_BUFFDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn teamSmallIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMSMALLICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn teamBigIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMBIGICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn teamDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn teamBgId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMBGID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RiftTeamBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("teamId", Self::VT_TEAMID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "teamName",
                Self::VT_TEAMNAME,
                false,
            )?
            .visit_field::<i32>("buffLevel", Self::VT_BUFFLEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffDesc",
                Self::VT_BUFFDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "teamSmallIconId",
                Self::VT_TEAMSMALLICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "teamBigIconId",
                Self::VT_TEAMBIGICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "teamDesc",
                Self::VT_TEAMDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "teamBgId",
                Self::VT_TEAMBGID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RiftTeamBuffDataArgs<'a> {
    pub teamId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teamName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffLevel: i32,
    pub buffDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teamSmallIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teamBigIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teamDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teamBgId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2RiftTeamBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RiftTeamBuffDataArgs {
            teamId: None,
            teamName: None,
            buffLevel: 0,
            buffDesc: None,
            teamSmallIconId: None,
            teamBigIconId: None,
            teamDesc: None,
            teamBgId: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2RiftTeamBuffData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2RiftTeamBuffData", 8)?;
        if let Some(f) = self.teamId() {
            s.serialize_field("teamId", &f)?;
        } else {
            s.skip_field("teamId")?;
        }
        if let Some(f) = self.teamName() {
            s.serialize_field("teamName", &f)?;
        } else {
            s.skip_field("teamName")?;
        }
        s.serialize_field("buffLevel", &self.buffLevel())?;
        if let Some(f) = self.buffDesc() {
            s.serialize_field("buffDesc", &f)?;
        } else {
            s.skip_field("buffDesc")?;
        }
        if let Some(f) = self.teamSmallIconId() {
            s.serialize_field("teamSmallIconId", &f)?;
        } else {
            s.skip_field("teamSmallIconId")?;
        }
        if let Some(f) = self.teamBigIconId() {
            s.serialize_field("teamBigIconId", &f)?;
        } else {
            s.skip_field("teamBigIconId")?;
        }
        if let Some(f) = self.teamDesc() {
            s.serialize_field("teamDesc", &f)?;
        } else {
            s.skip_field("teamDesc")?;
        }
        if let Some(f) = self.teamBgId() {
            s.serialize_field("teamBgId", &f)?;
        } else {
            s.skip_field("teamBgId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2RiftTeamBuffDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RiftTeamBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_teamId(&mut self, teamId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMID,
            teamId,
        );
    }
    #[inline]
    pub fn add_teamName(&mut self, teamName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMNAME,
            teamName,
        );
    }
    #[inline]
    pub fn add_buffLevel(&mut self, buffLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2RiftTeamBuffData::VT_BUFFLEVEL,
            buffLevel,
            0,
        );
    }
    #[inline]
    pub fn add_buffDesc(&mut self, buffDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftTeamBuffData::VT_BUFFDESC,
            buffDesc,
        );
    }
    #[inline]
    pub fn add_teamSmallIconId(&mut self, teamSmallIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMSMALLICONID,
            teamSmallIconId,
        );
    }
    #[inline]
    pub fn add_teamBigIconId(&mut self, teamBigIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMBIGICONID,
            teamBigIconId,
        );
    }
    #[inline]
    pub fn add_teamDesc(&mut self, teamDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMDESC,
            teamDesc,
        );
    }
    #[inline]
    pub fn add_teamBgId(&mut self, teamBgId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftTeamBuffData::VT_TEAMBGID,
            teamBgId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RiftTeamBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RiftTeamBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftTeamBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RiftTeamBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RiftTeamBuffData");
        ds.field("teamId", &self.teamId());
        ds.field("teamName", &self.teamName());
        ds.field("buffLevel", &self.buffLevel());
        ds.field("buffDesc", &self.buffDesc());
        ds.field("teamSmallIconId", &self.teamSmallIconId());
        ds.field("teamBigIconId", &self.teamBigIconId());
        ds.field("teamDesc", &self.teamDesc());
        ds.field("teamBgId", &self.teamBgId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2RiftTeamBuffDataT {
    pub teamId: Option<String>,
    pub teamName: Option<String>,
    pub buffLevel: i32,
    pub buffDesc: Option<String>,
    pub teamSmallIconId: Option<String>,
    pub teamBigIconId: Option<String>,
    pub teamDesc: Option<String>,
    pub teamBgId: Option<String>,
}
impl Default for clz_Torappu_SandboxV2RiftTeamBuffDataT {
    fn default() -> Self {
        Self {
            teamId: None,
            teamName: None,
            buffLevel: 0,
            buffDesc: None,
            teamSmallIconId: None,
            teamBigIconId: None,
            teamDesc: None,
            teamBgId: None,
        }
    }
}
impl clz_Torappu_SandboxV2RiftTeamBuffDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftTeamBuffData<'b>> {
        let teamId = self.teamId.as_ref().map(|x| _fbb.create_string(x));
        let teamName = self.teamName.as_ref().map(|x| _fbb.create_string(x));
        let buffLevel = self.buffLevel;
        let buffDesc = self.buffDesc.as_ref().map(|x| _fbb.create_string(x));
        let teamSmallIconId = self.teamSmallIconId.as_ref().map(|x| _fbb.create_string(x));
        let teamBigIconId = self.teamBigIconId.as_ref().map(|x| _fbb.create_string(x));
        let teamDesc = self.teamDesc.as_ref().map(|x| _fbb.create_string(x));
        let teamBgId = self.teamBgId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2RiftTeamBuffData::create(
            _fbb,
            &clz_Torappu_SandboxV2RiftTeamBuffDataArgs {
                teamId,
                teamName,
                buffLevel,
                buffDesc,
                teamSmallIconId,
                teamBigIconId,
                teamDesc,
                teamBgId,
            },
        )
    }
}
pub enum dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'a> {
    type Inner = dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'bldr>>
    {
        let mut builder =
            dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| x.iter().map(|t| t.unpack()).collect());
        dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftTeamBuffData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftTeamBuffData>,
                >,
            >>(
                dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftTeamBuffData>,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftTeamBuffData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftTeamBuffData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataT {
    pub key: String,
    pub value: Option<Vec<clz_Torappu_SandboxV2RiftTeamBuffDataT>>,
}
impl Default for dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData::create(
            _fbb,
            &dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2RiftDifficultyDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RiftDifficultyData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RiftDifficultyData<'a> {
    type Inner = clz_Torappu_SandboxV2RiftDifficultyData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RiftDifficultyData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_RIFTID: flatbuffers::VOffsetT = 6;
    pub const VT_DESC: flatbuffers::VOffsetT = 8;
    pub const VT_DIFFICULTYLEVEL: flatbuffers::VOffsetT = 10;
    pub const VT_REWARDGROUPID: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RiftDifficultyData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RiftDifficultyDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftDifficultyData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RiftDifficultyDataBuilder::new(_fbb);
        if let Some(x) = args.rewardGroupId {
            builder.add_rewardGroupId(x);
        }
        builder.add_difficultyLevel(args.difficultyLevel);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.riftId {
            builder.add_riftId(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2RiftDifficultyDataT {
        let id = self.id().map(|x| x.to_string());
        let riftId = self.riftId().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let difficultyLevel = self.difficultyLevel();
        let rewardGroupId = self.rewardGroupId().map(|x| x.to_string());
        clz_Torappu_SandboxV2RiftDifficultyDataT {
            id,
            riftId,
            desc,
            difficultyLevel,
            rewardGroupId,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftDifficultyData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn riftId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftDifficultyData::VT_RIFTID,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftDifficultyData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn difficultyLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2RiftDifficultyData::VT_DIFFICULTYLEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rewardGroupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RiftDifficultyData::VT_REWARDGROUPID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RiftDifficultyData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("riftId", Self::VT_RIFTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<i32>("difficultyLevel", Self::VT_DIFFICULTYLEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rewardGroupId",
                Self::VT_REWARDGROUPID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RiftDifficultyDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub riftId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub difficultyLevel: i32,
    pub rewardGroupId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2RiftDifficultyDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RiftDifficultyDataArgs {
            id: None,
            riftId: None,
            desc: None,
            difficultyLevel: 0,
            rewardGroupId: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2RiftDifficultyData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2RiftDifficultyData", 5)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.riftId() {
            s.serialize_field("riftId", &f)?;
        } else {
            s.skip_field("riftId")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        s.serialize_field("difficultyLevel", &self.difficultyLevel())?;
        if let Some(f) = self.rewardGroupId() {
            s.serialize_field("rewardGroupId", &f)?;
        } else {
            s.skip_field("rewardGroupId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2RiftDifficultyDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RiftDifficultyDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftDifficultyData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_riftId(&mut self, riftId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftDifficultyData::VT_RIFTID,
            riftId,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftDifficultyData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_difficultyLevel(&mut self, difficultyLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2RiftDifficultyData::VT_DIFFICULTYLEVEL,
            difficultyLevel,
            0,
        );
    }
    #[inline]
    pub fn add_rewardGroupId(&mut self, rewardGroupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RiftDifficultyData::VT_REWARDGROUPID,
            rewardGroupId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RiftDifficultyDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RiftDifficultyDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftDifficultyData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RiftDifficultyData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RiftDifficultyData");
        ds.field("id", &self.id());
        ds.field("riftId", &self.riftId());
        ds.field("desc", &self.desc());
        ds.field("difficultyLevel", &self.difficultyLevel());
        ds.field("rewardGroupId", &self.rewardGroupId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2RiftDifficultyDataT {
    pub id: Option<String>,
    pub riftId: Option<String>,
    pub desc: Option<String>,
    pub difficultyLevel: i32,
    pub rewardGroupId: Option<String>,
}
impl Default for clz_Torappu_SandboxV2RiftDifficultyDataT {
    fn default() -> Self {
        Self {
            id: None,
            riftId: None,
            desc: None,
            difficultyLevel: 0,
            rewardGroupId: None,
        }
    }
}
impl clz_Torappu_SandboxV2RiftDifficultyDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftDifficultyData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let riftId = self.riftId.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let difficultyLevel = self.difficultyLevel;
        let rewardGroupId = self.rewardGroupId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2RiftDifficultyData::create(
            _fbb,
            &clz_Torappu_SandboxV2RiftDifficultyDataArgs {
                id,
                riftId,
                desc,
                difficultyLevel,
                rewardGroupId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RiftDifficultyDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RiftDifficultyData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RiftDifficultyDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2RiftDifficultyDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2RiftDifficultyDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2RiftDifficultyDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RiftDifficultyData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2RiftDifficultyData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RiftDifficultyData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftDifficultyData>>(
                    dict__string__clz_Torappu_SandboxV2RiftDifficultyData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftDifficultyData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RiftDifficultyDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftDifficultyData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RiftDifficultyDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RiftDifficultyDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_SandboxV2RiftDifficultyData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RiftDifficultyDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RiftDifficultyDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RiftDifficultyData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftDifficultyData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftDifficultyData>>(
                dict__string__clz_Torappu_SandboxV2RiftDifficultyData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RiftDifficultyDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RiftDifficultyDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RiftDifficultyData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RiftDifficultyData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2RiftDifficultyDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2RiftDifficultyDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2RiftDifficultyDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2RiftDifficultyDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2RiftDifficultyData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2RiftDifficultyDataArgs { key, value },
        )
    }
}
pub enum dict__string__list_dict__string__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_dict__string__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__list_dict__string__string<'a> {
    type Inner = dict__string__list_dict__string__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__list_dict__string__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_dict__string__string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_dict__string__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__list_dict__string__string<'bldr>> {
        let mut builder = dict__string__list_dict__string__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__list_dict__string__stringT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| x.iter().map(|t| t.unpack()).collect());
        dict__string__list_dict__string__stringT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__list_dict__string__string::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__list_dict__string__string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(dict__string__list_dict__string__string::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__list_dict__string__string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_dict__string__stringArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>,
        >,
    >,
}
impl<'a> Default for dict__string__list_dict__string__stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__list_dict__string__stringArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__list_dict__string__string<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__list_dict__string__string", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__list_dict__string__stringBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__list_dict__string__stringBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_dict__string__string::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_dict__string__string::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__list_dict__string__stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__list_dict__string__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__list_dict__string__string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__list_dict__string__string::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__list_dict__string__string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__list_dict__string__string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__list_dict__string__stringT {
    pub key: String,
    pub value: Option<Vec<dict__string__stringT>>,
}
impl Default for dict__string__list_dict__string__stringT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__list_dict__string__stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__list_dict__string__string<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        dict__string__list_dict__string__string::create(
            _fbb,
            &dict__string__list_dict__string__stringArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2ArchiveQuestAvgDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ArchiveQuestAvgData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ArchiveQuestAvgData<'a> {
    type Inner = clz_Torappu_SandboxV2ArchiveQuestAvgData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ArchiveQuestAvgData<'a> {
    pub const VT_AVGID: flatbuffers::VOffsetT = 4;
    pub const VT_AVGNAME: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ArchiveQuestAvgData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ArchiveQuestAvgDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestAvgData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ArchiveQuestAvgDataBuilder::new(_fbb);
        if let Some(x) = args.avgName {
            builder.add_avgName(x);
        }
        if let Some(x) = args.avgId {
            builder.add_avgId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2ArchiveQuestAvgDataT {
        let avgId = self.avgId().map(|x| x.to_string());
        let avgName = self.avgName().map(|x| x.to_string());
        clz_Torappu_SandboxV2ArchiveQuestAvgDataT { avgId, avgName }
    }

    #[inline]
    pub fn avgId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestAvgData::VT_AVGID,
                None,
            )
        }
    }
    #[inline]
    pub fn avgName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestAvgData::VT_AVGNAME,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ArchiveQuestAvgData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("avgId", Self::VT_AVGID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("avgName", Self::VT_AVGNAME, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ArchiveQuestAvgDataArgs<'a> {
    pub avgId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub avgName: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ArchiveQuestAvgDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ArchiveQuestAvgDataArgs {
            avgId: None,
            avgName: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2ArchiveQuestAvgData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2ArchiveQuestAvgData", 2)?;
        if let Some(f) = self.avgId() {
            s.serialize_field("avgId", &f)?;
        } else {
            s.skip_field("avgId")?;
        }
        if let Some(f) = self.avgName() {
            s.serialize_field("avgName", &f)?;
        } else {
            s.skip_field("avgName")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2ArchiveQuestAvgDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ArchiveQuestAvgDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_avgId(&mut self, avgId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestAvgData::VT_AVGID,
            avgId,
        );
    }
    #[inline]
    pub fn add_avgName(&mut self, avgName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestAvgData::VT_AVGNAME,
            avgName,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ArchiveQuestAvgDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ArchiveQuestAvgDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestAvgData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ArchiveQuestAvgData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ArchiveQuestAvgData");
        ds.field("avgId", &self.avgId());
        ds.field("avgName", &self.avgName());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2ArchiveQuestAvgDataT {
    pub avgId: Option<String>,
    pub avgName: Option<String>,
}
impl Default for clz_Torappu_SandboxV2ArchiveQuestAvgDataT {
    fn default() -> Self {
        Self {
            avgId: None,
            avgName: None,
        }
    }
}
impl clz_Torappu_SandboxV2ArchiveQuestAvgDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestAvgData<'b>> {
        let avgId = self.avgId.as_ref().map(|x| _fbb.create_string(x));
        let avgName = self.avgName.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2ArchiveQuestAvgData::create(
            _fbb,
            &clz_Torappu_SandboxV2ArchiveQuestAvgDataArgs { avgId, avgName },
        )
    }
}
pub enum clz_Torappu_SandboxV2ArchiveQuestCgDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ArchiveQuestCgData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ArchiveQuestCgData<'a> {
    type Inner = clz_Torappu_SandboxV2ArchiveQuestCgData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ArchiveQuestCgData<'a> {
    pub const VT_CGID: flatbuffers::VOffsetT = 4;
    pub const VT_CGTITLE: flatbuffers::VOffsetT = 6;
    pub const VT_CGDESC: flatbuffers::VOffsetT = 8;
    pub const VT_CGPATH: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ArchiveQuestCgData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ArchiveQuestCgDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestCgData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ArchiveQuestCgDataBuilder::new(_fbb);
        if let Some(x) = args.cgPath {
            builder.add_cgPath(x);
        }
        if let Some(x) = args.cgDesc {
            builder.add_cgDesc(x);
        }
        if let Some(x) = args.cgTitle {
            builder.add_cgTitle(x);
        }
        if let Some(x) = args.cgId {
            builder.add_cgId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2ArchiveQuestCgDataT {
        let cgId = self.cgId().map(|x| x.to_string());
        let cgTitle = self.cgTitle().map(|x| x.to_string());
        let cgDesc = self.cgDesc().map(|x| x.to_string());
        let cgPath = self.cgPath().map(|x| x.to_string());
        clz_Torappu_SandboxV2ArchiveQuestCgDataT {
            cgId,
            cgTitle,
            cgDesc,
            cgPath,
        }
    }

    #[inline]
    pub fn cgId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestCgData::VT_CGID,
                None,
            )
        }
    }
    #[inline]
    pub fn cgTitle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestCgData::VT_CGTITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn cgDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestCgData::VT_CGDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn cgPath(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestCgData::VT_CGPATH,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ArchiveQuestCgData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cgId", Self::VT_CGID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cgTitle", Self::VT_CGTITLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cgDesc", Self::VT_CGDESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cgPath", Self::VT_CGPATH, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ArchiveQuestCgDataArgs<'a> {
    pub cgId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cgTitle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cgDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cgPath: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ArchiveQuestCgDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ArchiveQuestCgDataArgs {
            cgId: None,
            cgTitle: None,
            cgDesc: None,
            cgPath: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2ArchiveQuestCgData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2ArchiveQuestCgData", 4)?;
        if let Some(f) = self.cgId() {
            s.serialize_field("cgId", &f)?;
        } else {
            s.skip_field("cgId")?;
        }
        if let Some(f) = self.cgTitle() {
            s.serialize_field("cgTitle", &f)?;
        } else {
            s.skip_field("cgTitle")?;
        }
        if let Some(f) = self.cgDesc() {
            s.serialize_field("cgDesc", &f)?;
        } else {
            s.skip_field("cgDesc")?;
        }
        if let Some(f) = self.cgPath() {
            s.serialize_field("cgPath", &f)?;
        } else {
            s.skip_field("cgPath")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2ArchiveQuestCgDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ArchiveQuestCgDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_cgId(&mut self, cgId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestCgData::VT_CGID,
            cgId,
        );
    }
    #[inline]
    pub fn add_cgTitle(&mut self, cgTitle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestCgData::VT_CGTITLE,
            cgTitle,
        );
    }
    #[inline]
    pub fn add_cgDesc(&mut self, cgDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestCgData::VT_CGDESC,
            cgDesc,
        );
    }
    #[inline]
    pub fn add_cgPath(&mut self, cgPath: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestCgData::VT_CGPATH,
            cgPath,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ArchiveQuestCgDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ArchiveQuestCgDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestCgData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ArchiveQuestCgData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ArchiveQuestCgData");
        ds.field("cgId", &self.cgId());
        ds.field("cgTitle", &self.cgTitle());
        ds.field("cgDesc", &self.cgDesc());
        ds.field("cgPath", &self.cgPath());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2ArchiveQuestCgDataT {
    pub cgId: Option<String>,
    pub cgTitle: Option<String>,
    pub cgDesc: Option<String>,
    pub cgPath: Option<String>,
}
impl Default for clz_Torappu_SandboxV2ArchiveQuestCgDataT {
    fn default() -> Self {
        Self {
            cgId: None,
            cgTitle: None,
            cgDesc: None,
            cgPath: None,
        }
    }
}
impl clz_Torappu_SandboxV2ArchiveQuestCgDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestCgData<'b>> {
        let cgId = self.cgId.as_ref().map(|x| _fbb.create_string(x));
        let cgTitle = self.cgTitle.as_ref().map(|x| _fbb.create_string(x));
        let cgDesc = self.cgDesc.as_ref().map(|x| _fbb.create_string(x));
        let cgPath = self.cgPath.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2ArchiveQuestCgData::create(
            _fbb,
            &clz_Torappu_SandboxV2ArchiveQuestCgDataArgs {
                cgId,
                cgTitle,
                cgDesc,
                cgPath,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2ArchiveQuestZoneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ArchiveQuestZoneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ArchiveQuestZoneData<'a> {
    type Inner = clz_Torappu_SandboxV2ArchiveQuestZoneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ArchiveQuestZoneData<'a> {
    pub const VT_ZONEID: flatbuffers::VOffsetT = 4;
    pub const VT_ZONENAME: flatbuffers::VOffsetT = 6;
    pub const VT_ZONEBGPICID: flatbuffers::VOffsetT = 8;
    pub const VT_ZONENAMEIDEN: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ArchiveQuestZoneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ArchiveQuestZoneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestZoneData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ArchiveQuestZoneDataBuilder::new(_fbb);
        if let Some(x) = args.zoneNameIdEn {
            builder.add_zoneNameIdEn(x);
        }
        if let Some(x) = args.zoneBgPicId {
            builder.add_zoneBgPicId(x);
        }
        if let Some(x) = args.zoneName {
            builder.add_zoneName(x);
        }
        if let Some(x) = args.zoneId {
            builder.add_zoneId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2ArchiveQuestZoneDataT {
        let zoneId = self.zoneId().map(|x| x.to_string());
        let zoneName = self.zoneName().map(|x| x.to_string());
        let zoneBgPicId = self.zoneBgPicId().map(|x| x.to_string());
        let zoneNameIdEn = self.zoneNameIdEn().map(|x| x.to_string());
        clz_Torappu_SandboxV2ArchiveQuestZoneDataT {
            zoneId,
            zoneName,
            zoneBgPicId,
            zoneNameIdEn,
        }
    }

    #[inline]
    pub fn zoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestZoneData::VT_ZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn zoneName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestZoneData::VT_ZONENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn zoneBgPicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestZoneData::VT_ZONEBGPICID,
                None,
            )
        }
    }
    #[inline]
    pub fn zoneNameIdEn(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestZoneData::VT_ZONENAMEIDEN,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ArchiveQuestZoneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zoneId", Self::VT_ZONEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "zoneName",
                Self::VT_ZONENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "zoneBgPicId",
                Self::VT_ZONEBGPICID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "zoneNameIdEn",
                Self::VT_ZONENAMEIDEN,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ArchiveQuestZoneDataArgs<'a> {
    pub zoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneBgPicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneNameIdEn: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ArchiveQuestZoneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ArchiveQuestZoneDataArgs {
            zoneId: None,
            zoneName: None,
            zoneBgPicId: None,
            zoneNameIdEn: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2ArchiveQuestZoneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2ArchiveQuestZoneData", 4)?;
        if let Some(f) = self.zoneId() {
            s.serialize_field("zoneId", &f)?;
        } else {
            s.skip_field("zoneId")?;
        }
        if let Some(f) = self.zoneName() {
            s.serialize_field("zoneName", &f)?;
        } else {
            s.skip_field("zoneName")?;
        }
        if let Some(f) = self.zoneBgPicId() {
            s.serialize_field("zoneBgPicId", &f)?;
        } else {
            s.skip_field("zoneBgPicId")?;
        }
        if let Some(f) = self.zoneNameIdEn() {
            s.serialize_field("zoneNameIdEn", &f)?;
        } else {
            s.skip_field("zoneNameIdEn")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2ArchiveQuestZoneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ArchiveQuestZoneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_zoneId(&mut self, zoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestZoneData::VT_ZONEID,
            zoneId,
        );
    }
    #[inline]
    pub fn add_zoneName(&mut self, zoneName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestZoneData::VT_ZONENAME,
            zoneName,
        );
    }
    #[inline]
    pub fn add_zoneBgPicId(&mut self, zoneBgPicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestZoneData::VT_ZONEBGPICID,
            zoneBgPicId,
        );
    }
    #[inline]
    pub fn add_zoneNameIdEn(&mut self, zoneNameIdEn: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestZoneData::VT_ZONENAMEIDEN,
            zoneNameIdEn,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ArchiveQuestZoneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ArchiveQuestZoneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestZoneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ArchiveQuestZoneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ArchiveQuestZoneData");
        ds.field("zoneId", &self.zoneId());
        ds.field("zoneName", &self.zoneName());
        ds.field("zoneBgPicId", &self.zoneBgPicId());
        ds.field("zoneNameIdEn", &self.zoneNameIdEn());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2ArchiveQuestZoneDataT {
    pub zoneId: Option<String>,
    pub zoneName: Option<String>,
    pub zoneBgPicId: Option<String>,
    pub zoneNameIdEn: Option<String>,
}
impl Default for clz_Torappu_SandboxV2ArchiveQuestZoneDataT {
    fn default() -> Self {
        Self {
            zoneId: None,
            zoneName: None,
            zoneBgPicId: None,
            zoneNameIdEn: None,
        }
    }
}
impl clz_Torappu_SandboxV2ArchiveQuestZoneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestZoneData<'b>> {
        let zoneId = self.zoneId.as_ref().map(|x| _fbb.create_string(x));
        let zoneName = self.zoneName.as_ref().map(|x| _fbb.create_string(x));
        let zoneBgPicId = self.zoneBgPicId.as_ref().map(|x| _fbb.create_string(x));
        let zoneNameIdEn = self.zoneNameIdEn.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2ArchiveQuestZoneData::create(
            _fbb,
            &clz_Torappu_SandboxV2ArchiveQuestZoneDataArgs {
                zoneId,
                zoneName,
                zoneBgPicId,
                zoneNameIdEn,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2ArchiveQuestDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ArchiveQuestData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ArchiveQuestData<'a> {
    type Inner = clz_Torappu_SandboxV2ArchiveQuestData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ArchiveQuestData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_QUESTTYPE: flatbuffers::VOffsetT = 8;
    pub const VT_NAME: flatbuffers::VOffsetT = 10;
    pub const VT_DESC: flatbuffers::VOffsetT = 12;
    pub const VT_AVGDATALIST: flatbuffers::VOffsetT = 14;
    pub const VT_CGDATALIST: flatbuffers::VOffsetT = 16;
    pub const VT_NPCPICIDLIST: flatbuffers::VOffsetT = 18;
    pub const VT_ZONEDATA: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ArchiveQuestData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ArchiveQuestDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ArchiveQuestDataBuilder::new(_fbb);
        if let Some(x) = args.zoneData {
            builder.add_zoneData(x);
        }
        if let Some(x) = args.npcPicIdList {
            builder.add_npcPicIdList(x);
        }
        if let Some(x) = args.cgDataList {
            builder.add_cgDataList(x);
        }
        if let Some(x) = args.avgDataList {
            builder.add_avgDataList(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_questType(args.questType);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2ArchiveQuestDataT {
        let id = self.id().map(|x| x.to_string());
        let sortId = self.sortId();
        let questType = self.questType();
        let name = self.name().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let avgDataList = self
            .avgDataList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let cgDataList = self
            .cgDataList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let npcPicIdList = self
            .npcPicIdList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let zoneData = self.zoneData().map(|x| Box::new(x.unpack()));
        clz_Torappu_SandboxV2ArchiveQuestDataT {
            id,
            sortId,
            questType,
            name,
            desc,
            avgDataList,
            cgDataList,
            npcPicIdList,
            zoneData,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2ArchiveQuestData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn questType(&self) -> enum__Torappu_SandboxV2ArchiveQuestType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2ArchiveQuestType>(
                    clz_Torappu_SandboxV2ArchiveQuestData::VT_QUESTTYPE,
                    Some(enum__Torappu_SandboxV2ArchiveQuestType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn avgDataList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestAvgData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestAvgData>,
                >,
            >>(clz_Torappu_SandboxV2ArchiveQuestData::VT_AVGDATALIST, None)
        }
    }
    #[inline]
    pub fn cgDataList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestCgData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestCgData>,
                >,
            >>(clz_Torappu_SandboxV2ArchiveQuestData::VT_CGDATALIST, None)
        }
    }
    #[inline]
    pub fn npcPicIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxV2ArchiveQuestData::VT_NPCPICIDLIST, None)
        }
    }
    #[inline]
    pub fn zoneData(&self) -> Option<clz_Torappu_SandboxV2ArchiveQuestZoneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestZoneData>>(
                    clz_Torappu_SandboxV2ArchiveQuestData::VT_ZONEDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ArchiveQuestData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<enum__Torappu_SandboxV2ArchiveQuestType>(
                "questType",
                Self::VT_QUESTTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestAvgData>,
                >,
            >>("avgDataList", Self::VT_AVGDATALIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestCgData>,
                >,
            >>("cgDataList", Self::VT_CGDATALIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("npcPicIdList", Self::VT_NPCPICIDLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestZoneData>>(
                "zoneData",
                Self::VT_ZONEDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ArchiveQuestDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub questType: enum__Torappu_SandboxV2ArchiveQuestType,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub avgDataList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestAvgData<'a>>,
            >,
        >,
    >,
    pub cgDataList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestCgData<'a>>,
            >,
        >,
    >,
    pub npcPicIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub zoneData: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestZoneData<'a>>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ArchiveQuestDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ArchiveQuestDataArgs {
            id: None,
            sortId: 0,
            questType: enum__Torappu_SandboxV2ArchiveQuestType::NONE,
            name: None,
            desc: None,
            avgDataList: None,
            cgDataList: None,
            npcPicIdList: None,
            zoneData: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2ArchiveQuestData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2ArchiveQuestData", 9)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.serialize_field("questType", &self.questType())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.avgDataList() {
            s.serialize_field("avgDataList", &f)?;
        } else {
            s.skip_field("avgDataList")?;
        }
        if let Some(f) = self.cgDataList() {
            s.serialize_field("cgDataList", &f)?;
        } else {
            s.skip_field("cgDataList")?;
        }
        if let Some(f) = self.npcPicIdList() {
            s.serialize_field("npcPicIdList", &f)?;
        } else {
            s.skip_field("npcPicIdList")?;
        }
        if let Some(f) = self.zoneData() {
            s.serialize_field("zoneData", &f)?;
        } else {
            s.skip_field("zoneData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2ArchiveQuestDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ArchiveQuestDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2ArchiveQuestData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_questType(&mut self, questType: enum__Torappu_SandboxV2ArchiveQuestType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2ArchiveQuestType>(
                clz_Torappu_SandboxV2ArchiveQuestData::VT_QUESTTYPE,
                questType,
                enum__Torappu_SandboxV2ArchiveQuestType::NONE,
            );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_avgDataList(
        &mut self,
        avgDataList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestAvgData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestData::VT_AVGDATALIST,
            avgDataList,
        );
    }
    #[inline]
    pub fn add_cgDataList(
        &mut self,
        cgDataList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestCgData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestData::VT_CGDATALIST,
            cgDataList,
        );
    }
    #[inline]
    pub fn add_npcPicIdList(
        &mut self,
        npcPicIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestData::VT_NPCPICIDLIST,
            npcPicIdList,
        );
    }
    #[inline]
    pub fn add_zoneData(
        &mut self,
        zoneData: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestZoneData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestZoneData>>(
                clz_Torappu_SandboxV2ArchiveQuestData::VT_ZONEDATA,
                zoneData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ArchiveQuestDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ArchiveQuestDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ArchiveQuestData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ArchiveQuestData");
        ds.field("id", &self.id());
        ds.field("sortId", &self.sortId());
        ds.field("questType", &self.questType());
        ds.field("name", &self.name());
        ds.field("desc", &self.desc());
        ds.field("avgDataList", &self.avgDataList());
        ds.field("cgDataList", &self.cgDataList());
        ds.field("npcPicIdList", &self.npcPicIdList());
        ds.field("zoneData", &self.zoneData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2ArchiveQuestDataT {
    pub id: Option<String>,
    pub sortId: i32,
    pub questType: enum__Torappu_SandboxV2ArchiveQuestType,
    pub name: Option<String>,
    pub desc: Option<String>,
    pub avgDataList: Option<Vec<clz_Torappu_SandboxV2ArchiveQuestAvgDataT>>,
    pub cgDataList: Option<Vec<clz_Torappu_SandboxV2ArchiveQuestCgDataT>>,
    pub npcPicIdList: Option<Vec<String>>,
    pub zoneData: Option<Box<clz_Torappu_SandboxV2ArchiveQuestZoneDataT>>,
}
impl Default for clz_Torappu_SandboxV2ArchiveQuestDataT {
    fn default() -> Self {
        Self {
            id: None,
            sortId: 0,
            questType: enum__Torappu_SandboxV2ArchiveQuestType::NONE,
            name: None,
            desc: None,
            avgDataList: None,
            cgDataList: None,
            npcPicIdList: None,
            zoneData: None,
        }
    }
}
impl clz_Torappu_SandboxV2ArchiveQuestDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let questType = self.questType;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let avgDataList = self.avgDataList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let cgDataList = self.cgDataList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let npcPicIdList = self.npcPicIdList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let zoneData = self.zoneData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_SandboxV2ArchiveQuestData::create(
            _fbb,
            &clz_Torappu_SandboxV2ArchiveQuestDataArgs {
                id,
                sortId,
                questType,
                name,
                desc,
                avgDataList,
                cgDataList,
                npcPicIdList,
                zoneData,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ArchiveQuestDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ArchiveQuestData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ArchiveQuestDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2ArchiveQuestDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2ArchiveQuestDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2ArchiveQuestDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ArchiveQuestData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2ArchiveQuestData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ArchiveQuestData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestData>>(
                    dict__string__clz_Torappu_SandboxV2ArchiveQuestData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ArchiveQuestDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ArchiveQuestDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ArchiveQuestDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_SandboxV2ArchiveQuestData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ArchiveQuestDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ArchiveQuestDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ArchiveQuestData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestData>>(
                dict__string__clz_Torappu_SandboxV2ArchiveQuestData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ArchiveQuestDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ArchiveQuestDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ArchiveQuestData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2ArchiveQuestData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2ArchiveQuestDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2ArchiveQuestDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2ArchiveQuestDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2ArchiveQuestDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2ArchiveQuestData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2ArchiveQuestDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2ArchiveAchievementDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ArchiveAchievementData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ArchiveAchievementData<'a> {
    type Inner = clz_Torappu_SandboxV2ArchiveAchievementData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ArchiveAchievementData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_ACHIEVEMENTTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_RARITYSORTID: flatbuffers::VOffsetT = 8;
    pub const VT_SORTID: flatbuffers::VOffsetT = 10;
    pub const VT_NAME: flatbuffers::VOffsetT = 12;
    pub const VT_DESC: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ArchiveAchievementData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ArchiveAchievementDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveAchievementData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ArchiveAchievementDataBuilder::new(_fbb);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_sortId(args.sortId);
        builder.add_raritySortId(args.raritySortId);
        if let Some(x) = args.achievementType {
            builder.add_achievementType(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2ArchiveAchievementDataT {
        let id = self.id().map(|x| x.to_string());
        let achievementType = self
            .achievementType()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let raritySortId = self.raritySortId();
        let sortId = self.sortId();
        let name = self.name().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        clz_Torappu_SandboxV2ArchiveAchievementDataT {
            id,
            achievementType,
            raritySortId,
            sortId,
            name,
            desc,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveAchievementData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn achievementType(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2ArchiveAchievementData::VT_ACHIEVEMENTTYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn raritySortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2ArchiveAchievementData::VT_RARITYSORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2ArchiveAchievementData::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveAchievementData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveAchievementData::VT_DESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ArchiveAchievementData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("achievementType", Self::VT_ACHIEVEMENTTYPE, false)?
            .visit_field::<i32>("raritySortId", Self::VT_RARITYSORTID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ArchiveAchievementDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub achievementType: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub raritySortId: i32,
    pub sortId: i32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ArchiveAchievementDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ArchiveAchievementDataArgs {
            id: None,
            achievementType: None,
            raritySortId: 0,
            sortId: 0,
            name: None,
            desc: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2ArchiveAchievementData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_SandboxV2ArchiveAchievementData", 6)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.achievementType() {
            s.serialize_field("achievementType", &f)?;
        } else {
            s.skip_field("achievementType")?;
        }
        s.serialize_field("raritySortId", &self.raritySortId())?;
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2ArchiveAchievementDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ArchiveAchievementDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveAchievementData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_achievementType(
        &mut self,
        achievementType: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveAchievementData::VT_ACHIEVEMENTTYPE,
            achievementType,
        );
    }
    #[inline]
    pub fn add_raritySortId(&mut self, raritySortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ArchiveAchievementData::VT_RARITYSORTID,
            raritySortId,
            0,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ArchiveAchievementData::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveAchievementData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveAchievementData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ArchiveAchievementDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ArchiveAchievementDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveAchievementData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ArchiveAchievementData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ArchiveAchievementData");
        ds.field("id", &self.id());
        ds.field("achievementType", &self.achievementType());
        ds.field("raritySortId", &self.raritySortId());
        ds.field("sortId", &self.sortId());
        ds.field("name", &self.name());
        ds.field("desc", &self.desc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2ArchiveAchievementDataT {
    pub id: Option<String>,
    pub achievementType: Option<Vec<String>>,
    pub raritySortId: i32,
    pub sortId: i32,
    pub name: Option<String>,
    pub desc: Option<String>,
}
impl Default for clz_Torappu_SandboxV2ArchiveAchievementDataT {
    fn default() -> Self {
        Self {
            id: None,
            achievementType: None,
            raritySortId: 0,
            sortId: 0,
            name: None,
            desc: None,
        }
    }
}
impl clz_Torappu_SandboxV2ArchiveAchievementDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveAchievementData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let achievementType = self.achievementType.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let raritySortId = self.raritySortId;
        let sortId = self.sortId;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2ArchiveAchievementData::create(
            _fbb,
            &clz_Torappu_SandboxV2ArchiveAchievementDataArgs {
                id,
                achievementType,
                raritySortId,
                sortId,
                name,
                desc,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ArchiveAchievementData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ArchiveAchievementData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2ArchiveAchievementData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ArchiveAchievementData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveAchievementData>>(
                    dict__string__clz_Torappu_SandboxV2ArchiveAchievementData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveAchievementData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveAchievementData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_SandboxV2ArchiveAchievementData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ArchiveAchievementData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveAchievementData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveAchievementData>>(dict__string__clz_Torappu_SandboxV2ArchiveAchievementData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ArchiveAchievementData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2ArchiveAchievementData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2ArchiveAchievementDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2ArchiveAchievementData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2ArchiveAchievementTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a> {
    type Inner = clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a> {
    pub const VT_ACHIEVEMENTTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_SORTID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ArchiveAchievementTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ArchiveAchievementTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveAchievementTypeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ArchiveAchievementTypeDataBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.achievementType {
            builder.add_achievementType(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2ArchiveAchievementTypeDataT {
        let achievementType = self.achievementType().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let sortId = self.sortId();
        clz_Torappu_SandboxV2ArchiveAchievementTypeDataT {
            achievementType,
            name,
            sortId,
        }
    }

    #[inline]
    pub fn achievementType(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveAchievementTypeData::VT_ACHIEVEMENTTYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveAchievementTypeData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2ArchiveAchievementTypeData::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ArchiveAchievementTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "achievementType",
                Self::VT_ACHIEVEMENTTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ArchiveAchievementTypeDataArgs<'a> {
    pub achievementType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2ArchiveAchievementTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ArchiveAchievementTypeDataArgs {
            achievementType: None,
            name: None,
            sortId: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2ArchiveAchievementTypeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_SandboxV2ArchiveAchievementTypeData", 3)?;
        if let Some(f) = self.achievementType() {
            s.serialize_field("achievementType", &f)?;
        } else {
            s.skip_field("achievementType")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2ArchiveAchievementTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ArchiveAchievementTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_achievementType(&mut self, achievementType: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveAchievementTypeData::VT_ACHIEVEMENTTYPE,
            achievementType,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveAchievementTypeData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ArchiveAchievementTypeData::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ArchiveAchievementTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ArchiveAchievementTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ArchiveAchievementTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ArchiveAchievementTypeData");
        ds.field("achievementType", &self.achievementType());
        ds.field("name", &self.name());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2ArchiveAchievementTypeDataT {
    pub achievementType: Option<String>,
    pub name: Option<String>,
    pub sortId: i32,
}
impl Default for clz_Torappu_SandboxV2ArchiveAchievementTypeDataT {
    fn default() -> Self {
        Self {
            achievementType: None,
            name: None,
            sortId: 0,
        }
    }
}
impl clz_Torappu_SandboxV2ArchiveAchievementTypeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveAchievementTypeData<'b>> {
        let achievementType = self.achievementType.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        clz_Torappu_SandboxV2ArchiveAchievementTypeData::create(
            _fbb,
            &clz_Torappu_SandboxV2ArchiveAchievementTypeDataArgs {
                achievementType,
                name,
                sortId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a>
{
    type Inner = dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveAchievementTypeData>>(dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveAchievementTypeData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveAchievementTypeData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveAchievementTypeData>>(dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2ArchiveAchievementTypeDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'b>>
    {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2ArchiveQuestTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ArchiveQuestTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ArchiveQuestTypeData<'a> {
    type Inner = clz_Torappu_SandboxV2ArchiveQuestTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ArchiveQuestTypeData<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_ICONID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ArchiveQuestTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ArchiveQuestTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestTypeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ArchiveQuestTypeDataBuilder::new(_fbb);
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2ArchiveQuestTypeDataT {
        let type_ = self.type_();
        let name = self.name().map(|x| x.to_string());
        let iconId = self.iconId().map(|x| x.to_string());
        clz_Torappu_SandboxV2ArchiveQuestTypeDataT {
            type_,
            name,
            iconId,
        }
    }

    #[inline]
    pub fn type_(&self) -> enum__Torappu_SandboxV2ArchiveQuestType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2ArchiveQuestType>(
                    clz_Torappu_SandboxV2ArchiveQuestTypeData::VT_TYPE_,
                    Some(enum__Torappu_SandboxV2ArchiveQuestType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestTypeData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveQuestTypeData::VT_ICONID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ArchiveQuestTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxV2ArchiveQuestType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ArchiveQuestTypeDataArgs<'a> {
    pub type_: enum__Torappu_SandboxV2ArchiveQuestType,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ArchiveQuestTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ArchiveQuestTypeDataArgs {
            type_: enum__Torappu_SandboxV2ArchiveQuestType::NONE,
            name: None,
            iconId: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2ArchiveQuestTypeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2ArchiveQuestTypeData", 3)?;
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.iconId() {
            s.serialize_field("iconId", &f)?;
        } else {
            s.skip_field("iconId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2ArchiveQuestTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ArchiveQuestTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_SandboxV2ArchiveQuestType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2ArchiveQuestType>(
                clz_Torappu_SandboxV2ArchiveQuestTypeData::VT_TYPE_,
                type_,
                enum__Torappu_SandboxV2ArchiveQuestType::NONE,
            );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestTypeData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveQuestTypeData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ArchiveQuestTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ArchiveQuestTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ArchiveQuestTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ArchiveQuestTypeData");
        ds.field("type_", &self.type_());
        ds.field("name", &self.name());
        ds.field("iconId", &self.iconId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2ArchiveQuestTypeDataT {
    pub type_: enum__Torappu_SandboxV2ArchiveQuestType,
    pub name: Option<String>,
    pub iconId: Option<String>,
}
impl Default for clz_Torappu_SandboxV2ArchiveQuestTypeDataT {
    fn default() -> Self {
        Self {
            type_: enum__Torappu_SandboxV2ArchiveQuestType::NONE,
            name: None,
            iconId: None,
        }
    }
}
impl clz_Torappu_SandboxV2ArchiveQuestTypeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestTypeData<'b>> {
        let type_ = self.type_;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let iconId = self.iconId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2ArchiveQuestTypeData::create(
            _fbb,
            &clz_Torappu_SandboxV2ArchiveQuestTypeDataArgs {
                type_,
                name,
                iconId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'bldr>>
    {
        let mut builder = dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ArchiveQuestTypeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestTypeData>>(
                    dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveQuestTypeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestTypeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestTypeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveQuestTypeData>>(
                dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2ArchiveQuestTypeDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2ArchiveMusicUnlockDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a> {
    type Inner = clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a> {
    pub const VT_MUSICID: flatbuffers::VOffsetT = 4;
    pub const VT_UNLOCKCONDDESC: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ArchiveMusicUnlockData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ArchiveMusicUnlockDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveMusicUnlockData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ArchiveMusicUnlockDataBuilder::new(_fbb);
        if let Some(x) = args.unlockCondDesc {
            builder.add_unlockCondDesc(x);
        }
        if let Some(x) = args.musicId {
            builder.add_musicId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2ArchiveMusicUnlockDataT {
        let musicId = self.musicId().map(|x| x.to_string());
        let unlockCondDesc = self.unlockCondDesc().map(|x| x.to_string());
        clz_Torappu_SandboxV2ArchiveMusicUnlockDataT {
            musicId,
            unlockCondDesc,
        }
    }

    #[inline]
    pub fn musicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveMusicUnlockData::VT_MUSICID,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockCondDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ArchiveMusicUnlockData::VT_UNLOCKCONDDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ArchiveMusicUnlockData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("musicId", Self::VT_MUSICID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockCondDesc",
                Self::VT_UNLOCKCONDDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ArchiveMusicUnlockDataArgs<'a> {
    pub musicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockCondDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ArchiveMusicUnlockDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ArchiveMusicUnlockDataArgs {
            musicId: None,
            unlockCondDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2ArchiveMusicUnlockData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_SandboxV2ArchiveMusicUnlockData", 2)?;
        if let Some(f) = self.musicId() {
            s.serialize_field("musicId", &f)?;
        } else {
            s.skip_field("musicId")?;
        }
        if let Some(f) = self.unlockCondDesc() {
            s.serialize_field("unlockCondDesc", &f)?;
        } else {
            s.skip_field("unlockCondDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2ArchiveMusicUnlockDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ArchiveMusicUnlockDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_musicId(&mut self, musicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveMusicUnlockData::VT_MUSICID,
            musicId,
        );
    }
    #[inline]
    pub fn add_unlockCondDesc(&mut self, unlockCondDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ArchiveMusicUnlockData::VT_UNLOCKCONDDESC,
            unlockCondDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ArchiveMusicUnlockDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ArchiveMusicUnlockDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ArchiveMusicUnlockData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ArchiveMusicUnlockData");
        ds.field("musicId", &self.musicId());
        ds.field("unlockCondDesc", &self.unlockCondDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2ArchiveMusicUnlockDataT {
    pub musicId: Option<String>,
    pub unlockCondDesc: Option<String>,
}
impl Default for clz_Torappu_SandboxV2ArchiveMusicUnlockDataT {
    fn default() -> Self {
        Self {
            musicId: None,
            unlockCondDesc: None,
        }
    }
}
impl clz_Torappu_SandboxV2ArchiveMusicUnlockDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveMusicUnlockData<'b>> {
        let musicId = self.musicId.as_ref().map(|x| _fbb.create_string(x));
        let unlockCondDesc = self.unlockCondDesc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2ArchiveMusicUnlockData::create(
            _fbb,
            &clz_Torappu_SandboxV2ArchiveMusicUnlockDataArgs {
                musicId,
                unlockCondDesc,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveMusicUnlockData>>(
                    dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ArchiveMusicUnlockData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveMusicUnlockData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ArchiveMusicUnlockData>>(dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2ArchiveMusicUnlockDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2BaseUpdateConditionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2BaseUpdateCondition<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2BaseUpdateCondition<'a> {
    type Inner = clz_Torappu_SandboxV2BaseUpdateCondition<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2BaseUpdateCondition<'a> {
    pub const VT_DESC: flatbuffers::VOffsetT = 4;
    pub const VT_LIMITCOND: flatbuffers::VOffsetT = 6;
    pub const VT_PARAM: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2BaseUpdateCondition { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2BaseUpdateConditionArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseUpdateCondition<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2BaseUpdateConditionBuilder::new(_fbb);
        if let Some(x) = args.param {
            builder.add_param(x);
        }
        if let Some(x) = args.limitCond {
            builder.add_limitCond(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2BaseUpdateConditionT {
        let desc = self.desc().map(|x| x.to_string());
        let limitCond = self.limitCond().map(|x| x.to_string());
        let param = self
            .param()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_SandboxV2BaseUpdateConditionT {
            desc,
            limitCond,
            param,
        }
    }

    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BaseUpdateCondition::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn limitCond(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BaseUpdateCondition::VT_LIMITCOND,
                None,
            )
        }
    }
    #[inline]
    pub fn param(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxV2BaseUpdateCondition::VT_PARAM, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2BaseUpdateCondition<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "limitCond",
                Self::VT_LIMITCOND,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("param", Self::VT_PARAM, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2BaseUpdateConditionArgs<'a> {
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub limitCond: Option<flatbuffers::WIPOffset<&'a str>>,
    pub param: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2BaseUpdateConditionArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2BaseUpdateConditionArgs {
            desc: None,
            limitCond: None,
            param: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2BaseUpdateCondition<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2BaseUpdateCondition", 3)?;
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.limitCond() {
            s.serialize_field("limitCond", &f)?;
        } else {
            s.skip_field("limitCond")?;
        }
        if let Some(f) = self.param() {
            s.serialize_field("param", &f)?;
        } else {
            s.skip_field("param")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2BaseUpdateConditionBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2BaseUpdateConditionBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateCondition::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_limitCond(&mut self, limitCond: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateCondition::VT_LIMITCOND,
            limitCond,
        );
    }
    #[inline]
    pub fn add_param(
        &mut self,
        param: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateCondition::VT_PARAM,
            param,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2BaseUpdateConditionBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2BaseUpdateConditionBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseUpdateCondition<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2BaseUpdateCondition<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2BaseUpdateCondition");
        ds.field("desc", &self.desc());
        ds.field("limitCond", &self.limitCond());
        ds.field("param", &self.param());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2BaseUpdateConditionT {
    pub desc: Option<String>,
    pub limitCond: Option<String>,
    pub param: Option<Vec<String>>,
}
impl Default for clz_Torappu_SandboxV2BaseUpdateConditionT {
    fn default() -> Self {
        Self {
            desc: None,
            limitCond: None,
            param: None,
        }
    }
}
impl clz_Torappu_SandboxV2BaseUpdateConditionT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseUpdateCondition<'b>> {
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let limitCond = self.limitCond.as_ref().map(|x| _fbb.create_string(x));
        let param = self.param.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SandboxV2BaseUpdateCondition::create(
            _fbb,
            &clz_Torappu_SandboxV2BaseUpdateConditionArgs {
                desc,
                limitCond,
                param,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'a> {
    type Inner = clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'a> {
    pub const VT_FUNCID: flatbuffers::VOffsetT = 4;
    pub const VT_UNLOCKTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_TYPETITLE: flatbuffers::VOffsetT = 8;
    pub const VT_DESC: flatbuffers::VOffsetT = 10;
    pub const VT_ICON: flatbuffers::VOffsetT = 12;
    pub const VT_DARKMODE: flatbuffers::VOffsetT = 14;
    pub const VT_SORTID: flatbuffers::VOffsetT = 16;
    pub const VT_DISPLAYTYPE: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'bldr>>
    {
        let mut builder =
            clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataBuilder::new(_fbb);
        builder.add_displayType(args.displayType);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.icon {
            builder.add_icon(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.typeTitle {
            builder.add_typeTitle(x);
        }
        builder.add_unlockType(args.unlockType);
        if let Some(x) = args.funcId {
            builder.add_funcId(x);
        }
        builder.add_darkMode(args.darkMode);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataT {
        let funcId = self.funcId().map(|x| x.to_string());
        let unlockType = self.unlockType();
        let typeTitle = self.typeTitle().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let icon = self.icon().map(|x| x.to_string());
        let darkMode = self.darkMode();
        let sortId = self.sortId();
        let displayType = self.displayType();
        clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataT {
            funcId,
            unlockType,
            typeTitle,
            desc,
            icon,
            darkMode,
            sortId,
            displayType,
        }
    }

    #[inline]
    pub fn funcId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_FUNCID,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockType(&self) -> enum__Torappu_SandboxV2BaseUnlockFuncType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2BaseUnlockFuncType>(
                    clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_UNLOCKTYPE,
                    Some(enum__Torappu_SandboxV2BaseUnlockFuncType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn typeTitle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_TYPETITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn icon(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_ICON,
                None,
            )
        }
    }
    #[inline]
    pub fn darkMode(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_DARKMODE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn displayType(&self) -> enum__Torappu_SandboxV2BaseUnlockFuncDisplayType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2BaseUnlockFuncDisplayType>(
                    clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_DISPLAYTYPE,
                    Some(enum__Torappu_SandboxV2BaseUnlockFuncDisplayType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("funcId", Self::VT_FUNCID, false)?
            .visit_field::<enum__Torappu_SandboxV2BaseUnlockFuncType>(
                "unlockType",
                Self::VT_UNLOCKTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "typeTitle",
                Self::VT_TYPETITLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("icon", Self::VT_ICON, false)?
            .visit_field::<bool>("darkMode", Self::VT_DARKMODE, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<enum__Torappu_SandboxV2BaseUnlockFuncDisplayType>(
                "displayType",
                Self::VT_DISPLAYTYPE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataArgs<'a> {
    pub funcId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockType: enum__Torappu_SandboxV2BaseUnlockFuncType,
    pub typeTitle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub icon: Option<flatbuffers::WIPOffset<&'a str>>,
    pub darkMode: bool,
    pub sortId: i32,
    pub displayType: enum__Torappu_SandboxV2BaseUnlockFuncDisplayType,
}
impl<'a> Default for clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataArgs {
            funcId: None,
            unlockType: enum__Torappu_SandboxV2BaseUnlockFuncType::NONE,
            typeTitle: None,
            desc: None,
            icon: None,
            darkMode: false,
            sortId: 0,
            displayType: enum__Torappu_SandboxV2BaseUnlockFuncDisplayType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData",
            8,
        )?;
        if let Some(f) = self.funcId() {
            s.serialize_field("funcId", &f)?;
        } else {
            s.skip_field("funcId")?;
        }
        s.serialize_field("unlockType", &self.unlockType())?;
        if let Some(f) = self.typeTitle() {
            s.serialize_field("typeTitle", &f)?;
        } else {
            s.skip_field("typeTitle")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.icon() {
            s.serialize_field("icon", &f)?;
        } else {
            s.skip_field("icon")?;
        }
        s.serialize_field("darkMode", &self.darkMode())?;
        s.serialize_field("sortId", &self.sortId())?;
        s.serialize_field("displayType", &self.displayType())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_funcId(&mut self, funcId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_FUNCID,
            funcId,
        );
    }
    #[inline]
    pub fn add_unlockType(&mut self, unlockType: enum__Torappu_SandboxV2BaseUnlockFuncType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2BaseUnlockFuncType>(
                clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_UNLOCKTYPE,
                unlockType,
                enum__Torappu_SandboxV2BaseUnlockFuncType::NONE,
            );
    }
    #[inline]
    pub fn add_typeTitle(&mut self, typeTitle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_TYPETITLE,
            typeTitle,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_icon(&mut self, icon: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_ICON,
            icon,
        );
    }
    #[inline]
    pub fn add_darkMode(&mut self, darkMode: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_DARKMODE,
            darkMode,
            false,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn add_displayType(
        &mut self,
        displayType: enum__Torappu_SandboxV2BaseUnlockFuncDisplayType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2BaseUnlockFuncDisplayType>(
                clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::VT_DISPLAYTYPE,
                displayType,
                enum__Torappu_SandboxV2BaseUnlockFuncDisplayType::NONE,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData");
        ds.field("funcId", &self.funcId());
        ds.field("unlockType", &self.unlockType());
        ds.field("typeTitle", &self.typeTitle());
        ds.field("desc", &self.desc());
        ds.field("icon", &self.icon());
        ds.field("darkMode", &self.darkMode());
        ds.field("sortId", &self.sortId());
        ds.field("displayType", &self.displayType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataT {
    pub funcId: Option<String>,
    pub unlockType: enum__Torappu_SandboxV2BaseUnlockFuncType,
    pub typeTitle: Option<String>,
    pub desc: Option<String>,
    pub icon: Option<String>,
    pub darkMode: bool,
    pub sortId: i32,
    pub displayType: enum__Torappu_SandboxV2BaseUnlockFuncDisplayType,
}
impl Default for clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataT {
    fn default() -> Self {
        Self {
            funcId: None,
            unlockType: enum__Torappu_SandboxV2BaseUnlockFuncType::NONE,
            typeTitle: None,
            desc: None,
            icon: None,
            darkMode: false,
            sortId: 0,
            displayType: enum__Torappu_SandboxV2BaseUnlockFuncDisplayType::NONE,
        }
    }
}
impl clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'b>> {
        let funcId = self.funcId.as_ref().map(|x| _fbb.create_string(x));
        let unlockType = self.unlockType;
        let typeTitle = self.typeTitle.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let icon = self.icon.as_ref().map(|x| _fbb.create_string(x));
        let darkMode = self.darkMode;
        let sortId = self.sortId;
        let displayType = self.displayType;
        clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData::create(
            _fbb,
            &clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataArgs {
                funcId,
                unlockType,
                typeTitle,
                desc,
                icon,
                darkMode,
                sortId,
                displayType,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2BaseFunctionPreviewDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2BaseFunctionPreviewData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2BaseFunctionPreviewData<'a> {
    type Inner = clz_Torappu_SandboxV2BaseFunctionPreviewData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2BaseFunctionPreviewData<'a> {
    pub const VT_PREVIEWID: flatbuffers::VOffsetT = 4;
    pub const VT_PREVIEWVALUE: flatbuffers::VOffsetT = 6;
    pub const VT_DETAILDATA: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2BaseFunctionPreviewData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2BaseFunctionPreviewDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseFunctionPreviewData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2BaseFunctionPreviewDataBuilder::new(_fbb);
        if let Some(x) = args.detailData {
            builder.add_detailData(x);
        }
        builder.add_previewValue(args.previewValue);
        if let Some(x) = args.previewId {
            builder.add_previewId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2BaseFunctionPreviewDataT {
        let previewId = self.previewId().map(|x| x.to_string());
        let previewValue = self.previewValue();
        let detailData = self.detailData().map(|x| Box::new(x.unpack()));
        clz_Torappu_SandboxV2BaseFunctionPreviewDataT {
            previewId,
            previewValue,
            detailData,
        }
    }

    #[inline]
    pub fn previewId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BaseFunctionPreviewData::VT_PREVIEWID,
                None,
            )
        }
    }
    #[inline]
    pub fn previewValue(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BaseFunctionPreviewData::VT_PREVIEWVALUE,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn detailData(
        &self,
    ) -> Option<clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData,
            >>(
                clz_Torappu_SandboxV2BaseFunctionPreviewData::VT_DETAILDATA,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2BaseFunctionPreviewData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("previewId", Self::VT_PREVIEWID, false)?
     .visit_field::<i32>("previewValue", Self::VT_PREVIEWVALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData>>("detailData", Self::VT_DETAILDATA, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2BaseFunctionPreviewDataArgs<'a> {
    pub previewId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub previewValue: i32,
    pub detailData: Option<
        flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'a>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2BaseFunctionPreviewDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2BaseFunctionPreviewDataArgs {
            previewId: None,
            previewValue: 0,
            detailData: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2BaseFunctionPreviewData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_SandboxV2BaseFunctionPreviewData", 3)?;
        if let Some(f) = self.previewId() {
            s.serialize_field("previewId", &f)?;
        } else {
            s.skip_field("previewId")?;
        }
        s.serialize_field("previewValue", &self.previewValue())?;
        if let Some(f) = self.detailData() {
            s.serialize_field("detailData", &f)?;
        } else {
            s.skip_field("detailData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2BaseFunctionPreviewDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2BaseFunctionPreviewDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_previewId(&mut self, previewId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseFunctionPreviewData::VT_PREVIEWID,
            previewId,
        );
    }
    #[inline]
    pub fn add_previewValue(&mut self, previewValue: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BaseFunctionPreviewData::VT_PREVIEWVALUE,
            previewValue,
            0,
        );
    }
    #[inline]
    pub fn add_detailData(
        &mut self,
        detailData: flatbuffers::WIPOffset<
            clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailData>>(clz_Torappu_SandboxV2BaseFunctionPreviewData::VT_DETAILDATA, detailData);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2BaseFunctionPreviewDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2BaseFunctionPreviewDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseFunctionPreviewData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2BaseFunctionPreviewData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2BaseFunctionPreviewData");
        ds.field("previewId", &self.previewId());
        ds.field("previewValue", &self.previewValue());
        ds.field("detailData", &self.detailData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2BaseFunctionPreviewDataT {
    pub previewId: Option<String>,
    pub previewValue: i32,
    pub detailData: Option<Box<clz_Torappu_SandboxV2BaseUpdateFunctionPreviewDetailDataT>>,
}
impl Default for clz_Torappu_SandboxV2BaseFunctionPreviewDataT {
    fn default() -> Self {
        Self {
            previewId: None,
            previewValue: 0,
            detailData: None,
        }
    }
}
impl clz_Torappu_SandboxV2BaseFunctionPreviewDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseFunctionPreviewData<'b>> {
        let previewId = self.previewId.as_ref().map(|x| _fbb.create_string(x));
        let previewValue = self.previewValue;
        let detailData = self.detailData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_SandboxV2BaseFunctionPreviewData::create(
            _fbb,
            &clz_Torappu_SandboxV2BaseFunctionPreviewDataArgs {
                previewId,
                previewValue,
                detailData,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2BaseUpdateDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2BaseUpdateData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2BaseUpdateData<'a> {
    type Inner = clz_Torappu_SandboxV2BaseUpdateData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2BaseUpdateData<'a> {
    pub const VT_BASELEVELID: flatbuffers::VOffsetT = 4;
    pub const VT_BASELEVEL: flatbuffers::VOffsetT = 6;
    pub const VT_CONDITIONS: flatbuffers::VOffsetT = 8;
    pub const VT_ITEMS: flatbuffers::VOffsetT = 10;
    pub const VT_PREVIEWDATAS: flatbuffers::VOffsetT = 12;
    pub const VT_SCOREFACTOR: flatbuffers::VOffsetT = 14;
    pub const VT_PORTABLEREPAIRCOST: flatbuffers::VOffsetT = 16;
    pub const VT_ENTRYCOUNT: flatbuffers::VOffsetT = 18;
    pub const VT_REPAIRCOST: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2BaseUpdateData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2BaseUpdateDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseUpdateData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2BaseUpdateDataBuilder::new(_fbb);
        builder.add_repairCost(args.repairCost);
        builder.add_entryCount(args.entryCount);
        builder.add_portableRepairCost(args.portableRepairCost);
        if let Some(x) = args.scoreFactor {
            builder.add_scoreFactor(x);
        }
        if let Some(x) = args.previewDatas {
            builder.add_previewDatas(x);
        }
        if let Some(x) = args.items {
            builder.add_items(x);
        }
        if let Some(x) = args.conditions {
            builder.add_conditions(x);
        }
        builder.add_baseLevel(args.baseLevel);
        if let Some(x) = args.baseLevelId {
            builder.add_baseLevelId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2BaseUpdateDataT {
        let baseLevelId = self.baseLevelId().map(|x| x.to_string());
        let baseLevel = self.baseLevel();
        let conditions = self
            .conditions()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let items = self.items().map(|x| x.iter().map(|t| t.unpack()).collect());
        let previewDatas = self
            .previewDatas()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let scoreFactor = self.scoreFactor().map(|x| x.to_string());
        let portableRepairCost = self.portableRepairCost();
        let entryCount = self.entryCount();
        let repairCost = self.repairCost();
        clz_Torappu_SandboxV2BaseUpdateDataT {
            baseLevelId,
            baseLevel,
            conditions,
            items,
            previewDatas,
            scoreFactor,
            portableRepairCost,
            entryCount,
            repairCost,
        }
    }

    #[inline]
    pub fn baseLevelId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BaseUpdateData::VT_BASELEVELID,
                None,
            )
        }
    }
    #[inline]
    pub fn baseLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2BaseUpdateData::VT_BASELEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn conditions(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseUpdateCondition<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseUpdateCondition>,
                >,
            >>(clz_Torappu_SandboxV2BaseUpdateData::VT_CONDITIONS, None)
        }
    }
    #[inline]
    pub fn items(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>(clz_Torappu_SandboxV2BaseUpdateData::VT_ITEMS, None)
        }
    }
    #[inline]
    pub fn previewDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseFunctionPreviewData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseFunctionPreviewData>,
                >,
            >>(clz_Torappu_SandboxV2BaseUpdateData::VT_PREVIEWDATAS, None)
        }
    }
    #[inline]
    pub fn scoreFactor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BaseUpdateData::VT_SCOREFACTOR,
                None,
            )
        }
    }
    #[inline]
    pub fn portableRepairCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BaseUpdateData::VT_PORTABLEREPAIRCOST,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn entryCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2BaseUpdateData::VT_ENTRYCOUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn repairCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2BaseUpdateData::VT_REPAIRCOST, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2BaseUpdateData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "baseLevelId",
                Self::VT_BASELEVELID,
                false,
            )?
            .visit_field::<i32>("baseLevel", Self::VT_BASELEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseUpdateCondition>,
                >,
            >>("conditions", Self::VT_CONDITIONS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>("items", Self::VT_ITEMS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseFunctionPreviewData>,
                >,
            >>("previewDatas", Self::VT_PREVIEWDATAS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "scoreFactor",
                Self::VT_SCOREFACTOR,
                false,
            )?
            .visit_field::<i32>("portableRepairCost", Self::VT_PORTABLEREPAIRCOST, false)?
            .visit_field::<i32>("entryCount", Self::VT_ENTRYCOUNT, false)?
            .visit_field::<i32>("repairCost", Self::VT_REPAIRCOST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2BaseUpdateDataArgs<'a> {
    pub baseLevelId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub baseLevel: i32,
    pub conditions: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseUpdateCondition<'a>>,
            >,
        >,
    >,
    pub items: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>,
        >,
    >,
    pub previewDatas: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseFunctionPreviewData<'a>>,
            >,
        >,
    >,
    pub scoreFactor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub portableRepairCost: i32,
    pub entryCount: i32,
    pub repairCost: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2BaseUpdateDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2BaseUpdateDataArgs {
            baseLevelId: None,
            baseLevel: 0,
            conditions: None,
            items: None,
            previewDatas: None,
            scoreFactor: None,
            portableRepairCost: 0,
            entryCount: 0,
            repairCost: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2BaseUpdateData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2BaseUpdateData", 9)?;
        if let Some(f) = self.baseLevelId() {
            s.serialize_field("baseLevelId", &f)?;
        } else {
            s.skip_field("baseLevelId")?;
        }
        s.serialize_field("baseLevel", &self.baseLevel())?;
        if let Some(f) = self.conditions() {
            s.serialize_field("conditions", &f)?;
        } else {
            s.skip_field("conditions")?;
        }
        if let Some(f) = self.items() {
            s.serialize_field("items", &f)?;
        } else {
            s.skip_field("items")?;
        }
        if let Some(f) = self.previewDatas() {
            s.serialize_field("previewDatas", &f)?;
        } else {
            s.skip_field("previewDatas")?;
        }
        if let Some(f) = self.scoreFactor() {
            s.serialize_field("scoreFactor", &f)?;
        } else {
            s.skip_field("scoreFactor")?;
        }
        s.serialize_field("portableRepairCost", &self.portableRepairCost())?;
        s.serialize_field("entryCount", &self.entryCount())?;
        s.serialize_field("repairCost", &self.repairCost())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2BaseUpdateDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2BaseUpdateDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_baseLevelId(&mut self, baseLevelId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateData::VT_BASELEVELID,
            baseLevelId,
        );
    }
    #[inline]
    pub fn add_baseLevel(&mut self, baseLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BaseUpdateData::VT_BASELEVEL,
            baseLevel,
            0,
        );
    }
    #[inline]
    pub fn add_conditions(
        &mut self,
        conditions: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseUpdateCondition<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateData::VT_CONDITIONS,
            conditions,
        );
    }
    #[inline]
    pub fn add_items(
        &mut self,
        items: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__int<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateData::VT_ITEMS,
            items,
        );
    }
    #[inline]
    pub fn add_previewDatas(
        &mut self,
        previewDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseFunctionPreviewData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateData::VT_PREVIEWDATAS,
            previewDatas,
        );
    }
    #[inline]
    pub fn add_scoreFactor(&mut self, scoreFactor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BaseUpdateData::VT_SCOREFACTOR,
            scoreFactor,
        );
    }
    #[inline]
    pub fn add_portableRepairCost(&mut self, portableRepairCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BaseUpdateData::VT_PORTABLEREPAIRCOST,
            portableRepairCost,
            0,
        );
    }
    #[inline]
    pub fn add_entryCount(&mut self, entryCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BaseUpdateData::VT_ENTRYCOUNT,
            entryCount,
            0,
        );
    }
    #[inline]
    pub fn add_repairCost(&mut self, repairCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BaseUpdateData::VT_REPAIRCOST,
            repairCost,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2BaseUpdateDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2BaseUpdateDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseUpdateData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2BaseUpdateData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2BaseUpdateData");
        ds.field("baseLevelId", &self.baseLevelId());
        ds.field("baseLevel", &self.baseLevel());
        ds.field("conditions", &self.conditions());
        ds.field("items", &self.items());
        ds.field("previewDatas", &self.previewDatas());
        ds.field("scoreFactor", &self.scoreFactor());
        ds.field("portableRepairCost", &self.portableRepairCost());
        ds.field("entryCount", &self.entryCount());
        ds.field("repairCost", &self.repairCost());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2BaseUpdateDataT {
    pub baseLevelId: Option<String>,
    pub baseLevel: i32,
    pub conditions: Option<Vec<clz_Torappu_SandboxV2BaseUpdateConditionT>>,
    pub items: Option<Vec<dict__string__intT>>,
    pub previewDatas: Option<Vec<clz_Torappu_SandboxV2BaseFunctionPreviewDataT>>,
    pub scoreFactor: Option<String>,
    pub portableRepairCost: i32,
    pub entryCount: i32,
    pub repairCost: i32,
}
impl Default for clz_Torappu_SandboxV2BaseUpdateDataT {
    fn default() -> Self {
        Self {
            baseLevelId: None,
            baseLevel: 0,
            conditions: None,
            items: None,
            previewDatas: None,
            scoreFactor: None,
            portableRepairCost: 0,
            entryCount: 0,
            repairCost: 0,
        }
    }
}
impl clz_Torappu_SandboxV2BaseUpdateDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BaseUpdateData<'b>> {
        let baseLevelId = self.baseLevelId.as_ref().map(|x| _fbb.create_string(x));
        let baseLevel = self.baseLevel;
        let conditions = self.conditions.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let items = self.items.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let previewDatas = self.previewDatas.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let scoreFactor = self.scoreFactor.as_ref().map(|x| _fbb.create_string(x));
        let portableRepairCost = self.portableRepairCost;
        let entryCount = self.entryCount;
        let repairCost = self.repairCost;
        clz_Torappu_SandboxV2BaseUpdateData::create(
            _fbb,
            &clz_Torappu_SandboxV2BaseUpdateDataArgs {
                baseLevelId,
                baseLevel,
                conditions,
                items,
                previewDatas,
                scoreFactor,
                portableRepairCost,
                entryCount,
                repairCost,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2DevelopmentLineSegmentDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2DevelopmentLineSegmentData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2DevelopmentLineSegmentData<'a> {
    type Inner = clz_Torappu_SandboxV2DevelopmentLineSegmentData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2DevelopmentLineSegmentData<'a> {
    pub const VT_FROMNODEID: flatbuffers::VOffsetT = 4;
    pub const VT_PASSINGNODEIDS: flatbuffers::VOffsetT = 6;
    pub const VT_FROMAXISPOSX: flatbuffers::VOffsetT = 8;
    pub const VT_FROMAXISPOSY: flatbuffers::VOffsetT = 10;
    pub const VT_TOAXISPOSX: flatbuffers::VOffsetT = 12;
    pub const VT_TOAXISPOSY: flatbuffers::VOffsetT = 14;
    pub const VT_LINESTYLE: flatbuffers::VOffsetT = 16;
    pub const VT_UNLOCKBASEMENTLEVEL: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2DevelopmentLineSegmentData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2DevelopmentLineSegmentDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentLineSegmentData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2DevelopmentLineSegmentDataBuilder::new(_fbb);
        builder.add_unlockBasementLevel(args.unlockBasementLevel);
        builder.add_lineStyle(args.lineStyle);
        builder.add_toAxisPosY(args.toAxisPosY);
        builder.add_toAxisPosX(args.toAxisPosX);
        builder.add_fromAxisPosY(args.fromAxisPosY);
        builder.add_fromAxisPosX(args.fromAxisPosX);
        if let Some(x) = args.passingNodeIds {
            builder.add_passingNodeIds(x);
        }
        if let Some(x) = args.fromNodeId {
            builder.add_fromNodeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2DevelopmentLineSegmentDataT {
        let fromNodeId = self.fromNodeId().map(|x| x.to_string());
        let passingNodeIds = self
            .passingNodeIds()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let fromAxisPosX = self.fromAxisPosX();
        let fromAxisPosY = self.fromAxisPosY();
        let toAxisPosX = self.toAxisPosX();
        let toAxisPosY = self.toAxisPosY();
        let lineStyle = self.lineStyle();
        let unlockBasementLevel = self.unlockBasementLevel();
        clz_Torappu_SandboxV2DevelopmentLineSegmentDataT {
            fromNodeId,
            passingNodeIds,
            fromAxisPosX,
            fromAxisPosY,
            toAxisPosX,
            toAxisPosY,
            lineStyle,
            unlockBasementLevel,
        }
    }

    #[inline]
    pub fn fromNodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_FROMNODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn passingNodeIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_PASSINGNODEIDS,
                None,
            )
        }
    }
    #[inline]
    pub fn fromAxisPosX(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_FROMAXISPOSX,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn fromAxisPosY(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_FROMAXISPOSY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn toAxisPosX(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_TOAXISPOSX,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn toAxisPosY(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_TOAXISPOSY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn lineStyle(&self) -> enum__Torappu_SandboxV2DevelopmentLineStyle {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2DevelopmentLineStyle>(
                    clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_LINESTYLE,
                    Some(enum__Torappu_SandboxV2DevelopmentLineStyle::EMPTY),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockBasementLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_UNLOCKBASEMENTLEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2DevelopmentLineSegmentData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "fromNodeId",
                Self::VT_FROMNODEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("passingNodeIds", Self::VT_PASSINGNODEIDS, false)?
            .visit_field::<i32>("fromAxisPosX", Self::VT_FROMAXISPOSX, false)?
            .visit_field::<i32>("fromAxisPosY", Self::VT_FROMAXISPOSY, false)?
            .visit_field::<i32>("toAxisPosX", Self::VT_TOAXISPOSX, false)?
            .visit_field::<i32>("toAxisPosY", Self::VT_TOAXISPOSY, false)?
            .visit_field::<enum__Torappu_SandboxV2DevelopmentLineStyle>(
                "lineStyle",
                Self::VT_LINESTYLE,
                false,
            )?
            .visit_field::<i32>("unlockBasementLevel", Self::VT_UNLOCKBASEMENTLEVEL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2DevelopmentLineSegmentDataArgs<'a> {
    pub fromNodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub passingNodeIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub fromAxisPosX: i32,
    pub fromAxisPosY: i32,
    pub toAxisPosX: i32,
    pub toAxisPosY: i32,
    pub lineStyle: enum__Torappu_SandboxV2DevelopmentLineStyle,
    pub unlockBasementLevel: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2DevelopmentLineSegmentDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2DevelopmentLineSegmentDataArgs {
            fromNodeId: None,
            passingNodeIds: None,
            fromAxisPosX: 0,
            fromAxisPosY: 0,
            toAxisPosX: 0,
            toAxisPosY: 0,
            lineStyle: enum__Torappu_SandboxV2DevelopmentLineStyle::EMPTY,
            unlockBasementLevel: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2DevelopmentLineSegmentData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_SandboxV2DevelopmentLineSegmentData", 8)?;
        if let Some(f) = self.fromNodeId() {
            s.serialize_field("fromNodeId", &f)?;
        } else {
            s.skip_field("fromNodeId")?;
        }
        if let Some(f) = self.passingNodeIds() {
            s.serialize_field("passingNodeIds", &f)?;
        } else {
            s.skip_field("passingNodeIds")?;
        }
        s.serialize_field("fromAxisPosX", &self.fromAxisPosX())?;
        s.serialize_field("fromAxisPosY", &self.fromAxisPosY())?;
        s.serialize_field("toAxisPosX", &self.toAxisPosX())?;
        s.serialize_field("toAxisPosY", &self.toAxisPosY())?;
        s.serialize_field("lineStyle", &self.lineStyle())?;
        s.serialize_field("unlockBasementLevel", &self.unlockBasementLevel())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2DevelopmentLineSegmentDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2DevelopmentLineSegmentDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_fromNodeId(&mut self, fromNodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_FROMNODEID,
            fromNodeId,
        );
    }
    #[inline]
    pub fn add_passingNodeIds(
        &mut self,
        passingNodeIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_PASSINGNODEIDS,
            passingNodeIds,
        );
    }
    #[inline]
    pub fn add_fromAxisPosX(&mut self, fromAxisPosX: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_FROMAXISPOSX,
            fromAxisPosX,
            0,
        );
    }
    #[inline]
    pub fn add_fromAxisPosY(&mut self, fromAxisPosY: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_FROMAXISPOSY,
            fromAxisPosY,
            0,
        );
    }
    #[inline]
    pub fn add_toAxisPosX(&mut self, toAxisPosX: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_TOAXISPOSX,
            toAxisPosX,
            0,
        );
    }
    #[inline]
    pub fn add_toAxisPosY(&mut self, toAxisPosY: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_TOAXISPOSY,
            toAxisPosY,
            0,
        );
    }
    #[inline]
    pub fn add_lineStyle(&mut self, lineStyle: enum__Torappu_SandboxV2DevelopmentLineStyle) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2DevelopmentLineStyle>(
                clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_LINESTYLE,
                lineStyle,
                enum__Torappu_SandboxV2DevelopmentLineStyle::EMPTY,
            );
    }
    #[inline]
    pub fn add_unlockBasementLevel(&mut self, unlockBasementLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2DevelopmentLineSegmentData::VT_UNLOCKBASEMENTLEVEL,
            unlockBasementLevel,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2DevelopmentLineSegmentDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2DevelopmentLineSegmentDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentLineSegmentData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2DevelopmentLineSegmentData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2DevelopmentLineSegmentData");
        ds.field("fromNodeId", &self.fromNodeId());
        ds.field("passingNodeIds", &self.passingNodeIds());
        ds.field("fromAxisPosX", &self.fromAxisPosX());
        ds.field("fromAxisPosY", &self.fromAxisPosY());
        ds.field("toAxisPosX", &self.toAxisPosX());
        ds.field("toAxisPosY", &self.toAxisPosY());
        ds.field("lineStyle", &self.lineStyle());
        ds.field("unlockBasementLevel", &self.unlockBasementLevel());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2DevelopmentLineSegmentDataT {
    pub fromNodeId: Option<String>,
    pub passingNodeIds: Option<Vec<String>>,
    pub fromAxisPosX: i32,
    pub fromAxisPosY: i32,
    pub toAxisPosX: i32,
    pub toAxisPosY: i32,
    pub lineStyle: enum__Torappu_SandboxV2DevelopmentLineStyle,
    pub unlockBasementLevel: i32,
}
impl Default for clz_Torappu_SandboxV2DevelopmentLineSegmentDataT {
    fn default() -> Self {
        Self {
            fromNodeId: None,
            passingNodeIds: None,
            fromAxisPosX: 0,
            fromAxisPosY: 0,
            toAxisPosX: 0,
            toAxisPosY: 0,
            lineStyle: enum__Torappu_SandboxV2DevelopmentLineStyle::EMPTY,
            unlockBasementLevel: 0,
        }
    }
}
impl clz_Torappu_SandboxV2DevelopmentLineSegmentDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentLineSegmentData<'b>> {
        let fromNodeId = self.fromNodeId.as_ref().map(|x| _fbb.create_string(x));
        let passingNodeIds = self.passingNodeIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let fromAxisPosX = self.fromAxisPosX;
        let fromAxisPosY = self.fromAxisPosY;
        let toAxisPosX = self.toAxisPosX;
        let toAxisPosY = self.toAxisPosY;
        let lineStyle = self.lineStyle;
        let unlockBasementLevel = self.unlockBasementLevel;
        clz_Torappu_SandboxV2DevelopmentLineSegmentData::create(
            _fbb,
            &clz_Torappu_SandboxV2DevelopmentLineSegmentDataArgs {
                fromNodeId,
                passingNodeIds,
                fromAxisPosX,
                fromAxisPosY,
                toAxisPosX,
                toAxisPosY,
                lineStyle,
                unlockBasementLevel,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2BuildingNodeScoreDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2BuildingNodeScoreData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2BuildingNodeScoreData<'a> {
    type Inner = clz_Torappu_SandboxV2BuildingNodeScoreData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2BuildingNodeScoreData<'a> {
    pub const VT_NODEID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_LIMITSCORE: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2BuildingNodeScoreData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2BuildingNodeScoreDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BuildingNodeScoreData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2BuildingNodeScoreDataBuilder::new(_fbb);
        builder.add_limitScore(args.limitScore);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.nodeId {
            builder.add_nodeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2BuildingNodeScoreDataT {
        let nodeId = self.nodeId().map(|x| x.to_string());
        let sortId = self.sortId();
        let limitScore = self.limitScore();
        clz_Torappu_SandboxV2BuildingNodeScoreDataT {
            nodeId,
            sortId,
            limitScore,
        }
    }

    #[inline]
    pub fn nodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2BuildingNodeScoreData::VT_NODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BuildingNodeScoreData::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn limitScore(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2BuildingNodeScoreData::VT_LIMITSCORE,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2BuildingNodeScoreData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nodeId", Self::VT_NODEID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<i32>("limitScore", Self::VT_LIMITSCORE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2BuildingNodeScoreDataArgs<'a> {
    pub nodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub limitScore: i32,
}
impl<'a> Default for clz_Torappu_SandboxV2BuildingNodeScoreDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2BuildingNodeScoreDataArgs {
            nodeId: None,
            sortId: 0,
            limitScore: 0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2BuildingNodeScoreData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2BuildingNodeScoreData", 3)?;
        if let Some(f) = self.nodeId() {
            s.serialize_field("nodeId", &f)?;
        } else {
            s.skip_field("nodeId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.serialize_field("limitScore", &self.limitScore())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2BuildingNodeScoreDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2BuildingNodeScoreDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeId(&mut self, nodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2BuildingNodeScoreData::VT_NODEID,
            nodeId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BuildingNodeScoreData::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn add_limitScore(&mut self, limitScore: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2BuildingNodeScoreData::VT_LIMITSCORE,
            limitScore,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2BuildingNodeScoreDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2BuildingNodeScoreDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BuildingNodeScoreData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2BuildingNodeScoreData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2BuildingNodeScoreData");
        ds.field("nodeId", &self.nodeId());
        ds.field("sortId", &self.sortId());
        ds.field("limitScore", &self.limitScore());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2BuildingNodeScoreDataT {
    pub nodeId: Option<String>,
    pub sortId: i32,
    pub limitScore: i32,
}
impl Default for clz_Torappu_SandboxV2BuildingNodeScoreDataT {
    fn default() -> Self {
        Self {
            nodeId: None,
            sortId: 0,
            limitScore: 0,
        }
    }
}
impl clz_Torappu_SandboxV2BuildingNodeScoreDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2BuildingNodeScoreData<'b>> {
        let nodeId = self.nodeId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let limitScore = self.limitScore;
        clz_Torappu_SandboxV2BuildingNodeScoreData::create(
            _fbb,
            &clz_Torappu_SandboxV2BuildingNodeScoreDataArgs {
                nodeId,
                sortId,
                limitScore,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2BuildingNodeScoreData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BuildingNodeScoreData>>(
                    dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BuildingNodeScoreData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2BuildingNodeScoreData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2BuildingNodeScoreData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2BuildingNodeScoreData>>(
                dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2BuildingNodeScoreDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2SeasonDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2SeasonData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2SeasonData<'a> {
    type Inner = clz_Torappu_SandboxV2SeasonData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2SeasonData<'a> {
    pub const VT_SEASONTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_FUNCTIONDESC: flatbuffers::VOffsetT = 8;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
    pub const VT_COLOR: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2SeasonData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2SeasonDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2SeasonData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2SeasonDataBuilder::new(_fbb);
        if let Some(x) = args.color {
            builder.add_color(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.functionDesc {
            builder.add_functionDesc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_seasonType(args.seasonType);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2SeasonDataT {
        let seasonType = self.seasonType();
        let name = self.name().map(|x| x.to_string());
        let functionDesc = self.functionDesc().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let color = self.color().map(|x| x.to_string());
        clz_Torappu_SandboxV2SeasonDataT {
            seasonType,
            name,
            functionDesc,
            description,
            color,
        }
    }

    #[inline]
    pub fn seasonType(&self) -> enum__Torappu_SandboxV2SeasonType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2SeasonType>(
                    clz_Torappu_SandboxV2SeasonData::VT_SEASONTYPE,
                    Some(enum__Torappu_SandboxV2SeasonType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2SeasonData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn functionDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2SeasonData::VT_FUNCTIONDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2SeasonData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn color(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2SeasonData::VT_COLOR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2SeasonData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxV2SeasonType>(
                "seasonType",
                Self::VT_SEASONTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "functionDesc",
                Self::VT_FUNCTIONDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("color", Self::VT_COLOR, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2SeasonDataArgs<'a> {
    pub seasonType: enum__Torappu_SandboxV2SeasonType,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub functionDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub color: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2SeasonDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2SeasonDataArgs {
            seasonType: enum__Torappu_SandboxV2SeasonType::NONE,
            name: None,
            functionDesc: None,
            description: None,
            color: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2SeasonData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2SeasonData", 5)?;
        s.serialize_field("seasonType", &self.seasonType())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.functionDesc() {
            s.serialize_field("functionDesc", &f)?;
        } else {
            s.skip_field("functionDesc")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        if let Some(f) = self.color() {
            s.serialize_field("color", &f)?;
        } else {
            s.skip_field("color")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2SeasonDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2SeasonDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_seasonType(&mut self, seasonType: enum__Torappu_SandboxV2SeasonType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2SeasonType>(
            clz_Torappu_SandboxV2SeasonData::VT_SEASONTYPE,
            seasonType,
            enum__Torappu_SandboxV2SeasonType::NONE,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2SeasonData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_functionDesc(&mut self, functionDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2SeasonData::VT_FUNCTIONDESC,
            functionDesc,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2SeasonData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_color(&mut self, color: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2SeasonData::VT_COLOR,
            color,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2SeasonDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2SeasonDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2SeasonData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2SeasonData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2SeasonData");
        ds.field("seasonType", &self.seasonType());
        ds.field("name", &self.name());
        ds.field("functionDesc", &self.functionDesc());
        ds.field("description", &self.description());
        ds.field("color", &self.color());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2SeasonDataT {
    pub seasonType: enum__Torappu_SandboxV2SeasonType,
    pub name: Option<String>,
    pub functionDesc: Option<String>,
    pub description: Option<String>,
    pub color: Option<String>,
}
impl Default for clz_Torappu_SandboxV2SeasonDataT {
    fn default() -> Self {
        Self {
            seasonType: enum__Torappu_SandboxV2SeasonType::NONE,
            name: None,
            functionDesc: None,
            description: None,
            color: None,
        }
    }
}
impl clz_Torappu_SandboxV2SeasonDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2SeasonData<'b>> {
        let seasonType = self.seasonType;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let functionDesc = self.functionDesc.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let color = self.color.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2SeasonData::create(
            _fbb,
            &clz_Torappu_SandboxV2SeasonDataArgs {
                seasonType,
                name,
                functionDesc,
                description,
                color,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2SeasonDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2SeasonData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2SeasonData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2SeasonData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2SeasonData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2SeasonData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2SeasonDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2SeasonData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2SeasonDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2SeasonDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2SeasonDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2SeasonData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2SeasonData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2SeasonData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2SeasonData>>(
                    dict__string__clz_Torappu_SandboxV2SeasonData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2SeasonData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2SeasonData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2SeasonDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2SeasonData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2SeasonDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2SeasonDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2SeasonData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2SeasonData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2SeasonDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2SeasonDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2SeasonData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2SeasonData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2SeasonData>>(
                dict__string__clz_Torappu_SandboxV2SeasonData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2SeasonDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2SeasonDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2SeasonData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2SeasonData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2SeasonData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2SeasonData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2SeasonDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2SeasonDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2SeasonDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2SeasonDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2SeasonData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2SeasonData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2SeasonDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2ConfirmIconDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ConfirmIconData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ConfirmIconData<'a> {
    type Inner = clz_Torappu_SandboxV2ConfirmIconData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ConfirmIconData<'a> {
    pub const VT_ICONTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_ICONPICID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ConfirmIconData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ConfirmIconDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ConfirmIconData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ConfirmIconDataBuilder::new(_fbb);
        if let Some(x) = args.iconPicId {
            builder.add_iconPicId(x);
        }
        builder.add_iconType(args.iconType);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2ConfirmIconDataT {
        let iconType = self.iconType();
        let iconPicId = self.iconPicId().map(|x| x.to_string());
        clz_Torappu_SandboxV2ConfirmIconDataT {
            iconType,
            iconPicId,
        }
    }

    #[inline]
    pub fn iconType(&self) -> enum__Torappu_SandboxV2ConfirmIconType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2ConfirmIconType>(
                    clz_Torappu_SandboxV2ConfirmIconData::VT_ICONTYPE,
                    Some(enum__Torappu_SandboxV2ConfirmIconType::COMMON),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn iconPicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ConfirmIconData::VT_ICONPICID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ConfirmIconData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxV2ConfirmIconType>(
                "iconType",
                Self::VT_ICONTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "iconPicId",
                Self::VT_ICONPICID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ConfirmIconDataArgs<'a> {
    pub iconType: enum__Torappu_SandboxV2ConfirmIconType,
    pub iconPicId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ConfirmIconDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ConfirmIconDataArgs {
            iconType: enum__Torappu_SandboxV2ConfirmIconType::COMMON,
            iconPicId: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2ConfirmIconData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2ConfirmIconData", 2)?;
        s.serialize_field("iconType", &self.iconType())?;
        if let Some(f) = self.iconPicId() {
            s.serialize_field("iconPicId", &f)?;
        } else {
            s.skip_field("iconPicId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2ConfirmIconDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ConfirmIconDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_iconType(&mut self, iconType: enum__Torappu_SandboxV2ConfirmIconType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2ConfirmIconType>(
                clz_Torappu_SandboxV2ConfirmIconData::VT_ICONTYPE,
                iconType,
                enum__Torappu_SandboxV2ConfirmIconType::COMMON,
            );
    }
    #[inline]
    pub fn add_iconPicId(&mut self, iconPicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ConfirmIconData::VT_ICONPICID,
            iconPicId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ConfirmIconDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ConfirmIconDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ConfirmIconData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ConfirmIconData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ConfirmIconData");
        ds.field("iconType", &self.iconType());
        ds.field("iconPicId", &self.iconPicId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2ConfirmIconDataT {
    pub iconType: enum__Torappu_SandboxV2ConfirmIconType,
    pub iconPicId: Option<String>,
}
impl Default for clz_Torappu_SandboxV2ConfirmIconDataT {
    fn default() -> Self {
        Self {
            iconType: enum__Torappu_SandboxV2ConfirmIconType::COMMON,
            iconPicId: None,
        }
    }
}
impl clz_Torappu_SandboxV2ConfirmIconDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ConfirmIconData<'b>> {
        let iconType = self.iconType;
        let iconPicId = self.iconPicId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2ConfirmIconData::create(
            _fbb,
            &clz_Torappu_SandboxV2ConfirmIconDataArgs {
                iconType,
                iconPicId,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2TutorialRepoCharDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2TutorialRepoCharData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2TutorialRepoCharData<'a> {
    type Inner = clz_Torappu_SandboxV2TutorialRepoCharData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2TutorialRepoCharData<'a> {
    pub const VT_INSTID: flatbuffers::VOffsetT = 4;
    pub const VT_CHARID: flatbuffers::VOffsetT = 6;
    pub const VT_EVOLVEPHASE: flatbuffers::VOffsetT = 8;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 10;
    pub const VT_FAVORPOINT: flatbuffers::VOffsetT = 12;
    pub const VT_POTENTIALRANK: flatbuffers::VOffsetT = 14;
    pub const VT_MAINSKILLLV: flatbuffers::VOffsetT = 16;
    pub const VT_SPECSKILLLIST: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2TutorialRepoCharData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2TutorialRepoCharDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialRepoCharData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2TutorialRepoCharDataBuilder::new(_fbb);
        if let Some(x) = args.specSkillList {
            builder.add_specSkillList(x);
        }
        builder.add_mainSkillLv(args.mainSkillLv);
        builder.add_potentialRank(args.potentialRank);
        builder.add_favorPoint(args.favorPoint);
        builder.add_level(args.level);
        builder.add_evolvePhase(args.evolvePhase);
        if let Some(x) = args.charId {
            builder.add_charId(x);
        }
        builder.add_instId(args.instId);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2TutorialRepoCharDataT {
        let instId = self.instId();
        let charId = self.charId().map(|x| x.to_string());
        let evolvePhase = self.evolvePhase();
        let level = self.level();
        let favorPoint = self.favorPoint();
        let potentialRank = self.potentialRank();
        let mainSkillLv = self.mainSkillLv();
        let specSkillList = self.specSkillList().map(|x| x.into_iter().collect());
        clz_Torappu_SandboxV2TutorialRepoCharDataT {
            instId,
            charId,
            evolvePhase,
            level,
            favorPoint,
            potentialRank,
            mainSkillLv,
            specSkillList,
        }
    }

    #[inline]
    pub fn instId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2TutorialRepoCharData::VT_INSTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn charId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2TutorialRepoCharData::VT_CHARID,
                None,
            )
        }
    }
    #[inline]
    pub fn evolvePhase(&self) -> enum__Torappu_EvolvePhase {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_EvolvePhase>(
                    clz_Torappu_SandboxV2TutorialRepoCharData::VT_EVOLVEPHASE,
                    Some(enum__Torappu_EvolvePhase::PHASE_0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2TutorialRepoCharData::VT_LEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn favorPoint(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2TutorialRepoCharData::VT_FAVORPOINT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn potentialRank(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2TutorialRepoCharData::VT_POTENTIALRANK,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn mainSkillLv(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2TutorialRepoCharData::VT_MAINSKILLLV,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn specSkillList(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    clz_Torappu_SandboxV2TutorialRepoCharData::VT_SPECSKILLLIST,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2TutorialRepoCharData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("instId", Self::VT_INSTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("charId", Self::VT_CHARID, false)?
            .visit_field::<enum__Torappu_EvolvePhase>("evolvePhase", Self::VT_EVOLVEPHASE, false)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .visit_field::<i32>("favorPoint", Self::VT_FAVORPOINT, false)?
            .visit_field::<i32>("potentialRank", Self::VT_POTENTIALRANK, false)?
            .visit_field::<i32>("mainSkillLv", Self::VT_MAINSKILLLV, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "specSkillList",
                Self::VT_SPECSKILLLIST,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2TutorialRepoCharDataArgs<'a> {
    pub instId: i32,
    pub charId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub evolvePhase: enum__Torappu_EvolvePhase,
    pub level: i32,
    pub favorPoint: i32,
    pub potentialRank: i32,
    pub mainSkillLv: i32,
    pub specSkillList: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for clz_Torappu_SandboxV2TutorialRepoCharDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2TutorialRepoCharDataArgs {
            instId: 0,
            charId: None,
            evolvePhase: enum__Torappu_EvolvePhase::PHASE_0,
            level: 0,
            favorPoint: 0,
            potentialRank: 0,
            mainSkillLv: 0,
            specSkillList: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2TutorialRepoCharData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2TutorialRepoCharData", 8)?;
        s.serialize_field("instId", &self.instId())?;
        if let Some(f) = self.charId() {
            s.serialize_field("charId", &f)?;
        } else {
            s.skip_field("charId")?;
        }
        s.serialize_field("evolvePhase", &self.evolvePhase())?;
        s.serialize_field("level", &self.level())?;
        s.serialize_field("favorPoint", &self.favorPoint())?;
        s.serialize_field("potentialRank", &self.potentialRank())?;
        s.serialize_field("mainSkillLv", &self.mainSkillLv())?;
        if let Some(f) = self.specSkillList() {
            s.serialize_field("specSkillList", &f)?;
        } else {
            s.skip_field("specSkillList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2TutorialRepoCharDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2TutorialRepoCharDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_instId(&mut self, instId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2TutorialRepoCharData::VT_INSTID,
            instId,
            0,
        );
    }
    #[inline]
    pub fn add_charId(&mut self, charId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2TutorialRepoCharData::VT_CHARID,
            charId,
        );
    }
    #[inline]
    pub fn add_evolvePhase(&mut self, evolvePhase: enum__Torappu_EvolvePhase) {
        self.fbb_.push_slot::<enum__Torappu_EvolvePhase>(
            clz_Torappu_SandboxV2TutorialRepoCharData::VT_EVOLVEPHASE,
            evolvePhase,
            enum__Torappu_EvolvePhase::PHASE_0,
        );
    }
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2TutorialRepoCharData::VT_LEVEL,
            level,
            0,
        );
    }
    #[inline]
    pub fn add_favorPoint(&mut self, favorPoint: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2TutorialRepoCharData::VT_FAVORPOINT,
            favorPoint,
            0,
        );
    }
    #[inline]
    pub fn add_potentialRank(&mut self, potentialRank: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2TutorialRepoCharData::VT_POTENTIALRANK,
            potentialRank,
            0,
        );
    }
    #[inline]
    pub fn add_mainSkillLv(&mut self, mainSkillLv: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2TutorialRepoCharData::VT_MAINSKILLLV,
            mainSkillLv,
            0,
        );
    }
    #[inline]
    pub fn add_specSkillList(
        &mut self,
        specSkillList: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2TutorialRepoCharData::VT_SPECSKILLLIST,
            specSkillList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2TutorialRepoCharDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2TutorialRepoCharDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialRepoCharData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2TutorialRepoCharData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2TutorialRepoCharData");
        ds.field("instId", &self.instId());
        ds.field("charId", &self.charId());
        ds.field("evolvePhase", &self.evolvePhase());
        ds.field("level", &self.level());
        ds.field("favorPoint", &self.favorPoint());
        ds.field("potentialRank", &self.potentialRank());
        ds.field("mainSkillLv", &self.mainSkillLv());
        ds.field("specSkillList", &self.specSkillList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2TutorialRepoCharDataT {
    pub instId: i32,
    pub charId: Option<String>,
    pub evolvePhase: enum__Torappu_EvolvePhase,
    pub level: i32,
    pub favorPoint: i32,
    pub potentialRank: i32,
    pub mainSkillLv: i32,
    pub specSkillList: Option<Vec<i32>>,
}
impl Default for clz_Torappu_SandboxV2TutorialRepoCharDataT {
    fn default() -> Self {
        Self {
            instId: 0,
            charId: None,
            evolvePhase: enum__Torappu_EvolvePhase::PHASE_0,
            level: 0,
            favorPoint: 0,
            potentialRank: 0,
            mainSkillLv: 0,
            specSkillList: None,
        }
    }
}
impl clz_Torappu_SandboxV2TutorialRepoCharDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialRepoCharData<'b>> {
        let instId = self.instId;
        let charId = self.charId.as_ref().map(|x| _fbb.create_string(x));
        let evolvePhase = self.evolvePhase;
        let level = self.level;
        let favorPoint = self.favorPoint;
        let potentialRank = self.potentialRank;
        let mainSkillLv = self.mainSkillLv;
        let specSkillList = self.specSkillList.as_ref().map(|x| _fbb.create_vector(x));
        clz_Torappu_SandboxV2TutorialRepoCharData::create(
            _fbb,
            &clz_Torappu_SandboxV2TutorialRepoCharDataArgs {
                instId,
                charId,
                evolvePhase,
                level,
                favorPoint,
                potentialRank,
                mainSkillLv,
                specSkillList,
            },
        )
    }
}
pub enum dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'a> {
    type Inner = dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__clz_Torappu_SandboxV2TutorialRepoCharData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'bldr>> {
        let mut builder = dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataT {
        let key = self.key();
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    dict__int__clz_Torappu_SandboxV2TutorialRepoCharData::VT_KEY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__int__clz_Torappu_SandboxV2TutorialRepoCharData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2TutorialRepoCharData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2TutorialRepoCharData>>(
                    dict__int__clz_Torappu_SandboxV2TutorialRepoCharData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2TutorialRepoCharData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataArgs<'a> {
    pub key: i32,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialRepoCharData<'a>>>,
}
impl<'a> Default for dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataArgs {
            key: 0,
            value: None,
        }
    }
}

impl Serialize for dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__int__clz_Torappu_SandboxV2TutorialRepoCharData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_.push_slot::<i32>(
            dict__int__clz_Torappu_SandboxV2TutorialRepoCharData::VT_KEY,
            key,
            0,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialRepoCharData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialRepoCharData>>(
                dict__int__clz_Torappu_SandboxV2TutorialRepoCharData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__int__clz_Torappu_SandboxV2TutorialRepoCharData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataT {
    pub key: i32,
    pub value: Option<Box<clz_Torappu_SandboxV2TutorialRepoCharDataT>>,
}
impl Default for dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataT {
    fn default() -> Self {
        Self {
            key: 0,
            value: None,
        }
    }
}
impl dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'b>> {
        let key = self.key;
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__int__clz_Torappu_SandboxV2TutorialRepoCharData::create(
            _fbb,
            &dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2TutorialBasicConstOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2TutorialBasicConst<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2TutorialBasicConst<'a> {
    type Inner = clz_Torappu_SandboxV2TutorialBasicConst<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2TutorialBasicConst<'a> {
    pub const VT_TRAININGQUESTLIST: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2TutorialBasicConst { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2TutorialBasicConstArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialBasicConst<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2TutorialBasicConstBuilder::new(_fbb);
        if let Some(x) = args.trainingQuestList {
            builder.add_trainingQuestList(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2TutorialBasicConstT {
        let trainingQuestList = self
            .trainingQuestList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_SandboxV2TutorialBasicConstT { trainingQuestList }
    }

    #[inline]
    pub fn trainingQuestList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2TutorialBasicConst::VT_TRAININGQUESTLIST,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2TutorialBasicConst<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("trainingQuestList", Self::VT_TRAININGQUESTLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2TutorialBasicConstArgs<'a> {
    pub trainingQuestList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2TutorialBasicConstArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2TutorialBasicConstArgs {
            trainingQuestList: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2TutorialBasicConst<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2TutorialBasicConst", 1)?;
        if let Some(f) = self.trainingQuestList() {
            s.serialize_field("trainingQuestList", &f)?;
        } else {
            s.skip_field("trainingQuestList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2TutorialBasicConstBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2TutorialBasicConstBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_trainingQuestList(
        &mut self,
        trainingQuestList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2TutorialBasicConst::VT_TRAININGQUESTLIST,
            trainingQuestList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2TutorialBasicConstBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2TutorialBasicConstBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialBasicConst<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2TutorialBasicConst<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2TutorialBasicConst");
        ds.field("trainingQuestList", &self.trainingQuestList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2TutorialBasicConstT {
    pub trainingQuestList: Option<Vec<String>>,
}
impl Default for clz_Torappu_SandboxV2TutorialBasicConstT {
    fn default() -> Self {
        Self {
            trainingQuestList: None,
        }
    }
}
impl clz_Torappu_SandboxV2TutorialBasicConstT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialBasicConst<'b>> {
        let trainingQuestList = self.trainingQuestList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SandboxV2TutorialBasicConst::create(
            _fbb,
            &clz_Torappu_SandboxV2TutorialBasicConstArgs { trainingQuestList },
        )
    }
}
pub enum clz_Torappu_SandboxV2TutorialDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2TutorialData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2TutorialData<'a> {
    type Inner = clz_Torappu_SandboxV2TutorialData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2TutorialData<'a> {
    pub const VT_CHARREPODATA: flatbuffers::VOffsetT = 4;
    pub const VT_QUESTDATA: flatbuffers::VOffsetT = 6;
    pub const VT_GUIDEQUESTDATA: flatbuffers::VOffsetT = 8;
    pub const VT_QUESTLINEDATA: flatbuffers::VOffsetT = 10;
    pub const VT_BASICCONST: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2TutorialData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2TutorialDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2TutorialDataBuilder::new(_fbb);
        if let Some(x) = args.basicConst {
            builder.add_basicConst(x);
        }
        if let Some(x) = args.questLineData {
            builder.add_questLineData(x);
        }
        if let Some(x) = args.guideQuestData {
            builder.add_guideQuestData(x);
        }
        if let Some(x) = args.questData {
            builder.add_questData(x);
        }
        if let Some(x) = args.charRepoData {
            builder.add_charRepoData(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2TutorialDataT {
        let charRepoData = self
            .charRepoData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let questData = self
            .questData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let guideQuestData = self
            .guideQuestData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let questLineData = self
            .questLineData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let basicConst = self.basicConst().map(|x| Box::new(x.unpack()));
        clz_Torappu_SandboxV2TutorialDataT {
            charRepoData,
            questData,
            guideQuestData,
            questLineData,
            basicConst,
        }
    }

    #[inline]
    pub fn charRepoData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__int__clz_Torappu_SandboxV2TutorialRepoCharData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2TutorialData::VT_CHARREPODATA, None)
        }
    }
    #[inline]
    pub fn questData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestData>,
                >,
            >>(clz_Torappu_SandboxV2TutorialData::VT_QUESTDATA, None)
        }
    }
    #[inline]
    pub fn guideQuestData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData>,
                >,
            >>(clz_Torappu_SandboxV2TutorialData::VT_GUIDEQUESTDATA, None)
        }
    }
    #[inline]
    pub fn questLineData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestLineData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestLineData>,
                >,
            >>(clz_Torappu_SandboxV2TutorialData::VT_QUESTLINEDATA, None)
        }
    }
    #[inline]
    pub fn basicConst(&self) -> Option<clz_Torappu_SandboxV2TutorialBasicConst<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2TutorialBasicConst>>(
                    clz_Torappu_SandboxV2TutorialData::VT_BASICCONST,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2TutorialData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__int__clz_Torappu_SandboxV2TutorialRepoCharData,
                    >,
                >,
            >>("charRepoData", Self::VT_CHARREPODATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestData>,
                >,
            >>("questData", Self::VT_QUESTDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData>,
                >,
            >>("guideQuestData", Self::VT_GUIDEQUESTDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestLineData>,
                >,
            >>("questLineData", Self::VT_QUESTLINEDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2TutorialBasicConst>>(
                "basicConst",
                Self::VT_BASICCONST,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2TutorialDataArgs<'a> {
    pub charRepoData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'a>,
                >,
            >,
        >,
    >,
    pub questData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestData<'a>>,
            >,
        >,
    >,
    pub guideQuestData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData<'a>>,
            >,
        >,
    >,
    pub questLineData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestLineData<'a>>,
            >,
        >,
    >,
    pub basicConst: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialBasicConst<'a>>>,
}
impl<'a> Default for clz_Torappu_SandboxV2TutorialDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2TutorialDataArgs {
            charRepoData: None,
            questData: None,
            guideQuestData: None,
            questLineData: None,
            basicConst: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2TutorialData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2TutorialData", 5)?;
        if let Some(f) = self.charRepoData() {
            s.serialize_field("charRepoData", &f)?;
        } else {
            s.skip_field("charRepoData")?;
        }
        if let Some(f) = self.questData() {
            s.serialize_field("questData", &f)?;
        } else {
            s.skip_field("questData")?;
        }
        if let Some(f) = self.guideQuestData() {
            s.serialize_field("guideQuestData", &f)?;
        } else {
            s.skip_field("guideQuestData")?;
        }
        if let Some(f) = self.questLineData() {
            s.serialize_field("questLineData", &f)?;
        } else {
            s.skip_field("questLineData")?;
        }
        if let Some(f) = self.basicConst() {
            s.serialize_field("basicConst", &f)?;
        } else {
            s.skip_field("basicConst")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2TutorialDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2TutorialDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_charRepoData(
        &mut self,
        charRepoData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_SandboxV2TutorialRepoCharData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2TutorialData::VT_CHARREPODATA,
            charRepoData,
        );
    }
    #[inline]
    pub fn add_questData(
        &mut self,
        questData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2TutorialData::VT_QUESTDATA,
            questData,
        );
    }
    #[inline]
    pub fn add_guideQuestData(
        &mut self,
        guideQuestData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2TutorialData::VT_GUIDEQUESTDATA,
            guideQuestData,
        );
    }
    #[inline]
    pub fn add_questLineData(
        &mut self,
        questLineData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestLineData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2TutorialData::VT_QUESTLINEDATA,
            questLineData,
        );
    }
    #[inline]
    pub fn add_basicConst(
        &mut self,
        basicConst: flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialBasicConst<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialBasicConst>>(
                clz_Torappu_SandboxV2TutorialData::VT_BASICCONST,
                basicConst,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2TutorialDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2TutorialDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2TutorialData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2TutorialData");
        ds.field("charRepoData", &self.charRepoData());
        ds.field("questData", &self.questData());
        ds.field("guideQuestData", &self.guideQuestData());
        ds.field("questLineData", &self.questLineData());
        ds.field("basicConst", &self.basicConst());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2TutorialDataT {
    pub charRepoData: Option<Vec<dict__int__clz_Torappu_SandboxV2TutorialRepoCharDataT>>,
    pub questData: Option<Vec<dict__string__clz_Torappu_SandboxV2QuestDataT>>,
    pub guideQuestData: Option<Vec<dict__string__clz_Torappu_SandboxV2GuideQuestDataT>>,
    pub questLineData: Option<Vec<dict__string__clz_Torappu_SandboxV2QuestLineDataT>>,
    pub basicConst: Option<Box<clz_Torappu_SandboxV2TutorialBasicConstT>>,
}
impl Default for clz_Torappu_SandboxV2TutorialDataT {
    fn default() -> Self {
        Self {
            charRepoData: None,
            questData: None,
            guideQuestData: None,
            questLineData: None,
            basicConst: None,
        }
    }
}
impl clz_Torappu_SandboxV2TutorialDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialData<'b>> {
        let charRepoData = self.charRepoData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let questData = self.questData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let guideQuestData = self.guideQuestData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let questLineData = self.questLineData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let basicConst = self.basicConst.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_SandboxV2TutorialData::create(
            _fbb,
            &clz_Torappu_SandboxV2TutorialDataArgs {
                charRepoData,
                questData,
                guideQuestData,
                questLineData,
                basicConst,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2RacerBasicInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RacerBasicInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RacerBasicInfo<'a> {
    type Inner = clz_Torappu_SandboxV2RacerBasicInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RacerBasicInfo<'a> {
    pub const VT_RACERID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_RACERNAME: flatbuffers::VOffsetT = 8;
    pub const VT_ITEMID: flatbuffers::VOffsetT = 10;
    pub const VT_ATTRIBUTEMAXVALUE: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RacerBasicInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RacerBasicInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerBasicInfo<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RacerBasicInfoBuilder::new(_fbb);
        if let Some(x) = args.attributeMaxValue {
            builder.add_attributeMaxValue(x);
        }
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        if let Some(x) = args.racerName {
            builder.add_racerName(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.racerId {
            builder.add_racerId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2RacerBasicInfoT {
        let racerId = self.racerId().map(|x| x.to_string());
        let sortId = self.sortId();
        let racerName = self.racerName().map(|x| x.to_string());
        let itemId = self.itemId().map(|x| x.to_string());
        let attributeMaxValue = self.attributeMaxValue().map(|x| x.into_iter().collect());
        clz_Torappu_SandboxV2RacerBasicInfoT {
            racerId,
            sortId,
            racerName,
            itemId,
            attributeMaxValue,
        }
    }

    #[inline]
    pub fn racerId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerBasicInfo::VT_RACERID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2RacerBasicInfo::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn racerName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerBasicInfo::VT_RACERNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerBasicInfo::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn attributeMaxValue(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    clz_Torappu_SandboxV2RacerBasicInfo::VT_ATTRIBUTEMAXVALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RacerBasicInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("racerId", Self::VT_RACERID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "racerName",
                Self::VT_RACERNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "attributeMaxValue",
                Self::VT_ATTRIBUTEMAXVALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RacerBasicInfoArgs<'a> {
    pub racerId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub racerName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub attributeMaxValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for clz_Torappu_SandboxV2RacerBasicInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RacerBasicInfoArgs {
            racerId: None,
            sortId: 0,
            racerName: None,
            itemId: None,
            attributeMaxValue: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2RacerBasicInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2RacerBasicInfo", 5)?;
        if let Some(f) = self.racerId() {
            s.serialize_field("racerId", &f)?;
        } else {
            s.skip_field("racerId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.racerName() {
            s.serialize_field("racerName", &f)?;
        } else {
            s.skip_field("racerName")?;
        }
        if let Some(f) = self.itemId() {
            s.serialize_field("itemId", &f)?;
        } else {
            s.skip_field("itemId")?;
        }
        if let Some(f) = self.attributeMaxValue() {
            s.serialize_field("attributeMaxValue", &f)?;
        } else {
            s.skip_field("attributeMaxValue")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2RacerBasicInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RacerBasicInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_racerId(&mut self, racerId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerBasicInfo::VT_RACERID,
            racerId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2RacerBasicInfo::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_racerName(&mut self, racerName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerBasicInfo::VT_RACERNAME,
            racerName,
        );
    }
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerBasicInfo::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_attributeMaxValue(
        &mut self,
        attributeMaxValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerBasicInfo::VT_ATTRIBUTEMAXVALUE,
            attributeMaxValue,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RacerBasicInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RacerBasicInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerBasicInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RacerBasicInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RacerBasicInfo");
        ds.field("racerId", &self.racerId());
        ds.field("sortId", &self.sortId());
        ds.field("racerName", &self.racerName());
        ds.field("itemId", &self.itemId());
        ds.field("attributeMaxValue", &self.attributeMaxValue());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2RacerBasicInfoT {
    pub racerId: Option<String>,
    pub sortId: i32,
    pub racerName: Option<String>,
    pub itemId: Option<String>,
    pub attributeMaxValue: Option<Vec<i32>>,
}
impl Default for clz_Torappu_SandboxV2RacerBasicInfoT {
    fn default() -> Self {
        Self {
            racerId: None,
            sortId: 0,
            racerName: None,
            itemId: None,
            attributeMaxValue: None,
        }
    }
}
impl clz_Torappu_SandboxV2RacerBasicInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerBasicInfo<'b>> {
        let racerId = self.racerId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let racerName = self.racerName.as_ref().map(|x| _fbb.create_string(x));
        let itemId = self.itemId.as_ref().map(|x| _fbb.create_string(x));
        let attributeMaxValue = self
            .attributeMaxValue
            .as_ref()
            .map(|x| _fbb.create_vector(x));
        clz_Torappu_SandboxV2RacerBasicInfo::create(
            _fbb,
            &clz_Torappu_SandboxV2RacerBasicInfoArgs {
                racerId,
                sortId,
                racerName,
                itemId,
                attributeMaxValue,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RacerBasicInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RacerBasicInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RacerBasicInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2RacerBasicInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2RacerBasicInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2RacerBasicInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RacerBasicInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2RacerBasicInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RacerBasicInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacerBasicInfo>>(
                    dict__string__clz_Torappu_SandboxV2RacerBasicInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacerBasicInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RacerBasicInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerBasicInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RacerBasicInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RacerBasicInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2RacerBasicInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RacerBasicInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RacerBasicInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RacerBasicInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerBasicInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerBasicInfo>>(
                dict__string__clz_Torappu_SandboxV2RacerBasicInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RacerBasicInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RacerBasicInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RacerBasicInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RacerBasicInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2RacerBasicInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2RacerBasicInfoT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2RacerBasicInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2RacerBasicInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2RacerBasicInfo::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2RacerBasicInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2RacerTalentInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RacerTalentInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RacerTalentInfo<'a> {
    type Inner = clz_Torappu_SandboxV2RacerTalentInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RacerTalentInfo<'a> {
    pub const VT_TALENTID: flatbuffers::VOffsetT = 4;
    pub const VT_TALENTTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_TALENTICONID: flatbuffers::VOffsetT = 8;
    pub const VT_DESC: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RacerTalentInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RacerTalentInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerTalentInfo<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RacerTalentInfoBuilder::new(_fbb);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.talentIconId {
            builder.add_talentIconId(x);
        }
        builder.add_talentType(args.talentType);
        if let Some(x) = args.talentId {
            builder.add_talentId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2RacerTalentInfoT {
        let talentId = self.talentId().map(|x| x.to_string());
        let talentType = self.talentType();
        let talentIconId = self.talentIconId().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        clz_Torappu_SandboxV2RacerTalentInfoT {
            talentId,
            talentType,
            talentIconId,
            desc,
        }
    }

    #[inline]
    pub fn talentId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerTalentInfo::VT_TALENTID,
                None,
            )
        }
    }
    #[inline]
    pub fn talentType(&self) -> enum__Torappu_SandboxV2RacerTalentType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2RacerTalentType>(
                    clz_Torappu_SandboxV2RacerTalentInfo::VT_TALENTTYPE,
                    Some(enum__Torappu_SandboxV2RacerTalentType::BORN),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn talentIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerTalentInfo::VT_TALENTICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerTalentInfo::VT_DESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RacerTalentInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "talentId",
                Self::VT_TALENTID,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxV2RacerTalentType>(
                "talentType",
                Self::VT_TALENTTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "talentIconId",
                Self::VT_TALENTICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RacerTalentInfoArgs<'a> {
    pub talentId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub talentType: enum__Torappu_SandboxV2RacerTalentType,
    pub talentIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2RacerTalentInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RacerTalentInfoArgs {
            talentId: None,
            talentType: enum__Torappu_SandboxV2RacerTalentType::BORN,
            talentIconId: None,
            desc: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2RacerTalentInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2RacerTalentInfo", 4)?;
        if let Some(f) = self.talentId() {
            s.serialize_field("talentId", &f)?;
        } else {
            s.skip_field("talentId")?;
        }
        s.serialize_field("talentType", &self.talentType())?;
        if let Some(f) = self.talentIconId() {
            s.serialize_field("talentIconId", &f)?;
        } else {
            s.skip_field("talentIconId")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2RacerTalentInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RacerTalentInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_talentId(&mut self, talentId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerTalentInfo::VT_TALENTID,
            talentId,
        );
    }
    #[inline]
    pub fn add_talentType(&mut self, talentType: enum__Torappu_SandboxV2RacerTalentType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxV2RacerTalentType>(
                clz_Torappu_SandboxV2RacerTalentInfo::VT_TALENTTYPE,
                talentType,
                enum__Torappu_SandboxV2RacerTalentType::BORN,
            );
    }
    #[inline]
    pub fn add_talentIconId(&mut self, talentIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerTalentInfo::VT_TALENTICONID,
            talentIconId,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerTalentInfo::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RacerTalentInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RacerTalentInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerTalentInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RacerTalentInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RacerTalentInfo");
        ds.field("talentId", &self.talentId());
        ds.field("talentType", &self.talentType());
        ds.field("talentIconId", &self.talentIconId());
        ds.field("desc", &self.desc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2RacerTalentInfoT {
    pub talentId: Option<String>,
    pub talentType: enum__Torappu_SandboxV2RacerTalentType,
    pub talentIconId: Option<String>,
    pub desc: Option<String>,
}
impl Default for clz_Torappu_SandboxV2RacerTalentInfoT {
    fn default() -> Self {
        Self {
            talentId: None,
            talentType: enum__Torappu_SandboxV2RacerTalentType::BORN,
            talentIconId: None,
            desc: None,
        }
    }
}
impl clz_Torappu_SandboxV2RacerTalentInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerTalentInfo<'b>> {
        let talentId = self.talentId.as_ref().map(|x| _fbb.create_string(x));
        let talentType = self.talentType;
        let talentIconId = self.talentIconId.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2RacerTalentInfo::create(
            _fbb,
            &clz_Torappu_SandboxV2RacerTalentInfoArgs {
                talentId,
                talentType,
                talentIconId,
                desc,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RacerTalentInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RacerTalentInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RacerTalentInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2RacerTalentInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2RacerTalentInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2RacerTalentInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RacerTalentInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2RacerTalentInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RacerTalentInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacerTalentInfo>>(
                    dict__string__clz_Torappu_SandboxV2RacerTalentInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacerTalentInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RacerTalentInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerTalentInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RacerTalentInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RacerTalentInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2RacerTalentInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RacerTalentInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RacerTalentInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RacerTalentInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerTalentInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerTalentInfo>>(
                dict__string__clz_Torappu_SandboxV2RacerTalentInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RacerTalentInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RacerTalentInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RacerTalentInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RacerTalentInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2RacerTalentInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2RacerTalentInfoT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2RacerTalentInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2RacerTalentInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2RacerTalentInfo::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2RacerTalentInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2RacerNameInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RacerNameInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RacerNameInfo<'a> {
    type Inner = clz_Torappu_SandboxV2RacerNameInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RacerNameInfo<'a> {
    pub const VT_NAMEID: flatbuffers::VOffsetT = 4;
    pub const VT_NAMETYPE: flatbuffers::VOffsetT = 6;
    pub const VT_NAMEDESC: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RacerNameInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RacerNameInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerNameInfo<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RacerNameInfoBuilder::new(_fbb);
        if let Some(x) = args.nameDesc {
            builder.add_nameDesc(x);
        }
        builder.add_nameType(args.nameType);
        if let Some(x) = args.nameId {
            builder.add_nameId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2RacerNameInfoT {
        let nameId = self.nameId().map(|x| x.to_string());
        let nameType = self.nameType();
        let nameDesc = self.nameDesc().map(|x| x.to_string());
        clz_Torappu_SandboxV2RacerNameInfoT {
            nameId,
            nameType,
            nameDesc,
        }
    }

    #[inline]
    pub fn nameId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerNameInfo::VT_NAMEID,
                None,
            )
        }
    }
    #[inline]
    pub fn nameType(&self) -> enum__Torappu_SandboxV2RacerNameType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxV2RacerNameType>(
                    clz_Torappu_SandboxV2RacerNameInfo::VT_NAMETYPE,
                    Some(enum__Torappu_SandboxV2RacerNameType::PREFIX),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn nameDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerNameInfo::VT_NAMEDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RacerNameInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nameId", Self::VT_NAMEID, false)?
            .visit_field::<enum__Torappu_SandboxV2RacerNameType>(
                "nameType",
                Self::VT_NAMETYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nameDesc",
                Self::VT_NAMEDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RacerNameInfoArgs<'a> {
    pub nameId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nameType: enum__Torappu_SandboxV2RacerNameType,
    pub nameDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2RacerNameInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RacerNameInfoArgs {
            nameId: None,
            nameType: enum__Torappu_SandboxV2RacerNameType::PREFIX,
            nameDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2RacerNameInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2RacerNameInfo", 3)?;
        if let Some(f) = self.nameId() {
            s.serialize_field("nameId", &f)?;
        } else {
            s.skip_field("nameId")?;
        }
        s.serialize_field("nameType", &self.nameType())?;
        if let Some(f) = self.nameDesc() {
            s.serialize_field("nameDesc", &f)?;
        } else {
            s.skip_field("nameDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2RacerNameInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RacerNameInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nameId(&mut self, nameId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerNameInfo::VT_NAMEID,
            nameId,
        );
    }
    #[inline]
    pub fn add_nameType(&mut self, nameType: enum__Torappu_SandboxV2RacerNameType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxV2RacerNameType>(
            clz_Torappu_SandboxV2RacerNameInfo::VT_NAMETYPE,
            nameType,
            enum__Torappu_SandboxV2RacerNameType::PREFIX,
        );
    }
    #[inline]
    pub fn add_nameDesc(&mut self, nameDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerNameInfo::VT_NAMEDESC,
            nameDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RacerNameInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RacerNameInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerNameInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RacerNameInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RacerNameInfo");
        ds.field("nameId", &self.nameId());
        ds.field("nameType", &self.nameType());
        ds.field("nameDesc", &self.nameDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2RacerNameInfoT {
    pub nameId: Option<String>,
    pub nameType: enum__Torappu_SandboxV2RacerNameType,
    pub nameDesc: Option<String>,
}
impl Default for clz_Torappu_SandboxV2RacerNameInfoT {
    fn default() -> Self {
        Self {
            nameId: None,
            nameType: enum__Torappu_SandboxV2RacerNameType::PREFIX,
            nameDesc: None,
        }
    }
}
impl clz_Torappu_SandboxV2RacerNameInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerNameInfo<'b>> {
        let nameId = self.nameId.as_ref().map(|x| _fbb.create_string(x));
        let nameType = self.nameType;
        let nameDesc = self.nameDesc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2RacerNameInfo::create(
            _fbb,
            &clz_Torappu_SandboxV2RacerNameInfoArgs {
                nameId,
                nameType,
                nameDesc,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RacerNameInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RacerNameInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RacerNameInfo<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RacerNameInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RacerNameInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RacerNameInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RacerNameInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacerNameInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2RacerNameInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2RacerNameInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2RacerNameInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RacerNameInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2RacerNameInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RacerNameInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacerNameInfo>>(
                    dict__string__clz_Torappu_SandboxV2RacerNameInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RacerNameInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacerNameInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RacerNameInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerNameInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RacerNameInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RacerNameInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2RacerNameInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2RacerNameInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RacerNameInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RacerNameInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RacerNameInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerNameInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerNameInfo>>(
                dict__string__clz_Torappu_SandboxV2RacerNameInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RacerNameInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RacerNameInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacerNameInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RacerNameInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RacerNameInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RacerNameInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2RacerNameInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2RacerNameInfoT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2RacerNameInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2RacerNameInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacerNameInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2RacerNameInfo::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2RacerNameInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2RacerMedalInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RacerMedalInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RacerMedalInfo<'a> {
    type Inner = clz_Torappu_SandboxV2RacerMedalInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RacerMedalInfo<'a> {
    pub const VT_MEDALID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_NAME: flatbuffers::VOffsetT = 8;
    pub const VT_DESC: flatbuffers::VOffsetT = 10;
    pub const VT_ICONID: flatbuffers::VOffsetT = 12;
    pub const VT_SMALLICONID: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RacerMedalInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RacerMedalInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerMedalInfo<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RacerMedalInfoBuilder::new(_fbb);
        if let Some(x) = args.smallIconId {
            builder.add_smallIconId(x);
        }
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.medalId {
            builder.add_medalId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2RacerMedalInfoT {
        let medalId = self.medalId().map(|x| x.to_string());
        let sortId = self.sortId();
        let name = self.name().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let iconId = self.iconId().map(|x| x.to_string());
        let smallIconId = self.smallIconId().map(|x| x.to_string());
        clz_Torappu_SandboxV2RacerMedalInfoT {
            medalId,
            sortId,
            name,
            desc,
            iconId,
            smallIconId,
        }
    }

    #[inline]
    pub fn medalId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerMedalInfo::VT_MEDALID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxV2RacerMedalInfo::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerMedalInfo::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerMedalInfo::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerMedalInfo::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn smallIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacerMedalInfo::VT_SMALLICONID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RacerMedalInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("medalId", Self::VT_MEDALID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "smallIconId",
                Self::VT_SMALLICONID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RacerMedalInfoArgs<'a> {
    pub medalId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub smallIconId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2RacerMedalInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RacerMedalInfoArgs {
            medalId: None,
            sortId: 0,
            name: None,
            desc: None,
            iconId: None,
            smallIconId: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2RacerMedalInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2RacerMedalInfo", 6)?;
        if let Some(f) = self.medalId() {
            s.serialize_field("medalId", &f)?;
        } else {
            s.skip_field("medalId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.iconId() {
            s.serialize_field("iconId", &f)?;
        } else {
            s.skip_field("iconId")?;
        }
        if let Some(f) = self.smallIconId() {
            s.serialize_field("smallIconId", &f)?;
        } else {
            s.skip_field("smallIconId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2RacerMedalInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RacerMedalInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_medalId(&mut self, medalId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerMedalInfo::VT_MEDALID,
            medalId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxV2RacerMedalInfo::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerMedalInfo::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerMedalInfo::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerMedalInfo::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_smallIconId(&mut self, smallIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacerMedalInfo::VT_SMALLICONID,
            smallIconId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RacerMedalInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RacerMedalInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerMedalInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RacerMedalInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RacerMedalInfo");
        ds.field("medalId", &self.medalId());
        ds.field("sortId", &self.sortId());
        ds.field("name", &self.name());
        ds.field("desc", &self.desc());
        ds.field("iconId", &self.iconId());
        ds.field("smallIconId", &self.smallIconId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2RacerMedalInfoT {
    pub medalId: Option<String>,
    pub sortId: i32,
    pub name: Option<String>,
    pub desc: Option<String>,
    pub iconId: Option<String>,
    pub smallIconId: Option<String>,
}
impl Default for clz_Torappu_SandboxV2RacerMedalInfoT {
    fn default() -> Self {
        Self {
            medalId: None,
            sortId: 0,
            name: None,
            desc: None,
            iconId: None,
            smallIconId: None,
        }
    }
}
impl clz_Torappu_SandboxV2RacerMedalInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerMedalInfo<'b>> {
        let medalId = self.medalId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let iconId = self.iconId.as_ref().map(|x| _fbb.create_string(x));
        let smallIconId = self.smallIconId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2RacerMedalInfo::create(
            _fbb,
            &clz_Torappu_SandboxV2RacerMedalInfoArgs {
                medalId,
                sortId,
                name,
                desc,
                iconId,
                smallIconId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RacerMedalInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RacerMedalInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RacerMedalInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2RacerMedalInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2RacerMedalInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2RacerMedalInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RacerMedalInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2RacerMedalInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RacerMedalInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacerMedalInfo>>(
                    dict__string__clz_Torappu_SandboxV2RacerMedalInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacerMedalInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RacerMedalInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerMedalInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RacerMedalInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RacerMedalInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2RacerMedalInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RacerMedalInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RacerMedalInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RacerMedalInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerMedalInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacerMedalInfo>>(
                dict__string__clz_Torappu_SandboxV2RacerMedalInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RacerMedalInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RacerMedalInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RacerMedalInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RacerMedalInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2RacerMedalInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2RacerMedalInfoT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2RacerMedalInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2RacerMedalInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2RacerMedalInfo::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2RacerMedalInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2RacingItemInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RacingItemInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RacingItemInfo<'a> {
    type Inner = clz_Torappu_SandboxV2RacingItemInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RacingItemInfo<'a> {
    pub const VT_RACERITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_ICONID: flatbuffers::VOffsetT = 8;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RacingItemInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RacingItemInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingItemInfo<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RacingItemInfoBuilder::new(_fbb);
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.racerItemId {
            builder.add_racerItemId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2RacingItemInfoT {
        let racerItemId = self.racerItemId().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let iconId = self.iconId().map(|x| x.to_string());
        let blackboard = self
            .blackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_SandboxV2RacingItemInfoT {
            racerItemId,
            name,
            iconId,
            blackboard,
        }
    }

    #[inline]
    pub fn racerItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingItemInfo::VT_RACERITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingItemInfo::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingItemInfo::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(clz_Torappu_SandboxV2RacingItemInfo::VT_BLACKBOARD, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RacingItemInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "racerItemId",
                Self::VT_RACERITEMID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RacingItemInfoArgs<'a> {
    pub racerItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2RacingItemInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RacingItemInfoArgs {
            racerItemId: None,
            name: None,
            iconId: None,
            blackboard: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2RacingItemInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2RacingItemInfo", 4)?;
        if let Some(f) = self.racerItemId() {
            s.serialize_field("racerItemId", &f)?;
        } else {
            s.skip_field("racerItemId")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.iconId() {
            s.serialize_field("iconId", &f)?;
        } else {
            s.skip_field("iconId")?;
        }
        if let Some(f) = self.blackboard() {
            s.serialize_field("blackboard", &f)?;
        } else {
            s.skip_field("blackboard")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2RacingItemInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RacingItemInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_racerItemId(&mut self, racerItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingItemInfo::VT_RACERITEMID,
            racerItemId,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingItemInfo::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingItemInfo::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingItemInfo::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RacingItemInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RacingItemInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingItemInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RacingItemInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RacingItemInfo");
        ds.field("racerItemId", &self.racerItemId());
        ds.field("name", &self.name());
        ds.field("iconId", &self.iconId());
        ds.field("blackboard", &self.blackboard());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2RacingItemInfoT {
    pub racerItemId: Option<String>,
    pub name: Option<String>,
    pub iconId: Option<String>,
    pub blackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
}
impl Default for clz_Torappu_SandboxV2RacingItemInfoT {
    fn default() -> Self {
        Self {
            racerItemId: None,
            name: None,
            iconId: None,
            blackboard: None,
        }
    }
}
impl clz_Torappu_SandboxV2RacingItemInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingItemInfo<'b>> {
        let racerItemId = self.racerItemId.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let iconId = self.iconId.as_ref().map(|x| _fbb.create_string(x));
        let blackboard = self.blackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SandboxV2RacingItemInfo::create(
            _fbb,
            &clz_Torappu_SandboxV2RacingItemInfoArgs {
                racerItemId,
                name,
                iconId,
                blackboard,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2RacingItemInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2RacingItemInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2RacingItemInfo<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2RacingItemInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2RacingItemInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2RacingItemInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2RacingItemInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacingItemInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2RacingItemInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2RacingItemInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2RacingItemInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2RacingItemInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2RacingItemInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2RacingItemInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacingItemInfo>>(
                    dict__string__clz_Torappu_SandboxV2RacingItemInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2RacingItemInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacingItemInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2RacingItemInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingItemInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2RacingItemInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2RacingItemInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2RacingItemInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2RacingItemInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2RacingItemInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2RacingItemInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2RacingItemInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingItemInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingItemInfo>>(
                dict__string__clz_Torappu_SandboxV2RacingItemInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2RacingItemInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2RacingItemInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacingItemInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2RacingItemInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2RacingItemInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2RacingItemInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2RacingItemInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2RacingItemInfoT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2RacingItemInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2RacingItemInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2RacingItemInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2RacingItemInfo::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2RacingItemInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2RacingConstDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RacingConstData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RacingConstData<'a> {
    type Inner = clz_Torappu_SandboxV2RacingConstData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RacingConstData<'a> {
    pub const VT_ATTRIBUTENAMELIST: flatbuffers::VOffsetT = 4;
    pub const VT_RACERMAXVALUE: flatbuffers::VOffsetT = 6;
    pub const VT_BAGFULLHINTPERCENT: flatbuffers::VOffsetT = 8;
    pub const VT_TEMPBAGFULLHINTPERCENT: flatbuffers::VOffsetT = 10;
    pub const VT_BAGNAME: flatbuffers::VOffsetT = 12;
    pub const VT_TEMPBAGNAME: flatbuffers::VOffsetT = 14;
    pub const VT_BAGEMPTYLEFTDESC: flatbuffers::VOffsetT = 16;
    pub const VT_BAGEMPTYRIGHTDESC: flatbuffers::VOffsetT = 18;
    pub const VT_TEMPBAGEMPTYLEFTDESC: flatbuffers::VOffsetT = 20;
    pub const VT_TEMPBAGEMPTYRIGHTDESC: flatbuffers::VOffsetT = 22;
    pub const VT_BORNTALENTICONID: flatbuffers::VOffsetT = 24;
    pub const VT_BORNTALENTTITLE: flatbuffers::VOffsetT = 26;
    pub const VT_LEARNEDTALENTICONID: flatbuffers::VOffsetT = 28;
    pub const VT_LEARNEDTALENTTITLE: flatbuffers::VOffsetT = 30;
    pub const VT_TALENTEMPTYDESC: flatbuffers::VOffsetT = 32;
    pub const VT_SLUGITEMID: flatbuffers::VOffsetT = 34;
    pub const VT_RACINGHPFACTOR: flatbuffers::VOffsetT = 36;
    pub const VT_RACINGSPEEDFACTOR: flatbuffers::VOffsetT = 38;
    pub const VT_RACINGACCELERATIONFACTOR: flatbuffers::VOffsetT = 40;
    pub const VT_RECOVERMOVESPEED: flatbuffers::VOffsetT = 42;
    pub const VT_RECOVERHPFACTOR: flatbuffers::VOffsetT = 44;
    pub const VT_BLEEDINGFACTOR: flatbuffers::VOffsetT = 46;
    pub const VT_MAXSTEERINGFACTOR: flatbuffers::VOffsetT = 48;
    pub const VT_STEERINGMASSLEVELFACTOR: flatbuffers::VOffsetT = 50;
    pub const VT_STEERINGMOVESPEEDFACTOR: flatbuffers::VOffsetT = 52;
    pub const VT_SAFEANGLECOS: flatbuffers::VOffsetT = 54;
    pub const VT_SAFECOLLISIONFORCELEVEL: flatbuffers::VOffsetT = 56;
    pub const VT_TILECOLLISIONFACTOR: flatbuffers::VOffsetT = 58;
    pub const VT_COLLISIONFORCESECTOR: flatbuffers::VOffsetT = 60;
    pub const VT_COLLISIONFORCELEVEL: flatbuffers::VOffsetT = 62;
    pub const VT_COLLISIONSPEEDLOSS: flatbuffers::VOffsetT = 64;
    pub const VT_COLLISIONHPLOSS: flatbuffers::VOffsetT = 66;
    pub const VT_TILECOLLISIONSPEEDLOSS: flatbuffers::VOffsetT = 68;
    pub const VT_TILECOLLISIONHPLOSS: flatbuffers::VOffsetT = 70;
    pub const VT_AUTOUSEITEMTIMERANGE: flatbuffers::VOffsetT = 72;
    pub const VT_RECOVERACCELERATION: flatbuffers::VOffsetT = 74;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RacingConstData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RacingConstDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingConstData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RacingConstDataBuilder::new(_fbb);
        builder.add_recoverAcceleration(args.recoverAcceleration);
        if let Some(x) = args.autoUseItemTimeRange {
            builder.add_autoUseItemTimeRange(x);
        }
        if let Some(x) = args.tileCollisionHpLoss {
            builder.add_tileCollisionHpLoss(x);
        }
        if let Some(x) = args.tileCollisionSpeedLoss {
            builder.add_tileCollisionSpeedLoss(x);
        }
        if let Some(x) = args.collisionHpLoss {
            builder.add_collisionHpLoss(x);
        }
        if let Some(x) = args.collisionSpeedLoss {
            builder.add_collisionSpeedLoss(x);
        }
        if let Some(x) = args.collisionForceLevel {
            builder.add_collisionForceLevel(x);
        }
        if let Some(x) = args.collisionForceSector {
            builder.add_collisionForceSector(x);
        }
        builder.add_tileCollisionFactor(args.tileCollisionFactor);
        builder.add_safeCollisionForceLevel(args.safeCollisionForceLevel);
        builder.add_safeAngleCos(args.safeAngleCos);
        builder.add_steeringMoveSpeedFactor(args.steeringMoveSpeedFactor);
        builder.add_steeringMassLevelFactor(args.steeringMassLevelFactor);
        builder.add_maxSteeringFactor(args.maxSteeringFactor);
        builder.add_bleedingFactor(args.bleedingFactor);
        builder.add_recoverHpFactor(args.recoverHpFactor);
        builder.add_recoverMoveSpeed(args.recoverMoveSpeed);
        builder.add_racingAccelerationFactor(args.racingAccelerationFactor);
        builder.add_racingSpeedFactor(args.racingSpeedFactor);
        builder.add_racingHpFactor(args.racingHpFactor);
        if let Some(x) = args.slugItemId {
            builder.add_slugItemId(x);
        }
        if let Some(x) = args.talentEmptyDesc {
            builder.add_talentEmptyDesc(x);
        }
        if let Some(x) = args.learnedTalentTitle {
            builder.add_learnedTalentTitle(x);
        }
        if let Some(x) = args.learnedTalentIconId {
            builder.add_learnedTalentIconId(x);
        }
        if let Some(x) = args.bornTalentTitle {
            builder.add_bornTalentTitle(x);
        }
        if let Some(x) = args.bornTalentIconId {
            builder.add_bornTalentIconId(x);
        }
        if let Some(x) = args.tempBagEmptyRightDesc {
            builder.add_tempBagEmptyRightDesc(x);
        }
        if let Some(x) = args.tempBagEmptyLeftDesc {
            builder.add_tempBagEmptyLeftDesc(x);
        }
        if let Some(x) = args.bagEmptyRightDesc {
            builder.add_bagEmptyRightDesc(x);
        }
        if let Some(x) = args.bagEmptyLeftDesc {
            builder.add_bagEmptyLeftDesc(x);
        }
        if let Some(x) = args.tempBagName {
            builder.add_tempBagName(x);
        }
        if let Some(x) = args.bagName {
            builder.add_bagName(x);
        }
        builder.add_tempBagFullHintPercent(args.tempBagFullHintPercent);
        builder.add_bagFullHintPercent(args.bagFullHintPercent);
        if let Some(x) = args.racerMaxValue {
            builder.add_racerMaxValue(x);
        }
        if let Some(x) = args.attributeNameList {
            builder.add_attributeNameList(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2RacingConstDataT {
        let attributeNameList = self
            .attributeNameList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let racerMaxValue = self.racerMaxValue().map(|x| x.into_iter().collect());
        let bagFullHintPercent = self.bagFullHintPercent();
        let tempBagFullHintPercent = self.tempBagFullHintPercent();
        let bagName = self.bagName().map(|x| x.to_string());
        let tempBagName = self.tempBagName().map(|x| x.to_string());
        let bagEmptyLeftDesc = self.bagEmptyLeftDesc().map(|x| x.to_string());
        let bagEmptyRightDesc = self.bagEmptyRightDesc().map(|x| x.to_string());
        let tempBagEmptyLeftDesc = self.tempBagEmptyLeftDesc().map(|x| x.to_string());
        let tempBagEmptyRightDesc = self.tempBagEmptyRightDesc().map(|x| x.to_string());
        let bornTalentIconId = self.bornTalentIconId().map(|x| x.to_string());
        let bornTalentTitle = self.bornTalentTitle().map(|x| x.to_string());
        let learnedTalentIconId = self.learnedTalentIconId().map(|x| x.to_string());
        let learnedTalentTitle = self.learnedTalentTitle().map(|x| x.to_string());
        let talentEmptyDesc = self.talentEmptyDesc().map(|x| x.to_string());
        let slugItemId = self.slugItemId().map(|x| x.to_string());
        let racingHpFactor = self.racingHpFactor();
        let racingSpeedFactor = self.racingSpeedFactor();
        let racingAccelerationFactor = self.racingAccelerationFactor();
        let recoverMoveSpeed = self.recoverMoveSpeed();
        let recoverHpFactor = self.recoverHpFactor();
        let bleedingFactor = self.bleedingFactor();
        let maxSteeringFactor = self.maxSteeringFactor();
        let steeringMassLevelFactor = self.steeringMassLevelFactor();
        let steeringMoveSpeedFactor = self.steeringMoveSpeedFactor();
        let safeAngleCos = self.safeAngleCos();
        let safeCollisionForceLevel = self.safeCollisionForceLevel();
        let tileCollisionFactor = self.tileCollisionFactor();
        let collisionForceSector = self.collisionForceSector().map(|x| x.into_iter().collect());
        let collisionForceLevel = self.collisionForceLevel().map(|x| x.into_iter().collect());
        let collisionSpeedLoss = self.collisionSpeedLoss().map(|x| x.into_iter().collect());
        let collisionHpLoss = self.collisionHpLoss().map(|x| x.into_iter().collect());
        let tileCollisionSpeedLoss = self
            .tileCollisionSpeedLoss()
            .map(|x| x.into_iter().collect());
        let tileCollisionHpLoss = self.tileCollisionHpLoss().map(|x| x.into_iter().collect());
        let autoUseItemTimeRange = self.autoUseItemTimeRange().map(|x| x.into_iter().collect());
        let recoverAcceleration = self.recoverAcceleration();
        clz_Torappu_SandboxV2RacingConstDataT {
            attributeNameList,
            racerMaxValue,
            bagFullHintPercent,
            tempBagFullHintPercent,
            bagName,
            tempBagName,
            bagEmptyLeftDesc,
            bagEmptyRightDesc,
            tempBagEmptyLeftDesc,
            tempBagEmptyRightDesc,
            bornTalentIconId,
            bornTalentTitle,
            learnedTalentIconId,
            learnedTalentTitle,
            talentEmptyDesc,
            slugItemId,
            racingHpFactor,
            racingSpeedFactor,
            racingAccelerationFactor,
            recoverMoveSpeed,
            recoverHpFactor,
            bleedingFactor,
            maxSteeringFactor,
            steeringMassLevelFactor,
            steeringMoveSpeedFactor,
            safeAngleCos,
            safeCollisionForceLevel,
            tileCollisionFactor,
            collisionForceSector,
            collisionForceLevel,
            collisionSpeedLoss,
            collisionHpLoss,
            tileCollisionSpeedLoss,
            tileCollisionHpLoss,
            autoUseItemTimeRange,
            recoverAcceleration,
        }
    }

    #[inline]
    pub fn attributeNameList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxV2RacingConstData::VT_ATTRIBUTENAMELIST,
                None,
            )
        }
    }
    #[inline]
    pub fn racerMaxValue(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    clz_Torappu_SandboxV2RacingConstData::VT_RACERMAXVALUE,
                    None,
                )
        }
    }
    #[inline]
    pub fn bagFullHintPercent(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_BAGFULLHINTPERCENT,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn tempBagFullHintPercent(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_TEMPBAGFULLHINTPERCENT,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn bagName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_BAGNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn tempBagName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_TEMPBAGNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn bagEmptyLeftDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_BAGEMPTYLEFTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn bagEmptyRightDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_BAGEMPTYRIGHTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn tempBagEmptyLeftDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_TEMPBAGEMPTYLEFTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn tempBagEmptyRightDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_TEMPBAGEMPTYRIGHTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn bornTalentIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_BORNTALENTICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn bornTalentTitle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_BORNTALENTTITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn learnedTalentIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_LEARNEDTALENTICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn learnedTalentTitle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_LEARNEDTALENTTITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn talentEmptyDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_TALENTEMPTYDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn slugItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2RacingConstData::VT_SLUGITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn racingHpFactor(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_RACINGHPFACTOR,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn racingSpeedFactor(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_RACINGSPEEDFACTOR,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn racingAccelerationFactor(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_RACINGACCELERATIONFACTOR,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn recoverMoveSpeed(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_RECOVERMOVESPEED,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn recoverHpFactor(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_RECOVERHPFACTOR,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn bleedingFactor(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_BLEEDINGFACTOR,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxSteeringFactor(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_MAXSTEERINGFACTOR,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn steeringMassLevelFactor(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_STEERINGMASSLEVELFACTOR,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn steeringMoveSpeedFactor(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_STEERINGMOVESPEEDFACTOR,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn safeAngleCos(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_SAFEANGLECOS,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn safeCollisionForceLevel(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_SAFECOLLISIONFORCELEVEL,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn tileCollisionFactor(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_TILECOLLISIONFACTOR,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn collisionForceSector(&self) -> Option<flatbuffers::Vector<'a, f32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    clz_Torappu_SandboxV2RacingConstData::VT_COLLISIONFORCESECTOR,
                    None,
                )
        }
    }
    #[inline]
    pub fn collisionForceLevel(&self) -> Option<flatbuffers::Vector<'a, f32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    clz_Torappu_SandboxV2RacingConstData::VT_COLLISIONFORCELEVEL,
                    None,
                )
        }
    }
    #[inline]
    pub fn collisionSpeedLoss(&self) -> Option<flatbuffers::Vector<'a, f32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    clz_Torappu_SandboxV2RacingConstData::VT_COLLISIONSPEEDLOSS,
                    None,
                )
        }
    }
    #[inline]
    pub fn collisionHpLoss(&self) -> Option<flatbuffers::Vector<'a, f32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    clz_Torappu_SandboxV2RacingConstData::VT_COLLISIONHPLOSS,
                    None,
                )
        }
    }
    #[inline]
    pub fn tileCollisionSpeedLoss(&self) -> Option<flatbuffers::Vector<'a, f32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    clz_Torappu_SandboxV2RacingConstData::VT_TILECOLLISIONSPEEDLOSS,
                    None,
                )
        }
    }
    #[inline]
    pub fn tileCollisionHpLoss(&self) -> Option<flatbuffers::Vector<'a, f32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    clz_Torappu_SandboxV2RacingConstData::VT_TILECOLLISIONHPLOSS,
                    None,
                )
        }
    }
    #[inline]
    pub fn autoUseItemTimeRange(&self) -> Option<flatbuffers::Vector<'a, f32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    clz_Torappu_SandboxV2RacingConstData::VT_AUTOUSEITEMTIMERANGE,
                    None,
                )
        }
    }
    #[inline]
    pub fn recoverAcceleration(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_SandboxV2RacingConstData::VT_RECOVERACCELERATION,
                    Some(0.0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RacingConstData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("attributeNameList", Self::VT_ATTRIBUTENAMELIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "racerMaxValue",
                Self::VT_RACERMAXVALUE,
                false,
            )?
            .visit_field::<f32>("bagFullHintPercent", Self::VT_BAGFULLHINTPERCENT, false)?
            .visit_field::<f32>(
                "tempBagFullHintPercent",
                Self::VT_TEMPBAGFULLHINTPERCENT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bagName", Self::VT_BAGNAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "tempBagName",
                Self::VT_TEMPBAGNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bagEmptyLeftDesc",
                Self::VT_BAGEMPTYLEFTDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bagEmptyRightDesc",
                Self::VT_BAGEMPTYRIGHTDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "tempBagEmptyLeftDesc",
                Self::VT_TEMPBAGEMPTYLEFTDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "tempBagEmptyRightDesc",
                Self::VT_TEMPBAGEMPTYRIGHTDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bornTalentIconId",
                Self::VT_BORNTALENTICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bornTalentTitle",
                Self::VT_BORNTALENTTITLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "learnedTalentIconId",
                Self::VT_LEARNEDTALENTICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "learnedTalentTitle",
                Self::VT_LEARNEDTALENTTITLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "talentEmptyDesc",
                Self::VT_TALENTEMPTYDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "slugItemId",
                Self::VT_SLUGITEMID,
                false,
            )?
            .visit_field::<f32>("racingHpFactor", Self::VT_RACINGHPFACTOR, false)?
            .visit_field::<f32>("racingSpeedFactor", Self::VT_RACINGSPEEDFACTOR, false)?
            .visit_field::<f32>(
                "racingAccelerationFactor",
                Self::VT_RACINGACCELERATIONFACTOR,
                false,
            )?
            .visit_field::<f32>("recoverMoveSpeed", Self::VT_RECOVERMOVESPEED, false)?
            .visit_field::<f32>("recoverHpFactor", Self::VT_RECOVERHPFACTOR, false)?
            .visit_field::<f32>("bleedingFactor", Self::VT_BLEEDINGFACTOR, false)?
            .visit_field::<f32>("maxSteeringFactor", Self::VT_MAXSTEERINGFACTOR, false)?
            .visit_field::<f32>(
                "steeringMassLevelFactor",
                Self::VT_STEERINGMASSLEVELFACTOR,
                false,
            )?
            .visit_field::<f32>(
                "steeringMoveSpeedFactor",
                Self::VT_STEERINGMOVESPEEDFACTOR,
                false,
            )?
            .visit_field::<f32>("safeAngleCos", Self::VT_SAFEANGLECOS, false)?
            .visit_field::<f32>(
                "safeCollisionForceLevel",
                Self::VT_SAFECOLLISIONFORCELEVEL,
                false,
            )?
            .visit_field::<f32>("tileCollisionFactor", Self::VT_TILECOLLISIONFACTOR, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "collisionForceSector",
                Self::VT_COLLISIONFORCESECTOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "collisionForceLevel",
                Self::VT_COLLISIONFORCELEVEL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "collisionSpeedLoss",
                Self::VT_COLLISIONSPEEDLOSS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "collisionHpLoss",
                Self::VT_COLLISIONHPLOSS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "tileCollisionSpeedLoss",
                Self::VT_TILECOLLISIONSPEEDLOSS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "tileCollisionHpLoss",
                Self::VT_TILECOLLISIONHPLOSS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "autoUseItemTimeRange",
                Self::VT_AUTOUSEITEMTIMERANGE,
                false,
            )?
            .visit_field::<f32>("recoverAcceleration", Self::VT_RECOVERACCELERATION, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RacingConstDataArgs<'a> {
    pub attributeNameList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub racerMaxValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub bagFullHintPercent: f32,
    pub tempBagFullHintPercent: f32,
    pub bagName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tempBagName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bagEmptyLeftDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bagEmptyRightDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tempBagEmptyLeftDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tempBagEmptyRightDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bornTalentIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bornTalentTitle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub learnedTalentIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub learnedTalentTitle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub talentEmptyDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub slugItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub racingHpFactor: f32,
    pub racingSpeedFactor: f32,
    pub racingAccelerationFactor: f32,
    pub recoverMoveSpeed: f32,
    pub recoverHpFactor: f32,
    pub bleedingFactor: f32,
    pub maxSteeringFactor: f32,
    pub steeringMassLevelFactor: f32,
    pub steeringMoveSpeedFactor: f32,
    pub safeAngleCos: f32,
    pub safeCollisionForceLevel: f32,
    pub tileCollisionFactor: f32,
    pub collisionForceSector: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub collisionForceLevel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub collisionSpeedLoss: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub collisionHpLoss: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub tileCollisionSpeedLoss: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub tileCollisionHpLoss: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub autoUseItemTimeRange: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub recoverAcceleration: f32,
}
impl<'a> Default for clz_Torappu_SandboxV2RacingConstDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RacingConstDataArgs {
            attributeNameList: None,
            racerMaxValue: None,
            bagFullHintPercent: 0.0,
            tempBagFullHintPercent: 0.0,
            bagName: None,
            tempBagName: None,
            bagEmptyLeftDesc: None,
            bagEmptyRightDesc: None,
            tempBagEmptyLeftDesc: None,
            tempBagEmptyRightDesc: None,
            bornTalentIconId: None,
            bornTalentTitle: None,
            learnedTalentIconId: None,
            learnedTalentTitle: None,
            talentEmptyDesc: None,
            slugItemId: None,
            racingHpFactor: 0.0,
            racingSpeedFactor: 0.0,
            racingAccelerationFactor: 0.0,
            recoverMoveSpeed: 0.0,
            recoverHpFactor: 0.0,
            bleedingFactor: 0.0,
            maxSteeringFactor: 0.0,
            steeringMassLevelFactor: 0.0,
            steeringMoveSpeedFactor: 0.0,
            safeAngleCos: 0.0,
            safeCollisionForceLevel: 0.0,
            tileCollisionFactor: 0.0,
            collisionForceSector: None,
            collisionForceLevel: None,
            collisionSpeedLoss: None,
            collisionHpLoss: None,
            tileCollisionSpeedLoss: None,
            tileCollisionHpLoss: None,
            autoUseItemTimeRange: None,
            recoverAcceleration: 0.0,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2RacingConstData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2RacingConstData", 36)?;
        if let Some(f) = self.attributeNameList() {
            s.serialize_field("attributeNameList", &f)?;
        } else {
            s.skip_field("attributeNameList")?;
        }
        if let Some(f) = self.racerMaxValue() {
            s.serialize_field("racerMaxValue", &f)?;
        } else {
            s.skip_field("racerMaxValue")?;
        }
        s.serialize_field("bagFullHintPercent", &self.bagFullHintPercent())?;
        s.serialize_field("tempBagFullHintPercent", &self.tempBagFullHintPercent())?;
        if let Some(f) = self.bagName() {
            s.serialize_field("bagName", &f)?;
        } else {
            s.skip_field("bagName")?;
        }
        if let Some(f) = self.tempBagName() {
            s.serialize_field("tempBagName", &f)?;
        } else {
            s.skip_field("tempBagName")?;
        }
        if let Some(f) = self.bagEmptyLeftDesc() {
            s.serialize_field("bagEmptyLeftDesc", &f)?;
        } else {
            s.skip_field("bagEmptyLeftDesc")?;
        }
        if let Some(f) = self.bagEmptyRightDesc() {
            s.serialize_field("bagEmptyRightDesc", &f)?;
        } else {
            s.skip_field("bagEmptyRightDesc")?;
        }
        if let Some(f) = self.tempBagEmptyLeftDesc() {
            s.serialize_field("tempBagEmptyLeftDesc", &f)?;
        } else {
            s.skip_field("tempBagEmptyLeftDesc")?;
        }
        if let Some(f) = self.tempBagEmptyRightDesc() {
            s.serialize_field("tempBagEmptyRightDesc", &f)?;
        } else {
            s.skip_field("tempBagEmptyRightDesc")?;
        }
        if let Some(f) = self.bornTalentIconId() {
            s.serialize_field("bornTalentIconId", &f)?;
        } else {
            s.skip_field("bornTalentIconId")?;
        }
        if let Some(f) = self.bornTalentTitle() {
            s.serialize_field("bornTalentTitle", &f)?;
        } else {
            s.skip_field("bornTalentTitle")?;
        }
        if let Some(f) = self.learnedTalentIconId() {
            s.serialize_field("learnedTalentIconId", &f)?;
        } else {
            s.skip_field("learnedTalentIconId")?;
        }
        if let Some(f) = self.learnedTalentTitle() {
            s.serialize_field("learnedTalentTitle", &f)?;
        } else {
            s.skip_field("learnedTalentTitle")?;
        }
        if let Some(f) = self.talentEmptyDesc() {
            s.serialize_field("talentEmptyDesc", &f)?;
        } else {
            s.skip_field("talentEmptyDesc")?;
        }
        if let Some(f) = self.slugItemId() {
            s.serialize_field("slugItemId", &f)?;
        } else {
            s.skip_field("slugItemId")?;
        }
        s.serialize_field("racingHpFactor", &self.racingHpFactor())?;
        s.serialize_field("racingSpeedFactor", &self.racingSpeedFactor())?;
        s.serialize_field("racingAccelerationFactor", &self.racingAccelerationFactor())?;
        s.serialize_field("recoverMoveSpeed", &self.recoverMoveSpeed())?;
        s.serialize_field("recoverHpFactor", &self.recoverHpFactor())?;
        s.serialize_field("bleedingFactor", &self.bleedingFactor())?;
        s.serialize_field("maxSteeringFactor", &self.maxSteeringFactor())?;
        s.serialize_field("steeringMassLevelFactor", &self.steeringMassLevelFactor())?;
        s.serialize_field("steeringMoveSpeedFactor", &self.steeringMoveSpeedFactor())?;
        s.serialize_field("safeAngleCos", &self.safeAngleCos())?;
        s.serialize_field("safeCollisionForceLevel", &self.safeCollisionForceLevel())?;
        s.serialize_field("tileCollisionFactor", &self.tileCollisionFactor())?;
        if let Some(f) = self.collisionForceSector() {
            s.serialize_field("collisionForceSector", &f)?;
        } else {
            s.skip_field("collisionForceSector")?;
        }
        if let Some(f) = self.collisionForceLevel() {
            s.serialize_field("collisionForceLevel", &f)?;
        } else {
            s.skip_field("collisionForceLevel")?;
        }
        if let Some(f) = self.collisionSpeedLoss() {
            s.serialize_field("collisionSpeedLoss", &f)?;
        } else {
            s.skip_field("collisionSpeedLoss")?;
        }
        if let Some(f) = self.collisionHpLoss() {
            s.serialize_field("collisionHpLoss", &f)?;
        } else {
            s.skip_field("collisionHpLoss")?;
        }
        if let Some(f) = self.tileCollisionSpeedLoss() {
            s.serialize_field("tileCollisionSpeedLoss", &f)?;
        } else {
            s.skip_field("tileCollisionSpeedLoss")?;
        }
        if let Some(f) = self.tileCollisionHpLoss() {
            s.serialize_field("tileCollisionHpLoss", &f)?;
        } else {
            s.skip_field("tileCollisionHpLoss")?;
        }
        if let Some(f) = self.autoUseItemTimeRange() {
            s.serialize_field("autoUseItemTimeRange", &f)?;
        } else {
            s.skip_field("autoUseItemTimeRange")?;
        }
        s.serialize_field("recoverAcceleration", &self.recoverAcceleration())?;
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2RacingConstDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2RacingConstDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_attributeNameList(
        &mut self,
        attributeNameList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_ATTRIBUTENAMELIST,
            attributeNameList,
        );
    }
    #[inline]
    pub fn add_racerMaxValue(
        &mut self,
        racerMaxValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_RACERMAXVALUE,
            racerMaxValue,
        );
    }
    #[inline]
    pub fn add_bagFullHintPercent(&mut self, bagFullHintPercent: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_BAGFULLHINTPERCENT,
            bagFullHintPercent,
            0.0,
        );
    }
    #[inline]
    pub fn add_tempBagFullHintPercent(&mut self, tempBagFullHintPercent: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_TEMPBAGFULLHINTPERCENT,
            tempBagFullHintPercent,
            0.0,
        );
    }
    #[inline]
    pub fn add_bagName(&mut self, bagName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_BAGNAME,
            bagName,
        );
    }
    #[inline]
    pub fn add_tempBagName(&mut self, tempBagName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_TEMPBAGNAME,
            tempBagName,
        );
    }
    #[inline]
    pub fn add_bagEmptyLeftDesc(&mut self, bagEmptyLeftDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_BAGEMPTYLEFTDESC,
            bagEmptyLeftDesc,
        );
    }
    #[inline]
    pub fn add_bagEmptyRightDesc(&mut self, bagEmptyRightDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_BAGEMPTYRIGHTDESC,
            bagEmptyRightDesc,
        );
    }
    #[inline]
    pub fn add_tempBagEmptyLeftDesc(
        &mut self,
        tempBagEmptyLeftDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_TEMPBAGEMPTYLEFTDESC,
            tempBagEmptyLeftDesc,
        );
    }
    #[inline]
    pub fn add_tempBagEmptyRightDesc(
        &mut self,
        tempBagEmptyRightDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_TEMPBAGEMPTYRIGHTDESC,
            tempBagEmptyRightDesc,
        );
    }
    #[inline]
    pub fn add_bornTalentIconId(&mut self, bornTalentIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_BORNTALENTICONID,
            bornTalentIconId,
        );
    }
    #[inline]
    pub fn add_bornTalentTitle(&mut self, bornTalentTitle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_BORNTALENTTITLE,
            bornTalentTitle,
        );
    }
    #[inline]
    pub fn add_learnedTalentIconId(
        &mut self,
        learnedTalentIconId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_LEARNEDTALENTICONID,
            learnedTalentIconId,
        );
    }
    #[inline]
    pub fn add_learnedTalentTitle(&mut self, learnedTalentTitle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_LEARNEDTALENTTITLE,
            learnedTalentTitle,
        );
    }
    #[inline]
    pub fn add_talentEmptyDesc(&mut self, talentEmptyDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_TALENTEMPTYDESC,
            talentEmptyDesc,
        );
    }
    #[inline]
    pub fn add_slugItemId(&mut self, slugItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_SLUGITEMID,
            slugItemId,
        );
    }
    #[inline]
    pub fn add_racingHpFactor(&mut self, racingHpFactor: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_RACINGHPFACTOR,
            racingHpFactor,
            0.0,
        );
    }
    #[inline]
    pub fn add_racingSpeedFactor(&mut self, racingSpeedFactor: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_RACINGSPEEDFACTOR,
            racingSpeedFactor,
            0.0,
        );
    }
    #[inline]
    pub fn add_racingAccelerationFactor(&mut self, racingAccelerationFactor: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_RACINGACCELERATIONFACTOR,
            racingAccelerationFactor,
            0.0,
        );
    }
    #[inline]
    pub fn add_recoverMoveSpeed(&mut self, recoverMoveSpeed: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_RECOVERMOVESPEED,
            recoverMoveSpeed,
            0.0,
        );
    }
    #[inline]
    pub fn add_recoverHpFactor(&mut self, recoverHpFactor: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_RECOVERHPFACTOR,
            recoverHpFactor,
            0.0,
        );
    }
    #[inline]
    pub fn add_bleedingFactor(&mut self, bleedingFactor: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_BLEEDINGFACTOR,
            bleedingFactor,
            0.0,
        );
    }
    #[inline]
    pub fn add_maxSteeringFactor(&mut self, maxSteeringFactor: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_MAXSTEERINGFACTOR,
            maxSteeringFactor,
            0.0,
        );
    }
    #[inline]
    pub fn add_steeringMassLevelFactor(&mut self, steeringMassLevelFactor: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_STEERINGMASSLEVELFACTOR,
            steeringMassLevelFactor,
            0.0,
        );
    }
    #[inline]
    pub fn add_steeringMoveSpeedFactor(&mut self, steeringMoveSpeedFactor: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_STEERINGMOVESPEEDFACTOR,
            steeringMoveSpeedFactor,
            0.0,
        );
    }
    #[inline]
    pub fn add_safeAngleCos(&mut self, safeAngleCos: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_SAFEANGLECOS,
            safeAngleCos,
            0.0,
        );
    }
    #[inline]
    pub fn add_safeCollisionForceLevel(&mut self, safeCollisionForceLevel: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_SAFECOLLISIONFORCELEVEL,
            safeCollisionForceLevel,
            0.0,
        );
    }
    #[inline]
    pub fn add_tileCollisionFactor(&mut self, tileCollisionFactor: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_TILECOLLISIONFACTOR,
            tileCollisionFactor,
            0.0,
        );
    }
    #[inline]
    pub fn add_collisionForceSector(
        &mut self,
        collisionForceSector: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_COLLISIONFORCESECTOR,
            collisionForceSector,
        );
    }
    #[inline]
    pub fn add_collisionForceLevel(
        &mut self,
        collisionForceLevel: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_COLLISIONFORCELEVEL,
            collisionForceLevel,
        );
    }
    #[inline]
    pub fn add_collisionSpeedLoss(
        &mut self,
        collisionSpeedLoss: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_COLLISIONSPEEDLOSS,
            collisionSpeedLoss,
        );
    }
    #[inline]
    pub fn add_collisionHpLoss(
        &mut self,
        collisionHpLoss: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_COLLISIONHPLOSS,
            collisionHpLoss,
        );
    }
    #[inline]
    pub fn add_tileCollisionSpeedLoss(
        &mut self,
        tileCollisionSpeedLoss: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_TILECOLLISIONSPEEDLOSS,
            tileCollisionSpeedLoss,
        );
    }
    #[inline]
    pub fn add_tileCollisionHpLoss(
        &mut self,
        tileCollisionHpLoss: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_TILECOLLISIONHPLOSS,
            tileCollisionHpLoss,
        );
    }
    #[inline]
    pub fn add_autoUseItemTimeRange(
        &mut self,
        autoUseItemTimeRange: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingConstData::VT_AUTOUSEITEMTIMERANGE,
            autoUseItemTimeRange,
        );
    }
    #[inline]
    pub fn add_recoverAcceleration(&mut self, recoverAcceleration: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SandboxV2RacingConstData::VT_RECOVERACCELERATION,
            recoverAcceleration,
            0.0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RacingConstDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RacingConstDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingConstData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RacingConstData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RacingConstData");
        ds.field("attributeNameList", &self.attributeNameList());
        ds.field("racerMaxValue", &self.racerMaxValue());
        ds.field("bagFullHintPercent", &self.bagFullHintPercent());
        ds.field("tempBagFullHintPercent", &self.tempBagFullHintPercent());
        ds.field("bagName", &self.bagName());
        ds.field("tempBagName", &self.tempBagName());
        ds.field("bagEmptyLeftDesc", &self.bagEmptyLeftDesc());
        ds.field("bagEmptyRightDesc", &self.bagEmptyRightDesc());
        ds.field("tempBagEmptyLeftDesc", &self.tempBagEmptyLeftDesc());
        ds.field("tempBagEmptyRightDesc", &self.tempBagEmptyRightDesc());
        ds.field("bornTalentIconId", &self.bornTalentIconId());
        ds.field("bornTalentTitle", &self.bornTalentTitle());
        ds.field("learnedTalentIconId", &self.learnedTalentIconId());
        ds.field("learnedTalentTitle", &self.learnedTalentTitle());
        ds.field("talentEmptyDesc", &self.talentEmptyDesc());
        ds.field("slugItemId", &self.slugItemId());
        ds.field("racingHpFactor", &self.racingHpFactor());
        ds.field("racingSpeedFactor", &self.racingSpeedFactor());
        ds.field("racingAccelerationFactor", &self.racingAccelerationFactor());
        ds.field("recoverMoveSpeed", &self.recoverMoveSpeed());
        ds.field("recoverHpFactor", &self.recoverHpFactor());
        ds.field("bleedingFactor", &self.bleedingFactor());
        ds.field("maxSteeringFactor", &self.maxSteeringFactor());
        ds.field("steeringMassLevelFactor", &self.steeringMassLevelFactor());
        ds.field("steeringMoveSpeedFactor", &self.steeringMoveSpeedFactor());
        ds.field("safeAngleCos", &self.safeAngleCos());
        ds.field("safeCollisionForceLevel", &self.safeCollisionForceLevel());
        ds.field("tileCollisionFactor", &self.tileCollisionFactor());
        ds.field("collisionForceSector", &self.collisionForceSector());
        ds.field("collisionForceLevel", &self.collisionForceLevel());
        ds.field("collisionSpeedLoss", &self.collisionSpeedLoss());
        ds.field("collisionHpLoss", &self.collisionHpLoss());
        ds.field("tileCollisionSpeedLoss", &self.tileCollisionSpeedLoss());
        ds.field("tileCollisionHpLoss", &self.tileCollisionHpLoss());
        ds.field("autoUseItemTimeRange", &self.autoUseItemTimeRange());
        ds.field("recoverAcceleration", &self.recoverAcceleration());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2RacingConstDataT {
    pub attributeNameList: Option<Vec<String>>,
    pub racerMaxValue: Option<Vec<i32>>,
    pub bagFullHintPercent: f32,
    pub tempBagFullHintPercent: f32,
    pub bagName: Option<String>,
    pub tempBagName: Option<String>,
    pub bagEmptyLeftDesc: Option<String>,
    pub bagEmptyRightDesc: Option<String>,
    pub tempBagEmptyLeftDesc: Option<String>,
    pub tempBagEmptyRightDesc: Option<String>,
    pub bornTalentIconId: Option<String>,
    pub bornTalentTitle: Option<String>,
    pub learnedTalentIconId: Option<String>,
    pub learnedTalentTitle: Option<String>,
    pub talentEmptyDesc: Option<String>,
    pub slugItemId: Option<String>,
    pub racingHpFactor: f32,
    pub racingSpeedFactor: f32,
    pub racingAccelerationFactor: f32,
    pub recoverMoveSpeed: f32,
    pub recoverHpFactor: f32,
    pub bleedingFactor: f32,
    pub maxSteeringFactor: f32,
    pub steeringMassLevelFactor: f32,
    pub steeringMoveSpeedFactor: f32,
    pub safeAngleCos: f32,
    pub safeCollisionForceLevel: f32,
    pub tileCollisionFactor: f32,
    pub collisionForceSector: Option<Vec<f32>>,
    pub collisionForceLevel: Option<Vec<f32>>,
    pub collisionSpeedLoss: Option<Vec<f32>>,
    pub collisionHpLoss: Option<Vec<f32>>,
    pub tileCollisionSpeedLoss: Option<Vec<f32>>,
    pub tileCollisionHpLoss: Option<Vec<f32>>,
    pub autoUseItemTimeRange: Option<Vec<f32>>,
    pub recoverAcceleration: f32,
}
impl Default for clz_Torappu_SandboxV2RacingConstDataT {
    fn default() -> Self {
        Self {
            attributeNameList: None,
            racerMaxValue: None,
            bagFullHintPercent: 0.0,
            tempBagFullHintPercent: 0.0,
            bagName: None,
            tempBagName: None,
            bagEmptyLeftDesc: None,
            bagEmptyRightDesc: None,
            tempBagEmptyLeftDesc: None,
            tempBagEmptyRightDesc: None,
            bornTalentIconId: None,
            bornTalentTitle: None,
            learnedTalentIconId: None,
            learnedTalentTitle: None,
            talentEmptyDesc: None,
            slugItemId: None,
            racingHpFactor: 0.0,
            racingSpeedFactor: 0.0,
            racingAccelerationFactor: 0.0,
            recoverMoveSpeed: 0.0,
            recoverHpFactor: 0.0,
            bleedingFactor: 0.0,
            maxSteeringFactor: 0.0,
            steeringMassLevelFactor: 0.0,
            steeringMoveSpeedFactor: 0.0,
            safeAngleCos: 0.0,
            safeCollisionForceLevel: 0.0,
            tileCollisionFactor: 0.0,
            collisionForceSector: None,
            collisionForceLevel: None,
            collisionSpeedLoss: None,
            collisionHpLoss: None,
            tileCollisionSpeedLoss: None,
            tileCollisionHpLoss: None,
            autoUseItemTimeRange: None,
            recoverAcceleration: 0.0,
        }
    }
}
impl clz_Torappu_SandboxV2RacingConstDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingConstData<'b>> {
        let attributeNameList = self.attributeNameList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let racerMaxValue = self.racerMaxValue.as_ref().map(|x| _fbb.create_vector(x));
        let bagFullHintPercent = self.bagFullHintPercent;
        let tempBagFullHintPercent = self.tempBagFullHintPercent;
        let bagName = self.bagName.as_ref().map(|x| _fbb.create_string(x));
        let tempBagName = self.tempBagName.as_ref().map(|x| _fbb.create_string(x));
        let bagEmptyLeftDesc = self
            .bagEmptyLeftDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let bagEmptyRightDesc = self
            .bagEmptyRightDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let tempBagEmptyLeftDesc = self
            .tempBagEmptyLeftDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let tempBagEmptyRightDesc = self
            .tempBagEmptyRightDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let bornTalentIconId = self
            .bornTalentIconId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let bornTalentTitle = self.bornTalentTitle.as_ref().map(|x| _fbb.create_string(x));
        let learnedTalentIconId = self
            .learnedTalentIconId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let learnedTalentTitle = self
            .learnedTalentTitle
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let talentEmptyDesc = self.talentEmptyDesc.as_ref().map(|x| _fbb.create_string(x));
        let slugItemId = self.slugItemId.as_ref().map(|x| _fbb.create_string(x));
        let racingHpFactor = self.racingHpFactor;
        let racingSpeedFactor = self.racingSpeedFactor;
        let racingAccelerationFactor = self.racingAccelerationFactor;
        let recoverMoveSpeed = self.recoverMoveSpeed;
        let recoverHpFactor = self.recoverHpFactor;
        let bleedingFactor = self.bleedingFactor;
        let maxSteeringFactor = self.maxSteeringFactor;
        let steeringMassLevelFactor = self.steeringMassLevelFactor;
        let steeringMoveSpeedFactor = self.steeringMoveSpeedFactor;
        let safeAngleCos = self.safeAngleCos;
        let safeCollisionForceLevel = self.safeCollisionForceLevel;
        let tileCollisionFactor = self.tileCollisionFactor;
        let collisionForceSector = self
            .collisionForceSector
            .as_ref()
            .map(|x| _fbb.create_vector(x));
        let collisionForceLevel = self
            .collisionForceLevel
            .as_ref()
            .map(|x| _fbb.create_vector(x));
        let collisionSpeedLoss = self
            .collisionSpeedLoss
            .as_ref()
            .map(|x| _fbb.create_vector(x));
        let collisionHpLoss = self.collisionHpLoss.as_ref().map(|x| _fbb.create_vector(x));
        let tileCollisionSpeedLoss = self
            .tileCollisionSpeedLoss
            .as_ref()
            .map(|x| _fbb.create_vector(x));
        let tileCollisionHpLoss = self
            .tileCollisionHpLoss
            .as_ref()
            .map(|x| _fbb.create_vector(x));
        let autoUseItemTimeRange = self
            .autoUseItemTimeRange
            .as_ref()
            .map(|x| _fbb.create_vector(x));
        let recoverAcceleration = self.recoverAcceleration;
        clz_Torappu_SandboxV2RacingConstData::create(
            _fbb,
            &clz_Torappu_SandboxV2RacingConstDataArgs {
                attributeNameList,
                racerMaxValue,
                bagFullHintPercent,
                tempBagFullHintPercent,
                bagName,
                tempBagName,
                bagEmptyLeftDesc,
                bagEmptyRightDesc,
                tempBagEmptyLeftDesc,
                tempBagEmptyRightDesc,
                bornTalentIconId,
                bornTalentTitle,
                learnedTalentIconId,
                learnedTalentTitle,
                talentEmptyDesc,
                slugItemId,
                racingHpFactor,
                racingSpeedFactor,
                racingAccelerationFactor,
                recoverMoveSpeed,
                recoverHpFactor,
                bleedingFactor,
                maxSteeringFactor,
                steeringMassLevelFactor,
                steeringMoveSpeedFactor,
                safeAngleCos,
                safeCollisionForceLevel,
                tileCollisionFactor,
                collisionForceSector,
                collisionForceLevel,
                collisionSpeedLoss,
                collisionHpLoss,
                tileCollisionSpeedLoss,
                tileCollisionHpLoss,
                autoUseItemTimeRange,
                recoverAcceleration,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2RacingDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2RacingData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2RacingData<'a> {
    type Inner = clz_Torappu_SandboxV2RacingData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2RacingData<'a> {
    pub const VT_RACERBASICINFO: flatbuffers::VOffsetT = 4;
    pub const VT_RACERTALENTINFO: flatbuffers::VOffsetT = 6;
    pub const VT_RACERNAMEINFO: flatbuffers::VOffsetT = 8;
    pub const VT_RACERMEDALINFO: flatbuffers::VOffsetT = 10;
    pub const VT_ENEMYITEMMAP: flatbuffers::VOffsetT = 12;
    pub const VT_RACINGITEMINFO: flatbuffers::VOffsetT = 14;
    pub const VT_CONSTDATA: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2RacingData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2RacingDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2RacingDataBuilder::new(_fbb);
        if let Some(x) = args.constData {
            builder.add_constData(x);
        }
        if let Some(x) = args.racingItemInfo {
            builder.add_racingItemInfo(x);
        }
        if let Some(x) = args.enemyItemMap {
            builder.add_enemyItemMap(x);
        }
        if let Some(x) = args.racerMedalInfo {
            builder.add_racerMedalInfo(x);
        }
        if let Some(x) = args.racerNameInfo {
            builder.add_racerNameInfo(x);
        }
        if let Some(x) = args.racerTalentInfo {
            builder.add_racerTalentInfo(x);
        }
        if let Some(x) = args.racerBasicInfo {
            builder.add_racerBasicInfo(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2RacingDataT {
        let racerBasicInfo = self
            .racerBasicInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let racerTalentInfo = self
            .racerTalentInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let racerNameInfo = self
            .racerNameInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let racerMedalInfo = self
            .racerMedalInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let enemyItemMap = self
            .enemyItemMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let racingItemInfo = self
            .racingItemInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let constData = self.constData().map(|x| Box::new(x.unpack()));
        clz_Torappu_SandboxV2RacingDataT {
            racerBasicInfo,
            racerTalentInfo,
            racerNameInfo,
            racerMedalInfo,
            enemyItemMap,
            racingItemInfo,
            constData,
        }
    }

    #[inline]
    pub fn racerBasicInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerBasicInfo>,
                >,
            >>(clz_Torappu_SandboxV2RacingData::VT_RACERBASICINFO, None)
        }
    }
    #[inline]
    pub fn racerTalentInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2RacerTalentInfo,
                    >,
                >,
            >>(clz_Torappu_SandboxV2RacingData::VT_RACERTALENTINFO, None)
        }
    }
    #[inline]
    pub fn racerNameInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerNameInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerNameInfo>,
                >,
            >>(clz_Torappu_SandboxV2RacingData::VT_RACERNAMEINFO, None)
        }
    }
    #[inline]
    pub fn racerMedalInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerMedalInfo>,
                >,
            >>(clz_Torappu_SandboxV2RacingData::VT_RACERMEDALINFO, None)
        }
    }
    #[inline]
    pub fn enemyItemMap(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(clz_Torappu_SandboxV2RacingData::VT_ENEMYITEMMAP, None)
        }
    }
    #[inline]
    pub fn racingItemInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacingItemInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacingItemInfo>,
                >,
            >>(clz_Torappu_SandboxV2RacingData::VT_RACINGITEMINFO, None)
        }
    }
    #[inline]
    pub fn constData(&self) -> Option<clz_Torappu_SandboxV2RacingConstData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacingConstData>>(
                    clz_Torappu_SandboxV2RacingData::VT_CONSTDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2RacingData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerBasicInfo>,
                >,
            >>("racerBasicInfo", Self::VT_RACERBASICINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2RacerTalentInfo,
                    >,
                >,
            >>("racerTalentInfo", Self::VT_RACERTALENTINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerNameInfo>,
                >,
            >>("racerNameInfo", Self::VT_RACERNAMEINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerMedalInfo>,
                >,
            >>("racerMedalInfo", Self::VT_RACERMEDALINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>("enemyItemMap", Self::VT_ENEMYITEMMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacingItemInfo>,
                >,
            >>("racingItemInfo", Self::VT_RACINGITEMINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacingConstData>>(
                "constData",
                Self::VT_CONSTDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2RacingDataArgs<'a> {
    pub racerBasicInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'a>>,
            >,
        >,
    >,
    pub racerTalentInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'a>,
                >,
            >,
        >,
    >,
    pub racerNameInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerNameInfo<'a>>,
            >,
        >,
    >,
    pub racerMedalInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'a>>,
            >,
        >,
    >,
    pub enemyItemMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>,
        >,
    >,
    pub racingItemInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacingItemInfo<'a>>,
            >,
        >,
    >,
    pub constData: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingConstData<'a>>>,
}
impl<'a> Default for clz_Torappu_SandboxV2RacingDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2RacingDataArgs {
            racerBasicInfo: None,
            racerTalentInfo: None,
            racerNameInfo: None,
            racerMedalInfo: None,
            enemyItemMap: None,
            racingItemInfo: None,
            constData: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2RacingData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2RacingData", 7)?;
        if let Some(f) = self.racerBasicInfo() {
            s.serialize_field("racerBasicInfo", &f)?;
        } else {
            s.skip_field("racerBasicInfo")?;
        }
        if let Some(f) = self.racerTalentInfo() {
            s.serialize_field("racerTalentInfo", &f)?;
        } else {
            s.skip_field("racerTalentInfo")?;
        }
        if let Some(f) = self.racerNameInfo() {
            s.serialize_field("racerNameInfo", &f)?;
        } else {
            s.skip_field("racerNameInfo")?;
        }
        if let Some(f) = self.racerMedalInfo() {
            s.serialize_field("racerMedalInfo", &f)?;
        } else {
            s.skip_field("racerMedalInfo")?;
        }
        if let Some(f) = self.enemyItemMap() {
            s.serialize_field("enemyItemMap", &f)?;
        } else {
            s.skip_field("enemyItemMap")?;
        }
        if let Some(f) = self.racingItemInfo() {
            s.serialize_field("racingItemInfo", &f)?;
        } else {
            s.skip_field("racingItemInfo")?;
        }
        if let Some(f) = self.constData() {
            s.serialize_field("constData", &f)?;
        } else {
            s.skip_field("constData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2RacingDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2RacingDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_racerBasicInfo(
        &mut self,
        racerBasicInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerBasicInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingData::VT_RACERBASICINFO,
            racerBasicInfo,
        );
    }
    #[inline]
    pub fn add_racerTalentInfo(
        &mut self,
        racerTalentInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RacerTalentInfo<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingData::VT_RACERTALENTINFO,
            racerTalentInfo,
        );
    }
    #[inline]
    pub fn add_racerNameInfo(
        &mut self,
        racerNameInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerNameInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingData::VT_RACERNAMEINFO,
            racerNameInfo,
        );
    }
    #[inline]
    pub fn add_racerMedalInfo(
        &mut self,
        racerMedalInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacerMedalInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingData::VT_RACERMEDALINFO,
            racerMedalInfo,
        );
    }
    #[inline]
    pub fn add_enemyItemMap(
        &mut self,
        enemyItemMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingData::VT_ENEMYITEMMAP,
            enemyItemMap,
        );
    }
    #[inline]
    pub fn add_racingItemInfo(
        &mut self,
        racingItemInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RacingItemInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2RacingData::VT_RACINGITEMINFO,
            racingItemInfo,
        );
    }
    #[inline]
    pub fn add_constData(
        &mut self,
        constData: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingConstData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingConstData>>(
                clz_Torappu_SandboxV2RacingData::VT_CONSTDATA,
                constData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2RacingDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2RacingDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2RacingData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2RacingData");
        ds.field("racerBasicInfo", &self.racerBasicInfo());
        ds.field("racerTalentInfo", &self.racerTalentInfo());
        ds.field("racerNameInfo", &self.racerNameInfo());
        ds.field("racerMedalInfo", &self.racerMedalInfo());
        ds.field("enemyItemMap", &self.enemyItemMap());
        ds.field("racingItemInfo", &self.racingItemInfo());
        ds.field("constData", &self.constData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2RacingDataT {
    pub racerBasicInfo: Option<Vec<dict__string__clz_Torappu_SandboxV2RacerBasicInfoT>>,
    pub racerTalentInfo: Option<Vec<dict__string__clz_Torappu_SandboxV2RacerTalentInfoT>>,
    pub racerNameInfo: Option<Vec<dict__string__clz_Torappu_SandboxV2RacerNameInfoT>>,
    pub racerMedalInfo: Option<Vec<dict__string__clz_Torappu_SandboxV2RacerMedalInfoT>>,
    pub enemyItemMap: Option<Vec<dict__string__stringT>>,
    pub racingItemInfo: Option<Vec<dict__string__clz_Torappu_SandboxV2RacingItemInfoT>>,
    pub constData: Option<Box<clz_Torappu_SandboxV2RacingConstDataT>>,
}
impl Default for clz_Torappu_SandboxV2RacingDataT {
    fn default() -> Self {
        Self {
            racerBasicInfo: None,
            racerTalentInfo: None,
            racerNameInfo: None,
            racerMedalInfo: None,
            enemyItemMap: None,
            racingItemInfo: None,
            constData: None,
        }
    }
}
impl clz_Torappu_SandboxV2RacingDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingData<'b>> {
        let racerBasicInfo = self.racerBasicInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let racerTalentInfo = self.racerTalentInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let racerNameInfo = self.racerNameInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let racerMedalInfo = self.racerMedalInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let enemyItemMap = self.enemyItemMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let racingItemInfo = self.racingItemInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let constData = self.constData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_SandboxV2RacingData::create(
            _fbb,
            &clz_Torappu_SandboxV2RacingDataArgs {
                racerBasicInfo,
                racerTalentInfo,
                racerNameInfo,
                racerMedalInfo,
                enemyItemMap,
                racingItemInfo,
                constData,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2ChallengeConstOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ChallengeConst<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ChallengeConst<'a> {
    type Inner = clz_Torappu_SandboxV2ChallengeConst<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ChallengeConst<'a> {
    pub const VT_CHALLENGEMODEDESC: flatbuffers::VOffsetT = 4;
    pub const VT_DAILYTITLEDESC: flatbuffers::VOffsetT = 6;
    pub const VT_DEBUFFCOUNTDOWNDESC: flatbuffers::VOffsetT = 8;
    pub const VT_GAINALLDEBUFFDESC: flatbuffers::VOffsetT = 10;
    pub const VT_DAILYUPATTRIBUTEDESC: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ChallengeConst { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ChallengeConstArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeConst<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ChallengeConstBuilder::new(_fbb);
        if let Some(x) = args.dailyUpAttributeDesc {
            builder.add_dailyUpAttributeDesc(x);
        }
        if let Some(x) = args.gainAllDebuffDesc {
            builder.add_gainAllDebuffDesc(x);
        }
        if let Some(x) = args.debuffCountdownDesc {
            builder.add_debuffCountdownDesc(x);
        }
        if let Some(x) = args.dailyTitleDesc {
            builder.add_dailyTitleDesc(x);
        }
        if let Some(x) = args.challengeModeDesc {
            builder.add_challengeModeDesc(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2ChallengeConstT {
        let challengeModeDesc = self.challengeModeDesc().map(|x| x.to_string());
        let dailyTitleDesc = self.dailyTitleDesc().map(|x| x.to_string());
        let debuffCountdownDesc = self.debuffCountdownDesc().map(|x| x.to_string());
        let gainAllDebuffDesc = self.gainAllDebuffDesc().map(|x| x.to_string());
        let dailyUpAttributeDesc = self.dailyUpAttributeDesc().map(|x| x.to_string());
        clz_Torappu_SandboxV2ChallengeConstT {
            challengeModeDesc,
            dailyTitleDesc,
            debuffCountdownDesc,
            gainAllDebuffDesc,
            dailyUpAttributeDesc,
        }
    }

    #[inline]
    pub fn challengeModeDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ChallengeConst::VT_CHALLENGEMODEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn dailyTitleDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ChallengeConst::VT_DAILYTITLEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn debuffCountdownDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ChallengeConst::VT_DEBUFFCOUNTDOWNDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn gainAllDebuffDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ChallengeConst::VT_GAINALLDEBUFFDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn dailyUpAttributeDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ChallengeConst::VT_DAILYUPATTRIBUTEDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ChallengeConst<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "challengeModeDesc",
                Self::VT_CHALLENGEMODEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dailyTitleDesc",
                Self::VT_DAILYTITLEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "debuffCountdownDesc",
                Self::VT_DEBUFFCOUNTDOWNDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "gainAllDebuffDesc",
                Self::VT_GAINALLDEBUFFDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dailyUpAttributeDesc",
                Self::VT_DAILYUPATTRIBUTEDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ChallengeConstArgs<'a> {
    pub challengeModeDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dailyTitleDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub debuffCountdownDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gainAllDebuffDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dailyUpAttributeDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ChallengeConstArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ChallengeConstArgs {
            challengeModeDesc: None,
            dailyTitleDesc: None,
            debuffCountdownDesc: None,
            gainAllDebuffDesc: None,
            dailyUpAttributeDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2ChallengeConst<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2ChallengeConst", 5)?;
        if let Some(f) = self.challengeModeDesc() {
            s.serialize_field("challengeModeDesc", &f)?;
        } else {
            s.skip_field("challengeModeDesc")?;
        }
        if let Some(f) = self.dailyTitleDesc() {
            s.serialize_field("dailyTitleDesc", &f)?;
        } else {
            s.skip_field("dailyTitleDesc")?;
        }
        if let Some(f) = self.debuffCountdownDesc() {
            s.serialize_field("debuffCountdownDesc", &f)?;
        } else {
            s.skip_field("debuffCountdownDesc")?;
        }
        if let Some(f) = self.gainAllDebuffDesc() {
            s.serialize_field("gainAllDebuffDesc", &f)?;
        } else {
            s.skip_field("gainAllDebuffDesc")?;
        }
        if let Some(f) = self.dailyUpAttributeDesc() {
            s.serialize_field("dailyUpAttributeDesc", &f)?;
        } else {
            s.skip_field("dailyUpAttributeDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2ChallengeConstBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ChallengeConstBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_challengeModeDesc(&mut self, challengeModeDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeConst::VT_CHALLENGEMODEDESC,
            challengeModeDesc,
        );
    }
    #[inline]
    pub fn add_dailyTitleDesc(&mut self, dailyTitleDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeConst::VT_DAILYTITLEDESC,
            dailyTitleDesc,
        );
    }
    #[inline]
    pub fn add_debuffCountdownDesc(
        &mut self,
        debuffCountdownDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeConst::VT_DEBUFFCOUNTDOWNDESC,
            debuffCountdownDesc,
        );
    }
    #[inline]
    pub fn add_gainAllDebuffDesc(&mut self, gainAllDebuffDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeConst::VT_GAINALLDEBUFFDESC,
            gainAllDebuffDesc,
        );
    }
    #[inline]
    pub fn add_dailyUpAttributeDesc(
        &mut self,
        dailyUpAttributeDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeConst::VT_DAILYUPATTRIBUTEDESC,
            dailyUpAttributeDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ChallengeConstBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ChallengeConstBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeConst<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ChallengeConst<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ChallengeConst");
        ds.field("challengeModeDesc", &self.challengeModeDesc());
        ds.field("dailyTitleDesc", &self.dailyTitleDesc());
        ds.field("debuffCountdownDesc", &self.debuffCountdownDesc());
        ds.field("gainAllDebuffDesc", &self.gainAllDebuffDesc());
        ds.field("dailyUpAttributeDesc", &self.dailyUpAttributeDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2ChallengeConstT {
    pub challengeModeDesc: Option<String>,
    pub dailyTitleDesc: Option<String>,
    pub debuffCountdownDesc: Option<String>,
    pub gainAllDebuffDesc: Option<String>,
    pub dailyUpAttributeDesc: Option<String>,
}
impl Default for clz_Torappu_SandboxV2ChallengeConstT {
    fn default() -> Self {
        Self {
            challengeModeDesc: None,
            dailyTitleDesc: None,
            debuffCountdownDesc: None,
            gainAllDebuffDesc: None,
            dailyUpAttributeDesc: None,
        }
    }
}
impl clz_Torappu_SandboxV2ChallengeConstT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeConst<'b>> {
        let challengeModeDesc = self
            .challengeModeDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let dailyTitleDesc = self.dailyTitleDesc.as_ref().map(|x| _fbb.create_string(x));
        let debuffCountdownDesc = self
            .debuffCountdownDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let gainAllDebuffDesc = self
            .gainAllDebuffDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let dailyUpAttributeDesc = self
            .dailyUpAttributeDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2ChallengeConst::create(
            _fbb,
            &clz_Torappu_SandboxV2ChallengeConstArgs {
                challengeModeDesc,
                dailyTitleDesc,
                debuffCountdownDesc,
                gainAllDebuffDesc,
                dailyUpAttributeDesc,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2ChallengeModeUnlockDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ChallengeModeUnlockData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ChallengeModeUnlockData<'a> {
    type Inner = clz_Torappu_SandboxV2ChallengeModeUnlockData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ChallengeModeUnlockData<'a> {
    pub const VT_UNLOCKID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_CONDITIONDESC: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ChallengeModeUnlockData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ChallengeModeUnlockDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeUnlockData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ChallengeModeUnlockDataBuilder::new(_fbb);
        if let Some(x) = args.conditionDesc {
            builder.add_conditionDesc(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.unlockId {
            builder.add_unlockId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2ChallengeModeUnlockDataT {
        let unlockId = self.unlockId().map(|x| x.to_string());
        let sortId = self.sortId();
        let conditionDesc = self.conditionDesc().map(|x| x.to_string());
        clz_Torappu_SandboxV2ChallengeModeUnlockDataT {
            unlockId,
            sortId,
            conditionDesc,
        }
    }

    #[inline]
    pub fn unlockId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ChallengeModeUnlockData::VT_UNLOCKID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2ChallengeModeUnlockData::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn conditionDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ChallengeModeUnlockData::VT_CONDITIONDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ChallengeModeUnlockData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockId",
                Self::VT_UNLOCKID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "conditionDesc",
                Self::VT_CONDITIONDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ChallengeModeUnlockDataArgs<'a> {
    pub unlockId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub conditionDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ChallengeModeUnlockDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ChallengeModeUnlockDataArgs {
            unlockId: None,
            sortId: 0,
            conditionDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2ChallengeModeUnlockData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_SandboxV2ChallengeModeUnlockData", 3)?;
        if let Some(f) = self.unlockId() {
            s.serialize_field("unlockId", &f)?;
        } else {
            s.skip_field("unlockId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.conditionDesc() {
            s.serialize_field("conditionDesc", &f)?;
        } else {
            s.skip_field("conditionDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2ChallengeModeUnlockDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ChallengeModeUnlockDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_unlockId(&mut self, unlockId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeModeUnlockData::VT_UNLOCKID,
            unlockId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ChallengeModeUnlockData::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn add_conditionDesc(&mut self, conditionDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeModeUnlockData::VT_CONDITIONDESC,
            conditionDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ChallengeModeUnlockDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ChallengeModeUnlockDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeUnlockData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ChallengeModeUnlockData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ChallengeModeUnlockData");
        ds.field("unlockId", &self.unlockId());
        ds.field("sortId", &self.sortId());
        ds.field("conditionDesc", &self.conditionDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2ChallengeModeUnlockDataT {
    pub unlockId: Option<String>,
    pub sortId: i32,
    pub conditionDesc: Option<String>,
}
impl Default for clz_Torappu_SandboxV2ChallengeModeUnlockDataT {
    fn default() -> Self {
        Self {
            unlockId: None,
            sortId: 0,
            conditionDesc: None,
        }
    }
}
impl clz_Torappu_SandboxV2ChallengeModeUnlockDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeUnlockData<'b>> {
        let unlockId = self.unlockId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let conditionDesc = self.conditionDesc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2ChallengeModeUnlockData::create(
            _fbb,
            &clz_Torappu_SandboxV2ChallengeModeUnlockDataArgs {
                unlockId,
                sortId,
                conditionDesc,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'a>
{
    type Inner = dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ChallengeModeUnlockData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeModeUnlockData>>(
                    dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeModeUnlockData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeUnlockData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeUnlockData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeUnlockData>>(dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2ChallengeModeUnlockDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'b>>
    {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2ChallengeModeRewardDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ChallengeModeRewardData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ChallengeModeRewardData<'a> {
    type Inner = clz_Torappu_SandboxV2ChallengeModeRewardData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ChallengeModeRewardData<'a> {
    pub const VT_REWARDID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_REWARDDAY: flatbuffers::VOffsetT = 8;
    pub const VT_REWARDITEMLIST: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ChallengeModeRewardData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ChallengeModeRewardDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeRewardData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ChallengeModeRewardDataBuilder::new(_fbb);
        if let Some(x) = args.rewardItemList {
            builder.add_rewardItemList(x);
        }
        builder.add_rewardDay(args.rewardDay);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.rewardId {
            builder.add_rewardId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2ChallengeModeRewardDataT {
        let rewardId = self.rewardId().map(|x| x.to_string());
        let sortId = self.sortId();
        let rewardDay = self.rewardDay();
        let rewardItemList = self
            .rewardItemList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_SandboxV2ChallengeModeRewardDataT {
            rewardId,
            sortId,
            rewardDay,
            rewardItemList,
        }
    }

    #[inline]
    pub fn rewardId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ChallengeModeRewardData::VT_REWARDID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2ChallengeModeRewardData::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rewardDay(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2ChallengeModeRewardData::VT_REWARDDAY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rewardItemList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(
                clz_Torappu_SandboxV2ChallengeModeRewardData::VT_REWARDITEMLIST,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ChallengeModeRewardData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rewardId",
                Self::VT_REWARDID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<i32>("rewardDay", Self::VT_REWARDDAY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("rewardItemList", Self::VT_REWARDITEMLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ChallengeModeRewardDataArgs<'a> {
    pub rewardId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub rewardDay: i32,
    pub rewardItemList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2ChallengeModeRewardDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ChallengeModeRewardDataArgs {
            rewardId: None,
            sortId: 0,
            rewardDay: 0,
            rewardItemList: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2ChallengeModeRewardData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_SandboxV2ChallengeModeRewardData", 4)?;
        if let Some(f) = self.rewardId() {
            s.serialize_field("rewardId", &f)?;
        } else {
            s.skip_field("rewardId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.serialize_field("rewardDay", &self.rewardDay())?;
        if let Some(f) = self.rewardItemList() {
            s.serialize_field("rewardItemList", &f)?;
        } else {
            s.skip_field("rewardItemList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2ChallengeModeRewardDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ChallengeModeRewardDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_rewardId(&mut self, rewardId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeModeRewardData::VT_REWARDID,
            rewardId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ChallengeModeRewardData::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn add_rewardDay(&mut self, rewardDay: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ChallengeModeRewardData::VT_REWARDDAY,
            rewardDay,
            0,
        );
    }
    #[inline]
    pub fn add_rewardItemList(
        &mut self,
        rewardItemList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeModeRewardData::VT_REWARDITEMLIST,
            rewardItemList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ChallengeModeRewardDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ChallengeModeRewardDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeRewardData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ChallengeModeRewardData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ChallengeModeRewardData");
        ds.field("rewardId", &self.rewardId());
        ds.field("sortId", &self.sortId());
        ds.field("rewardDay", &self.rewardDay());
        ds.field("rewardItemList", &self.rewardItemList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2ChallengeModeRewardDataT {
    pub rewardId: Option<String>,
    pub sortId: i32,
    pub rewardDay: i32,
    pub rewardItemList: Option<Vec<clz_Torappu_ItemBundleT>>,
}
impl Default for clz_Torappu_SandboxV2ChallengeModeRewardDataT {
    fn default() -> Self {
        Self {
            rewardId: None,
            sortId: 0,
            rewardDay: 0,
            rewardItemList: None,
        }
    }
}
impl clz_Torappu_SandboxV2ChallengeModeRewardDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeRewardData<'b>> {
        let rewardId = self.rewardId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let rewardDay = self.rewardDay;
        let rewardItemList = self.rewardItemList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SandboxV2ChallengeModeRewardData::create(
            _fbb,
            &clz_Torappu_SandboxV2ChallengeModeRewardDataArgs {
                rewardId,
                sortId,
                rewardDay,
                rewardItemList,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'a>
{
    type Inner = dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2ChallengeModeRewardData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeModeRewardData>>(
                    dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeModeRewardData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeRewardData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeRewardData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeRewardData>>(dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2ChallengeModeRewardDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'b>>
    {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxV2ChallengeModeDifficultyDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ChallengeModeDifficultyData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ChallengeModeDifficultyData<'a> {
    type Inner = clz_Torappu_SandboxV2ChallengeModeDifficultyData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ChallengeModeDifficultyData<'a> {
    pub const VT_CHALLENGEDAY: flatbuffers::VOffsetT = 4;
    pub const VT_DIFFDESC: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ChallengeModeDifficultyData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ChallengeModeDifficultyDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeDifficultyData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ChallengeModeDifficultyDataBuilder::new(_fbb);
        if let Some(x) = args.diffDesc {
            builder.add_diffDesc(x);
        }
        builder.add_challengeDay(args.challengeDay);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2ChallengeModeDifficultyDataT {
        let challengeDay = self.challengeDay();
        let diffDesc = self.diffDesc().map(|x| x.to_string());
        clz_Torappu_SandboxV2ChallengeModeDifficultyDataT {
            challengeDay,
            diffDesc,
        }
    }

    #[inline]
    pub fn challengeDay(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxV2ChallengeModeDifficultyData::VT_CHALLENGEDAY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn diffDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxV2ChallengeModeDifficultyData::VT_DIFFDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ChallengeModeDifficultyData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("challengeDay", Self::VT_CHALLENGEDAY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "diffDesc",
                Self::VT_DIFFDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ChallengeModeDifficultyDataArgs<'a> {
    pub challengeDay: i32,
    pub diffDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxV2ChallengeModeDifficultyDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ChallengeModeDifficultyDataArgs {
            challengeDay: 0,
            diffDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2ChallengeModeDifficultyData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_SandboxV2ChallengeModeDifficultyData", 2)?;
        s.serialize_field("challengeDay", &self.challengeDay())?;
        if let Some(f) = self.diffDesc() {
            s.serialize_field("diffDesc", &f)?;
        } else {
            s.skip_field("diffDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2ChallengeModeDifficultyDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ChallengeModeDifficultyDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_challengeDay(&mut self, challengeDay: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxV2ChallengeModeDifficultyData::VT_CHALLENGEDAY,
            challengeDay,
            0,
        );
    }
    #[inline]
    pub fn add_diffDesc(&mut self, diffDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeModeDifficultyData::VT_DIFFDESC,
            diffDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ChallengeModeDifficultyDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ChallengeModeDifficultyDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeDifficultyData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ChallengeModeDifficultyData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ChallengeModeDifficultyData");
        ds.field("challengeDay", &self.challengeDay());
        ds.field("diffDesc", &self.diffDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2ChallengeModeDifficultyDataT {
    pub challengeDay: i32,
    pub diffDesc: Option<String>,
}
impl Default for clz_Torappu_SandboxV2ChallengeModeDifficultyDataT {
    fn default() -> Self {
        Self {
            challengeDay: 0,
            diffDesc: None,
        }
    }
}
impl clz_Torappu_SandboxV2ChallengeModeDifficultyDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeDifficultyData<'b>> {
        let challengeDay = self.challengeDay;
        let diffDesc = self.diffDesc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxV2ChallengeModeDifficultyData::create(
            _fbb,
            &clz_Torappu_SandboxV2ChallengeModeDifficultyDataArgs {
                challengeDay,
                diffDesc,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2ChallengeModeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2ChallengeModeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2ChallengeModeData<'a> {
    type Inner = clz_Torappu_SandboxV2ChallengeModeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2ChallengeModeData<'a> {
    pub const VT_CHALLENGECONST: flatbuffers::VOffsetT = 4;
    pub const VT_CHALLENGEMODEUNLOCKDATA: flatbuffers::VOffsetT = 6;
    pub const VT_CHALLENGEMODEREWARDDATA: flatbuffers::VOffsetT = 8;
    pub const VT_CHALLENGEMODEDIFFICULTYDATA: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2ChallengeModeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2ChallengeModeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2ChallengeModeDataBuilder::new(_fbb);
        if let Some(x) = args.challengeModeDifficultyData {
            builder.add_challengeModeDifficultyData(x);
        }
        if let Some(x) = args.challengeModeRewardData {
            builder.add_challengeModeRewardData(x);
        }
        if let Some(x) = args.challengeModeUnlockData {
            builder.add_challengeModeUnlockData(x);
        }
        if let Some(x) = args.challengeConst {
            builder.add_challengeConst(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2ChallengeModeDataT {
        let challengeConst = self.challengeConst().map(|x| Box::new(x.unpack()));
        let challengeModeUnlockData = self
            .challengeModeUnlockData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let challengeModeRewardData = self
            .challengeModeRewardData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let challengeModeDifficultyData = self
            .challengeModeDifficultyData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_SandboxV2ChallengeModeDataT {
            challengeConst,
            challengeModeUnlockData,
            challengeModeRewardData,
            challengeModeDifficultyData,
        }
    }

    #[inline]
    pub fn challengeConst(&self) -> Option<clz_Torappu_SandboxV2ChallengeConst<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeConst>>(
                    clz_Torappu_SandboxV2ChallengeModeData::VT_CHALLENGECONST,
                    None,
                )
        }
    }
    #[inline]
    pub fn challengeModeUnlockData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData,
                    >,
                >,
            >>(
                clz_Torappu_SandboxV2ChallengeModeData::VT_CHALLENGEMODEUNLOCKDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn challengeModeRewardData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData,
                    >,
                >,
            >>(
                clz_Torappu_SandboxV2ChallengeModeData::VT_CHALLENGEMODEREWARDDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn challengeModeDifficultyData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeModeDifficultyData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeModeDifficultyData>,
                >,
            >>(
                clz_Torappu_SandboxV2ChallengeModeData::VT_CHALLENGEMODEDIFFICULTYDATA,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2ChallengeModeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeConst>>(
                "challengeConst",
                Self::VT_CHALLENGECONST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData,
                    >,
                >,
            >>(
                "challengeModeUnlockData",
                Self::VT_CHALLENGEMODEUNLOCKDATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData,
                    >,
                >,
            >>(
                "challengeModeRewardData",
                Self::VT_CHALLENGEMODEREWARDDATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeModeDifficultyData>,
                >,
            >>(
                "challengeModeDifficultyData",
                Self::VT_CHALLENGEMODEDIFFICULTYDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2ChallengeModeDataArgs<'a> {
    pub challengeConst: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeConst<'a>>>,
    pub challengeModeUnlockData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'a>,
                >,
            >,
        >,
    >,
    pub challengeModeRewardData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'a>,
                >,
            >,
        >,
    >,
    pub challengeModeDifficultyData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeModeDifficultyData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SandboxV2ChallengeModeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2ChallengeModeDataArgs {
            challengeConst: None,
            challengeModeUnlockData: None,
            challengeModeRewardData: None,
            challengeModeDifficultyData: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2ChallengeModeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2ChallengeModeData", 4)?;
        if let Some(f) = self.challengeConst() {
            s.serialize_field("challengeConst", &f)?;
        } else {
            s.skip_field("challengeConst")?;
        }
        if let Some(f) = self.challengeModeUnlockData() {
            s.serialize_field("challengeModeUnlockData", &f)?;
        } else {
            s.skip_field("challengeModeUnlockData")?;
        }
        if let Some(f) = self.challengeModeRewardData() {
            s.serialize_field("challengeModeRewardData", &f)?;
        } else {
            s.skip_field("challengeModeRewardData")?;
        }
        if let Some(f) = self.challengeModeDifficultyData() {
            s.serialize_field("challengeModeDifficultyData", &f)?;
        } else {
            s.skip_field("challengeModeDifficultyData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2ChallengeModeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxV2ChallengeModeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_challengeConst(
        &mut self,
        challengeConst: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeConst<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeConst>>(
                clz_Torappu_SandboxV2ChallengeModeData::VT_CHALLENGECONST,
                challengeConst,
            );
    }
    #[inline]
    pub fn add_challengeModeUnlockData(
        &mut self,
        challengeModeUnlockData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeModeData::VT_CHALLENGEMODEUNLOCKDATA,
            challengeModeUnlockData,
        );
    }
    #[inline]
    pub fn add_challengeModeRewardData(
        &mut self,
        challengeModeRewardData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ChallengeModeRewardData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeModeData::VT_CHALLENGEMODEREWARDDATA,
            challengeModeRewardData,
        );
    }
    #[inline]
    pub fn add_challengeModeDifficultyData(
        &mut self,
        challengeModeDifficultyData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeModeDifficultyData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2ChallengeModeData::VT_CHALLENGEMODEDIFFICULTYDATA,
            challengeModeDifficultyData,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2ChallengeModeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2ChallengeModeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2ChallengeModeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2ChallengeModeData");
        ds.field("challengeConst", &self.challengeConst());
        ds.field("challengeModeUnlockData", &self.challengeModeUnlockData());
        ds.field("challengeModeRewardData", &self.challengeModeRewardData());
        ds.field(
            "challengeModeDifficultyData",
            &self.challengeModeDifficultyData(),
        );
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2ChallengeModeDataT {
    pub challengeConst: Option<Box<clz_Torappu_SandboxV2ChallengeConstT>>,
    pub challengeModeUnlockData:
        Option<Vec<dict__string__clz_Torappu_SandboxV2ChallengeModeUnlockDataT>>,
    pub challengeModeRewardData:
        Option<Vec<dict__string__clz_Torappu_SandboxV2ChallengeModeRewardDataT>>,
    pub challengeModeDifficultyData: Option<Vec<clz_Torappu_SandboxV2ChallengeModeDifficultyDataT>>,
}
impl Default for clz_Torappu_SandboxV2ChallengeModeDataT {
    fn default() -> Self {
        Self {
            challengeConst: None,
            challengeModeUnlockData: None,
            challengeModeRewardData: None,
            challengeModeDifficultyData: None,
        }
    }
}
impl clz_Torappu_SandboxV2ChallengeModeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeData<'b>> {
        let challengeConst = self.challengeConst.as_ref().map(|x| x.pack(_fbb));
        let challengeModeUnlockData = self.challengeModeUnlockData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let challengeModeRewardData = self.challengeModeRewardData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let challengeModeDifficultyData = self.challengeModeDifficultyData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SandboxV2ChallengeModeData::create(
            _fbb,
            &clz_Torappu_SandboxV2ChallengeModeDataArgs {
                challengeConst,
                challengeModeUnlockData,
                challengeModeRewardData,
                challengeModeDifficultyData,
            },
        )
    }
}
pub enum clz_Torappu_SandboxV2DataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxV2Data<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxV2Data<'a> {
    type Inner = clz_Torappu_SandboxV2Data<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxV2Data<'a> {
    pub const VT_MAPDATA: flatbuffers::VOffsetT = 4;
    pub const VT_ITEMTRAPDATA: flatbuffers::VOffsetT = 6;
    pub const VT_ITEMTRAPTAGDATA: flatbuffers::VOffsetT = 8;
    pub const VT_BUILDINGITEMDATA: flatbuffers::VOffsetT = 10;
    pub const VT_CRAFTITEMDATA: flatbuffers::VOffsetT = 12;
    pub const VT_LIVESTOCKPRODUCEDATA: flatbuffers::VOffsetT = 14;
    pub const VT_CRAFTGROUPDATA: flatbuffers::VOffsetT = 16;
    pub const VT_ALCHEMYRECIPEDATA: flatbuffers::VOffsetT = 18;
    pub const VT_DRINKMATDATA: flatbuffers::VOffsetT = 20;
    pub const VT_FOODMATDATA: flatbuffers::VOffsetT = 22;
    pub const VT_FOODDATA: flatbuffers::VOffsetT = 24;
    pub const VT_NODETYPEDATA: flatbuffers::VOffsetT = 26;
    pub const VT_NODEUPGRADEDATA: flatbuffers::VOffsetT = 28;
    pub const VT_WEATHERDATA: flatbuffers::VOffsetT = 30;
    pub const VT_STAGEDATA: flatbuffers::VOffsetT = 32;
    pub const VT_ZONEDATA: flatbuffers::VOffsetT = 34;
    pub const VT_NODEBUFFDATA: flatbuffers::VOffsetT = 36;
    pub const VT_REWARDCONFIGDATA: flatbuffers::VOffsetT = 38;
    pub const VT_FLOATICONDATA: flatbuffers::VOffsetT = 40;
    pub const VT_ENEMYRUSHTYPEDATA: flatbuffers::VOffsetT = 42;
    pub const VT_RUSHENEMYDATA: flatbuffers::VOffsetT = 44;
    pub const VT_GAMECONST: flatbuffers::VOffsetT = 46;
    pub const VT_BASICCONST: flatbuffers::VOffsetT = 48;
    pub const VT_RIFTCONST: flatbuffers::VOffsetT = 50;
    pub const VT_DEVELOPMENTCONST: flatbuffers::VOffsetT = 52;
    pub const VT_BATTLELOADINGTIPS: flatbuffers::VOffsetT = 54;
    pub const VT_RUNEDATAS: flatbuffers::VOffsetT = 56;
    pub const VT_ITEMRUNELIST: flatbuffers::VOffsetT = 58;
    pub const VT_QUESTDATA: flatbuffers::VOffsetT = 60;
    pub const VT_NPCDATA: flatbuffers::VOffsetT = 62;
    pub const VT_DIALOGDATA: flatbuffers::VOffsetT = 64;
    pub const VT_QUESTLINEDATA: flatbuffers::VOffsetT = 66;
    pub const VT_QUESTLINESTORYDATA: flatbuffers::VOffsetT = 68;
    pub const VT_GUIDEQUESTDATA: flatbuffers::VOffsetT = 70;
    pub const VT_DEVELOPMENTDATA: flatbuffers::VOffsetT = 72;
    pub const VT_EVENTDATA: flatbuffers::VOffsetT = 74;
    pub const VT_EVENTSCENEDATA: flatbuffers::VOffsetT = 76;
    pub const VT_EVENTCHOICEDATA: flatbuffers::VOffsetT = 78;
    pub const VT_EXPEDITIONDATA: flatbuffers::VOffsetT = 80;
    pub const VT_EVENTEFFECTDATA: flatbuffers::VOffsetT = 82;
    pub const VT_SHOPGOODDATA: flatbuffers::VOffsetT = 84;
    pub const VT_SHOPDIALOGDATA: flatbuffers::VOffsetT = 86;
    pub const VT_LOGISTICSDATA: flatbuffers::VOffsetT = 88;
    pub const VT_LOGISTICSCHARMAPPING: flatbuffers::VOffsetT = 90;
    pub const VT_MATERIALKEYWORDDATA: flatbuffers::VOffsetT = 92;
    pub const VT_MONTHRUSHDATA: flatbuffers::VOffsetT = 94;
    pub const VT_RIFTTERRAINPARAMDATA: flatbuffers::VOffsetT = 96;
    pub const VT_RIFTCLIMATEPARAMDATA: flatbuffers::VOffsetT = 98;
    pub const VT_RIFTENEMYPARAMDATA: flatbuffers::VOffsetT = 100;
    pub const VT_RIFTSUBTARGETDATA: flatbuffers::VOffsetT = 102;
    pub const VT_RIFTMAINTARGETDATA: flatbuffers::VOffsetT = 104;
    pub const VT_RIFTGLOBALEFFECTDATA: flatbuffers::VOffsetT = 106;
    pub const VT_FIXEDRIFTDATA: flatbuffers::VOffsetT = 108;
    pub const VT_RIFTTEAMBUFFDATA: flatbuffers::VOffsetT = 110;
    pub const VT_RIFTDIFFICULTYDATA: flatbuffers::VOffsetT = 112;
    pub const VT_RIFTREWARDDISPLAYDATA: flatbuffers::VOffsetT = 114;
    pub const VT_ENEMYREPLACEDATA: flatbuffers::VOffsetT = 116;
    pub const VT_ARCHIVEQUESTDATA: flatbuffers::VOffsetT = 118;
    pub const VT_ACHIEVEMENTDATA: flatbuffers::VOffsetT = 120;
    pub const VT_ACHIEVEMENTTYPEDATA: flatbuffers::VOffsetT = 122;
    pub const VT_ARCHIVEQUESTTYPEDATA: flatbuffers::VOffsetT = 124;
    pub const VT_ARCHIVEMUSICUNLOCKDATA: flatbuffers::VOffsetT = 126;
    pub const VT_BASEUPDATE: flatbuffers::VOffsetT = 128;
    pub const VT_DEVELOPMENTLINESEGMENTDATAS: flatbuffers::VOffsetT = 130;
    pub const VT_BUILDINGNODESCOREDATA: flatbuffers::VOffsetT = 132;
    pub const VT_SEASONDATA: flatbuffers::VOffsetT = 134;
    pub const VT_CONFIRMICONDATA: flatbuffers::VOffsetT = 136;
    pub const VT_SHOPUPDATETIMEDATA: flatbuffers::VOffsetT = 138;
    pub const VT_TUTORIALDATA: flatbuffers::VOffsetT = 140;
    pub const VT_RACINGDATA: flatbuffers::VOffsetT = 142;
    pub const VT_CHALLENGEMODEDATA: flatbuffers::VOffsetT = 144;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxV2Data { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxV2DataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2Data<'bldr>> {
        let mut builder = clz_Torappu_SandboxV2DataBuilder::new(_fbb);
        if let Some(x) = args.challengeModeData {
            builder.add_challengeModeData(x);
        }
        if let Some(x) = args.racingData {
            builder.add_racingData(x);
        }
        if let Some(x) = args.tutorialData {
            builder.add_tutorialData(x);
        }
        if let Some(x) = args.shopUpdateTimeData {
            builder.add_shopUpdateTimeData(x);
        }
        if let Some(x) = args.confirmIconData {
            builder.add_confirmIconData(x);
        }
        if let Some(x) = args.seasonData {
            builder.add_seasonData(x);
        }
        if let Some(x) = args.buildingNodeScoreData {
            builder.add_buildingNodeScoreData(x);
        }
        if let Some(x) = args.developmentLineSegmentDatas {
            builder.add_developmentLineSegmentDatas(x);
        }
        if let Some(x) = args.baseUpdate {
            builder.add_baseUpdate(x);
        }
        if let Some(x) = args.archiveMusicUnlockData {
            builder.add_archiveMusicUnlockData(x);
        }
        if let Some(x) = args.archiveQuestTypeData {
            builder.add_archiveQuestTypeData(x);
        }
        if let Some(x) = args.achievementTypeData {
            builder.add_achievementTypeData(x);
        }
        if let Some(x) = args.achievementData {
            builder.add_achievementData(x);
        }
        if let Some(x) = args.archiveQuestData {
            builder.add_archiveQuestData(x);
        }
        if let Some(x) = args.enemyReplaceData {
            builder.add_enemyReplaceData(x);
        }
        if let Some(x) = args.riftRewardDisplayData {
            builder.add_riftRewardDisplayData(x);
        }
        if let Some(x) = args.riftDifficultyData {
            builder.add_riftDifficultyData(x);
        }
        if let Some(x) = args.riftTeamBuffData {
            builder.add_riftTeamBuffData(x);
        }
        if let Some(x) = args.fixedRiftData {
            builder.add_fixedRiftData(x);
        }
        if let Some(x) = args.riftGlobalEffectData {
            builder.add_riftGlobalEffectData(x);
        }
        if let Some(x) = args.riftMainTargetData {
            builder.add_riftMainTargetData(x);
        }
        if let Some(x) = args.riftSubTargetData {
            builder.add_riftSubTargetData(x);
        }
        if let Some(x) = args.riftEnemyParamData {
            builder.add_riftEnemyParamData(x);
        }
        if let Some(x) = args.riftClimateParamData {
            builder.add_riftClimateParamData(x);
        }
        if let Some(x) = args.riftTerrainParamData {
            builder.add_riftTerrainParamData(x);
        }
        if let Some(x) = args.monthRushData {
            builder.add_monthRushData(x);
        }
        if let Some(x) = args.materialKeywordData {
            builder.add_materialKeywordData(x);
        }
        if let Some(x) = args.logisticsCharMapping {
            builder.add_logisticsCharMapping(x);
        }
        if let Some(x) = args.logisticsData {
            builder.add_logisticsData(x);
        }
        if let Some(x) = args.shopDialogData {
            builder.add_shopDialogData(x);
        }
        if let Some(x) = args.shopGoodData {
            builder.add_shopGoodData(x);
        }
        if let Some(x) = args.eventEffectData {
            builder.add_eventEffectData(x);
        }
        if let Some(x) = args.expeditionData {
            builder.add_expeditionData(x);
        }
        if let Some(x) = args.eventChoiceData {
            builder.add_eventChoiceData(x);
        }
        if let Some(x) = args.eventSceneData {
            builder.add_eventSceneData(x);
        }
        if let Some(x) = args.eventData {
            builder.add_eventData(x);
        }
        if let Some(x) = args.developmentData {
            builder.add_developmentData(x);
        }
        if let Some(x) = args.guideQuestData {
            builder.add_guideQuestData(x);
        }
        if let Some(x) = args.questLineStoryData {
            builder.add_questLineStoryData(x);
        }
        if let Some(x) = args.questLineData {
            builder.add_questLineData(x);
        }
        if let Some(x) = args.dialogData {
            builder.add_dialogData(x);
        }
        if let Some(x) = args.npcData {
            builder.add_npcData(x);
        }
        if let Some(x) = args.questData {
            builder.add_questData(x);
        }
        if let Some(x) = args.itemRuneList {
            builder.add_itemRuneList(x);
        }
        if let Some(x) = args.runeDatas {
            builder.add_runeDatas(x);
        }
        if let Some(x) = args.battleLoadingTips {
            builder.add_battleLoadingTips(x);
        }
        if let Some(x) = args.developmentConst {
            builder.add_developmentConst(x);
        }
        if let Some(x) = args.riftConst {
            builder.add_riftConst(x);
        }
        if let Some(x) = args.basicConst {
            builder.add_basicConst(x);
        }
        if let Some(x) = args.gameConst {
            builder.add_gameConst(x);
        }
        if let Some(x) = args.rushEnemyData {
            builder.add_rushEnemyData(x);
        }
        if let Some(x) = args.enemyRushTypeData {
            builder.add_enemyRushTypeData(x);
        }
        if let Some(x) = args.floatIconData {
            builder.add_floatIconData(x);
        }
        if let Some(x) = args.rewardConfigData {
            builder.add_rewardConfigData(x);
        }
        if let Some(x) = args.nodeBuffData {
            builder.add_nodeBuffData(x);
        }
        if let Some(x) = args.zoneData {
            builder.add_zoneData(x);
        }
        if let Some(x) = args.stageData {
            builder.add_stageData(x);
        }
        if let Some(x) = args.weatherData {
            builder.add_weatherData(x);
        }
        if let Some(x) = args.nodeUpgradeData {
            builder.add_nodeUpgradeData(x);
        }
        if let Some(x) = args.nodeTypeData {
            builder.add_nodeTypeData(x);
        }
        if let Some(x) = args.foodData {
            builder.add_foodData(x);
        }
        if let Some(x) = args.foodMatData {
            builder.add_foodMatData(x);
        }
        if let Some(x) = args.drinkMatData {
            builder.add_drinkMatData(x);
        }
        if let Some(x) = args.alchemyRecipeData {
            builder.add_alchemyRecipeData(x);
        }
        if let Some(x) = args.craftGroupData {
            builder.add_craftGroupData(x);
        }
        if let Some(x) = args.livestockProduceData {
            builder.add_livestockProduceData(x);
        }
        if let Some(x) = args.craftItemData {
            builder.add_craftItemData(x);
        }
        if let Some(x) = args.buildingItemData {
            builder.add_buildingItemData(x);
        }
        if let Some(x) = args.itemTrapTagData {
            builder.add_itemTrapTagData(x);
        }
        if let Some(x) = args.itemTrapData {
            builder.add_itemTrapData(x);
        }
        if let Some(x) = args.mapData {
            builder.add_mapData(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxV2DataT {
        let mapData = self
            .mapData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let itemTrapData = self
            .itemTrapData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let itemTrapTagData = self
            .itemTrapTagData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let buildingItemData = self
            .buildingItemData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let craftItemData = self
            .craftItemData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let livestockProduceData = self
            .livestockProduceData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let craftGroupData = self
            .craftGroupData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let alchemyRecipeData = self
            .alchemyRecipeData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let drinkMatData = self
            .drinkMatData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let foodMatData = self
            .foodMatData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let foodData = self
            .foodData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let nodeTypeData = self
            .nodeTypeData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let nodeUpgradeData = self
            .nodeUpgradeData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let weatherData = self
            .weatherData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let stageData = self
            .stageData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let zoneData = self
            .zoneData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let nodeBuffData = self
            .nodeBuffData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let rewardConfigData = self.rewardConfigData().map(|x| Box::new(x.unpack()));
        let floatIconData = self
            .floatIconData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let enemyRushTypeData = self
            .enemyRushTypeData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let rushEnemyData = self.rushEnemyData().map(|x| Box::new(x.unpack()));
        let gameConst = self.gameConst().map(|x| Box::new(x.unpack()));
        let basicConst = self.basicConst().map(|x| Box::new(x.unpack()));
        let riftConst = self.riftConst().map(|x| Box::new(x.unpack()));
        let developmentConst = self.developmentConst().map(|x| Box::new(x.unpack()));
        let battleLoadingTips = self
            .battleLoadingTips()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let runeDatas = self
            .runeDatas()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let itemRuneList = self
            .itemRuneList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let questData = self
            .questData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let npcData = self
            .npcData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let dialogData = self
            .dialogData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let questLineData = self
            .questLineData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let questLineStoryData = self
            .questLineStoryData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let guideQuestData = self
            .guideQuestData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let developmentData = self
            .developmentData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let eventData = self
            .eventData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let eventSceneData = self
            .eventSceneData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let eventChoiceData = self
            .eventChoiceData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let expeditionData = self
            .expeditionData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let eventEffectData = self
            .eventEffectData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let shopGoodData = self
            .shopGoodData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let shopDialogData = self.shopDialogData().map(|x| Box::new(x.unpack()));
        let logisticsData = self
            .logisticsData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let logisticsCharMapping = self
            .logisticsCharMapping()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let materialKeywordData = self
            .materialKeywordData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let monthRushData = self
            .monthRushData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let riftTerrainParamData = self
            .riftTerrainParamData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let riftClimateParamData = self
            .riftClimateParamData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let riftEnemyParamData = self
            .riftEnemyParamData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let riftSubTargetData = self
            .riftSubTargetData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let riftMainTargetData = self
            .riftMainTargetData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let riftGlobalEffectData = self
            .riftGlobalEffectData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let fixedRiftData = self
            .fixedRiftData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let riftTeamBuffData = self
            .riftTeamBuffData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let riftDifficultyData = self
            .riftDifficultyData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let riftRewardDisplayData = self
            .riftRewardDisplayData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let enemyReplaceData = self
            .enemyReplaceData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let archiveQuestData = self
            .archiveQuestData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let achievementData = self
            .achievementData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let achievementTypeData = self
            .achievementTypeData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let archiveQuestTypeData = self
            .archiveQuestTypeData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let archiveMusicUnlockData = self
            .archiveMusicUnlockData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let baseUpdate = self
            .baseUpdate()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let developmentLineSegmentDatas = self
            .developmentLineSegmentDatas()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let buildingNodeScoreData = self
            .buildingNodeScoreData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let seasonData = self
            .seasonData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let confirmIconData = self
            .confirmIconData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let shopUpdateTimeData = self.shopUpdateTimeData().map(|x| x.into_iter().collect());
        let tutorialData = self.tutorialData().map(|x| Box::new(x.unpack()));
        let racingData = self.racingData().map(|x| Box::new(x.unpack()));
        let challengeModeData = self.challengeModeData().map(|x| Box::new(x.unpack()));
        clz_Torappu_SandboxV2DataT {
            mapData,
            itemTrapData,
            itemTrapTagData,
            buildingItemData,
            craftItemData,
            livestockProduceData,
            craftGroupData,
            alchemyRecipeData,
            drinkMatData,
            foodMatData,
            foodData,
            nodeTypeData,
            nodeUpgradeData,
            weatherData,
            stageData,
            zoneData,
            nodeBuffData,
            rewardConfigData,
            floatIconData,
            enemyRushTypeData,
            rushEnemyData,
            gameConst,
            basicConst,
            riftConst,
            developmentConst,
            battleLoadingTips,
            runeDatas,
            itemRuneList,
            questData,
            npcData,
            dialogData,
            questLineData,
            questLineStoryData,
            guideQuestData,
            developmentData,
            eventData,
            eventSceneData,
            eventChoiceData,
            expeditionData,
            eventEffectData,
            shopGoodData,
            shopDialogData,
            logisticsData,
            logisticsCharMapping,
            materialKeywordData,
            monthRushData,
            riftTerrainParamData,
            riftClimateParamData,
            riftEnemyParamData,
            riftSubTargetData,
            riftMainTargetData,
            riftGlobalEffectData,
            fixedRiftData,
            riftTeamBuffData,
            riftDifficultyData,
            riftRewardDisplayData,
            enemyReplaceData,
            archiveQuestData,
            achievementData,
            achievementTypeData,
            archiveQuestTypeData,
            archiveMusicUnlockData,
            baseUpdate,
            developmentLineSegmentDatas,
            buildingNodeScoreData,
            seasonData,
            confirmIconData,
            shopUpdateTimeData,
            tutorialData,
            racingData,
            challengeModeData,
        }
    }

    #[inline]
    pub fn mapData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2MapData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2MapData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_MAPDATA, None)
        }
    }
    #[inline]
    pub fn itemTrapData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ItemTrapData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ItemTrapData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ITEMTRAPDATA, None)
        }
    }
    #[inline]
    pub fn itemTrapTagData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2ItemTrapTagData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ITEMTRAPTAGDATA, None)
        }
    }
    #[inline]
    pub fn buildingItemData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2BuildingItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2BuildingItemData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_BUILDINGITEMDATA, None)
        }
    }
    #[inline]
    pub fn craftItemData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2CraftItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2CraftItemData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_CRAFTITEMDATA, None)
        }
    }
    #[inline]
    pub fn livestockProduceData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2LivestockData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2LivestockData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_LIVESTOCKPRODUCEDATA, None)
        }
    }
    #[inline]
    pub fn craftGroupData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2CraftGroupData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2CraftGroupData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_CRAFTGROUPDATA, None)
        }
    }
    #[inline]
    pub fn alchemyRecipeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2AlchemyRecipeData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ALCHEMYRECIPEDATA, None)
        }
    }
    #[inline]
    pub fn drinkMatData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DrinkMatData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DrinkMatData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_DRINKMATDATA, None)
        }
    }
    #[inline]
    pub fn foodMatData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FoodMatData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FoodMatData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_FOODMATDATA, None)
        }
    }
    #[inline]
    pub fn foodData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FoodData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FoodData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_FOODDATA, None)
        }
    }
    #[inline]
    pub fn nodeTypeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeTypeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeTypeData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_NODETYPEDATA, None)
        }
    }
    #[inline]
    pub fn nodeUpgradeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2NodeUpgradeData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_NODEUPGRADEDATA, None)
        }
    }
    #[inline]
    pub fn weatherData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2WeatherData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2WeatherData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_WEATHERDATA, None)
        }
    }
    #[inline]
    pub fn stageData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2StageData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2StageData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_STAGEDATA, None)
        }
    }
    #[inline]
    pub fn zoneData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ZoneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ZoneData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ZONEDATA, None)
        }
    }
    #[inline]
    pub fn nodeBuffData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeBuffData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeBuffData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_NODEBUFFDATA, None)
        }
    }
    #[inline]
    pub fn rewardConfigData(&self) -> Option<clz_Torappu_SandboxV2RewardConfigGroupData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RewardConfigGroupData>>(
                    clz_Torappu_SandboxV2Data::VT_REWARDCONFIGDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn floatIconData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FloatIconData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FloatIconData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_FLOATICONDATA, None)
        }
    }
    #[inline]
    pub fn enemyRushTypeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2EnemyRushTypeData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ENEMYRUSHTYPEDATA, None)
        }
    }
    #[inline]
    pub fn rushEnemyData(&self) -> Option<clz_Torappu_SandboxV2BattleRushEnemyData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyData>>(
                    clz_Torappu_SandboxV2Data::VT_RUSHENEMYDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn gameConst(&self) -> Option<clz_Torappu_SandboxV2GameConst<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2GameConst>>(
                    clz_Torappu_SandboxV2Data::VT_GAMECONST,
                    None,
                )
        }
    }
    #[inline]
    pub fn basicConst(&self) -> Option<clz_Torappu_SandboxV2BasicConst<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BasicConst>>(
                    clz_Torappu_SandboxV2Data::VT_BASICCONST,
                    None,
                )
        }
    }
    #[inline]
    pub fn riftConst(&self) -> Option<clz_Torappu_SandboxV2RiftConst<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftConst>>(
                    clz_Torappu_SandboxV2Data::VT_RIFTCONST,
                    None,
                )
        }
    }
    #[inline]
    pub fn developmentConst(&self) -> Option<clz_Torappu_SandboxV2DevelopmentConst<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DevelopmentConst>>(
                    clz_Torappu_SandboxV2Data::VT_DEVELOPMENTCONST,
                    None,
                )
        }
    }
    #[inline]
    pub fn battleLoadingTips(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TipData<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TipData>>,
            >>(clz_Torappu_SandboxV2Data::VT_BATTLELOADINGTIPS, None)
        }
    }
    #[inline]
    pub fn runeDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RuneTable_PackedRuneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RuneTable_PackedRuneData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_RUNEDATAS, None)
        }
    }
    #[inline]
    pub fn itemRuneList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__list_clz_Torappu_LegacyInLevelRuneData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ITEMRUNELIST, None)
        }
    }
    #[inline]
    pub fn questData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_QUESTDATA, None)
        }
    }
    #[inline]
    pub fn npcData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NpcData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NpcData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_NPCDATA, None)
        }
    }
    #[inline]
    pub fn dialogData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DialogData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DialogData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_DIALOGDATA, None)
        }
    }
    #[inline]
    pub fn questLineData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestLineData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestLineData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_QUESTLINEDATA, None)
        }
    }
    #[inline]
    pub fn questLineStoryData(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(clz_Torappu_SandboxV2Data::VT_QUESTLINESTORYDATA, None)
        }
    }
    #[inline]
    pub fn guideQuestData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_GUIDEQUESTDATA, None)
        }
    }
    #[inline]
    pub fn developmentData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DevelopmentData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2DevelopmentData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_DEVELOPMENTDATA, None)
        }
    }
    #[inline]
    pub fn eventData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_EVENTDATA, None)
        }
    }
    #[inline]
    pub fn eventSceneData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventSceneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventSceneData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_EVENTSCENEDATA, None)
        }
    }
    #[inline]
    pub fn eventChoiceData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventChoiceData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2EventChoiceData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_EVENTCHOICEDATA, None)
        }
    }
    #[inline]
    pub fn expeditionData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ExpeditionData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ExpeditionData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_EXPEDITIONDATA, None)
        }
    }
    #[inline]
    pub fn eventEffectData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventEffectData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2EventEffectData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_EVENTEFFECTDATA, None)
        }
    }
    #[inline]
    pub fn shopGoodData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ShopGoodData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ShopGoodData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_SHOPGOODDATA, None)
        }
    }
    #[inline]
    pub fn shopDialogData(&self) -> Option<clz_Torappu_SandboxV2ShopDialogData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ShopDialogData>>(
                    clz_Torappu_SandboxV2Data::VT_SHOPDIALOGDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn logisticsData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LogisticsData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LogisticsData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_LOGISTICSDATA, None)
        }
    }
    #[inline]
    pub fn logisticsCharMapping(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_LOGISTICSCHARMAPPING, None)
        }
    }
    #[inline]
    pub fn materialKeywordData(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(clz_Torappu_SandboxV2Data::VT_MATERIALKEYWORDDATA, None)
        }
    }
    #[inline]
    pub fn monthRushData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2MonthRushData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2MonthRushData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_MONTHRUSHDATA, None)
        }
    }
    #[inline]
    pub fn riftTerrainParamData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_RIFTTERRAINPARAMDATA, None)
        }
    }
    #[inline]
    pub fn riftClimateParamData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_RIFTCLIMATEPARAMDATA, None)
        }
    }
    #[inline]
    pub fn riftEnemyParamData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_RIFTENEMYPARAMDATA, None)
        }
    }
    #[inline]
    pub fn riftSubTargetData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2RiftSubTargetData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_RIFTSUBTARGETDATA, None)
        }
    }
    #[inline]
    pub fn riftMainTargetData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2RiftMainTargetData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_RIFTMAINTARGETDATA, None)
        }
    }
    #[inline]
    pub fn riftGlobalEffectData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_RIFTGLOBALEFFECTDATA, None)
        }
    }
    #[inline]
    pub fn fixedRiftData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FixedRiftData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FixedRiftData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_FIXEDRIFTDATA, None)
        }
    }
    #[inline]
    pub fn riftTeamBuffData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_RIFTTEAMBUFFDATA, None)
        }
    }
    #[inline]
    pub fn riftDifficultyData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2RiftDifficultyData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_RIFTDIFFICULTYDATA, None)
        }
    }
    #[inline]
    pub fn riftRewardDisplayData(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string>>,
            >>(clz_Torappu_SandboxV2Data::VT_RIFTREWARDDISPLAYDATA, None)
        }
    }
    #[inline]
    pub fn enemyReplaceData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__list_dict__string__string<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__list_dict__string__string>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ENEMYREPLACEDATA, None)
        }
    }
    #[inline]
    pub fn archiveQuestData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2ArchiveQuestData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ARCHIVEQUESTDATA, None)
        }
    }
    #[inline]
    pub fn achievementData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2ArchiveAchievementData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ACHIEVEMENTDATA, None)
        }
    }
    #[inline]
    pub fn achievementTypeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ACHIEVEMENTTYPEDATA, None)
        }
    }
    #[inline]
    pub fn archiveQuestTypeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ARCHIVEQUESTTYPEDATA, None)
        }
    }
    #[inline]
    pub fn archiveMusicUnlockData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_ARCHIVEMUSICUNLOCKDATA, None)
        }
    }
    #[inline]
    pub fn baseUpdate(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseUpdateData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseUpdateData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_BASEUPDATE, None)
        }
    }
    #[inline]
    pub fn developmentLineSegmentDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DevelopmentLineSegmentData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DevelopmentLineSegmentData>,
                >,
            >>(
                clz_Torappu_SandboxV2Data::VT_DEVELOPMENTLINESEGMENTDATAS,
                None,
            )
        }
    }
    #[inline]
    pub fn buildingNodeScoreData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData,
                    >,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_BUILDINGNODESCOREDATA, None)
        }
    }
    #[inline]
    pub fn seasonData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2SeasonData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2SeasonData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_SEASONDATA, None)
        }
    }
    #[inline]
    pub fn confirmIconData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ConfirmIconData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ConfirmIconData>,
                >,
            >>(clz_Torappu_SandboxV2Data::VT_CONFIRMICONDATA, None)
        }
    }
    #[inline]
    pub fn shopUpdateTimeData(&self) -> Option<flatbuffers::Vector<'a, i64>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(
                    clz_Torappu_SandboxV2Data::VT_SHOPUPDATETIMEDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn tutorialData(&self) -> Option<clz_Torappu_SandboxV2TutorialData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2TutorialData>>(
                    clz_Torappu_SandboxV2Data::VT_TUTORIALDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn racingData(&self) -> Option<clz_Torappu_SandboxV2RacingData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacingData>>(
                    clz_Torappu_SandboxV2Data::VT_RACINGDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn challengeModeData(&self) -> Option<clz_Torappu_SandboxV2ChallengeModeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeModeData>>(
                    clz_Torappu_SandboxV2Data::VT_CHALLENGEMODEDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxV2Data<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2MapData>>>>("mapData", Self::VT_MAPDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ItemTrapData>>>>("itemTrapData", Self::VT_ITEMTRAPDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ItemTrapTagData>>>>("itemTrapTagData", Self::VT_ITEMTRAPTAGDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2BuildingItemData>>>>("buildingItemData", Self::VT_BUILDINGITEMDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2CraftItemData>>>>("craftItemData", Self::VT_CRAFTITEMDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2LivestockData>>>>("livestockProduceData", Self::VT_LIVESTOCKPRODUCEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2CraftGroupData>>>>("craftGroupData", Self::VT_CRAFTGROUPDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2AlchemyRecipeData>>>>("alchemyRecipeData", Self::VT_ALCHEMYRECIPEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DrinkMatData>>>>("drinkMatData", Self::VT_DRINKMATDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FoodMatData>>>>("foodMatData", Self::VT_FOODMATDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FoodData>>>>("foodData", Self::VT_FOODDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeTypeData>>>>("nodeTypeData", Self::VT_NODETYPEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeUpgradeData>>>>("nodeUpgradeData", Self::VT_NODEUPGRADEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2WeatherData>>>>("weatherData", Self::VT_WEATHERDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2StageData>>>>("stageData", Self::VT_STAGEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ZoneData>>>>("zoneData", Self::VT_ZONEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeBuffData>>>>("nodeBuffData", Self::VT_NODEBUFFDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RewardConfigGroupData>>("rewardConfigData", Self::VT_REWARDCONFIGDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FloatIconData>>>>("floatIconData", Self::VT_FLOATICONDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EnemyRushTypeData>>>>("enemyRushTypeData", Self::VT_ENEMYRUSHTYPEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BattleRushEnemyData>>("rushEnemyData", Self::VT_RUSHENEMYDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2GameConst>>("gameConst", Self::VT_GAMECONST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BasicConst>>("basicConst", Self::VT_BASICCONST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RiftConst>>("riftConst", Self::VT_RIFTCONST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DevelopmentConst>>("developmentConst", Self::VT_DEVELOPMENTCONST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_TipData>>>>("battleLoadingTips", Self::VT_BATTLELOADINGTIPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RuneTable_PackedRuneData>>>>("runeDatas", Self::VT_RUNEDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__list_clz_Torappu_LegacyInLevelRuneData>>>>("itemRuneList", Self::VT_ITEMRUNELIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestData>>>>("questData", Self::VT_QUESTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NpcData>>>>("npcData", Self::VT_NPCDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DialogData>>>>("dialogData", Self::VT_DIALOGDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestLineData>>>>("questLineData", Self::VT_QUESTLINEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>>>("questLineStoryData", Self::VT_QUESTLINESTORYDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData>>>>("guideQuestData", Self::VT_GUIDEQUESTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DevelopmentData>>>>("developmentData", Self::VT_DEVELOPMENTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventData>>>>("eventData", Self::VT_EVENTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventSceneData>>>>("eventSceneData", Self::VT_EVENTSCENEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventChoiceData>>>>("eventChoiceData", Self::VT_EVENTCHOICEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ExpeditionData>>>>("expeditionData", Self::VT_EXPEDITIONDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventEffectData>>>>("eventEffectData", Self::VT_EVENTEFFECTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ShopGoodData>>>>("shopGoodData", Self::VT_SHOPGOODDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ShopDialogData>>("shopDialogData", Self::VT_SHOPDIALOGDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LogisticsData>>>>("logisticsData", Self::VT_LOGISTICSDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData>>>>("logisticsCharMapping", Self::VT_LOGISTICSCHARMAPPING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>>>("materialKeywordData", Self::VT_MATERIALKEYWORDDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2MonthRushData>>>>("monthRushData", Self::VT_MONTHRUSHDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData>>>>("riftTerrainParamData", Self::VT_RIFTTERRAINPARAMDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData>>>>("riftClimateParamData", Self::VT_RIFTCLIMATEPARAMDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData>>>>("riftEnemyParamData", Self::VT_RIFTENEMYPARAMDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftSubTargetData>>>>("riftSubTargetData", Self::VT_RIFTSUBTARGETDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftMainTargetData>>>>("riftMainTargetData", Self::VT_RIFTMAINTARGETDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData>>>>("riftGlobalEffectData", Self::VT_RIFTGLOBALEFFECTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FixedRiftData>>>>("fixedRiftData", Self::VT_FIXEDRIFTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData>>>>("riftTeamBuffData", Self::VT_RIFTTEAMBUFFDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftDifficultyData>>>>("riftDifficultyData", Self::VT_RIFTDIFFICULTYDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__list_string>>>>("riftRewardDisplayData", Self::VT_RIFTREWARDDISPLAYDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__list_dict__string__string>>>>("enemyReplaceData", Self::VT_ENEMYREPLACEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ArchiveQuestData>>>>("archiveQuestData", Self::VT_ARCHIVEQUESTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ArchiveAchievementData>>>>("achievementData", Self::VT_ACHIEVEMENTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData>>>>("achievementTypeData", Self::VT_ACHIEVEMENTTYPEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData>>>>("archiveQuestTypeData", Self::VT_ARCHIVEQUESTTYPEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData>>>>("archiveMusicUnlockData", Self::VT_ARCHIVEMUSICUNLOCKDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseUpdateData>>>>("baseUpdate", Self::VT_BASEUPDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DevelopmentLineSegmentData>>>>("developmentLineSegmentDatas", Self::VT_DEVELOPMENTLINESEGMENTDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData>>>>("buildingNodeScoreData", Self::VT_BUILDINGNODESCOREDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2SeasonData>>>>("seasonData", Self::VT_SEASONDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ConfirmIconData>>>>("confirmIconData", Self::VT_CONFIRMICONDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("shopUpdateTimeData", Self::VT_SHOPUPDATETIMEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2TutorialData>>("tutorialData", Self::VT_TUTORIALDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2RacingData>>("racingData", Self::VT_RACINGDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ChallengeModeData>>("challengeModeData", Self::VT_CHALLENGEMODEDATA, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxV2DataArgs<'a> {
    pub mapData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2MapData<'a>>,
            >,
        >,
    >,
    pub itemTrapData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ItemTrapData<'a>>,
            >,
        >,
    >,
    pub itemTrapTagData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'a>,
                >,
            >,
        >,
    >,
    pub buildingItemData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2BuildingItemData<'a>,
                >,
            >,
        >,
    >,
    pub craftItemData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2CraftItemData<'a>>,
            >,
        >,
    >,
    pub livestockProduceData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2LivestockData<'a>>,
            >,
        >,
    >,
    pub craftGroupData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2CraftGroupData<'a>>,
            >,
        >,
    >,
    pub alchemyRecipeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'a>,
                >,
            >,
        >,
    >,
    pub drinkMatData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DrinkMatData<'a>>,
            >,
        >,
    >,
    pub foodMatData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FoodMatData<'a>>,
            >,
        >,
    >,
    pub foodData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FoodData<'a>>,
            >,
        >,
    >,
    pub nodeTypeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeTypeData<'a>>,
            >,
        >,
    >,
    pub nodeUpgradeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'a>,
                >,
            >,
        >,
    >,
    pub weatherData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2WeatherData<'a>>,
            >,
        >,
    >,
    pub stageData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2StageData<'a>>,
            >,
        >,
    >,
    pub zoneData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ZoneData<'a>>,
            >,
        >,
    >,
    pub nodeBuffData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeBuffData<'a>>,
            >,
        >,
    >,
    pub rewardConfigData:
        Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardConfigGroupData<'a>>>,
    pub floatIconData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FloatIconData<'a>>,
            >,
        >,
    >,
    pub enemyRushTypeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'a>,
                >,
            >,
        >,
    >,
    pub rushEnemyData: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyData<'a>>>,
    pub gameConst: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2GameConst<'a>>>,
    pub basicConst: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2BasicConst<'a>>>,
    pub riftConst: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftConst<'a>>>,
    pub developmentConst: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentConst<'a>>>,
    pub battleLoadingTips: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TipData<'a>>>,
        >,
    >,
    pub runeDatas: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RuneTable_PackedRuneData<'a>,
                >,
            >,
        >,
    >,
    pub itemRuneList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a>,
                >,
            >,
        >,
    >,
    pub questData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestData<'a>>,
            >,
        >,
    >,
    pub npcData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NpcData<'a>>,
            >,
        >,
    >,
    pub dialogData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DialogData<'a>>,
            >,
        >,
    >,
    pub questLineData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestLineData<'a>>,
            >,
        >,
    >,
    pub questLineStoryData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>,
        >,
    >,
    pub guideQuestData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData<'a>>,
            >,
        >,
    >,
    pub developmentData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2DevelopmentData<'a>,
                >,
            >,
        >,
    >,
    pub eventData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventData<'a>>,
            >,
        >,
    >,
    pub eventSceneData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventSceneData<'a>>,
            >,
        >,
    >,
    pub eventChoiceData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2EventChoiceData<'a>,
                >,
            >,
        >,
    >,
    pub expeditionData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ExpeditionData<'a>>,
            >,
        >,
    >,
    pub eventEffectData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2EventEffectData<'a>,
                >,
            >,
        >,
    >,
    pub shopGoodData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ShopGoodData<'a>>,
            >,
        >,
    >,
    pub shopDialogData: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ShopDialogData<'a>>>,
    pub logisticsData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LogisticsData<'a>>,
            >,
        >,
    >,
    pub logisticsCharMapping: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'a>,
                >,
            >,
        >,
    >,
    pub materialKeywordData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>,
        >,
    >,
    pub monthRushData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2MonthRushData<'a>>,
            >,
        >,
    >,
    pub riftTerrainParamData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'a>>,
            >,
        >,
    >,
    pub riftClimateParamData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'a>>,
            >,
        >,
    >,
    pub riftEnemyParamData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'a>>,
            >,
        >,
    >,
    pub riftSubTargetData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'a>,
                >,
            >,
        >,
    >,
    pub riftMainTargetData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'a>,
                >,
            >,
        >,
    >,
    pub riftGlobalEffectData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'a>,
                >,
            >,
        >,
    >,
    pub fixedRiftData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FixedRiftData<'a>>,
            >,
        >,
    >,
    pub riftTeamBuffData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'a>,
                >,
            >,
        >,
    >,
    pub riftDifficultyData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'a>,
                >,
            >,
        >,
    >,
    pub riftRewardDisplayData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string<'a>>>,
        >,
    >,
    pub enemyReplaceData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__list_dict__string__string<'a>>,
            >,
        >,
    >,
    pub archiveQuestData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'a>,
                >,
            >,
        >,
    >,
    pub achievementData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'a>,
                >,
            >,
        >,
    >,
    pub achievementTypeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'a>,
                >,
            >,
        >,
    >,
    pub archiveQuestTypeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'a>,
                >,
            >,
        >,
    >,
    pub archiveMusicUnlockData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'a>,
                >,
            >,
        >,
    >,
    pub baseUpdate: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseUpdateData<'a>>,
            >,
        >,
    >,
    pub developmentLineSegmentDatas: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DevelopmentLineSegmentData<'a>>,
            >,
        >,
    >,
    pub buildingNodeScoreData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'a>,
                >,
            >,
        >,
    >,
    pub seasonData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2SeasonData<'a>>,
            >,
        >,
    >,
    pub confirmIconData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ConfirmIconData<'a>>,
            >,
        >,
    >,
    pub shopUpdateTimeData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub tutorialData: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialData<'a>>>,
    pub racingData: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingData<'a>>>,
    pub challengeModeData:
        Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeData<'a>>>,
}
impl<'a> Default for clz_Torappu_SandboxV2DataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxV2DataArgs {
            mapData: None,
            itemTrapData: None,
            itemTrapTagData: None,
            buildingItemData: None,
            craftItemData: None,
            livestockProduceData: None,
            craftGroupData: None,
            alchemyRecipeData: None,
            drinkMatData: None,
            foodMatData: None,
            foodData: None,
            nodeTypeData: None,
            nodeUpgradeData: None,
            weatherData: None,
            stageData: None,
            zoneData: None,
            nodeBuffData: None,
            rewardConfigData: None,
            floatIconData: None,
            enemyRushTypeData: None,
            rushEnemyData: None,
            gameConst: None,
            basicConst: None,
            riftConst: None,
            developmentConst: None,
            battleLoadingTips: None,
            runeDatas: None,
            itemRuneList: None,
            questData: None,
            npcData: None,
            dialogData: None,
            questLineData: None,
            questLineStoryData: None,
            guideQuestData: None,
            developmentData: None,
            eventData: None,
            eventSceneData: None,
            eventChoiceData: None,
            expeditionData: None,
            eventEffectData: None,
            shopGoodData: None,
            shopDialogData: None,
            logisticsData: None,
            logisticsCharMapping: None,
            materialKeywordData: None,
            monthRushData: None,
            riftTerrainParamData: None,
            riftClimateParamData: None,
            riftEnemyParamData: None,
            riftSubTargetData: None,
            riftMainTargetData: None,
            riftGlobalEffectData: None,
            fixedRiftData: None,
            riftTeamBuffData: None,
            riftDifficultyData: None,
            riftRewardDisplayData: None,
            enemyReplaceData: None,
            archiveQuestData: None,
            achievementData: None,
            achievementTypeData: None,
            archiveQuestTypeData: None,
            archiveMusicUnlockData: None,
            baseUpdate: None,
            developmentLineSegmentDatas: None,
            buildingNodeScoreData: None,
            seasonData: None,
            confirmIconData: None,
            shopUpdateTimeData: None,
            tutorialData: None,
            racingData: None,
            challengeModeData: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxV2Data<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxV2Data", 71)?;
        if let Some(f) = self.mapData() {
            s.serialize_field("mapData", &f)?;
        } else {
            s.skip_field("mapData")?;
        }
        if let Some(f) = self.itemTrapData() {
            s.serialize_field("itemTrapData", &f)?;
        } else {
            s.skip_field("itemTrapData")?;
        }
        if let Some(f) = self.itemTrapTagData() {
            s.serialize_field("itemTrapTagData", &f)?;
        } else {
            s.skip_field("itemTrapTagData")?;
        }
        if let Some(f) = self.buildingItemData() {
            s.serialize_field("buildingItemData", &f)?;
        } else {
            s.skip_field("buildingItemData")?;
        }
        if let Some(f) = self.craftItemData() {
            s.serialize_field("craftItemData", &f)?;
        } else {
            s.skip_field("craftItemData")?;
        }
        if let Some(f) = self.livestockProduceData() {
            s.serialize_field("livestockProduceData", &f)?;
        } else {
            s.skip_field("livestockProduceData")?;
        }
        if let Some(f) = self.craftGroupData() {
            s.serialize_field("craftGroupData", &f)?;
        } else {
            s.skip_field("craftGroupData")?;
        }
        if let Some(f) = self.alchemyRecipeData() {
            s.serialize_field("alchemyRecipeData", &f)?;
        } else {
            s.skip_field("alchemyRecipeData")?;
        }
        if let Some(f) = self.drinkMatData() {
            s.serialize_field("drinkMatData", &f)?;
        } else {
            s.skip_field("drinkMatData")?;
        }
        if let Some(f) = self.foodMatData() {
            s.serialize_field("foodMatData", &f)?;
        } else {
            s.skip_field("foodMatData")?;
        }
        if let Some(f) = self.foodData() {
            s.serialize_field("foodData", &f)?;
        } else {
            s.skip_field("foodData")?;
        }
        if let Some(f) = self.nodeTypeData() {
            s.serialize_field("nodeTypeData", &f)?;
        } else {
            s.skip_field("nodeTypeData")?;
        }
        if let Some(f) = self.nodeUpgradeData() {
            s.serialize_field("nodeUpgradeData", &f)?;
        } else {
            s.skip_field("nodeUpgradeData")?;
        }
        if let Some(f) = self.weatherData() {
            s.serialize_field("weatherData", &f)?;
        } else {
            s.skip_field("weatherData")?;
        }
        if let Some(f) = self.stageData() {
            s.serialize_field("stageData", &f)?;
        } else {
            s.skip_field("stageData")?;
        }
        if let Some(f) = self.zoneData() {
            s.serialize_field("zoneData", &f)?;
        } else {
            s.skip_field("zoneData")?;
        }
        if let Some(f) = self.nodeBuffData() {
            s.serialize_field("nodeBuffData", &f)?;
        } else {
            s.skip_field("nodeBuffData")?;
        }
        if let Some(f) = self.rewardConfigData() {
            s.serialize_field("rewardConfigData", &f)?;
        } else {
            s.skip_field("rewardConfigData")?;
        }
        if let Some(f) = self.floatIconData() {
            s.serialize_field("floatIconData", &f)?;
        } else {
            s.skip_field("floatIconData")?;
        }
        if let Some(f) = self.enemyRushTypeData() {
            s.serialize_field("enemyRushTypeData", &f)?;
        } else {
            s.skip_field("enemyRushTypeData")?;
        }
        if let Some(f) = self.rushEnemyData() {
            s.serialize_field("rushEnemyData", &f)?;
        } else {
            s.skip_field("rushEnemyData")?;
        }
        if let Some(f) = self.gameConst() {
            s.serialize_field("gameConst", &f)?;
        } else {
            s.skip_field("gameConst")?;
        }
        if let Some(f) = self.basicConst() {
            s.serialize_field("basicConst", &f)?;
        } else {
            s.skip_field("basicConst")?;
        }
        if let Some(f) = self.riftConst() {
            s.serialize_field("riftConst", &f)?;
        } else {
            s.skip_field("riftConst")?;
        }
        if let Some(f) = self.developmentConst() {
            s.serialize_field("developmentConst", &f)?;
        } else {
            s.skip_field("developmentConst")?;
        }
        if let Some(f) = self.battleLoadingTips() {
            s.serialize_field("battleLoadingTips", &f)?;
        } else {
            s.skip_field("battleLoadingTips")?;
        }
        if let Some(f) = self.runeDatas() {
            s.serialize_field("runeDatas", &f)?;
        } else {
            s.skip_field("runeDatas")?;
        }
        if let Some(f) = self.itemRuneList() {
            s.serialize_field("itemRuneList", &f)?;
        } else {
            s.skip_field("itemRuneList")?;
        }
        if let Some(f) = self.questData() {
            s.serialize_field("questData", &f)?;
        } else {
            s.skip_field("questData")?;
        }
        if let Some(f) = self.npcData() {
            s.serialize_field("npcData", &f)?;
        } else {
            s.skip_field("npcData")?;
        }
        if let Some(f) = self.dialogData() {
            s.serialize_field("dialogData", &f)?;
        } else {
            s.skip_field("dialogData")?;
        }
        if let Some(f) = self.questLineData() {
            s.serialize_field("questLineData", &f)?;
        } else {
            s.skip_field("questLineData")?;
        }
        if let Some(f) = self.questLineStoryData() {
            s.serialize_field("questLineStoryData", &f)?;
        } else {
            s.skip_field("questLineStoryData")?;
        }
        if let Some(f) = self.guideQuestData() {
            s.serialize_field("guideQuestData", &f)?;
        } else {
            s.skip_field("guideQuestData")?;
        }
        if let Some(f) = self.developmentData() {
            s.serialize_field("developmentData", &f)?;
        } else {
            s.skip_field("developmentData")?;
        }
        if let Some(f) = self.eventData() {
            s.serialize_field("eventData", &f)?;
        } else {
            s.skip_field("eventData")?;
        }
        if let Some(f) = self.eventSceneData() {
            s.serialize_field("eventSceneData", &f)?;
        } else {
            s.skip_field("eventSceneData")?;
        }
        if let Some(f) = self.eventChoiceData() {
            s.serialize_field("eventChoiceData", &f)?;
        } else {
            s.skip_field("eventChoiceData")?;
        }
        if let Some(f) = self.expeditionData() {
            s.serialize_field("expeditionData", &f)?;
        } else {
            s.skip_field("expeditionData")?;
        }
        if let Some(f) = self.eventEffectData() {
            s.serialize_field("eventEffectData", &f)?;
        } else {
            s.skip_field("eventEffectData")?;
        }
        if let Some(f) = self.shopGoodData() {
            s.serialize_field("shopGoodData", &f)?;
        } else {
            s.skip_field("shopGoodData")?;
        }
        if let Some(f) = self.shopDialogData() {
            s.serialize_field("shopDialogData", &f)?;
        } else {
            s.skip_field("shopDialogData")?;
        }
        if let Some(f) = self.logisticsData() {
            s.serialize_field("logisticsData", &f)?;
        } else {
            s.skip_field("logisticsData")?;
        }
        if let Some(f) = self.logisticsCharMapping() {
            s.serialize_field("logisticsCharMapping", &f)?;
        } else {
            s.skip_field("logisticsCharMapping")?;
        }
        if let Some(f) = self.materialKeywordData() {
            s.serialize_field("materialKeywordData", &f)?;
        } else {
            s.skip_field("materialKeywordData")?;
        }
        if let Some(f) = self.monthRushData() {
            s.serialize_field("monthRushData", &f)?;
        } else {
            s.skip_field("monthRushData")?;
        }
        if let Some(f) = self.riftTerrainParamData() {
            s.serialize_field("riftTerrainParamData", &f)?;
        } else {
            s.skip_field("riftTerrainParamData")?;
        }
        if let Some(f) = self.riftClimateParamData() {
            s.serialize_field("riftClimateParamData", &f)?;
        } else {
            s.skip_field("riftClimateParamData")?;
        }
        if let Some(f) = self.riftEnemyParamData() {
            s.serialize_field("riftEnemyParamData", &f)?;
        } else {
            s.skip_field("riftEnemyParamData")?;
        }
        if let Some(f) = self.riftSubTargetData() {
            s.serialize_field("riftSubTargetData", &f)?;
        } else {
            s.skip_field("riftSubTargetData")?;
        }
        if let Some(f) = self.riftMainTargetData() {
            s.serialize_field("riftMainTargetData", &f)?;
        } else {
            s.skip_field("riftMainTargetData")?;
        }
        if let Some(f) = self.riftGlobalEffectData() {
            s.serialize_field("riftGlobalEffectData", &f)?;
        } else {
            s.skip_field("riftGlobalEffectData")?;
        }
        if let Some(f) = self.fixedRiftData() {
            s.serialize_field("fixedRiftData", &f)?;
        } else {
            s.skip_field("fixedRiftData")?;
        }
        if let Some(f) = self.riftTeamBuffData() {
            s.serialize_field("riftTeamBuffData", &f)?;
        } else {
            s.skip_field("riftTeamBuffData")?;
        }
        if let Some(f) = self.riftDifficultyData() {
            s.serialize_field("riftDifficultyData", &f)?;
        } else {
            s.skip_field("riftDifficultyData")?;
        }
        if let Some(f) = self.riftRewardDisplayData() {
            s.serialize_field("riftRewardDisplayData", &f)?;
        } else {
            s.skip_field("riftRewardDisplayData")?;
        }
        if let Some(f) = self.enemyReplaceData() {
            s.serialize_field("enemyReplaceData", &f)?;
        } else {
            s.skip_field("enemyReplaceData")?;
        }
        if let Some(f) = self.archiveQuestData() {
            s.serialize_field("archiveQuestData", &f)?;
        } else {
            s.skip_field("archiveQuestData")?;
        }
        if let Some(f) = self.achievementData() {
            s.serialize_field("achievementData", &f)?;
        } else {
            s.skip_field("achievementData")?;
        }
        if let Some(f) = self.achievementTypeData() {
            s.serialize_field("achievementTypeData", &f)?;
        } else {
            s.skip_field("achievementTypeData")?;
        }
        if let Some(f) = self.archiveQuestTypeData() {
            s.serialize_field("archiveQuestTypeData", &f)?;
        } else {
            s.skip_field("archiveQuestTypeData")?;
        }
        if let Some(f) = self.archiveMusicUnlockData() {
            s.serialize_field("archiveMusicUnlockData", &f)?;
        } else {
            s.skip_field("archiveMusicUnlockData")?;
        }
        if let Some(f) = self.baseUpdate() {
            s.serialize_field("baseUpdate", &f)?;
        } else {
            s.skip_field("baseUpdate")?;
        }
        if let Some(f) = self.developmentLineSegmentDatas() {
            s.serialize_field("developmentLineSegmentDatas", &f)?;
        } else {
            s.skip_field("developmentLineSegmentDatas")?;
        }
        if let Some(f) = self.buildingNodeScoreData() {
            s.serialize_field("buildingNodeScoreData", &f)?;
        } else {
            s.skip_field("buildingNodeScoreData")?;
        }
        if let Some(f) = self.seasonData() {
            s.serialize_field("seasonData", &f)?;
        } else {
            s.skip_field("seasonData")?;
        }
        if let Some(f) = self.confirmIconData() {
            s.serialize_field("confirmIconData", &f)?;
        } else {
            s.skip_field("confirmIconData")?;
        }
        if let Some(f) = self.shopUpdateTimeData() {
            s.serialize_field("shopUpdateTimeData", &f)?;
        } else {
            s.skip_field("shopUpdateTimeData")?;
        }
        if let Some(f) = self.tutorialData() {
            s.serialize_field("tutorialData", &f)?;
        } else {
            s.skip_field("tutorialData")?;
        }
        if let Some(f) = self.racingData() {
            s.serialize_field("racingData", &f)?;
        } else {
            s.skip_field("racingData")?;
        }
        if let Some(f) = self.challengeModeData() {
            s.serialize_field("challengeModeData", &f)?;
        } else {
            s.skip_field("challengeModeData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxV2DataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxV2DataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_mapData(
        &mut self,
        mapData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2MapData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_MAPDATA,
            mapData,
        );
    }
    #[inline]
    pub fn add_itemTrapData(
        &mut self,
        itemTrapData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ItemTrapData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ITEMTRAPDATA,
            itemTrapData,
        );
    }
    #[inline]
    pub fn add_itemTrapTagData(
        &mut self,
        itemTrapTagData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ItemTrapTagData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ITEMTRAPTAGDATA,
            itemTrapTagData,
        );
    }
    #[inline]
    pub fn add_buildingItemData(
        &mut self,
        buildingItemData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2BuildingItemData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_BUILDINGITEMDATA,
            buildingItemData,
        );
    }
    #[inline]
    pub fn add_craftItemData(
        &mut self,
        craftItemData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2CraftItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_CRAFTITEMDATA,
            craftItemData,
        );
    }
    #[inline]
    pub fn add_livestockProduceData(
        &mut self,
        livestockProduceData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2LivestockData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_LIVESTOCKPRODUCEDATA,
            livestockProduceData,
        );
    }
    #[inline]
    pub fn add_craftGroupData(
        &mut self,
        craftGroupData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2CraftGroupData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_CRAFTGROUPDATA,
            craftGroupData,
        );
    }
    #[inline]
    pub fn add_alchemyRecipeData(
        &mut self,
        alchemyRecipeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2AlchemyRecipeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ALCHEMYRECIPEDATA,
            alchemyRecipeData,
        );
    }
    #[inline]
    pub fn add_drinkMatData(
        &mut self,
        drinkMatData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DrinkMatData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_DRINKMATDATA,
            drinkMatData,
        );
    }
    #[inline]
    pub fn add_foodMatData(
        &mut self,
        foodMatData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FoodMatData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_FOODMATDATA,
            foodMatData,
        );
    }
    #[inline]
    pub fn add_foodData(
        &mut self,
        foodData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FoodData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_FOODDATA,
            foodData,
        );
    }
    #[inline]
    pub fn add_nodeTypeData(
        &mut self,
        nodeTypeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeTypeData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_NODETYPEDATA,
            nodeTypeData,
        );
    }
    #[inline]
    pub fn add_nodeUpgradeData(
        &mut self,
        nodeUpgradeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2NodeUpgradeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_NODEUPGRADEDATA,
            nodeUpgradeData,
        );
    }
    #[inline]
    pub fn add_weatherData(
        &mut self,
        weatherData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2WeatherData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_WEATHERDATA,
            weatherData,
        );
    }
    #[inline]
    pub fn add_stageData(
        &mut self,
        stageData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2StageData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_STAGEDATA,
            stageData,
        );
    }
    #[inline]
    pub fn add_zoneData(
        &mut self,
        zoneData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ZoneData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ZONEDATA,
            zoneData,
        );
    }
    #[inline]
    pub fn add_nodeBuffData(
        &mut self,
        nodeBuffData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NodeBuffData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_NODEBUFFDATA,
            nodeBuffData,
        );
    }
    #[inline]
    pub fn add_rewardConfigData(
        &mut self,
        rewardConfigData: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardConfigGroupData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RewardConfigGroupData>>(
                clz_Torappu_SandboxV2Data::VT_REWARDCONFIGDATA,
                rewardConfigData,
            );
    }
    #[inline]
    pub fn add_floatIconData(
        &mut self,
        floatIconData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FloatIconData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_FLOATICONDATA,
            floatIconData,
        );
    }
    #[inline]
    pub fn add_enemyRushTypeData(
        &mut self,
        enemyRushTypeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2EnemyRushTypeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ENEMYRUSHTYPEDATA,
            enemyRushTypeData,
        );
    }
    #[inline]
    pub fn add_rushEnemyData(
        &mut self,
        rushEnemyData: flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2BattleRushEnemyData>>(
                clz_Torappu_SandboxV2Data::VT_RUSHENEMYDATA,
                rushEnemyData,
            );
    }
    #[inline]
    pub fn add_gameConst(
        &mut self,
        gameConst: flatbuffers::WIPOffset<clz_Torappu_SandboxV2GameConst<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2GameConst>>(
                clz_Torappu_SandboxV2Data::VT_GAMECONST,
                gameConst,
            );
    }
    #[inline]
    pub fn add_basicConst(
        &mut self,
        basicConst: flatbuffers::WIPOffset<clz_Torappu_SandboxV2BasicConst<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2BasicConst>>(
                clz_Torappu_SandboxV2Data::VT_BASICCONST,
                basicConst,
            );
    }
    #[inline]
    pub fn add_riftConst(
        &mut self,
        riftConst: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftConst<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RiftConst>>(
                clz_Torappu_SandboxV2Data::VT_RIFTCONST,
                riftConst,
            );
    }
    #[inline]
    pub fn add_developmentConst(
        &mut self,
        developmentConst: flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentConst<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2DevelopmentConst>>(
                clz_Torappu_SandboxV2Data::VT_DEVELOPMENTCONST,
                developmentConst,
            );
    }
    #[inline]
    pub fn add_battleLoadingTips(
        &mut self,
        battleLoadingTips: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_TipData<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_BATTLELOADINGTIPS,
            battleLoadingTips,
        );
    }
    #[inline]
    pub fn add_runeDatas(
        &mut self,
        runeDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RuneTable_PackedRuneData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_RUNEDATAS,
            runeDatas,
        );
    }
    #[inline]
    pub fn add_itemRuneList(
        &mut self,
        itemRuneList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_clz_Torappu_LegacyInLevelRuneData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ITEMRUNELIST,
            itemRuneList,
        );
    }
    #[inline]
    pub fn add_questData(
        &mut self,
        questData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_QUESTDATA,
            questData,
        );
    }
    #[inline]
    pub fn add_npcData(
        &mut self,
        npcData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2NpcData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_NPCDATA,
            npcData,
        );
    }
    #[inline]
    pub fn add_dialogData(
        &mut self,
        dialogData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2DialogData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_DIALOGDATA,
            dialogData,
        );
    }
    #[inline]
    pub fn add_questLineData(
        &mut self,
        questLineData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2QuestLineData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_QUESTLINEDATA,
            questLineData,
        );
    }
    #[inline]
    pub fn add_questLineStoryData(
        &mut self,
        questLineStoryData: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_QUESTLINESTORYDATA,
            questLineStoryData,
        );
    }
    #[inline]
    pub fn add_guideQuestData(
        &mut self,
        guideQuestData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2GuideQuestData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_GUIDEQUESTDATA,
            guideQuestData,
        );
    }
    #[inline]
    pub fn add_developmentData(
        &mut self,
        developmentData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2DevelopmentData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_DEVELOPMENTDATA,
            developmentData,
        );
    }
    #[inline]
    pub fn add_eventData(
        &mut self,
        eventData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_EVENTDATA,
            eventData,
        );
    }
    #[inline]
    pub fn add_eventSceneData(
        &mut self,
        eventSceneData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2EventSceneData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_EVENTSCENEDATA,
            eventSceneData,
        );
    }
    #[inline]
    pub fn add_eventChoiceData(
        &mut self,
        eventChoiceData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2EventChoiceData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_EVENTCHOICEDATA,
            eventChoiceData,
        );
    }
    #[inline]
    pub fn add_expeditionData(
        &mut self,
        expeditionData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ExpeditionData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_EXPEDITIONDATA,
            expeditionData,
        );
    }
    #[inline]
    pub fn add_eventEffectData(
        &mut self,
        eventEffectData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2EventEffectData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_EVENTEFFECTDATA,
            eventEffectData,
        );
    }
    #[inline]
    pub fn add_shopGoodData(
        &mut self,
        shopGoodData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2ShopGoodData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_SHOPGOODDATA,
            shopGoodData,
        );
    }
    #[inline]
    pub fn add_shopDialogData(
        &mut self,
        shopDialogData: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ShopDialogData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ShopDialogData>>(
                clz_Torappu_SandboxV2Data::VT_SHOPDIALOGDATA,
                shopDialogData,
            );
    }
    #[inline]
    pub fn add_logisticsData(
        &mut self,
        logisticsData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2LogisticsData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_LOGISTICSDATA,
            logisticsData,
        );
    }
    #[inline]
    pub fn add_logisticsCharMapping(
        &mut self,
        logisticsCharMapping: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_LOGISTICSCHARMAPPING,
            logisticsCharMapping,
        );
    }
    #[inline]
    pub fn add_materialKeywordData(
        &mut self,
        materialKeywordData: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_MATERIALKEYWORDDATA,
            materialKeywordData,
        );
    }
    #[inline]
    pub fn add_monthRushData(
        &mut self,
        monthRushData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2MonthRushData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_MONTHRUSHDATA,
            monthRushData,
        );
    }
    #[inline]
    pub fn add_riftTerrainParamData(
        &mut self,
        riftTerrainParamData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_RIFTTERRAINPARAMDATA,
            riftTerrainParamData,
        );
    }
    #[inline]
    pub fn add_riftClimateParamData(
        &mut self,
        riftClimateParamData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_RIFTCLIMATEPARAMDATA,
            riftClimateParamData,
        );
    }
    #[inline]
    pub fn add_riftEnemyParamData(
        &mut self,
        riftEnemyParamData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2RiftParamData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_RIFTENEMYPARAMDATA,
            riftEnemyParamData,
        );
    }
    #[inline]
    pub fn add_riftSubTargetData(
        &mut self,
        riftSubTargetData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RiftSubTargetData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_RIFTSUBTARGETDATA,
            riftSubTargetData,
        );
    }
    #[inline]
    pub fn add_riftMainTargetData(
        &mut self,
        riftMainTargetData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RiftMainTargetData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_RIFTMAINTARGETDATA,
            riftMainTargetData,
        );
    }
    #[inline]
    pub fn add_riftGlobalEffectData(
        &mut self,
        riftGlobalEffectData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RiftGlobalEffectData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_RIFTGLOBALEFFECTDATA,
            riftGlobalEffectData,
        );
    }
    #[inline]
    pub fn add_fixedRiftData(
        &mut self,
        fixedRiftData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2FixedRiftData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_FIXEDRIFTDATA,
            fixedRiftData,
        );
    }
    #[inline]
    pub fn add_riftTeamBuffData(
        &mut self,
        riftTeamBuffData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_RIFTTEAMBUFFDATA,
            riftTeamBuffData,
        );
    }
    #[inline]
    pub fn add_riftDifficultyData(
        &mut self,
        riftDifficultyData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2RiftDifficultyData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_RIFTDIFFICULTYDATA,
            riftDifficultyData,
        );
    }
    #[inline]
    pub fn add_riftRewardDisplayData(
        &mut self,
        riftRewardDisplayData: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__list_string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_RIFTREWARDDISPLAYDATA,
            riftRewardDisplayData,
        );
    }
    #[inline]
    pub fn add_enemyReplaceData(
        &mut self,
        enemyReplaceData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__list_dict__string__string<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ENEMYREPLACEDATA,
            enemyReplaceData,
        );
    }
    #[inline]
    pub fn add_archiveQuestData(
        &mut self,
        archiveQuestData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ArchiveQuestData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ARCHIVEQUESTDATA,
            archiveQuestData,
        );
    }
    #[inline]
    pub fn add_achievementData(
        &mut self,
        achievementData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ArchiveAchievementData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ACHIEVEMENTDATA,
            achievementData,
        );
    }
    #[inline]
    pub fn add_achievementTypeData(
        &mut self,
        achievementTypeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ACHIEVEMENTTYPEDATA,
            achievementTypeData,
        );
    }
    #[inline]
    pub fn add_archiveQuestTypeData(
        &mut self,
        archiveQuestTypeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ARCHIVEQUESTTYPEDATA,
            archiveQuestTypeData,
        );
    }
    #[inline]
    pub fn add_archiveMusicUnlockData(
        &mut self,
        archiveMusicUnlockData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_ARCHIVEMUSICUNLOCKDATA,
            archiveMusicUnlockData,
        );
    }
    #[inline]
    pub fn add_baseUpdate(
        &mut self,
        baseUpdate: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2BaseUpdateData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_BASEUPDATE,
            baseUpdate,
        );
    }
    #[inline]
    pub fn add_developmentLineSegmentDatas(
        &mut self,
        developmentLineSegmentDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2DevelopmentLineSegmentData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_DEVELOPMENTLINESEGMENTDATAS,
            developmentLineSegmentDatas,
        );
    }
    #[inline]
    pub fn add_buildingNodeScoreData(
        &mut self,
        buildingNodeScoreData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxV2BuildingNodeScoreData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_BUILDINGNODESCOREDATA,
            buildingNodeScoreData,
        );
    }
    #[inline]
    pub fn add_seasonData(
        &mut self,
        seasonData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2SeasonData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_SEASONDATA,
            seasonData,
        );
    }
    #[inline]
    pub fn add_confirmIconData(
        &mut self,
        confirmIconData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2ConfirmIconData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_CONFIRMICONDATA,
            confirmIconData,
        );
    }
    #[inline]
    pub fn add_shopUpdateTimeData(
        &mut self,
        shopUpdateTimeData: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i64>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxV2Data::VT_SHOPUPDATETIMEDATA,
            shopUpdateTimeData,
        );
    }
    #[inline]
    pub fn add_tutorialData(
        &mut self,
        tutorialData: flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2TutorialData>>(
                clz_Torappu_SandboxV2Data::VT_TUTORIALDATA,
                tutorialData,
            );
    }
    #[inline]
    pub fn add_racingData(
        &mut self,
        racingData: flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2RacingData>>(
                clz_Torappu_SandboxV2Data::VT_RACINGDATA,
                racingData,
            );
    }
    #[inline]
    pub fn add_challengeModeData(
        &mut self,
        challengeModeData: flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2ChallengeModeData>>(
                clz_Torappu_SandboxV2Data::VT_CHALLENGEMODEDATA,
                challengeModeData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxV2DataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxV2DataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2Data<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxV2Data<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxV2Data");
        ds.field("mapData", &self.mapData());
        ds.field("itemTrapData", &self.itemTrapData());
        ds.field("itemTrapTagData", &self.itemTrapTagData());
        ds.field("buildingItemData", &self.buildingItemData());
        ds.field("craftItemData", &self.craftItemData());
        ds.field("livestockProduceData", &self.livestockProduceData());
        ds.field("craftGroupData", &self.craftGroupData());
        ds.field("alchemyRecipeData", &self.alchemyRecipeData());
        ds.field("drinkMatData", &self.drinkMatData());
        ds.field("foodMatData", &self.foodMatData());
        ds.field("foodData", &self.foodData());
        ds.field("nodeTypeData", &self.nodeTypeData());
        ds.field("nodeUpgradeData", &self.nodeUpgradeData());
        ds.field("weatherData", &self.weatherData());
        ds.field("stageData", &self.stageData());
        ds.field("zoneData", &self.zoneData());
        ds.field("nodeBuffData", &self.nodeBuffData());
        ds.field("rewardConfigData", &self.rewardConfigData());
        ds.field("floatIconData", &self.floatIconData());
        ds.field("enemyRushTypeData", &self.enemyRushTypeData());
        ds.field("rushEnemyData", &self.rushEnemyData());
        ds.field("gameConst", &self.gameConst());
        ds.field("basicConst", &self.basicConst());
        ds.field("riftConst", &self.riftConst());
        ds.field("developmentConst", &self.developmentConst());
        ds.field("battleLoadingTips", &self.battleLoadingTips());
        ds.field("runeDatas", &self.runeDatas());
        ds.field("itemRuneList", &self.itemRuneList());
        ds.field("questData", &self.questData());
        ds.field("npcData", &self.npcData());
        ds.field("dialogData", &self.dialogData());
        ds.field("questLineData", &self.questLineData());
        ds.field("questLineStoryData", &self.questLineStoryData());
        ds.field("guideQuestData", &self.guideQuestData());
        ds.field("developmentData", &self.developmentData());
        ds.field("eventData", &self.eventData());
        ds.field("eventSceneData", &self.eventSceneData());
        ds.field("eventChoiceData", &self.eventChoiceData());
        ds.field("expeditionData", &self.expeditionData());
        ds.field("eventEffectData", &self.eventEffectData());
        ds.field("shopGoodData", &self.shopGoodData());
        ds.field("shopDialogData", &self.shopDialogData());
        ds.field("logisticsData", &self.logisticsData());
        ds.field("logisticsCharMapping", &self.logisticsCharMapping());
        ds.field("materialKeywordData", &self.materialKeywordData());
        ds.field("monthRushData", &self.monthRushData());
        ds.field("riftTerrainParamData", &self.riftTerrainParamData());
        ds.field("riftClimateParamData", &self.riftClimateParamData());
        ds.field("riftEnemyParamData", &self.riftEnemyParamData());
        ds.field("riftSubTargetData", &self.riftSubTargetData());
        ds.field("riftMainTargetData", &self.riftMainTargetData());
        ds.field("riftGlobalEffectData", &self.riftGlobalEffectData());
        ds.field("fixedRiftData", &self.fixedRiftData());
        ds.field("riftTeamBuffData", &self.riftTeamBuffData());
        ds.field("riftDifficultyData", &self.riftDifficultyData());
        ds.field("riftRewardDisplayData", &self.riftRewardDisplayData());
        ds.field("enemyReplaceData", &self.enemyReplaceData());
        ds.field("archiveQuestData", &self.archiveQuestData());
        ds.field("achievementData", &self.achievementData());
        ds.field("achievementTypeData", &self.achievementTypeData());
        ds.field("archiveQuestTypeData", &self.archiveQuestTypeData());
        ds.field("archiveMusicUnlockData", &self.archiveMusicUnlockData());
        ds.field("baseUpdate", &self.baseUpdate());
        ds.field(
            "developmentLineSegmentDatas",
            &self.developmentLineSegmentDatas(),
        );
        ds.field("buildingNodeScoreData", &self.buildingNodeScoreData());
        ds.field("seasonData", &self.seasonData());
        ds.field("confirmIconData", &self.confirmIconData());
        ds.field("shopUpdateTimeData", &self.shopUpdateTimeData());
        ds.field("tutorialData", &self.tutorialData());
        ds.field("racingData", &self.racingData());
        ds.field("challengeModeData", &self.challengeModeData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxV2DataT {
    pub mapData: Option<Vec<dict__string__clz_Torappu_SandboxV2MapDataT>>,
    pub itemTrapData: Option<Vec<dict__string__clz_Torappu_SandboxV2ItemTrapDataT>>,
    pub itemTrapTagData: Option<Vec<dict__string__clz_Torappu_SandboxV2ItemTrapTagDataT>>,
    pub buildingItemData: Option<Vec<dict__string__clz_Torappu_SandboxV2BuildingItemDataT>>,
    pub craftItemData: Option<Vec<dict__string__clz_Torappu_SandboxV2CraftItemDataT>>,
    pub livestockProduceData: Option<Vec<dict__string__clz_Torappu_SandboxV2LivestockDataT>>,
    pub craftGroupData: Option<Vec<dict__string__clz_Torappu_SandboxV2CraftGroupDataT>>,
    pub alchemyRecipeData: Option<Vec<dict__string__clz_Torappu_SandboxV2AlchemyRecipeDataT>>,
    pub drinkMatData: Option<Vec<dict__string__clz_Torappu_SandboxV2DrinkMatDataT>>,
    pub foodMatData: Option<Vec<dict__string__clz_Torappu_SandboxV2FoodMatDataT>>,
    pub foodData: Option<Vec<dict__string__clz_Torappu_SandboxV2FoodDataT>>,
    pub nodeTypeData: Option<Vec<dict__string__clz_Torappu_SandboxV2NodeTypeDataT>>,
    pub nodeUpgradeData: Option<Vec<dict__string__clz_Torappu_SandboxV2NodeUpgradeDataT>>,
    pub weatherData: Option<Vec<dict__string__clz_Torappu_SandboxV2WeatherDataT>>,
    pub stageData: Option<Vec<dict__string__clz_Torappu_SandboxV2StageDataT>>,
    pub zoneData: Option<Vec<dict__string__clz_Torappu_SandboxV2ZoneDataT>>,
    pub nodeBuffData: Option<Vec<dict__string__clz_Torappu_SandboxV2NodeBuffDataT>>,
    pub rewardConfigData: Option<Box<clz_Torappu_SandboxV2RewardConfigGroupDataT>>,
    pub floatIconData: Option<Vec<dict__string__clz_Torappu_SandboxV2FloatIconDataT>>,
    pub enemyRushTypeData: Option<Vec<dict__string__clz_Torappu_SandboxV2EnemyRushTypeDataT>>,
    pub rushEnemyData: Option<Box<clz_Torappu_SandboxV2BattleRushEnemyDataT>>,
    pub gameConst: Option<Box<clz_Torappu_SandboxV2GameConstT>>,
    pub basicConst: Option<Box<clz_Torappu_SandboxV2BasicConstT>>,
    pub riftConst: Option<Box<clz_Torappu_SandboxV2RiftConstT>>,
    pub developmentConst: Option<Box<clz_Torappu_SandboxV2DevelopmentConstT>>,
    pub battleLoadingTips: Option<Vec<clz_Torappu_TipDataT>>,
    pub runeDatas: Option<Vec<dict__string__clz_Torappu_RuneTable_PackedRuneDataT>>,
    pub itemRuneList: Option<Vec<dict__string__list_clz_Torappu_LegacyInLevelRuneDataT>>,
    pub questData: Option<Vec<dict__string__clz_Torappu_SandboxV2QuestDataT>>,
    pub npcData: Option<Vec<dict__string__clz_Torappu_SandboxV2NpcDataT>>,
    pub dialogData: Option<Vec<dict__string__clz_Torappu_SandboxV2DialogDataT>>,
    pub questLineData: Option<Vec<dict__string__clz_Torappu_SandboxV2QuestLineDataT>>,
    pub questLineStoryData: Option<Vec<dict__string__stringT>>,
    pub guideQuestData: Option<Vec<dict__string__clz_Torappu_SandboxV2GuideQuestDataT>>,
    pub developmentData: Option<Vec<dict__string__clz_Torappu_SandboxV2DevelopmentDataT>>,
    pub eventData: Option<Vec<dict__string__clz_Torappu_SandboxV2EventDataT>>,
    pub eventSceneData: Option<Vec<dict__string__clz_Torappu_SandboxV2EventSceneDataT>>,
    pub eventChoiceData: Option<Vec<dict__string__clz_Torappu_SandboxV2EventChoiceDataT>>,
    pub expeditionData: Option<Vec<dict__string__clz_Torappu_SandboxV2ExpeditionDataT>>,
    pub eventEffectData: Option<Vec<dict__string__clz_Torappu_SandboxV2EventEffectDataT>>,
    pub shopGoodData: Option<Vec<dict__string__clz_Torappu_SandboxV2ShopGoodDataT>>,
    pub shopDialogData: Option<Box<clz_Torappu_SandboxV2ShopDialogDataT>>,
    pub logisticsData: Option<Vec<clz_Torappu_SandboxV2LogisticsDataT>>,
    pub logisticsCharMapping:
        Option<Vec<dict__int__list_dict__int__list_clz_Torappu_SandboxV2LogisticsCharDataT>>,
    pub materialKeywordData: Option<Vec<dict__string__stringT>>,
    pub monthRushData: Option<Vec<clz_Torappu_SandboxV2MonthRushDataT>>,
    pub riftTerrainParamData: Option<Vec<dict__string__clz_Torappu_SandboxV2RiftParamDataT>>,
    pub riftClimateParamData: Option<Vec<dict__string__clz_Torappu_SandboxV2RiftParamDataT>>,
    pub riftEnemyParamData: Option<Vec<dict__string__clz_Torappu_SandboxV2RiftParamDataT>>,
    pub riftSubTargetData: Option<Vec<dict__string__clz_Torappu_SandboxV2RiftSubTargetDataT>>,
    pub riftMainTargetData: Option<Vec<dict__string__clz_Torappu_SandboxV2RiftMainTargetDataT>>,
    pub riftGlobalEffectData: Option<Vec<dict__string__clz_Torappu_SandboxV2RiftGlobalEffectDataT>>,
    pub fixedRiftData: Option<Vec<dict__string__clz_Torappu_SandboxV2FixedRiftDataT>>,
    pub riftTeamBuffData: Option<Vec<dict__string__list_clz_Torappu_SandboxV2RiftTeamBuffDataT>>,
    pub riftDifficultyData: Option<Vec<dict__string__clz_Torappu_SandboxV2RiftDifficultyDataT>>,
    pub riftRewardDisplayData: Option<Vec<dict__string__list_stringT>>,
    pub enemyReplaceData: Option<Vec<dict__string__list_dict__string__stringT>>,
    pub archiveQuestData: Option<Vec<dict__string__clz_Torappu_SandboxV2ArchiveQuestDataT>>,
    pub achievementData: Option<Vec<dict__string__clz_Torappu_SandboxV2ArchiveAchievementDataT>>,
    pub achievementTypeData:
        Option<Vec<dict__string__clz_Torappu_SandboxV2ArchiveAchievementTypeDataT>>,
    pub archiveQuestTypeData: Option<Vec<dict__string__clz_Torappu_SandboxV2ArchiveQuestTypeDataT>>,
    pub archiveMusicUnlockData:
        Option<Vec<dict__string__clz_Torappu_SandboxV2ArchiveMusicUnlockDataT>>,
    pub baseUpdate: Option<Vec<clz_Torappu_SandboxV2BaseUpdateDataT>>,
    pub developmentLineSegmentDatas: Option<Vec<clz_Torappu_SandboxV2DevelopmentLineSegmentDataT>>,
    pub buildingNodeScoreData:
        Option<Vec<dict__string__clz_Torappu_SandboxV2BuildingNodeScoreDataT>>,
    pub seasonData: Option<Vec<dict__string__clz_Torappu_SandboxV2SeasonDataT>>,
    pub confirmIconData: Option<Vec<clz_Torappu_SandboxV2ConfirmIconDataT>>,
    pub shopUpdateTimeData: Option<Vec<i64>>,
    pub tutorialData: Option<Box<clz_Torappu_SandboxV2TutorialDataT>>,
    pub racingData: Option<Box<clz_Torappu_SandboxV2RacingDataT>>,
    pub challengeModeData: Option<Box<clz_Torappu_SandboxV2ChallengeModeDataT>>,
}
impl Default for clz_Torappu_SandboxV2DataT {
    fn default() -> Self {
        Self {
            mapData: None,
            itemTrapData: None,
            itemTrapTagData: None,
            buildingItemData: None,
            craftItemData: None,
            livestockProduceData: None,
            craftGroupData: None,
            alchemyRecipeData: None,
            drinkMatData: None,
            foodMatData: None,
            foodData: None,
            nodeTypeData: None,
            nodeUpgradeData: None,
            weatherData: None,
            stageData: None,
            zoneData: None,
            nodeBuffData: None,
            rewardConfigData: None,
            floatIconData: None,
            enemyRushTypeData: None,
            rushEnemyData: None,
            gameConst: None,
            basicConst: None,
            riftConst: None,
            developmentConst: None,
            battleLoadingTips: None,
            runeDatas: None,
            itemRuneList: None,
            questData: None,
            npcData: None,
            dialogData: None,
            questLineData: None,
            questLineStoryData: None,
            guideQuestData: None,
            developmentData: None,
            eventData: None,
            eventSceneData: None,
            eventChoiceData: None,
            expeditionData: None,
            eventEffectData: None,
            shopGoodData: None,
            shopDialogData: None,
            logisticsData: None,
            logisticsCharMapping: None,
            materialKeywordData: None,
            monthRushData: None,
            riftTerrainParamData: None,
            riftClimateParamData: None,
            riftEnemyParamData: None,
            riftSubTargetData: None,
            riftMainTargetData: None,
            riftGlobalEffectData: None,
            fixedRiftData: None,
            riftTeamBuffData: None,
            riftDifficultyData: None,
            riftRewardDisplayData: None,
            enemyReplaceData: None,
            archiveQuestData: None,
            achievementData: None,
            achievementTypeData: None,
            archiveQuestTypeData: None,
            archiveMusicUnlockData: None,
            baseUpdate: None,
            developmentLineSegmentDatas: None,
            buildingNodeScoreData: None,
            seasonData: None,
            confirmIconData: None,
            shopUpdateTimeData: None,
            tutorialData: None,
            racingData: None,
            challengeModeData: None,
        }
    }
}
impl clz_Torappu_SandboxV2DataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxV2Data<'b>> {
        let mapData = self.mapData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let itemTrapData = self.itemTrapData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let itemTrapTagData = self.itemTrapTagData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let buildingItemData = self.buildingItemData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let craftItemData = self.craftItemData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let livestockProduceData = self.livestockProduceData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let craftGroupData = self.craftGroupData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let alchemyRecipeData = self.alchemyRecipeData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let drinkMatData = self.drinkMatData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let foodMatData = self.foodMatData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let foodData = self.foodData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let nodeTypeData = self.nodeTypeData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let nodeUpgradeData = self.nodeUpgradeData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let weatherData = self.weatherData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let stageData = self.stageData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let zoneData = self.zoneData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let nodeBuffData = self.nodeBuffData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let rewardConfigData = self.rewardConfigData.as_ref().map(|x| x.pack(_fbb));
        let floatIconData = self.floatIconData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let enemyRushTypeData = self.enemyRushTypeData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let rushEnemyData = self.rushEnemyData.as_ref().map(|x| x.pack(_fbb));
        let gameConst = self.gameConst.as_ref().map(|x| x.pack(_fbb));
        let basicConst = self.basicConst.as_ref().map(|x| x.pack(_fbb));
        let riftConst = self.riftConst.as_ref().map(|x| x.pack(_fbb));
        let developmentConst = self.developmentConst.as_ref().map(|x| x.pack(_fbb));
        let battleLoadingTips = self.battleLoadingTips.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let runeDatas = self.runeDatas.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let itemRuneList = self.itemRuneList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let questData = self.questData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let npcData = self.npcData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let dialogData = self.dialogData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let questLineData = self.questLineData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let questLineStoryData = self.questLineStoryData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let guideQuestData = self.guideQuestData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let developmentData = self.developmentData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let eventData = self.eventData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let eventSceneData = self.eventSceneData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let eventChoiceData = self.eventChoiceData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let expeditionData = self.expeditionData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let eventEffectData = self.eventEffectData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let shopGoodData = self.shopGoodData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let shopDialogData = self.shopDialogData.as_ref().map(|x| x.pack(_fbb));
        let logisticsData = self.logisticsData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let logisticsCharMapping = self.logisticsCharMapping.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let materialKeywordData = self.materialKeywordData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let monthRushData = self.monthRushData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let riftTerrainParamData = self.riftTerrainParamData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let riftClimateParamData = self.riftClimateParamData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let riftEnemyParamData = self.riftEnemyParamData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let riftSubTargetData = self.riftSubTargetData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let riftMainTargetData = self.riftMainTargetData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let riftGlobalEffectData = self.riftGlobalEffectData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let fixedRiftData = self.fixedRiftData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let riftTeamBuffData = self.riftTeamBuffData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let riftDifficultyData = self.riftDifficultyData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let riftRewardDisplayData = self.riftRewardDisplayData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let enemyReplaceData = self.enemyReplaceData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let archiveQuestData = self.archiveQuestData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let achievementData = self.achievementData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let achievementTypeData = self.achievementTypeData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let archiveQuestTypeData = self.archiveQuestTypeData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let archiveMusicUnlockData = self.archiveMusicUnlockData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let baseUpdate = self.baseUpdate.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let developmentLineSegmentDatas = self.developmentLineSegmentDatas.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let buildingNodeScoreData = self.buildingNodeScoreData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let seasonData = self.seasonData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let confirmIconData = self.confirmIconData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let shopUpdateTimeData = self
            .shopUpdateTimeData
            .as_ref()
            .map(|x| _fbb.create_vector(x));
        let tutorialData = self.tutorialData.as_ref().map(|x| x.pack(_fbb));
        let racingData = self.racingData.as_ref().map(|x| x.pack(_fbb));
        let challengeModeData = self.challengeModeData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_SandboxV2Data::create(
            _fbb,
            &clz_Torappu_SandboxV2DataArgs {
                mapData,
                itemTrapData,
                itemTrapTagData,
                buildingItemData,
                craftItemData,
                livestockProduceData,
                craftGroupData,
                alchemyRecipeData,
                drinkMatData,
                foodMatData,
                foodData,
                nodeTypeData,
                nodeUpgradeData,
                weatherData,
                stageData,
                zoneData,
                nodeBuffData,
                rewardConfigData,
                floatIconData,
                enemyRushTypeData,
                rushEnemyData,
                gameConst,
                basicConst,
                riftConst,
                developmentConst,
                battleLoadingTips,
                runeDatas,
                itemRuneList,
                questData,
                npcData,
                dialogData,
                questLineData,
                questLineStoryData,
                guideQuestData,
                developmentData,
                eventData,
                eventSceneData,
                eventChoiceData,
                expeditionData,
                eventEffectData,
                shopGoodData,
                shopDialogData,
                logisticsData,
                logisticsCharMapping,
                materialKeywordData,
                monthRushData,
                riftTerrainParamData,
                riftClimateParamData,
                riftEnemyParamData,
                riftSubTargetData,
                riftMainTargetData,
                riftGlobalEffectData,
                fixedRiftData,
                riftTeamBuffData,
                riftDifficultyData,
                riftRewardDisplayData,
                enemyReplaceData,
                archiveQuestData,
                achievementData,
                achievementTypeData,
                archiveQuestTypeData,
                archiveMusicUnlockData,
                baseUpdate,
                developmentLineSegmentDatas,
                buildingNodeScoreData,
                seasonData,
                confirmIconData,
                shopUpdateTimeData,
                tutorialData,
                racingData,
                challengeModeData,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxV2DataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxV2Data<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxV2Data<'a> {
    type Inner = dict__string__clz_Torappu_SandboxV2Data<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxV2Data<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxV2Data { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxV2DataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2Data<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxV2DataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxV2DataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxV2DataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxV2Data::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxV2Data) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxV2Data<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2Data>>(
                    dict__string__clz_Torappu_SandboxV2Data::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxV2Data<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxV2Data>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxV2DataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxV2Data<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxV2DataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxV2DataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxV2Data<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_SandboxV2Data", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxV2DataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxV2DataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxV2Data::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxV2Data<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxV2Data>>(
                dict__string__clz_Torappu_SandboxV2Data::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxV2DataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxV2DataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2Data<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_SandboxV2Data::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxV2Data<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxV2Data");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxV2DataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxV2DataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxV2DataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxV2DataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxV2Data<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxV2Data::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxV2DataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxPermDetailDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxPermDetailData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxPermDetailData<'a> {
    type Inner = clz_Torappu_SandboxPermDetailData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxPermDetailData<'a> {
    pub const VT_SANDBOX_V2: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxPermDetailData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxPermDetailDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermDetailData<'bldr>> {
        let mut builder = clz_Torappu_SandboxPermDetailDataBuilder::new(_fbb);
        if let Some(x) = args.SANDBOX_V2 {
            builder.add_SANDBOX_V2(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxPermDetailDataT {
        let SANDBOX_V2 = self
            .SANDBOX_V2()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_SandboxPermDetailDataT { SANDBOX_V2 }
    }

    #[inline]
    pub fn SANDBOX_V2(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2Data<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2Data>,
                >,
            >>(clz_Torappu_SandboxPermDetailData::VT_SANDBOX_V2, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxPermDetailData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2Data>,
                >,
            >>("SANDBOX_V2", Self::VT_SANDBOX_V2, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxPermDetailDataArgs<'a> {
    pub SANDBOX_V2: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2Data<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SandboxPermDetailDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxPermDetailDataArgs { SANDBOX_V2: None }
    }
}

impl Serialize for clz_Torappu_SandboxPermDetailData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxPermDetailData", 1)?;
        if let Some(f) = self.SANDBOX_V2() {
            s.serialize_field("SANDBOX_V2", &f)?;
        } else {
            s.skip_field("SANDBOX_V2")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxPermDetailDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxPermDetailDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_SANDBOX_V2(
        &mut self,
        SANDBOX_V2: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxV2Data<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermDetailData::VT_SANDBOX_V2,
            SANDBOX_V2,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxPermDetailDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxPermDetailDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermDetailData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxPermDetailData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxPermDetailData");
        ds.field("SANDBOX_V2", &self.SANDBOX_V2());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxPermDetailDataT {
    pub SANDBOX_V2: Option<Vec<dict__string__clz_Torappu_SandboxV2DataT>>,
}
impl Default for clz_Torappu_SandboxPermDetailDataT {
    fn default() -> Self {
        Self { SANDBOX_V2: None }
    }
}
impl clz_Torappu_SandboxPermDetailDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermDetailData<'b>> {
        let SANDBOX_V2 = self.SANDBOX_V2.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SandboxPermDetailData::create(
            _fbb,
            &clz_Torappu_SandboxPermDetailDataArgs { SANDBOX_V2 },
        )
    }
}
pub enum clz_Torappu_SandboxPermItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxPermItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxPermItemData<'a> {
    type Inner = clz_Torappu_SandboxPermItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxPermItemData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_ITEMTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_ITEMNAME: flatbuffers::VOffsetT = 8;
    pub const VT_ITEMUSAGE: flatbuffers::VOffsetT = 10;
    pub const VT_ITEMDESC: flatbuffers::VOffsetT = 12;
    pub const VT_ITEMRARITY: flatbuffers::VOffsetT = 14;
    pub const VT_SORTID: flatbuffers::VOffsetT = 16;
    pub const VT_OBTAINAPPROACH: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxPermItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxPermItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermItemData<'bldr>> {
        let mut builder = clz_Torappu_SandboxPermItemDataBuilder::new(_fbb);
        if let Some(x) = args.obtainApproach {
            builder.add_obtainApproach(x);
        }
        builder.add_sortId(args.sortId);
        builder.add_itemRarity(args.itemRarity);
        if let Some(x) = args.itemDesc {
            builder.add_itemDesc(x);
        }
        if let Some(x) = args.itemUsage {
            builder.add_itemUsage(x);
        }
        if let Some(x) = args.itemName {
            builder.add_itemName(x);
        }
        builder.add_itemType(args.itemType);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxPermItemDataT {
        let itemId = self.itemId().map(|x| x.to_string());
        let itemType = self.itemType();
        let itemName = self.itemName().map(|x| x.to_string());
        let itemUsage = self.itemUsage().map(|x| x.to_string());
        let itemDesc = self.itemDesc().map(|x| x.to_string());
        let itemRarity = self.itemRarity();
        let sortId = self.sortId();
        let obtainApproach = self.obtainApproach().map(|x| x.to_string());
        clz_Torappu_SandboxPermItemDataT {
            itemId,
            itemType,
            itemName,
            itemUsage,
            itemDesc,
            itemRarity,
            sortId,
            obtainApproach,
        }
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermItemData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn itemType(&self) -> enum__Torappu_SandboxPermItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxPermItemType>(
                    clz_Torappu_SandboxPermItemData::VT_ITEMTYPE,
                    Some(enum__Torappu_SandboxPermItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn itemName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermItemData::VT_ITEMNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn itemUsage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermItemData::VT_ITEMUSAGE,
                None,
            )
        }
    }
    #[inline]
    pub fn itemDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermItemData::VT_ITEMDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn itemRarity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxPermItemData::VT_ITEMRARITY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxPermItemData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn obtainApproach(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxPermItemData::VT_OBTAINAPPROACH,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxPermItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<enum__Torappu_SandboxPermItemType>("itemType", Self::VT_ITEMTYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "itemName",
                Self::VT_ITEMNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "itemUsage",
                Self::VT_ITEMUSAGE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "itemDesc",
                Self::VT_ITEMDESC,
                false,
            )?
            .visit_field::<i32>("itemRarity", Self::VT_ITEMRARITY, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "obtainApproach",
                Self::VT_OBTAINAPPROACH,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxPermItemDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemType: enum__Torappu_SandboxPermItemType,
    pub itemName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemUsage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemRarity: i32,
    pub sortId: i32,
    pub obtainApproach: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxPermItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxPermItemDataArgs {
            itemId: None,
            itemType: enum__Torappu_SandboxPermItemType::NONE,
            itemName: None,
            itemUsage: None,
            itemDesc: None,
            itemRarity: 0,
            sortId: 0,
            obtainApproach: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxPermItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxPermItemData", 8)?;
        if let Some(f) = self.itemId() {
            s.serialize_field("itemId", &f)?;
        } else {
            s.skip_field("itemId")?;
        }
        s.serialize_field("itemType", &self.itemType())?;
        if let Some(f) = self.itemName() {
            s.serialize_field("itemName", &f)?;
        } else {
            s.skip_field("itemName")?;
        }
        if let Some(f) = self.itemUsage() {
            s.serialize_field("itemUsage", &f)?;
        } else {
            s.skip_field("itemUsage")?;
        }
        if let Some(f) = self.itemDesc() {
            s.serialize_field("itemDesc", &f)?;
        } else {
            s.skip_field("itemDesc")?;
        }
        s.serialize_field("itemRarity", &self.itemRarity())?;
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.obtainApproach() {
            s.serialize_field("obtainApproach", &f)?;
        } else {
            s.skip_field("obtainApproach")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxPermItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxPermItemDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermItemData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_itemType(&mut self, itemType: enum__Torappu_SandboxPermItemType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxPermItemType>(
            clz_Torappu_SandboxPermItemData::VT_ITEMTYPE,
            itemType,
            enum__Torappu_SandboxPermItemType::NONE,
        );
    }
    #[inline]
    pub fn add_itemName(&mut self, itemName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermItemData::VT_ITEMNAME,
            itemName,
        );
    }
    #[inline]
    pub fn add_itemUsage(&mut self, itemUsage: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermItemData::VT_ITEMUSAGE,
            itemUsage,
        );
    }
    #[inline]
    pub fn add_itemDesc(&mut self, itemDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermItemData::VT_ITEMDESC,
            itemDesc,
        );
    }
    #[inline]
    pub fn add_itemRarity(&mut self, itemRarity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxPermItemData::VT_ITEMRARITY,
            itemRarity,
            0,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxPermItemData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_obtainApproach(&mut self, obtainApproach: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermItemData::VT_OBTAINAPPROACH,
            obtainApproach,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxPermItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxPermItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxPermItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxPermItemData");
        ds.field("itemId", &self.itemId());
        ds.field("itemType", &self.itemType());
        ds.field("itemName", &self.itemName());
        ds.field("itemUsage", &self.itemUsage());
        ds.field("itemDesc", &self.itemDesc());
        ds.field("itemRarity", &self.itemRarity());
        ds.field("sortId", &self.sortId());
        ds.field("obtainApproach", &self.obtainApproach());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxPermItemDataT {
    pub itemId: Option<String>,
    pub itemType: enum__Torappu_SandboxPermItemType,
    pub itemName: Option<String>,
    pub itemUsage: Option<String>,
    pub itemDesc: Option<String>,
    pub itemRarity: i32,
    pub sortId: i32,
    pub obtainApproach: Option<String>,
}
impl Default for clz_Torappu_SandboxPermItemDataT {
    fn default() -> Self {
        Self {
            itemId: None,
            itemType: enum__Torappu_SandboxPermItemType::NONE,
            itemName: None,
            itemUsage: None,
            itemDesc: None,
            itemRarity: 0,
            sortId: 0,
            obtainApproach: None,
        }
    }
}
impl clz_Torappu_SandboxPermItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermItemData<'b>> {
        let itemId = self.itemId.as_ref().map(|x| _fbb.create_string(x));
        let itemType = self.itemType;
        let itemName = self.itemName.as_ref().map(|x| _fbb.create_string(x));
        let itemUsage = self.itemUsage.as_ref().map(|x| _fbb.create_string(x));
        let itemDesc = self.itemDesc.as_ref().map(|x| _fbb.create_string(x));
        let itemRarity = self.itemRarity;
        let sortId = self.sortId;
        let obtainApproach = self.obtainApproach.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SandboxPermItemData::create(
            _fbb,
            &clz_Torappu_SandboxPermItemDataArgs {
                itemId,
                itemType,
                itemName,
                itemUsage,
                itemDesc,
                itemRarity,
                sortId,
                obtainApproach,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SandboxPermItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxPermItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxPermItemData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxPermItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxPermItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxPermItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxPermItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxPermItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxPermItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SandboxPermItemDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SandboxPermItemDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxPermItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxPermItemData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxPermItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxPermItemData>>(
                    dict__string__clz_Torappu_SandboxPermItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxPermItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxPermItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxPermItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxPermItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxPermItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxPermItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SandboxPermItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SandboxPermItemData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SandboxPermItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxPermItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxPermItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxPermItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxPermItemData>>(
                dict__string__clz_Torappu_SandboxPermItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxPermItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxPermItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxPermItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxPermItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxPermItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxPermItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SandboxPermItemDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SandboxPermItemDataT>>,
}
impl Default for dict__string__clz_Torappu_SandboxPermItemDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SandboxPermItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxPermItemData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SandboxPermItemData::create(
            _fbb,
            &dict__string__clz_Torappu_SandboxPermItemDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SandboxPermTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxPermTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxPermTable<'a> {
    type Inner = clz_Torappu_SandboxPermTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SandboxPermTable<'a> {
    pub const VT_BASICINFO: flatbuffers::VOffsetT = 4;
    pub const VT_DETAIL: flatbuffers::VOffsetT = 6;
    pub const VT_ITEMDATA: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxPermTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxPermTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermTable<'bldr>> {
        let mut builder = clz_Torappu_SandboxPermTableBuilder::new(_fbb);
        if let Some(x) = args.itemData {
            builder.add_itemData(x);
        }
        if let Some(x) = args.detail {
            builder.add_detail(x);
        }
        if let Some(x) = args.basicInfo {
            builder.add_basicInfo(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SandboxPermTableT {
        let basicInfo = self
            .basicInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let detail = self.detail().map(|x| Box::new(x.unpack()));
        let itemData = self
            .itemData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_SandboxPermTableT {
            basicInfo,
            detail,
            itemData,
        }
    }

    #[inline]
    pub fn basicInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxPermBasicData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxPermBasicData>,
                >,
            >>(clz_Torappu_SandboxPermTable::VT_BASICINFO, None)
        }
    }
    #[inline]
    pub fn detail(&self) -> Option<clz_Torappu_SandboxPermDetailData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxPermDetailData>>(
                    clz_Torappu_SandboxPermTable::VT_DETAIL,
                    None,
                )
        }
    }
    #[inline]
    pub fn itemData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxPermItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxPermItemData>,
                >,
            >>(clz_Torappu_SandboxPermTable::VT_ITEMDATA, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxPermTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxPermBasicData>,
                >,
            >>("basicInfo", Self::VT_BASICINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxPermDetailData>>(
                "detail",
                Self::VT_DETAIL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxPermItemData>,
                >,
            >>("itemData", Self::VT_ITEMDATA, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxPermTableArgs<'a> {
    pub basicInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxPermBasicData<'a>>,
            >,
        >,
    >,
    pub detail: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxPermDetailData<'a>>>,
    pub itemData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxPermItemData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SandboxPermTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxPermTableArgs {
            basicInfo: None,
            detail: None,
            itemData: None,
        }
    }
}

impl Serialize for clz_Torappu_SandboxPermTable<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SandboxPermTable", 3)?;
        if let Some(f) = self.basicInfo() {
            s.serialize_field("basicInfo", &f)?;
        } else {
            s.skip_field("basicInfo")?;
        }
        if let Some(f) = self.detail() {
            s.serialize_field("detail", &f)?;
        } else {
            s.skip_field("detail")?;
        }
        if let Some(f) = self.itemData() {
            s.serialize_field("itemData", &f)?;
        } else {
            s.skip_field("itemData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SandboxPermTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxPermTableBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_basicInfo(
        &mut self,
        basicInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxPermBasicData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermTable::VT_BASICINFO,
            basicInfo,
        );
    }
    #[inline]
    pub fn add_detail(
        &mut self,
        detail: flatbuffers::WIPOffset<clz_Torappu_SandboxPermDetailData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxPermDetailData>>(
                clz_Torappu_SandboxPermTable::VT_DETAIL,
                detail,
            );
    }
    #[inline]
    pub fn add_itemData(
        &mut self,
        itemData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxPermItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxPermTable::VT_ITEMDATA,
            itemData,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxPermTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxPermTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxPermTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxPermTable");
        ds.field("basicInfo", &self.basicInfo());
        ds.field("detail", &self.detail());
        ds.field("itemData", &self.itemData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SandboxPermTableT {
    pub basicInfo: Option<Vec<dict__string__clz_Torappu_SandboxPermBasicDataT>>,
    pub detail: Option<Box<clz_Torappu_SandboxPermDetailDataT>>,
    pub itemData: Option<Vec<dict__string__clz_Torappu_SandboxPermItemDataT>>,
}
impl Default for clz_Torappu_SandboxPermTableT {
    fn default() -> Self {
        Self {
            basicInfo: None,
            detail: None,
            itemData: None,
        }
    }
}
impl clz_Torappu_SandboxPermTableT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxPermTable<'b>> {
        let basicInfo = self.basicInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let detail = self.detail.as_ref().map(|x| x.pack(_fbb));
        let itemData = self.itemData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SandboxPermTable::create(
            _fbb,
            &clz_Torappu_SandboxPermTableArgs {
                basicInfo,
                detail,
                itemData,
            },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_SandboxPermTable`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_sandbox_perm_table_unchecked`.
pub fn root_as_clz_torappu_sandbox_perm_table(
    buf: &[u8],
) -> Result<clz_Torappu_SandboxPermTable, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_SandboxPermTable>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_SandboxPermTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_sandbox_perm_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_sandbox_perm_table(
    buf: &[u8],
) -> Result<clz_Torappu_SandboxPermTable, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_SandboxPermTable>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_SandboxPermTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_sandbox_perm_table_unchecked`.
pub fn root_as_clz_torappu_sandbox_perm_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_SandboxPermTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_SandboxPermTable<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_SandboxPermTable` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_sandbox_perm_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_sandbox_perm_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_SandboxPermTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_SandboxPermTable<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_SandboxPermTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_SandboxPermTable`.
pub unsafe fn root_as_clz_torappu_sandbox_perm_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_SandboxPermTable {
    unsafe { flatbuffers::root_unchecked::<clz_Torappu_SandboxPermTable>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_SandboxPermTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_SandboxPermTable`.
pub unsafe fn size_prefixed_root_as_clz_torappu_sandbox_perm_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_SandboxPermTable {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_SandboxPermTable>(buf) }
}
#[inline]
pub fn finish_clz_torappu_sandbox_perm_table_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_SandboxPermTable<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_sandbox_perm_table_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_SandboxPermTable<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
