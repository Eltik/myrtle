// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUILDING_DATA_LODLEVEL: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUILDING_DATA_LODLEVEL: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUILDING_DATA_LODLEVEL: [enum__Torappu_BuildingData_LODLEVEL;
    5] = [
    enum__Torappu_BuildingData_LODLEVEL::HIGHEST,
    enum__Torappu_BuildingData_LODLEVEL::HIGH,
    enum__Torappu_BuildingData_LODLEVEL::LOW,
    enum__Torappu_BuildingData_LODLEVEL::LOWEST,
    enum__Torappu_BuildingData_LODLEVEL::COUNT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuildingData_LODLEVEL(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuildingData_LODLEVEL {
    pub const HIGHEST: Self = Self(0);
    pub const HIGH: Self = Self(1);
    pub const LOW: Self = Self(2);
    pub const LOWEST: Self = Self(3);
    pub const COUNT: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::HIGHEST,
        Self::HIGH,
        Self::LOW,
        Self::LOWEST,
        Self::COUNT,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::HIGHEST => Some("HIGHEST"),
            Self::HIGH => Some("HIGH"),
            Self::LOW => Some("LOW"),
            Self::LOWEST => Some("LOWEST"),
            Self::COUNT => Some("COUNT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuildingData_LODLEVEL {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_BuildingData_LODLEVEL {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_BuildingData_LODLEVEL",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuildingData_LODLEVEL {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuildingData_LODLEVEL {
    type Output = enum__Torappu_BuildingData_LODLEVEL;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuildingData_LODLEVEL {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuildingData_LODLEVEL {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuildingData_LODLEVEL {}
pub enum clz_Torappu_GridPositionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_GridPosition<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_GridPosition<'a> {
    type Inner = clz_Torappu_GridPosition<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_GridPosition<'a> {
    pub const VT_ROW: flatbuffers::VOffsetT = 4;
    pub const VT_COL: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_GridPosition { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_GridPositionArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_GridPosition<'bldr>> {
        let mut builder = clz_Torappu_GridPositionBuilder::new(_fbb);
        builder.add_col(args.col);
        builder.add_row(args.row);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_GridPositionT {
        let row = self.row();
        let col = self.col();
        clz_Torappu_GridPositionT { row, col }
    }

    #[inline]
    pub fn row(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_GridPosition::VT_ROW, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn col(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_GridPosition::VT_COL, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_GridPosition<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("row", Self::VT_ROW, false)?
            .visit_field::<i32>("col", Self::VT_COL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_GridPositionArgs {
    pub row: i32,
    pub col: i32,
}
impl<'a> Default for clz_Torappu_GridPositionArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_GridPositionArgs { row: 0, col: 0 }
    }
}

impl Serialize for clz_Torappu_GridPosition<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_GridPosition", 2)?;
        s.serialize_field("row", &self.row())?;
        s.serialize_field("col", &self.col())?;
        s.end()
    }
}

pub struct clz_Torappu_GridPositionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_GridPositionBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_row(&mut self, row: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_GridPosition::VT_ROW, row, 0);
    }
    #[inline]
    pub fn add_col(&mut self, col: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_GridPosition::VT_COL, col, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_GridPositionBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_GridPositionBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_GridPosition<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_GridPosition<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_GridPosition");
        ds.field("row", &self.row());
        ds.field("col", &self.col());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_GridPositionT {
    pub row: i32,
    pub col: i32,
}
impl Default for clz_Torappu_GridPositionT {
    fn default() -> Self {
        Self { row: 0, col: 0 }
    }
}
impl clz_Torappu_GridPositionT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_GridPosition<'b>> {
        let row = self.row;
        let col = self.col;
        clz_Torappu_GridPosition::create(_fbb, &clz_Torappu_GridPositionArgs { row, col })
    }
}
pub enum clz_Torappu_BuildingData_ObstaclePointOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_ObstaclePoint<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_ObstaclePoint<'a> {
    type Inner = clz_Torappu_BuildingData_ObstaclePoint<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_BuildingData_ObstaclePoint<'a> {
    pub const VT_OFFSET: flatbuffers::VOffsetT = 4;
    pub const VT_EDGEWALKABLEMASK: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_ObstaclePoint { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_ObstaclePointArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ObstaclePoint<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_ObstaclePointBuilder::new(_fbb);
        if let Some(x) = args.offset {
            builder.add_offset(x);
        }
        builder.add_edgeWalkableMask(args.edgeWalkableMask);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_BuildingData_ObstaclePointT {
        let offset = self.offset().map(|x| Box::new(x.unpack()));
        let edgeWalkableMask = self.edgeWalkableMask();
        clz_Torappu_BuildingData_ObstaclePointT {
            offset,
            edgeWalkableMask,
        }
    }

    #[inline]
    pub fn offset(&self) -> Option<clz_Torappu_GridPosition<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                    clz_Torappu_BuildingData_ObstaclePoint::VT_OFFSET,
                    None,
                )
        }
    }
    #[inline]
    pub fn edgeWalkableMask(&self) -> u8 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u8>(
                    clz_Torappu_BuildingData_ObstaclePoint::VT_EDGEWALKABLEMASK,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_ObstaclePoint<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                "offset",
                Self::VT_OFFSET,
                false,
            )?
            .visit_field::<u8>("edgeWalkableMask", Self::VT_EDGEWALKABLEMASK, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_ObstaclePointArgs<'a> {
    pub offset: Option<flatbuffers::WIPOffset<clz_Torappu_GridPosition<'a>>>,
    pub edgeWalkableMask: u8,
}
impl<'a> Default for clz_Torappu_BuildingData_ObstaclePointArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_ObstaclePointArgs {
            offset: None,
            edgeWalkableMask: 0,
        }
    }
}

impl Serialize for clz_Torappu_BuildingData_ObstaclePoint<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_BuildingData_ObstaclePoint", 2)?;
        if let Some(f) = self.offset() {
            s.serialize_field("offset", &f)?;
        } else {
            s.skip_field("offset")?;
        }
        s.serialize_field("edgeWalkableMask", &self.edgeWalkableMask())?;
        s.end()
    }
}

pub struct clz_Torappu_BuildingData_ObstaclePointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_ObstaclePointBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_offset(&mut self, offset: flatbuffers::WIPOffset<clz_Torappu_GridPosition<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_GridPosition>>(
                clz_Torappu_BuildingData_ObstaclePoint::VT_OFFSET,
                offset,
            );
    }
    #[inline]
    pub fn add_edgeWalkableMask(&mut self, edgeWalkableMask: u8) {
        self.fbb_.push_slot::<u8>(
            clz_Torappu_BuildingData_ObstaclePoint::VT_EDGEWALKABLEMASK,
            edgeWalkableMask,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_ObstaclePointBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_ObstaclePointBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ObstaclePoint<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_ObstaclePoint<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_ObstaclePoint");
        ds.field("offset", &self.offset());
        ds.field("edgeWalkableMask", &self.edgeWalkableMask());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_BuildingData_ObstaclePointT {
    pub offset: Option<Box<clz_Torappu_GridPositionT>>,
    pub edgeWalkableMask: u8,
}
impl Default for clz_Torappu_BuildingData_ObstaclePointT {
    fn default() -> Self {
        Self {
            offset: None,
            edgeWalkableMask: 0,
        }
    }
}
impl clz_Torappu_BuildingData_ObstaclePointT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ObstaclePoint<'b>> {
        let offset = self.offset.as_ref().map(|x| x.pack(_fbb));
        let edgeWalkableMask = self.edgeWalkableMask;
        clz_Torappu_BuildingData_ObstaclePoint::create(
            _fbb,
            &clz_Torappu_BuildingData_ObstaclePointArgs {
                offset,
                edgeWalkableMask,
            },
        )
    }
}
pub enum clz_Torappu_BuildingData_ObstacleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_ObstacleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_ObstacleData<'a> {
    type Inner = clz_Torappu_BuildingData_ObstacleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_BuildingData_ObstacleData<'a> {
    pub const VT_FLOOROBSTACLES: flatbuffers::VOffsetT = 4;
    pub const VT_BACKWALLOBSTACLES: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_ObstacleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_ObstacleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ObstacleData<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_ObstacleDataBuilder::new(_fbb);
        if let Some(x) = args.backwallObstacles {
            builder.add_backwallObstacles(x);
        }
        if let Some(x) = args.floorObstacles {
            builder.add_floorObstacles(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_BuildingData_ObstacleDataT {
        let floorObstacles = self
            .floorObstacles()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let backwallObstacles = self
            .backwallObstacles()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_BuildingData_ObstacleDataT {
            floorObstacles,
            backwallObstacles,
        }
    }

    #[inline]
    pub fn floorObstacles(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ObstaclePoint<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ObstaclePoint>,
                >,
            >>(
                clz_Torappu_BuildingData_ObstacleData::VT_FLOOROBSTACLES,
                None,
            )
        }
    }
    #[inline]
    pub fn backwallObstacles(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ObstaclePoint<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ObstaclePoint>,
                >,
            >>(
                clz_Torappu_BuildingData_ObstacleData::VT_BACKWALLOBSTACLES,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_ObstacleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ObstaclePoint>,
                >,
            >>("floorObstacles", Self::VT_FLOOROBSTACLES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ObstaclePoint>,
                >,
            >>("backwallObstacles", Self::VT_BACKWALLOBSTACLES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_ObstacleDataArgs<'a> {
    pub floorObstacles: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ObstaclePoint<'a>>,
            >,
        >,
    >,
    pub backwallObstacles: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ObstaclePoint<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_ObstacleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_ObstacleDataArgs {
            floorObstacles: None,
            backwallObstacles: None,
        }
    }
}

impl Serialize for clz_Torappu_BuildingData_ObstacleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_BuildingData_ObstacleData", 2)?;
        if let Some(f) = self.floorObstacles() {
            s.serialize_field("floorObstacles", &f)?;
        } else {
            s.skip_field("floorObstacles")?;
        }
        if let Some(f) = self.backwallObstacles() {
            s.serialize_field("backwallObstacles", &f)?;
        } else {
            s.skip_field("backwallObstacles")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_BuildingData_ObstacleDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_ObstacleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_floorObstacles(
        &mut self,
        floorObstacles: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ObstaclePoint<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_ObstacleData::VT_FLOOROBSTACLES,
            floorObstacles,
        );
    }
    #[inline]
    pub fn add_backwallObstacles(
        &mut self,
        backwallObstacles: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ObstaclePoint<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_ObstacleData::VT_BACKWALLOBSTACLES,
            backwallObstacles,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_ObstacleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_ObstacleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ObstacleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_ObstacleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_ObstacleData");
        ds.field("floorObstacles", &self.floorObstacles());
        ds.field("backwallObstacles", &self.backwallObstacles());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_BuildingData_ObstacleDataT {
    pub floorObstacles: Option<Vec<clz_Torappu_BuildingData_ObstaclePointT>>,
    pub backwallObstacles: Option<Vec<clz_Torappu_BuildingData_ObstaclePointT>>,
}
impl Default for clz_Torappu_BuildingData_ObstacleDataT {
    fn default() -> Self {
        Self {
            floorObstacles: None,
            backwallObstacles: None,
        }
    }
}
impl clz_Torappu_BuildingData_ObstacleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ObstacleData<'b>> {
        let floorObstacles = self.floorObstacles.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let backwallObstacles = self.backwallObstacles.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_BuildingData_ObstacleData::create(
            _fbb,
            &clz_Torappu_BuildingData_ObstacleDataArgs {
                floorObstacles,
                backwallObstacles,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_BuildingData_ObstacleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_ObstacleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_BuildingData_ObstacleData<'a> {
    type Inner = dict__string__clz_Torappu_BuildingData_ObstacleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_ObstacleData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_ObstacleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_ObstacleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_ObstacleData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_BuildingData_ObstacleDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_BuildingData_ObstacleDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_BuildingData_ObstacleDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BuildingData_ObstacleData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_ObstacleData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_ObstacleData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ObstacleData>>(
                    dict__string__clz_Torappu_BuildingData_ObstacleData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_BuildingData_ObstacleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ObstacleData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_ObstacleDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_ObstacleData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BuildingData_ObstacleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_ObstacleDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_BuildingData_ObstacleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_BuildingData_ObstacleData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_BuildingData_ObstacleDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_ObstacleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuildingData_ObstacleData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_ObstacleData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_ObstacleData>>(
                dict__string__clz_Torappu_BuildingData_ObstacleData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuildingData_ObstacleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_ObstacleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_ObstacleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_BuildingData_ObstacleData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BuildingData_ObstacleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_BuildingData_ObstacleData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_BuildingData_ObstacleDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_BuildingData_ObstacleDataT>>,
}
impl Default for dict__string__clz_Torappu_BuildingData_ObstacleDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_BuildingData_ObstacleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_ObstacleData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_BuildingData_ObstacleData::create(
            _fbb,
            &dict__string__clz_Torappu_BuildingData_ObstacleDataArgs { key, value },
        )
    }
}
pub enum dict__enum__Torappu_BuildingData_LODLEVEL__list_stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_BuildingData_LODLEVEL__list_string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__enum__Torappu_BuildingData_LODLEVEL__list_string<'a> {
    type Inner = dict__enum__Torappu_BuildingData_LODLEVEL__list_string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__enum__Torappu_BuildingData_LODLEVEL__list_string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_BuildingData_LODLEVEL__list_string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__enum__Torappu_BuildingData_LODLEVEL__list_stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_BuildingData_LODLEVEL__list_string<'bldr>> {
        let mut builder = dict__enum__Torappu_BuildingData_LODLEVEL__list_stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__enum__Torappu_BuildingData_LODLEVEL__list_stringT {
        let key = self.key();
        let value = self
            .value()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        dict__enum__Torappu_BuildingData_LODLEVEL__list_stringT { key, value }
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_BuildingData_LODLEVEL {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_LODLEVEL>(
                    dict__enum__Torappu_BuildingData_LODLEVEL__list_string::VT_KEY,
                    Some(enum__Torappu_BuildingData_LODLEVEL::HIGHEST),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__enum__Torappu_BuildingData_LODLEVEL__list_string,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_BuildingData_LODLEVEL,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                dict__enum__Torappu_BuildingData_LODLEVEL__list_string::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for dict__enum__Torappu_BuildingData_LODLEVEL__list_string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_BuildingData_LODLEVEL>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__enum__Torappu_BuildingData_LODLEVEL__list_stringArgs<'a> {
    pub key: enum__Torappu_BuildingData_LODLEVEL,
    pub value: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for dict__enum__Torappu_BuildingData_LODLEVEL__list_stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__enum__Torappu_BuildingData_LODLEVEL__list_stringArgs {
            key: enum__Torappu_BuildingData_LODLEVEL::HIGHEST,
            value: None,
        }
    }
}

impl Serialize for dict__enum__Torappu_BuildingData_LODLEVEL__list_string<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__enum__Torappu_BuildingData_LODLEVEL__list_string", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__enum__Torappu_BuildingData_LODLEVEL__list_stringBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__enum__Torappu_BuildingData_LODLEVEL__list_stringBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: enum__Torappu_BuildingData_LODLEVEL) {
        self.fbb_.push_slot::<enum__Torappu_BuildingData_LODLEVEL>(
            dict__enum__Torappu_BuildingData_LODLEVEL__list_string::VT_KEY,
            key,
            enum__Torappu_BuildingData_LODLEVEL::HIGHEST,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__enum__Torappu_BuildingData_LODLEVEL__list_string::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__enum__Torappu_BuildingData_LODLEVEL__list_stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__enum__Torappu_BuildingData_LODLEVEL__list_stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_BuildingData_LODLEVEL__list_string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__enum__Torappu_BuildingData_LODLEVEL__list_string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__enum__Torappu_BuildingData_LODLEVEL__list_string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__enum__Torappu_BuildingData_LODLEVEL__list_stringT {
    pub key: enum__Torappu_BuildingData_LODLEVEL,
    pub value: Option<Vec<String>>,
}
impl Default for dict__enum__Torappu_BuildingData_LODLEVEL__list_stringT {
    fn default() -> Self {
        Self {
            key: enum__Torappu_BuildingData_LODLEVEL::HIGHEST,
            value: None,
        }
    }
}
impl dict__enum__Torappu_BuildingData_LODLEVEL__list_stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_BuildingData_LODLEVEL__list_string<'b>> {
        let key = self.key;
        let value = self.value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        dict__enum__Torappu_BuildingData_LODLEVEL__list_string::create(
            _fbb,
            &dict__enum__Torappu_BuildingData_LODLEVEL__list_stringArgs { key, value },
        )
    }
}
pub enum clz_Torappu_BuildingData_FurnitureLODConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_FurnitureLODConfig<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_FurnitureLODConfig<'a> {
    type Inner = clz_Torappu_BuildingData_FurnitureLODConfig<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_BuildingData_FurnitureLODConfig<'a> {
    pub const VT_SHOWEDOBJNAMES: flatbuffers::VOffsetT = 4;
    pub const VT_ISOVERWRITE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_FurnitureLODConfig { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_FurnitureLODConfigArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_FurnitureLODConfig<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_FurnitureLODConfigBuilder::new(_fbb);
        if let Some(x) = args.showedObjNames {
            builder.add_showedObjNames(x);
        }
        builder.add_isOverWrite(args.isOverWrite);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_BuildingData_FurnitureLODConfigT {
        let showedObjNames = self
            .showedObjNames()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let isOverWrite = self.isOverWrite();
        clz_Torappu_BuildingData_FurnitureLODConfigT {
            showedObjNames,
            isOverWrite,
        }
    }

    #[inline]
    pub fn showedObjNames(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__enum__Torappu_BuildingData_LODLEVEL__list_string<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__enum__Torappu_BuildingData_LODLEVEL__list_string,
                    >,
                >,
            >>(
                clz_Torappu_BuildingData_FurnitureLODConfig::VT_SHOWEDOBJNAMES,
                None,
            )
        }
    }
    #[inline]
    pub fn isOverWrite(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_BuildingData_FurnitureLODConfig::VT_ISOVERWRITE,
                    Some(false),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_FurnitureLODConfig<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__enum__Torappu_BuildingData_LODLEVEL__list_string,
                    >,
                >,
            >>("showedObjNames", Self::VT_SHOWEDOBJNAMES, false)?
            .visit_field::<bool>("isOverWrite", Self::VT_ISOVERWRITE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_FurnitureLODConfigArgs<'a> {
    pub showedObjNames: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_BuildingData_LODLEVEL__list_string<'a>,
                >,
            >,
        >,
    >,
    pub isOverWrite: bool,
}
impl<'a> Default for clz_Torappu_BuildingData_FurnitureLODConfigArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_FurnitureLODConfigArgs {
            showedObjNames: None,
            isOverWrite: false,
        }
    }
}

impl Serialize for clz_Torappu_BuildingData_FurnitureLODConfig<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_BuildingData_FurnitureLODConfig", 2)?;
        if let Some(f) = self.showedObjNames() {
            s.serialize_field("showedObjNames", &f)?;
        } else {
            s.skip_field("showedObjNames")?;
        }
        s.serialize_field("isOverWrite", &self.isOverWrite())?;
        s.end()
    }
}

pub struct clz_Torappu_BuildingData_FurnitureLODConfigBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_FurnitureLODConfigBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_showedObjNames(
        &mut self,
        showedObjNames: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_BuildingData_LODLEVEL__list_string<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_FurnitureLODConfig::VT_SHOWEDOBJNAMES,
            showedObjNames,
        );
    }
    #[inline]
    pub fn add_isOverWrite(&mut self, isOverWrite: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_BuildingData_FurnitureLODConfig::VT_ISOVERWRITE,
            isOverWrite,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_FurnitureLODConfigBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_FurnitureLODConfigBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_FurnitureLODConfig<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_FurnitureLODConfig<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_FurnitureLODConfig");
        ds.field("showedObjNames", &self.showedObjNames());
        ds.field("isOverWrite", &self.isOverWrite());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_BuildingData_FurnitureLODConfigT {
    pub showedObjNames: Option<Vec<dict__enum__Torappu_BuildingData_LODLEVEL__list_stringT>>,
    pub isOverWrite: bool,
}
impl Default for clz_Torappu_BuildingData_FurnitureLODConfigT {
    fn default() -> Self {
        Self {
            showedObjNames: None,
            isOverWrite: false,
        }
    }
}
impl clz_Torappu_BuildingData_FurnitureLODConfigT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_FurnitureLODConfig<'b>> {
        let showedObjNames = self.showedObjNames.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let isOverWrite = self.isOverWrite;
        clz_Torappu_BuildingData_FurnitureLODConfig::create(
            _fbb,
            &clz_Torappu_BuildingData_FurnitureLODConfigArgs {
                showedObjNames,
                isOverWrite,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_BuildingData_FurnitureLODConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_FurnitureLODConfig<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_BuildingData_FurnitureLODConfig<'a> {
    type Inner = dict__string__clz_Torappu_BuildingData_FurnitureLODConfig<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_FurnitureLODConfig<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_FurnitureLODConfig { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_FurnitureLODConfigArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_FurnitureLODConfig<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_BuildingData_FurnitureLODConfigBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_BuildingData_FurnitureLODConfigT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_BuildingData_FurnitureLODConfigT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BuildingData_FurnitureLODConfig::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_FurnitureLODConfig,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_FurnitureLODConfig<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_FurnitureLODConfig>>(
                    dict__string__clz_Torappu_BuildingData_FurnitureLODConfig::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_BuildingData_FurnitureLODConfig<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_FurnitureLODConfig>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_FurnitureLODConfigArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_FurnitureLODConfig<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BuildingData_FurnitureLODConfigArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_FurnitureLODConfigArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_BuildingData_FurnitureLODConfig<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_BuildingData_FurnitureLODConfig",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_BuildingData_FurnitureLODConfigBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_FurnitureLODConfigBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuildingData_FurnitureLODConfig::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_FurnitureLODConfig<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_FurnitureLODConfig>>(dict__string__clz_Torappu_BuildingData_FurnitureLODConfig::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuildingData_FurnitureLODConfigBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_FurnitureLODConfigBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_FurnitureLODConfig<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_BuildingData_FurnitureLODConfig::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BuildingData_FurnitureLODConfig<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_BuildingData_FurnitureLODConfig");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_BuildingData_FurnitureLODConfigT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_BuildingData_FurnitureLODConfigT>>,
}
impl Default for dict__string__clz_Torappu_BuildingData_FurnitureLODConfigT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_BuildingData_FurnitureLODConfigT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_FurnitureLODConfig<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_BuildingData_FurnitureLODConfig::create(
            _fbb,
            &dict__string__clz_Torappu_BuildingData_FurnitureLODConfigArgs { key, value },
        )
    }
}
pub enum clz_Torappu_BuildingData_BuildingLocalDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_BuildingLocalData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_BuildingLocalData<'a> {
    type Inner = clz_Torappu_BuildingData_BuildingLocalData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_BuildingData_BuildingLocalData<'a> {
    pub const VT_FURNITUREOBSTACLEDATA: flatbuffers::VOffsetT = 4;
    pub const VT_ROOMOBSTACLEDATA: flatbuffers::VOffsetT = 6;
    pub const VT_FURNITURELODCONFIG: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_BuildingLocalData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_BuildingLocalDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingLocalData<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_BuildingLocalDataBuilder::new(_fbb);
        if let Some(x) = args.furnitureLODConfig {
            builder.add_furnitureLODConfig(x);
        }
        if let Some(x) = args.roomObstacleData {
            builder.add_roomObstacleData(x);
        }
        if let Some(x) = args.furnitureObstacleData {
            builder.add_furnitureObstacleData(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_BuildingData_BuildingLocalDataT {
        let furnitureObstacleData = self
            .furnitureObstacleData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let roomObstacleData = self
            .roomObstacleData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let furnitureLODConfig = self
            .furnitureLODConfig()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_BuildingData_BuildingLocalDataT {
            furnitureObstacleData,
            roomObstacleData,
            furnitureLODConfig,
        }
    }

    #[inline]
    pub fn furnitureObstacleData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_ObstacleData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_ObstacleData,
                    >,
                >,
            >>(
                clz_Torappu_BuildingData_BuildingLocalData::VT_FURNITUREOBSTACLEDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn roomObstacleData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_ObstacleData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_ObstacleData,
                    >,
                >,
            >>(
                clz_Torappu_BuildingData_BuildingLocalData::VT_ROOMOBSTACLEDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn furnitureLODConfig(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_BuildingData_FurnitureLODConfig<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_FurnitureLODConfig,
                    >,
                >,
            >>(
                clz_Torappu_BuildingData_BuildingLocalData::VT_FURNITURELODCONFIG,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_BuildingLocalData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_ObstacleData,
                    >,
                >,
            >>(
                "furnitureObstacleData",
                Self::VT_FURNITUREOBSTACLEDATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_ObstacleData,
                    >,
                >,
            >>("roomObstacleData", Self::VT_ROOMOBSTACLEDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_FurnitureLODConfig,
                    >,
                >,
            >>("furnitureLODConfig", Self::VT_FURNITURELODCONFIG, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_BuildingLocalDataArgs<'a> {
    pub furnitureObstacleData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_ObstacleData<'a>,
                >,
            >,
        >,
    >,
    pub roomObstacleData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_ObstacleData<'a>,
                >,
            >,
        >,
    >,
    pub furnitureLODConfig: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_FurnitureLODConfig<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_BuildingLocalDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_BuildingLocalDataArgs {
            furnitureObstacleData: None,
            roomObstacleData: None,
            furnitureLODConfig: None,
        }
    }
}

impl Serialize for clz_Torappu_BuildingData_BuildingLocalData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_BuildingData_BuildingLocalData", 3)?;
        if let Some(f) = self.furnitureObstacleData() {
            s.serialize_field("furnitureObstacleData", &f)?;
        } else {
            s.skip_field("furnitureObstacleData")?;
        }
        if let Some(f) = self.roomObstacleData() {
            s.serialize_field("roomObstacleData", &f)?;
        } else {
            s.skip_field("roomObstacleData")?;
        }
        if let Some(f) = self.furnitureLODConfig() {
            s.serialize_field("furnitureLODConfig", &f)?;
        } else {
            s.skip_field("furnitureLODConfig")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_BuildingData_BuildingLocalDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_BuildingLocalDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_furnitureObstacleData(
        &mut self,
        furnitureObstacleData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_ObstacleData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_BuildingLocalData::VT_FURNITUREOBSTACLEDATA,
            furnitureObstacleData,
        );
    }
    #[inline]
    pub fn add_roomObstacleData(
        &mut self,
        roomObstacleData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_ObstacleData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_BuildingLocalData::VT_ROOMOBSTACLEDATA,
            roomObstacleData,
        );
    }
    #[inline]
    pub fn add_furnitureLODConfig(
        &mut self,
        furnitureLODConfig: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_FurnitureLODConfig<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_BuildingLocalData::VT_FURNITURELODCONFIG,
            furnitureLODConfig,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_BuildingLocalDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_BuildingLocalDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingLocalData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_BuildingLocalData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_BuildingLocalData");
        ds.field("furnitureObstacleData", &self.furnitureObstacleData());
        ds.field("roomObstacleData", &self.roomObstacleData());
        ds.field("furnitureLODConfig", &self.furnitureLODConfig());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_BuildingData_BuildingLocalDataT {
    pub furnitureObstacleData: Option<Vec<dict__string__clz_Torappu_BuildingData_ObstacleDataT>>,
    pub roomObstacleData: Option<Vec<dict__string__clz_Torappu_BuildingData_ObstacleDataT>>,
    pub furnitureLODConfig: Option<Vec<dict__string__clz_Torappu_BuildingData_FurnitureLODConfigT>>,
}
impl Default for clz_Torappu_BuildingData_BuildingLocalDataT {
    fn default() -> Self {
        Self {
            furnitureObstacleData: None,
            roomObstacleData: None,
            furnitureLODConfig: None,
        }
    }
}
impl clz_Torappu_BuildingData_BuildingLocalDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingLocalData<'b>> {
        let furnitureObstacleData = self.furnitureObstacleData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let roomObstacleData = self.roomObstacleData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let furnitureLODConfig = self.furnitureLODConfig.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_BuildingData_BuildingLocalData::create(
            _fbb,
            &clz_Torappu_BuildingData_BuildingLocalDataArgs {
                furnitureObstacleData,
                roomObstacleData,
                furnitureLODConfig,
            },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_BuildingData_BuildingLocalData`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_building_data_building_local_data_unchecked`.
pub fn root_as_clz_torappu_building_data_building_local_data(
    buf: &[u8],
) -> Result<clz_Torappu_BuildingData_BuildingLocalData<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_BuildingData_BuildingLocalData>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_BuildingData_BuildingLocalData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_building_data_building_local_data_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_building_data_building_local_data(
    buf: &[u8],
) -> Result<clz_Torappu_BuildingData_BuildingLocalData<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_BuildingData_BuildingLocalData>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_BuildingData_BuildingLocalData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_building_data_building_local_data_unchecked`.
pub fn root_as_clz_torappu_building_data_building_local_data_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_BuildingData_BuildingLocalData<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_BuildingData_BuildingLocalData<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_BuildingData_BuildingLocalData` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_building_data_building_local_data_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_building_data_building_local_data_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_BuildingData_BuildingLocalData<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_BuildingData_BuildingLocalData<'b>>(
        opts, buf,
    )
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_BuildingData_BuildingLocalData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_BuildingData_BuildingLocalData`.
pub unsafe fn root_as_clz_torappu_building_data_building_local_data_unchecked(
    buf: &[u8],
) -> clz_Torappu_BuildingData_BuildingLocalData<'_> {
    unsafe { flatbuffers::root_unchecked::<clz_Torappu_BuildingData_BuildingLocalData>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_BuildingData_BuildingLocalData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_BuildingData_BuildingLocalData`.
pub unsafe fn size_prefixed_root_as_clz_torappu_building_data_building_local_data_unchecked(
    buf: &[u8],
) -> clz_Torappu_BuildingData_BuildingLocalData<'_> {
    unsafe {
        flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_BuildingData_BuildingLocalData>(buf)
    }
}
#[inline]
pub fn finish_clz_torappu_building_data_building_local_data_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingLocalData<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_building_data_building_local_data_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingLocalData<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
