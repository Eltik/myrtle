// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_CHAR_WORD_VOICE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_CHAR_WORD_VOICE_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_CHAR_WORD_VOICE_TYPE: [enum__Torappu_CharWordVoiceType; 3] = [
    enum__Torappu_CharWordVoiceType::ONLY_TEXT,
    enum__Torappu_CharWordVoiceType::HAVE_CV,
    enum__Torappu_CharWordVoiceType::ENUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_CharWordVoiceType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_CharWordVoiceType {
    pub const ONLY_TEXT: Self = Self(0);
    pub const HAVE_CV: Self = Self(1);
    pub const ENUM: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::ONLY_TEXT, Self::HAVE_CV, Self::ENUM];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ONLY_TEXT => Some("ONLY_TEXT"),
            Self::HAVE_CV => Some("HAVE_CV"),
            Self::ENUM => Some("ENUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_CharWordVoiceType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_CharWordVoiceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_CharWordVoiceType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_CharWordVoiceType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_CharWordVoiceType {
    type Output = enum__Torappu_CharWordVoiceType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_CharWordVoiceType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_CharWordVoiceType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_CharWordVoiceType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_DATA_UNLOCK_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_DATA_UNLOCK_TYPE: i32 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_DATA_UNLOCK_TYPE: [enum__Torappu_DataUnlockType; 8] = [
    enum__Torappu_DataUnlockType::DIRECT,
    enum__Torappu_DataUnlockType::AWAKE,
    enum__Torappu_DataUnlockType::FAVOR,
    enum__Torappu_DataUnlockType::STAGE,
    enum__Torappu_DataUnlockType::ITEM,
    enum__Torappu_DataUnlockType::NEVER,
    enum__Torappu_DataUnlockType::PATCH,
    enum__Torappu_DataUnlockType::NONE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_DataUnlockType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_DataUnlockType {
    pub const DIRECT: Self = Self(0);
    pub const AWAKE: Self = Self(1);
    pub const FAVOR: Self = Self(2);
    pub const STAGE: Self = Self(3);
    pub const ITEM: Self = Self(4);
    pub const NEVER: Self = Self(5);
    pub const PATCH: Self = Self(6);
    pub const NONE: Self = Self(7);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 7;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::DIRECT,
        Self::AWAKE,
        Self::FAVOR,
        Self::STAGE,
        Self::ITEM,
        Self::NEVER,
        Self::PATCH,
        Self::NONE,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::DIRECT => Some("DIRECT"),
            Self::AWAKE => Some("AWAKE"),
            Self::FAVOR => Some("FAVOR"),
            Self::STAGE => Some("STAGE"),
            Self::ITEM => Some("ITEM"),
            Self::NEVER => Some("NEVER"),
            Self::PATCH => Some("PATCH"),
            Self::NONE => Some("NONE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_DataUnlockType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_DataUnlockType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_DataUnlockType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_DataUnlockType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_DataUnlockType {
    type Output = enum__Torappu_DataUnlockType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_DataUnlockType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_DataUnlockType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_DataUnlockType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_CHAR_WORD_SHOW_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_CHAR_WORD_SHOW_TYPE: i32 = 35;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_CHAR_WORD_SHOW_TYPE: [enum__Torappu_CharWordShowType; 36] = [
    enum__Torappu_CharWordShowType::HOME_SHOW,
    enum__Torappu_CharWordShowType::HOME_PLACE,
    enum__Torappu_CharWordShowType::HOME_WAIT,
    enum__Torappu_CharWordShowType::GACHA,
    enum__Torappu_CharWordShowType::EVOLVE_ONE,
    enum__Torappu_CharWordShowType::EVOLVE_TWO,
    enum__Torappu_CharWordShowType::FOUR_STAR,
    enum__Torappu_CharWordShowType::THREE_STAR,
    enum__Torappu_CharWordShowType::TWO_STAR,
    enum__Torappu_CharWordShowType::LOSE,
    enum__Torappu_CharWordShowType::LEVEL_UP,
    enum__Torappu_CharWordShowType::SQUAD,
    enum__Torappu_CharWordShowType::SQUAD_FIRST,
    enum__Torappu_CharWordShowType::BATTLE_START,
    enum__Torappu_CharWordShowType::BATTLE_FACE_ENEMY,
    enum__Torappu_CharWordShowType::BATTLE_SELECT,
    enum__Torappu_CharWordShowType::BATTLE_PLACE,
    enum__Torappu_CharWordShowType::BATTLE_SKILL_1,
    enum__Torappu_CharWordShowType::BATTLE_SKILL_2,
    enum__Torappu_CharWordShowType::BATTLE_SKILL_3,
    enum__Torappu_CharWordShowType::BATTLE_SKILL_4,
    enum__Torappu_CharWordShowType::BUILDING_PLACE,
    enum__Torappu_CharWordShowType::BUILDING_DRAGGING,
    enum__Torappu_CharWordShowType::BUILDING_FAVOR_BUBBLE,
    enum__Torappu_CharWordShowType::BUILDING_TOUCHING,
    enum__Torappu_CharWordShowType::LOADING_PANEL,
    enum__Torappu_CharWordShowType::BIRTHDAY,
    enum__Torappu_CharWordShowType::NEW_YEAR,
    enum__Torappu_CharWordShowType::VALENT_DAY,
    enum__Torappu_CharWordShowType::DRAGON_BOAT_FESTIVAL,
    enum__Torappu_CharWordShowType::HALLOWEEN_DAY,
    enum__Torappu_CharWordShowType::CHRISMATS_DAY,
    enum__Torappu_CharWordShowType::GREETING,
    enum__Torappu_CharWordShowType::ANNIVERSARY,
    enum__Torappu_CharWordShowType::UNUSED,
    enum__Torappu_CharWordShowType::E_ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_CharWordShowType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_CharWordShowType {
    pub const HOME_SHOW: Self = Self(0);
    pub const HOME_PLACE: Self = Self(1);
    pub const HOME_WAIT: Self = Self(2);
    pub const GACHA: Self = Self(3);
    pub const EVOLVE_ONE: Self = Self(4);
    pub const EVOLVE_TWO: Self = Self(5);
    pub const FOUR_STAR: Self = Self(6);
    pub const THREE_STAR: Self = Self(7);
    pub const TWO_STAR: Self = Self(8);
    pub const LOSE: Self = Self(9);
    pub const LEVEL_UP: Self = Self(10);
    pub const SQUAD: Self = Self(11);
    pub const SQUAD_FIRST: Self = Self(12);
    pub const BATTLE_START: Self = Self(13);
    pub const BATTLE_FACE_ENEMY: Self = Self(14);
    pub const BATTLE_SELECT: Self = Self(15);
    pub const BATTLE_PLACE: Self = Self(16);
    pub const BATTLE_SKILL_1: Self = Self(17);
    pub const BATTLE_SKILL_2: Self = Self(18);
    pub const BATTLE_SKILL_3: Self = Self(19);
    pub const BATTLE_SKILL_4: Self = Self(20);
    pub const BUILDING_PLACE: Self = Self(21);
    pub const BUILDING_DRAGGING: Self = Self(22);
    pub const BUILDING_FAVOR_BUBBLE: Self = Self(23);
    pub const BUILDING_TOUCHING: Self = Self(24);
    pub const LOADING_PANEL: Self = Self(25);
    pub const BIRTHDAY: Self = Self(26);
    pub const NEW_YEAR: Self = Self(27);
    pub const VALENT_DAY: Self = Self(28);
    pub const DRAGON_BOAT_FESTIVAL: Self = Self(29);
    pub const HALLOWEEN_DAY: Self = Self(30);
    pub const CHRISMATS_DAY: Self = Self(31);
    pub const GREETING: Self = Self(32);
    pub const ANNIVERSARY: Self = Self(33);
    pub const UNUSED: Self = Self(34);
    pub const E_ALL: Self = Self(35);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 35;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::HOME_SHOW,
        Self::HOME_PLACE,
        Self::HOME_WAIT,
        Self::GACHA,
        Self::EVOLVE_ONE,
        Self::EVOLVE_TWO,
        Self::FOUR_STAR,
        Self::THREE_STAR,
        Self::TWO_STAR,
        Self::LOSE,
        Self::LEVEL_UP,
        Self::SQUAD,
        Self::SQUAD_FIRST,
        Self::BATTLE_START,
        Self::BATTLE_FACE_ENEMY,
        Self::BATTLE_SELECT,
        Self::BATTLE_PLACE,
        Self::BATTLE_SKILL_1,
        Self::BATTLE_SKILL_2,
        Self::BATTLE_SKILL_3,
        Self::BATTLE_SKILL_4,
        Self::BUILDING_PLACE,
        Self::BUILDING_DRAGGING,
        Self::BUILDING_FAVOR_BUBBLE,
        Self::BUILDING_TOUCHING,
        Self::LOADING_PANEL,
        Self::BIRTHDAY,
        Self::NEW_YEAR,
        Self::VALENT_DAY,
        Self::DRAGON_BOAT_FESTIVAL,
        Self::HALLOWEEN_DAY,
        Self::CHRISMATS_DAY,
        Self::GREETING,
        Self::ANNIVERSARY,
        Self::UNUSED,
        Self::E_ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::HOME_SHOW => Some("HOME_SHOW"),
            Self::HOME_PLACE => Some("HOME_PLACE"),
            Self::HOME_WAIT => Some("HOME_WAIT"),
            Self::GACHA => Some("GACHA"),
            Self::EVOLVE_ONE => Some("EVOLVE_ONE"),
            Self::EVOLVE_TWO => Some("EVOLVE_TWO"),
            Self::FOUR_STAR => Some("FOUR_STAR"),
            Self::THREE_STAR => Some("THREE_STAR"),
            Self::TWO_STAR => Some("TWO_STAR"),
            Self::LOSE => Some("LOSE"),
            Self::LEVEL_UP => Some("LEVEL_UP"),
            Self::SQUAD => Some("SQUAD"),
            Self::SQUAD_FIRST => Some("SQUAD_FIRST"),
            Self::BATTLE_START => Some("BATTLE_START"),
            Self::BATTLE_FACE_ENEMY => Some("BATTLE_FACE_ENEMY"),
            Self::BATTLE_SELECT => Some("BATTLE_SELECT"),
            Self::BATTLE_PLACE => Some("BATTLE_PLACE"),
            Self::BATTLE_SKILL_1 => Some("BATTLE_SKILL_1"),
            Self::BATTLE_SKILL_2 => Some("BATTLE_SKILL_2"),
            Self::BATTLE_SKILL_3 => Some("BATTLE_SKILL_3"),
            Self::BATTLE_SKILL_4 => Some("BATTLE_SKILL_4"),
            Self::BUILDING_PLACE => Some("BUILDING_PLACE"),
            Self::BUILDING_DRAGGING => Some("BUILDING_DRAGGING"),
            Self::BUILDING_FAVOR_BUBBLE => Some("BUILDING_FAVOR_BUBBLE"),
            Self::BUILDING_TOUCHING => Some("BUILDING_TOUCHING"),
            Self::LOADING_PANEL => Some("LOADING_PANEL"),
            Self::BIRTHDAY => Some("BIRTHDAY"),
            Self::NEW_YEAR => Some("NEW_YEAR"),
            Self::VALENT_DAY => Some("VALENT_DAY"),
            Self::DRAGON_BOAT_FESTIVAL => Some("DRAGON_BOAT_FESTIVAL"),
            Self::HALLOWEEN_DAY => Some("HALLOWEEN_DAY"),
            Self::CHRISMATS_DAY => Some("CHRISMATS_DAY"),
            Self::GREETING => Some("GREETING"),
            Self::ANNIVERSARY => Some("ANNIVERSARY"),
            Self::UNUSED => Some("UNUSED"),
            Self::E_ALL => Some("E_ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_CharWordShowType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_CharWordShowType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_CharWordShowType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_CharWordShowType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_CharWordShowType {
    type Output = enum__Torappu_CharWordShowType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_CharWordShowType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_CharWordShowType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_CharWordShowType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_VOICE_LANG_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_VOICE_LANG_TYPE: i32 = 11;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_VOICE_LANG_TYPE: [enum__Torappu_VoiceLangType; 12] = [
    enum__Torappu_VoiceLangType::NONE,
    enum__Torappu_VoiceLangType::JP,
    enum__Torappu_VoiceLangType::CN_MANDARIN,
    enum__Torappu_VoiceLangType::EN,
    enum__Torappu_VoiceLangType::KR,
    enum__Torappu_VoiceLangType::CN_TOPOLECT,
    enum__Torappu_VoiceLangType::LINKAGE,
    enum__Torappu_VoiceLangType::ITA,
    enum__Torappu_VoiceLangType::GER,
    enum__Torappu_VoiceLangType::RUS,
    enum__Torappu_VoiceLangType::FRE,
    enum__Torappu_VoiceLangType::SPA,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_VoiceLangType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_VoiceLangType {
    pub const NONE: Self = Self(0);
    pub const JP: Self = Self(1);
    pub const CN_MANDARIN: Self = Self(2);
    pub const EN: Self = Self(3);
    pub const KR: Self = Self(4);
    pub const CN_TOPOLECT: Self = Self(5);
    pub const LINKAGE: Self = Self(6);
    pub const ITA: Self = Self(7);
    pub const GER: Self = Self(8);
    pub const RUS: Self = Self(9);
    pub const FRE: Self = Self(10);
    pub const SPA: Self = Self(11);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 11;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::JP,
        Self::CN_MANDARIN,
        Self::EN,
        Self::KR,
        Self::CN_TOPOLECT,
        Self::LINKAGE,
        Self::ITA,
        Self::GER,
        Self::RUS,
        Self::FRE,
        Self::SPA,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::JP => Some("JP"),
            Self::CN_MANDARIN => Some("CN_MANDARIN"),
            Self::EN => Some("EN"),
            Self::KR => Some("KR"),
            Self::CN_TOPOLECT => Some("CN_TOPOLECT"),
            Self::LINKAGE => Some("LINKAGE"),
            Self::ITA => Some("ITA"),
            Self::GER => Some("GER"),
            Self::RUS => Some("RUS"),
            Self::FRE => Some("FRE"),
            Self::SPA => Some("SPA"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_VoiceLangType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_VoiceLangType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_VoiceLangType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_VoiceLangType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_VoiceLangType {
    type Output = enum__Torappu_VoiceLangType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_VoiceLangType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_VoiceLangType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_VoiceLangType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_VOICE_LANG_GROUP_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_VOICE_LANG_GROUP_TYPE: i32 = 6;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_VOICE_LANG_GROUP_TYPE: [enum__Torappu_VoiceLangGroupType; 7] = [
    enum__Torappu_VoiceLangGroupType::NONE,
    enum__Torappu_VoiceLangGroupType::CN_MANDARIN,
    enum__Torappu_VoiceLangGroupType::JP,
    enum__Torappu_VoiceLangGroupType::EN,
    enum__Torappu_VoiceLangGroupType::KR,
    enum__Torappu_VoiceLangGroupType::CUSTOM,
    enum__Torappu_VoiceLangGroupType::LINKAGE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_VoiceLangGroupType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_VoiceLangGroupType {
    pub const NONE: Self = Self(0);
    pub const CN_MANDARIN: Self = Self(1);
    pub const JP: Self = Self(2);
    pub const EN: Self = Self(3);
    pub const KR: Self = Self(4);
    pub const CUSTOM: Self = Self(5);
    pub const LINKAGE: Self = Self(6);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 6;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::CN_MANDARIN,
        Self::JP,
        Self::EN,
        Self::KR,
        Self::CUSTOM,
        Self::LINKAGE,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::CN_MANDARIN => Some("CN_MANDARIN"),
            Self::JP => Some("JP"),
            Self::EN => Some("EN"),
            Self::KR => Some("KR"),
            Self::CUSTOM => Some("CUSTOM"),
            Self::LINKAGE => Some("LINKAGE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_VoiceLangGroupType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_VoiceLangGroupType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_VoiceLangGroupType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_VoiceLangGroupType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_VoiceLangGroupType {
    type Output = enum__Torappu_VoiceLangGroupType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_VoiceLangGroupType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_VoiceLangGroupType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_VoiceLangGroupType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_FESTIVAL_VOICE_TIME_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_FESTIVAL_VOICE_TIME_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_FESTIVAL_VOICE_TIME_TYPE:
    [enum__Torappu_FestivalVoiceTimeType; 3] = [
    enum__Torappu_FestivalVoiceTimeType::NONE,
    enum__Torappu_FestivalVoiceTimeType::FESTIVAL,
    enum__Torappu_FestivalVoiceTimeType::BIRTHDAY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_FestivalVoiceTimeType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_FestivalVoiceTimeType {
    pub const NONE: Self = Self(0);
    pub const FESTIVAL: Self = Self(1);
    pub const BIRTHDAY: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::FESTIVAL, Self::BIRTHDAY];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::FESTIVAL => Some("FESTIVAL"),
            Self::BIRTHDAY => Some("BIRTHDAY"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_FestivalVoiceTimeType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_FestivalVoiceTimeType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_FestivalVoiceTimeType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_FestivalVoiceTimeType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_FestivalVoiceTimeType {
    type Output = enum__Torappu_FestivalVoiceTimeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_FestivalVoiceTimeType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_FestivalVoiceTimeType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_FestivalVoiceTimeType {}
pub enum clz_Torappu_CharWordUnlockParamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharWordUnlockParam<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharWordUnlockParam<'a> {
    type Inner = clz_Torappu_CharWordUnlockParam<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharWordUnlockParam<'a> {
    pub const VT_VALUESTR: flatbuffers::VOffsetT = 4;
    pub const VT_VALUEINT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharWordUnlockParam { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharWordUnlockParamArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharWordUnlockParam<'bldr>> {
        let mut builder = clz_Torappu_CharWordUnlockParamBuilder::new(_fbb);
        builder.add_valueInt(args.valueInt);
        if let Some(x) = args.valueStr {
            builder.add_valueStr(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharWordUnlockParamT {
        let valueStr = self.valueStr().map(|x| x.to_string());
        let valueInt = self.valueInt();
        clz_Torappu_CharWordUnlockParamT { valueStr, valueInt }
    }

    #[inline]
    pub fn valueStr(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharWordUnlockParam::VT_VALUESTR,
                None,
            )
        }
    }
    #[inline]
    pub fn valueInt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CharWordUnlockParam::VT_VALUEINT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharWordUnlockParam<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "valueStr",
                Self::VT_VALUESTR,
                false,
            )?
            .visit_field::<i32>("valueInt", Self::VT_VALUEINT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharWordUnlockParamArgs<'a> {
    pub valueStr: Option<flatbuffers::WIPOffset<&'a str>>,
    pub valueInt: i32,
}
impl<'a> Default for clz_Torappu_CharWordUnlockParamArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharWordUnlockParamArgs {
            valueStr: None,
            valueInt: 0,
        }
    }
}

impl Serialize for clz_Torappu_CharWordUnlockParam<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharWordUnlockParam", 2)?;
        if let Some(f) = self.valueStr() {
            s.serialize_field("valueStr", &f)?;
        } else {
            s.skip_field("valueStr")?;
        }
        s.serialize_field("valueInt", &self.valueInt())?;
        s.end()
    }
}

pub struct clz_Torappu_CharWordUnlockParamBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_CharWordUnlockParamBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_valueStr(&mut self, valueStr: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordUnlockParam::VT_VALUESTR,
            valueStr,
        );
    }
    #[inline]
    pub fn add_valueInt(&mut self, valueInt: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_CharWordUnlockParam::VT_VALUEINT, valueInt, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharWordUnlockParamBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharWordUnlockParamBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharWordUnlockParam<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharWordUnlockParam<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharWordUnlockParam");
        ds.field("valueStr", &self.valueStr());
        ds.field("valueInt", &self.valueInt());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharWordUnlockParamT {
    pub valueStr: Option<String>,
    pub valueInt: i32,
}
impl Default for clz_Torappu_CharWordUnlockParamT {
    fn default() -> Self {
        Self {
            valueStr: None,
            valueInt: 0,
        }
    }
}
impl clz_Torappu_CharWordUnlockParamT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharWordUnlockParam<'b>> {
        let valueStr = self.valueStr.as_ref().map(|x| _fbb.create_string(x));
        let valueInt = self.valueInt;
        clz_Torappu_CharWordUnlockParam::create(
            _fbb,
            &clz_Torappu_CharWordUnlockParamArgs { valueStr, valueInt },
        )
    }
}
pub enum clz_Torappu_CharWordDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharWordData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharWordData<'a> {
    type Inner = clz_Torappu_CharWordData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharWordData<'a> {
    pub const VT_CHARWORDID: flatbuffers::VOffsetT = 4;
    pub const VT_WORDKEY: flatbuffers::VOffsetT = 6;
    pub const VT_CHARID: flatbuffers::VOffsetT = 8;
    pub const VT_VOICEID: flatbuffers::VOffsetT = 10;
    pub const VT_VOICETEXT: flatbuffers::VOffsetT = 12;
    pub const VT_VOICETITLE: flatbuffers::VOffsetT = 14;
    pub const VT_VOICEINDEX: flatbuffers::VOffsetT = 16;
    pub const VT_VOICETYPE: flatbuffers::VOffsetT = 18;
    pub const VT_UNLOCKTYPE: flatbuffers::VOffsetT = 20;
    pub const VT_UNLOCKPARAM: flatbuffers::VOffsetT = 22;
    pub const VT_LOCKDESCRIPTION: flatbuffers::VOffsetT = 24;
    pub const VT_PLACETYPE: flatbuffers::VOffsetT = 26;
    pub const VT_VOICEASSET: flatbuffers::VOffsetT = 28;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharWordData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharWordDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharWordData<'bldr>> {
        let mut builder = clz_Torappu_CharWordDataBuilder::new(_fbb);
        if let Some(x) = args.voiceAsset {
            builder.add_voiceAsset(x);
        }
        builder.add_placeType(args.placeType);
        if let Some(x) = args.lockDescription {
            builder.add_lockDescription(x);
        }
        if let Some(x) = args.unlockParam {
            builder.add_unlockParam(x);
        }
        builder.add_unlockType(args.unlockType);
        builder.add_voiceType(args.voiceType);
        builder.add_voiceIndex(args.voiceIndex);
        if let Some(x) = args.voiceTitle {
            builder.add_voiceTitle(x);
        }
        if let Some(x) = args.voiceText {
            builder.add_voiceText(x);
        }
        if let Some(x) = args.voiceId {
            builder.add_voiceId(x);
        }
        if let Some(x) = args.charId {
            builder.add_charId(x);
        }
        if let Some(x) = args.wordKey {
            builder.add_wordKey(x);
        }
        if let Some(x) = args.charWordId {
            builder.add_charWordId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharWordDataT {
        let charWordId = self.charWordId().map(|x| x.to_string());
        let wordKey = self.wordKey().map(|x| x.to_string());
        let charId = self.charId().map(|x| x.to_string());
        let voiceId = self.voiceId().map(|x| x.to_string());
        let voiceText = self.voiceText().map(|x| x.to_string());
        let voiceTitle = self.voiceTitle().map(|x| x.to_string());
        let voiceIndex = self.voiceIndex();
        let voiceType = self.voiceType();
        let unlockType = self.unlockType();
        let unlockParam = self
            .unlockParam()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let lockDescription = self.lockDescription().map(|x| x.to_string());
        let placeType = self.placeType();
        let voiceAsset = self.voiceAsset().map(|x| x.to_string());
        clz_Torappu_CharWordDataT {
            charWordId,
            wordKey,
            charId,
            voiceId,
            voiceText,
            voiceTitle,
            voiceIndex,
            voiceType,
            unlockType,
            unlockParam,
            lockDescription,
            placeType,
            voiceAsset,
        }
    }

    #[inline]
    pub fn charWordId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharWordData::VT_CHARWORDID,
                None,
            )
        }
    }
    #[inline]
    pub fn wordKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharWordData::VT_WORDKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn charId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharWordData::VT_CHARID,
                None,
            )
        }
    }
    #[inline]
    pub fn voiceId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharWordData::VT_VOICEID,
                None,
            )
        }
    }
    #[inline]
    pub fn voiceText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharWordData::VT_VOICETEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn voiceTitle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharWordData::VT_VOICETITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn voiceIndex(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CharWordData::VT_VOICEINDEX, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn voiceType(&self) -> enum__Torappu_CharWordVoiceType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_CharWordVoiceType>(
                    clz_Torappu_CharWordData::VT_VOICETYPE,
                    Some(enum__Torappu_CharWordVoiceType::ONLY_TEXT),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockType(&self) -> enum__Torappu_DataUnlockType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_DataUnlockType>(
                    clz_Torappu_CharWordData::VT_UNLOCKTYPE,
                    Some(enum__Torappu_DataUnlockType::DIRECT),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockParam(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_CharWordUnlockParam<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharWordUnlockParam>,
                >,
            >>(clz_Torappu_CharWordData::VT_UNLOCKPARAM, None)
        }
    }
    #[inline]
    pub fn lockDescription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharWordData::VT_LOCKDESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn placeType(&self) -> enum__Torappu_CharWordShowType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_CharWordShowType>(
                    clz_Torappu_CharWordData::VT_PLACETYPE,
                    Some(enum__Torappu_CharWordShowType::HOME_SHOW),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn voiceAsset(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharWordData::VT_VOICEASSET,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharWordData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "charWordId",
                Self::VT_CHARWORDID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("wordKey", Self::VT_WORDKEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("charId", Self::VT_CHARID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("voiceId", Self::VT_VOICEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "voiceText",
                Self::VT_VOICETEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "voiceTitle",
                Self::VT_VOICETITLE,
                false,
            )?
            .visit_field::<i32>("voiceIndex", Self::VT_VOICEINDEX, false)?
            .visit_field::<enum__Torappu_CharWordVoiceType>("voiceType", Self::VT_VOICETYPE, false)?
            .visit_field::<enum__Torappu_DataUnlockType>("unlockType", Self::VT_UNLOCKTYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharWordUnlockParam>,
                >,
            >>("unlockParam", Self::VT_UNLOCKPARAM, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "lockDescription",
                Self::VT_LOCKDESCRIPTION,
                false,
            )?
            .visit_field::<enum__Torappu_CharWordShowType>("placeType", Self::VT_PLACETYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "voiceAsset",
                Self::VT_VOICEASSET,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharWordDataArgs<'a> {
    pub charWordId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub wordKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub charId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub voiceId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub voiceText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub voiceTitle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub voiceIndex: i32,
    pub voiceType: enum__Torappu_CharWordVoiceType,
    pub unlockType: enum__Torappu_DataUnlockType,
    pub unlockParam: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharWordUnlockParam<'a>>,
            >,
        >,
    >,
    pub lockDescription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub placeType: enum__Torappu_CharWordShowType,
    pub voiceAsset: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_CharWordDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharWordDataArgs {
            charWordId: None,
            wordKey: None,
            charId: None,
            voiceId: None,
            voiceText: None,
            voiceTitle: None,
            voiceIndex: 0,
            voiceType: enum__Torappu_CharWordVoiceType::ONLY_TEXT,
            unlockType: enum__Torappu_DataUnlockType::DIRECT,
            unlockParam: None,
            lockDescription: None,
            placeType: enum__Torappu_CharWordShowType::HOME_SHOW,
            voiceAsset: None,
        }
    }
}

impl Serialize for clz_Torappu_CharWordData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharWordData", 13)?;
        if let Some(f) = self.charWordId() {
            s.serialize_field("charWordId", &f)?;
        } else {
            s.skip_field("charWordId")?;
        }
        if let Some(f) = self.wordKey() {
            s.serialize_field("wordKey", &f)?;
        } else {
            s.skip_field("wordKey")?;
        }
        if let Some(f) = self.charId() {
            s.serialize_field("charId", &f)?;
        } else {
            s.skip_field("charId")?;
        }
        if let Some(f) = self.voiceId() {
            s.serialize_field("voiceId", &f)?;
        } else {
            s.skip_field("voiceId")?;
        }
        if let Some(f) = self.voiceText() {
            s.serialize_field("voiceText", &f)?;
        } else {
            s.skip_field("voiceText")?;
        }
        if let Some(f) = self.voiceTitle() {
            s.serialize_field("voiceTitle", &f)?;
        } else {
            s.skip_field("voiceTitle")?;
        }
        s.serialize_field("voiceIndex", &self.voiceIndex())?;
        s.serialize_field("voiceType", &self.voiceType())?;
        s.serialize_field("unlockType", &self.unlockType())?;
        if let Some(f) = self.unlockParam() {
            s.serialize_field("unlockParam", &f)?;
        } else {
            s.skip_field("unlockParam")?;
        }
        if let Some(f) = self.lockDescription() {
            s.serialize_field("lockDescription", &f)?;
        } else {
            s.skip_field("lockDescription")?;
        }
        s.serialize_field("placeType", &self.placeType())?;
        if let Some(f) = self.voiceAsset() {
            s.serialize_field("voiceAsset", &f)?;
        } else {
            s.skip_field("voiceAsset")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CharWordDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_CharWordDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_charWordId(&mut self, charWordId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordData::VT_CHARWORDID,
            charWordId,
        );
    }
    #[inline]
    pub fn add_wordKey(&mut self, wordKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordData::VT_WORDKEY,
            wordKey,
        );
    }
    #[inline]
    pub fn add_charId(&mut self, charId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordData::VT_CHARID,
            charId,
        );
    }
    #[inline]
    pub fn add_voiceId(&mut self, voiceId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordData::VT_VOICEID,
            voiceId,
        );
    }
    #[inline]
    pub fn add_voiceText(&mut self, voiceText: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordData::VT_VOICETEXT,
            voiceText,
        );
    }
    #[inline]
    pub fn add_voiceTitle(&mut self, voiceTitle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordData::VT_VOICETITLE,
            voiceTitle,
        );
    }
    #[inline]
    pub fn add_voiceIndex(&mut self, voiceIndex: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_CharWordData::VT_VOICEINDEX, voiceIndex, 0);
    }
    #[inline]
    pub fn add_voiceType(&mut self, voiceType: enum__Torappu_CharWordVoiceType) {
        self.fbb_.push_slot::<enum__Torappu_CharWordVoiceType>(
            clz_Torappu_CharWordData::VT_VOICETYPE,
            voiceType,
            enum__Torappu_CharWordVoiceType::ONLY_TEXT,
        );
    }
    #[inline]
    pub fn add_unlockType(&mut self, unlockType: enum__Torappu_DataUnlockType) {
        self.fbb_.push_slot::<enum__Torappu_DataUnlockType>(
            clz_Torappu_CharWordData::VT_UNLOCKTYPE,
            unlockType,
            enum__Torappu_DataUnlockType::DIRECT,
        );
    }
    #[inline]
    pub fn add_unlockParam(
        &mut self,
        unlockParam: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharWordUnlockParam<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordData::VT_UNLOCKPARAM,
            unlockParam,
        );
    }
    #[inline]
    pub fn add_lockDescription(&mut self, lockDescription: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordData::VT_LOCKDESCRIPTION,
            lockDescription,
        );
    }
    #[inline]
    pub fn add_placeType(&mut self, placeType: enum__Torappu_CharWordShowType) {
        self.fbb_.push_slot::<enum__Torappu_CharWordShowType>(
            clz_Torappu_CharWordData::VT_PLACETYPE,
            placeType,
            enum__Torappu_CharWordShowType::HOME_SHOW,
        );
    }
    #[inline]
    pub fn add_voiceAsset(&mut self, voiceAsset: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordData::VT_VOICEASSET,
            voiceAsset,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharWordDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharWordDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharWordData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharWordData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharWordData");
        ds.field("charWordId", &self.charWordId());
        ds.field("wordKey", &self.wordKey());
        ds.field("charId", &self.charId());
        ds.field("voiceId", &self.voiceId());
        ds.field("voiceText", &self.voiceText());
        ds.field("voiceTitle", &self.voiceTitle());
        ds.field("voiceIndex", &self.voiceIndex());
        ds.field("voiceType", &self.voiceType());
        ds.field("unlockType", &self.unlockType());
        ds.field("unlockParam", &self.unlockParam());
        ds.field("lockDescription", &self.lockDescription());
        ds.field("placeType", &self.placeType());
        ds.field("voiceAsset", &self.voiceAsset());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharWordDataT {
    pub charWordId: Option<String>,
    pub wordKey: Option<String>,
    pub charId: Option<String>,
    pub voiceId: Option<String>,
    pub voiceText: Option<String>,
    pub voiceTitle: Option<String>,
    pub voiceIndex: i32,
    pub voiceType: enum__Torappu_CharWordVoiceType,
    pub unlockType: enum__Torappu_DataUnlockType,
    pub unlockParam: Option<Vec<clz_Torappu_CharWordUnlockParamT>>,
    pub lockDescription: Option<String>,
    pub placeType: enum__Torappu_CharWordShowType,
    pub voiceAsset: Option<String>,
}
impl Default for clz_Torappu_CharWordDataT {
    fn default() -> Self {
        Self {
            charWordId: None,
            wordKey: None,
            charId: None,
            voiceId: None,
            voiceText: None,
            voiceTitle: None,
            voiceIndex: 0,
            voiceType: enum__Torappu_CharWordVoiceType::ONLY_TEXT,
            unlockType: enum__Torappu_DataUnlockType::DIRECT,
            unlockParam: None,
            lockDescription: None,
            placeType: enum__Torappu_CharWordShowType::HOME_SHOW,
            voiceAsset: None,
        }
    }
}
impl clz_Torappu_CharWordDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharWordData<'b>> {
        let charWordId = self.charWordId.as_ref().map(|x| _fbb.create_string(x));
        let wordKey = self.wordKey.as_ref().map(|x| _fbb.create_string(x));
        let charId = self.charId.as_ref().map(|x| _fbb.create_string(x));
        let voiceId = self.voiceId.as_ref().map(|x| _fbb.create_string(x));
        let voiceText = self.voiceText.as_ref().map(|x| _fbb.create_string(x));
        let voiceTitle = self.voiceTitle.as_ref().map(|x| _fbb.create_string(x));
        let voiceIndex = self.voiceIndex;
        let voiceType = self.voiceType;
        let unlockType = self.unlockType;
        let unlockParam = self.unlockParam.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let lockDescription = self.lockDescription.as_ref().map(|x| _fbb.create_string(x));
        let placeType = self.placeType;
        let voiceAsset = self.voiceAsset.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_CharWordData::create(
            _fbb,
            &clz_Torappu_CharWordDataArgs {
                charWordId,
                wordKey,
                charId,
                voiceId,
                voiceText,
                voiceTitle,
                voiceIndex,
                voiceType,
                unlockType,
                unlockParam,
                lockDescription,
                placeType,
                voiceAsset,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_CharWordDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_CharWordData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_CharWordData<'a> {
    type Inner = dict__string__clz_Torappu_CharWordData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_CharWordData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_CharWordData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_CharWordDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharWordData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_CharWordDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_CharWordDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_CharWordDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_CharWordData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_CharWordData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_CharWordData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharWordData>>(
                    dict__string__clz_Torappu_CharWordData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_CharWordData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharWordData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_CharWordDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_CharWordData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_CharWordDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_CharWordDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_CharWordData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_CharWordData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_CharWordDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_CharWordDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_CharWordData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_CharWordData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharWordData>>(
                dict__string__clz_Torappu_CharWordData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_CharWordDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_CharWordDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharWordData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_CharWordData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_CharWordData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_CharWordData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_CharWordDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_CharWordDataT>>,
}
impl Default for dict__string__clz_Torappu_CharWordDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_CharWordDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharWordData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_CharWordData::create(
            _fbb,
            &dict__string__clz_Torappu_CharWordDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_CharExtraWordDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharExtraWordData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharExtraWordData<'a> {
    type Inner = clz_Torappu_CharExtraWordData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharExtraWordData<'a> {
    pub const VT_WORDKEY: flatbuffers::VOffsetT = 4;
    pub const VT_CHARID: flatbuffers::VOffsetT = 6;
    pub const VT_VOICEID: flatbuffers::VOffsetT = 8;
    pub const VT_VOICETEXT: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharExtraWordData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharExtraWordDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharExtraWordData<'bldr>> {
        let mut builder = clz_Torappu_CharExtraWordDataBuilder::new(_fbb);
        if let Some(x) = args.voiceText {
            builder.add_voiceText(x);
        }
        if let Some(x) = args.voiceId {
            builder.add_voiceId(x);
        }
        if let Some(x) = args.charId {
            builder.add_charId(x);
        }
        if let Some(x) = args.wordKey {
            builder.add_wordKey(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharExtraWordDataT {
        let wordKey = self.wordKey().map(|x| x.to_string());
        let charId = self.charId().map(|x| x.to_string());
        let voiceId = self.voiceId().map(|x| x.to_string());
        let voiceText = self.voiceText().map(|x| x.to_string());
        clz_Torappu_CharExtraWordDataT {
            wordKey,
            charId,
            voiceId,
            voiceText,
        }
    }

    #[inline]
    pub fn wordKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharExtraWordData::VT_WORDKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn charId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharExtraWordData::VT_CHARID,
                None,
            )
        }
    }
    #[inline]
    pub fn voiceId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharExtraWordData::VT_VOICEID,
                None,
            )
        }
    }
    #[inline]
    pub fn voiceText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharExtraWordData::VT_VOICETEXT,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharExtraWordData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("wordKey", Self::VT_WORDKEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("charId", Self::VT_CHARID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("voiceId", Self::VT_VOICEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "voiceText",
                Self::VT_VOICETEXT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharExtraWordDataArgs<'a> {
    pub wordKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub charId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub voiceId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub voiceText: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_CharExtraWordDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharExtraWordDataArgs {
            wordKey: None,
            charId: None,
            voiceId: None,
            voiceText: None,
        }
    }
}

impl Serialize for clz_Torappu_CharExtraWordData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharExtraWordData", 4)?;
        if let Some(f) = self.wordKey() {
            s.serialize_field("wordKey", &f)?;
        } else {
            s.skip_field("wordKey")?;
        }
        if let Some(f) = self.charId() {
            s.serialize_field("charId", &f)?;
        } else {
            s.skip_field("charId")?;
        }
        if let Some(f) = self.voiceId() {
            s.serialize_field("voiceId", &f)?;
        } else {
            s.skip_field("voiceId")?;
        }
        if let Some(f) = self.voiceText() {
            s.serialize_field("voiceText", &f)?;
        } else {
            s.skip_field("voiceText")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CharExtraWordDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_CharExtraWordDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_wordKey(&mut self, wordKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharExtraWordData::VT_WORDKEY,
            wordKey,
        );
    }
    #[inline]
    pub fn add_charId(&mut self, charId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharExtraWordData::VT_CHARID,
            charId,
        );
    }
    #[inline]
    pub fn add_voiceId(&mut self, voiceId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharExtraWordData::VT_VOICEID,
            voiceId,
        );
    }
    #[inline]
    pub fn add_voiceText(&mut self, voiceText: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharExtraWordData::VT_VOICETEXT,
            voiceText,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharExtraWordDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharExtraWordDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharExtraWordData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharExtraWordData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharExtraWordData");
        ds.field("wordKey", &self.wordKey());
        ds.field("charId", &self.charId());
        ds.field("voiceId", &self.voiceId());
        ds.field("voiceText", &self.voiceText());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharExtraWordDataT {
    pub wordKey: Option<String>,
    pub charId: Option<String>,
    pub voiceId: Option<String>,
    pub voiceText: Option<String>,
}
impl Default for clz_Torappu_CharExtraWordDataT {
    fn default() -> Self {
        Self {
            wordKey: None,
            charId: None,
            voiceId: None,
            voiceText: None,
        }
    }
}
impl clz_Torappu_CharExtraWordDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharExtraWordData<'b>> {
        let wordKey = self.wordKey.as_ref().map(|x| _fbb.create_string(x));
        let charId = self.charId.as_ref().map(|x| _fbb.create_string(x));
        let voiceId = self.voiceId.as_ref().map(|x| _fbb.create_string(x));
        let voiceText = self.voiceText.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_CharExtraWordData::create(
            _fbb,
            &clz_Torappu_CharExtraWordDataArgs {
                wordKey,
                charId,
                voiceId,
                voiceText,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_CharExtraWordDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_CharExtraWordData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_CharExtraWordData<'a> {
    type Inner = dict__string__clz_Torappu_CharExtraWordData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_CharExtraWordData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_CharExtraWordData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_CharExtraWordDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharExtraWordData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_CharExtraWordDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_CharExtraWordDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_CharExtraWordDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_CharExtraWordData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_CharExtraWordData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_CharExtraWordData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharExtraWordData>>(
                    dict__string__clz_Torappu_CharExtraWordData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_CharExtraWordData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharExtraWordData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_CharExtraWordDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_CharExtraWordData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_CharExtraWordDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_CharExtraWordDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_CharExtraWordData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_CharExtraWordData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_CharExtraWordDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_CharExtraWordDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_CharExtraWordData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_CharExtraWordData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharExtraWordData>>(
                dict__string__clz_Torappu_CharExtraWordData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_CharExtraWordDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_CharExtraWordDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharExtraWordData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_CharExtraWordData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_CharExtraWordData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_CharExtraWordData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_CharExtraWordDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_CharExtraWordDataT>>,
}
impl Default for dict__string__clz_Torappu_CharExtraWordDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_CharExtraWordDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharExtraWordData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_CharExtraWordData::create(
            _fbb,
            &dict__string__clz_Torappu_CharExtraWordDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_VoiceLangInfoDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_VoiceLangInfoData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_VoiceLangInfoData<'a> {
    type Inner = clz_Torappu_VoiceLangInfoData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_VoiceLangInfoData<'a> {
    pub const VT_WORDKEY: flatbuffers::VOffsetT = 4;
    pub const VT_VOICELANGTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_CVNAME: flatbuffers::VOffsetT = 8;
    pub const VT_VOICEPATH: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_VoiceLangInfoData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_VoiceLangInfoDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_VoiceLangInfoData<'bldr>> {
        let mut builder = clz_Torappu_VoiceLangInfoDataBuilder::new(_fbb);
        if let Some(x) = args.voicePath {
            builder.add_voicePath(x);
        }
        if let Some(x) = args.cvName {
            builder.add_cvName(x);
        }
        builder.add_voiceLangType(args.voiceLangType);
        if let Some(x) = args.wordkey {
            builder.add_wordkey(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_VoiceLangInfoDataT {
        let wordkey = self.wordkey().map(|x| x.to_string());
        let voiceLangType = self.voiceLangType();
        let cvName = self
            .cvName()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let voicePath = self.voicePath().map(|x| x.to_string());
        clz_Torappu_VoiceLangInfoDataT {
            wordkey,
            voiceLangType,
            cvName,
            voicePath,
        }
    }

    #[inline]
    pub fn wordkey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_VoiceLangInfoData::VT_WORDKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn voiceLangType(&self) -> enum__Torappu_VoiceLangType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_VoiceLangType>(
                    clz_Torappu_VoiceLangInfoData::VT_VOICELANGTYPE,
                    Some(enum__Torappu_VoiceLangType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn cvName(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_VoiceLangInfoData::VT_CVNAME, None)
        }
    }
    #[inline]
    pub fn voicePath(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_VoiceLangInfoData::VT_VOICEPATH,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_VoiceLangInfoData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("wordkey", Self::VT_WORDKEY, false)?
            .visit_field::<enum__Torappu_VoiceLangType>(
                "voiceLangType",
                Self::VT_VOICELANGTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("cvName", Self::VT_CVNAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "voicePath",
                Self::VT_VOICEPATH,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_VoiceLangInfoDataArgs<'a> {
    pub wordkey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub voiceLangType: enum__Torappu_VoiceLangType,
    pub cvName: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub voicePath: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_VoiceLangInfoDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_VoiceLangInfoDataArgs {
            wordkey: None,
            voiceLangType: enum__Torappu_VoiceLangType::NONE,
            cvName: None,
            voicePath: None,
        }
    }
}

impl Serialize for clz_Torappu_VoiceLangInfoData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_VoiceLangInfoData", 4)?;
        if let Some(f) = self.wordkey() {
            s.serialize_field("wordkey", &f)?;
        } else {
            s.skip_field("wordkey")?;
        }
        s.serialize_field("voiceLangType", &self.voiceLangType())?;
        if let Some(f) = self.cvName() {
            s.serialize_field("cvName", &f)?;
        } else {
            s.skip_field("cvName")?;
        }
        if let Some(f) = self.voicePath() {
            s.serialize_field("voicePath", &f)?;
        } else {
            s.skip_field("voicePath")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_VoiceLangInfoDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_VoiceLangInfoDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_wordkey(&mut self, wordkey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_VoiceLangInfoData::VT_WORDKEY,
            wordkey,
        );
    }
    #[inline]
    pub fn add_voiceLangType(&mut self, voiceLangType: enum__Torappu_VoiceLangType) {
        self.fbb_.push_slot::<enum__Torappu_VoiceLangType>(
            clz_Torappu_VoiceLangInfoData::VT_VOICELANGTYPE,
            voiceLangType,
            enum__Torappu_VoiceLangType::NONE,
        );
    }
    #[inline]
    pub fn add_cvName(
        &mut self,
        cvName: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_VoiceLangInfoData::VT_CVNAME,
            cvName,
        );
    }
    #[inline]
    pub fn add_voicePath(&mut self, voicePath: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_VoiceLangInfoData::VT_VOICEPATH,
            voicePath,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_VoiceLangInfoDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_VoiceLangInfoDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_VoiceLangInfoData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_VoiceLangInfoData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_VoiceLangInfoData");
        ds.field("wordkey", &self.wordkey());
        ds.field("voiceLangType", &self.voiceLangType());
        ds.field("cvName", &self.cvName());
        ds.field("voicePath", &self.voicePath());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_VoiceLangInfoDataT {
    pub wordkey: Option<String>,
    pub voiceLangType: enum__Torappu_VoiceLangType,
    pub cvName: Option<Vec<String>>,
    pub voicePath: Option<String>,
}
impl Default for clz_Torappu_VoiceLangInfoDataT {
    fn default() -> Self {
        Self {
            wordkey: None,
            voiceLangType: enum__Torappu_VoiceLangType::NONE,
            cvName: None,
            voicePath: None,
        }
    }
}
impl clz_Torappu_VoiceLangInfoDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_VoiceLangInfoData<'b>> {
        let wordkey = self.wordkey.as_ref().map(|x| _fbb.create_string(x));
        let voiceLangType = self.voiceLangType;
        let cvName = self.cvName.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let voicePath = self.voicePath.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_VoiceLangInfoData::create(
            _fbb,
            &clz_Torappu_VoiceLangInfoDataArgs {
                wordkey,
                voiceLangType,
                cvName,
                voicePath,
            },
        )
    }
}
pub enum dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData<'a>
{
    type Inner = dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData<'bldr>,
    > {
        let mut builder =
            dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoDataT {
        let key = self.key();
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_VoiceLangType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_VoiceLangType>(
                    dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData::VT_KEY,
                    Some(enum__Torappu_VoiceLangType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_VoiceLangType,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_VoiceLangInfoData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_VoiceLangInfoData>>(
                    dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_VoiceLangType>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_VoiceLangInfoData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoDataArgs<'a> {
    pub key: enum__Torappu_VoiceLangType,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_VoiceLangInfoData<'a>>>,
}
impl<'a> Default for dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoDataArgs {
            key: enum__Torappu_VoiceLangType::NONE,
            value: None,
        }
    }
}

impl Serialize for dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: enum__Torappu_VoiceLangType) {
        self.fbb_.push_slot::<enum__Torappu_VoiceLangType>(
            dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData::VT_KEY,
            key,
            enum__Torappu_VoiceLangType::NONE,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_VoiceLangInfoData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_VoiceLangInfoData>>(
                dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoDataT {
    pub key: enum__Torappu_VoiceLangType,
    pub value: Option<Box<clz_Torappu_VoiceLangInfoDataT>>,
}
impl Default for dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoDataT {
    fn default() -> Self {
        Self {
            key: enum__Torappu_VoiceLangType::NONE,
            value: None,
        }
    }
}
impl dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData<'b>>
    {
        let key = self.key;
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData::create(
            _fbb,
            &dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_VoiceLangDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_VoiceLangData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_VoiceLangData<'a> {
    type Inner = clz_Torappu_VoiceLangData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_VoiceLangData<'a> {
    pub const VT_WORDKEYS: flatbuffers::VOffsetT = 4;
    pub const VT_CHARID: flatbuffers::VOffsetT = 6;
    pub const VT_DICT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_VoiceLangData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_VoiceLangDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_VoiceLangData<'bldr>> {
        let mut builder = clz_Torappu_VoiceLangDataBuilder::new(_fbb);
        if let Some(x) = args.dict {
            builder.add_dict(x);
        }
        if let Some(x) = args.charId {
            builder.add_charId(x);
        }
        if let Some(x) = args.wordkeys {
            builder.add_wordkeys(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_VoiceLangDataT {
        let wordkeys = self
            .wordkeys()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let charId = self.charId().map(|x| x.to_string());
        let dict = self.dict().map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_VoiceLangDataT {
            wordkeys,
            charId,
            dict,
        }
    }

    #[inline]
    pub fn wordkeys(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_VoiceLangData::VT_WORDKEYS, None)
        }
    }
    #[inline]
    pub fn charId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_VoiceLangData::VT_CHARID,
                None,
            )
        }
    }
    #[inline]
    pub fn dict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData,
                    >,
                >,
            >>(clz_Torappu_VoiceLangData::VT_DICT, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_VoiceLangData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("wordkeys", Self::VT_WORDKEYS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("charId", Self::VT_CHARID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData,
                    >,
                >,
            >>("dict", Self::VT_DICT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_VoiceLangDataArgs<'a> {
    pub wordkeys: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub charId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_VoiceLangDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_VoiceLangDataArgs {
            wordkeys: None,
            charId: None,
            dict: None,
        }
    }
}

impl Serialize for clz_Torappu_VoiceLangData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_VoiceLangData", 3)?;
        if let Some(f) = self.wordkeys() {
            s.serialize_field("wordkeys", &f)?;
        } else {
            s.skip_field("wordkeys")?;
        }
        if let Some(f) = self.charId() {
            s.serialize_field("charId", &f)?;
        } else {
            s.skip_field("charId")?;
        }
        if let Some(f) = self.dict() {
            s.serialize_field("dict", &f)?;
        } else {
            s.skip_field("dict")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_VoiceLangDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_VoiceLangDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_wordkeys(
        &mut self,
        wordkeys: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_VoiceLangData::VT_WORDKEYS,
            wordkeys,
        );
    }
    #[inline]
    pub fn add_charId(&mut self, charId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_VoiceLangData::VT_CHARID,
            charId,
        );
    }
    #[inline]
    pub fn add_dict(
        &mut self,
        dict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_VoiceLangData::VT_DICT,
            dict,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_VoiceLangDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_VoiceLangDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_VoiceLangData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_VoiceLangData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_VoiceLangData");
        ds.field("wordkeys", &self.wordkeys());
        ds.field("charId", &self.charId());
        ds.field("dict", &self.dict());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_VoiceLangDataT {
    pub wordkeys: Option<Vec<String>>,
    pub charId: Option<String>,
    pub dict: Option<Vec<dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangInfoDataT>>,
}
impl Default for clz_Torappu_VoiceLangDataT {
    fn default() -> Self {
        Self {
            wordkeys: None,
            charId: None,
            dict: None,
        }
    }
}
impl clz_Torappu_VoiceLangDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_VoiceLangData<'b>> {
        let wordkeys = self.wordkeys.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let charId = self.charId.as_ref().map(|x| _fbb.create_string(x));
        let dict = self.dict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_VoiceLangData::create(
            _fbb,
            &clz_Torappu_VoiceLangDataArgs {
                wordkeys,
                charId,
                dict,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_VoiceLangDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_VoiceLangData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_VoiceLangData<'a> {
    type Inner = dict__string__clz_Torappu_VoiceLangData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_VoiceLangData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_VoiceLangData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_VoiceLangDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_VoiceLangData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_VoiceLangDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_VoiceLangDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_VoiceLangDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_VoiceLangData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_VoiceLangData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_VoiceLangData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_VoiceLangData>>(
                    dict__string__clz_Torappu_VoiceLangData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_VoiceLangData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_VoiceLangData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_VoiceLangDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_VoiceLangData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_VoiceLangDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_VoiceLangDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_VoiceLangData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_VoiceLangData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_VoiceLangDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_VoiceLangDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_VoiceLangData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_VoiceLangData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_VoiceLangData>>(
                dict__string__clz_Torappu_VoiceLangData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_VoiceLangDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_VoiceLangDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_VoiceLangData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_VoiceLangData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_VoiceLangData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_VoiceLangData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_VoiceLangDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_VoiceLangDataT>>,
}
impl Default for dict__string__clz_Torappu_VoiceLangDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_VoiceLangDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_VoiceLangData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_VoiceLangData::create(
            _fbb,
            &dict__string__clz_Torappu_VoiceLangDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_VoiceLangTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_VoiceLangTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_VoiceLangTypeData<'a> {
    type Inner = clz_Torappu_VoiceLangTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_VoiceLangTypeData<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_GROUPTYPE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_VoiceLangTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_VoiceLangTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_VoiceLangTypeData<'bldr>> {
        let mut builder = clz_Torappu_VoiceLangTypeDataBuilder::new(_fbb);
        builder.add_groupType(args.groupType);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_VoiceLangTypeDataT {
        let name = self.name().map(|x| x.to_string());
        let groupType = self.groupType();
        clz_Torappu_VoiceLangTypeDataT { name, groupType }
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_VoiceLangTypeData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn groupType(&self) -> enum__Torappu_VoiceLangGroupType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_VoiceLangGroupType>(
                    clz_Torappu_VoiceLangTypeData::VT_GROUPTYPE,
                    Some(enum__Torappu_VoiceLangGroupType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_VoiceLangTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<enum__Torappu_VoiceLangGroupType>(
                "groupType",
                Self::VT_GROUPTYPE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_VoiceLangTypeDataArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub groupType: enum__Torappu_VoiceLangGroupType,
}
impl<'a> Default for clz_Torappu_VoiceLangTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_VoiceLangTypeDataArgs {
            name: None,
            groupType: enum__Torappu_VoiceLangGroupType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_VoiceLangTypeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_VoiceLangTypeData", 2)?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        s.serialize_field("groupType", &self.groupType())?;
        s.end()
    }
}

pub struct clz_Torappu_VoiceLangTypeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_VoiceLangTypeDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_VoiceLangTypeData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_groupType(&mut self, groupType: enum__Torappu_VoiceLangGroupType) {
        self.fbb_.push_slot::<enum__Torappu_VoiceLangGroupType>(
            clz_Torappu_VoiceLangTypeData::VT_GROUPTYPE,
            groupType,
            enum__Torappu_VoiceLangGroupType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_VoiceLangTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_VoiceLangTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_VoiceLangTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_VoiceLangTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_VoiceLangTypeData");
        ds.field("name", &self.name());
        ds.field("groupType", &self.groupType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_VoiceLangTypeDataT {
    pub name: Option<String>,
    pub groupType: enum__Torappu_VoiceLangGroupType,
}
impl Default for clz_Torappu_VoiceLangTypeDataT {
    fn default() -> Self {
        Self {
            name: None,
            groupType: enum__Torappu_VoiceLangGroupType::NONE,
        }
    }
}
impl clz_Torappu_VoiceLangTypeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_VoiceLangTypeData<'b>> {
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let groupType = self.groupType;
        clz_Torappu_VoiceLangTypeData::create(
            _fbb,
            &clz_Torappu_VoiceLangTypeDataArgs { name, groupType },
        )
    }
}
pub enum dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData<'a>
{
    type Inner = dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData<'bldr>,
    > {
        let mut builder =
            dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeDataT {
        let key = self.key();
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_VoiceLangType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_VoiceLangType>(
                    dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData::VT_KEY,
                    Some(enum__Torappu_VoiceLangType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_VoiceLangType,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_VoiceLangTypeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_VoiceLangTypeData>>(
                    dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_VoiceLangType>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_VoiceLangTypeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeDataArgs<'a> {
    pub key: enum__Torappu_VoiceLangType,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_VoiceLangTypeData<'a>>>,
}
impl<'a> Default for dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeDataArgs {
            key: enum__Torappu_VoiceLangType::NONE,
            value: None,
        }
    }
}

impl Serialize for dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: enum__Torappu_VoiceLangType) {
        self.fbb_.push_slot::<enum__Torappu_VoiceLangType>(
            dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData::VT_KEY,
            key,
            enum__Torappu_VoiceLangType::NONE,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_VoiceLangTypeData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_VoiceLangTypeData>>(
                dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeDataT {
    pub key: enum__Torappu_VoiceLangType,
    pub value: Option<Box<clz_Torappu_VoiceLangTypeDataT>>,
}
impl Default for dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeDataT {
    fn default() -> Self {
        Self {
            key: enum__Torappu_VoiceLangType::NONE,
            value: None,
        }
    }
}
impl dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData<'b>>
    {
        let key = self.key;
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData::create(
            _fbb,
            &dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_VoiceLangGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_VoiceLangGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_VoiceLangGroupData<'a> {
    type Inner = clz_Torappu_VoiceLangGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_VoiceLangGroupData<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_MEMBERS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_VoiceLangGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_VoiceLangGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_VoiceLangGroupData<'bldr>> {
        let mut builder = clz_Torappu_VoiceLangGroupDataBuilder::new(_fbb);
        if let Some(x) = args.members {
            builder.add_members(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_VoiceLangGroupDataT {
        let name = self.name().map(|x| x.to_string());
        let members = self.members().map(|x| x.into_iter().collect());
        clz_Torappu_VoiceLangGroupDataT { name, members }
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_VoiceLangGroupData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn members(&self) -> Option<flatbuffers::Vector<'a, enum__Torappu_VoiceLangType>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_VoiceLangType>,
            >>(clz_Torappu_VoiceLangGroupData::VT_MEMBERS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_VoiceLangGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_VoiceLangType>>>("members", Self::VT_MEMBERS, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_VoiceLangGroupDataArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub members:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_VoiceLangType>>>,
}
impl<'a> Default for clz_Torappu_VoiceLangGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_VoiceLangGroupDataArgs {
            name: None,
            members: None,
        }
    }
}

impl Serialize for clz_Torappu_VoiceLangGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_VoiceLangGroupData", 2)?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.members() {
            s.serialize_field("members", &f)?;
        } else {
            s.skip_field("members")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_VoiceLangGroupDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_VoiceLangGroupDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_VoiceLangGroupData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_members(
        &mut self,
        members: flatbuffers::WIPOffset<flatbuffers::Vector<'b, enum__Torappu_VoiceLangType>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_VoiceLangGroupData::VT_MEMBERS,
            members,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_VoiceLangGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_VoiceLangGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_VoiceLangGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_VoiceLangGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_VoiceLangGroupData");
        ds.field("name", &self.name());
        ds.field("members", &self.members());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_VoiceLangGroupDataT {
    pub name: Option<String>,
    pub members: Option<Vec<enum__Torappu_VoiceLangType>>,
}
impl Default for clz_Torappu_VoiceLangGroupDataT {
    fn default() -> Self {
        Self {
            name: None,
            members: None,
        }
    }
}
impl clz_Torappu_VoiceLangGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_VoiceLangGroupData<'b>> {
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let members = self.members.as_ref().map(|x| _fbb.create_vector(x));
        clz_Torappu_VoiceLangGroupData::create(
            _fbb,
            &clz_Torappu_VoiceLangGroupDataArgs { name, members },
        )
    }
}
pub enum dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData<'a>
{
    type Inner = dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupDataArgs<
            'args,
        >,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData<'bldr>,
    > {
        let mut builder =
            dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupDataBuilder::new(
                _fbb,
            );
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(
        &self,
    ) -> dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupDataT {
        let key = self.key();
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_VoiceLangGroupType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_VoiceLangGroupType>(
                    dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData::VT_KEY,
                    Some(enum__Torappu_VoiceLangGroupType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_VoiceLangGroupType,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_VoiceLangGroupData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_VoiceLangGroupData>>(
                dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_VoiceLangGroupType>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_VoiceLangGroupData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupDataArgs<'a> {
    pub key: enum__Torappu_VoiceLangGroupType,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_VoiceLangGroupData<'a>>>,
}
impl<'a> Default
    for dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupDataArgs<'a>
{
    #[inline]
    fn default() -> Self {
        dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupDataArgs {
            key: enum__Torappu_VoiceLangGroupType::NONE,
            value: None,
        }
    }
}

impl Serialize for dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: enum__Torappu_VoiceLangGroupType) {
        self.fbb_.push_slot::<enum__Torappu_VoiceLangGroupType>(
            dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData::VT_KEY,
            key,
            enum__Torappu_VoiceLangGroupType::NONE,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_VoiceLangGroupData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_VoiceLangGroupData>>(
                dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupDataBuilder<'a, 'b, A>
    {
        let start = _fbb.start_table();
        dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f
            .debug_struct("dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupDataT {
    pub key: enum__Torappu_VoiceLangGroupType,
    pub value: Option<Box<clz_Torappu_VoiceLangGroupDataT>>,
}
impl Default for dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupDataT {
    fn default() -> Self {
        Self {
            key: enum__Torappu_VoiceLangGroupType::NONE,
            value: None,
        }
    }
}
impl dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData<'b>,
    > {
        let key = self.key;
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData::create(
            _fbb,
            &dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupDataArgs {
                key,
                value,
            },
        )
    }
}
pub enum dict__string__enum__Torappu_VoiceLangTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__enum__Torappu_VoiceLangType<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__enum__Torappu_VoiceLangType<'a> {
    type Inner = dict__string__enum__Torappu_VoiceLangType<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__enum__Torappu_VoiceLangType<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__enum__Torappu_VoiceLangType { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__enum__Torappu_VoiceLangTypeArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__enum__Torappu_VoiceLangType<'bldr>> {
        let mut builder = dict__string__enum__Torappu_VoiceLangTypeBuilder::new(_fbb);
        builder.add_value(args.value);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__enum__Torappu_VoiceLangTypeT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value();
        dict__string__enum__Torappu_VoiceLangTypeT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__enum__Torappu_VoiceLangType::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__enum__Torappu_VoiceLangType) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> enum__Torappu_VoiceLangType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_VoiceLangType>(
                    dict__string__enum__Torappu_VoiceLangType::VT_VALUE,
                    Some(enum__Torappu_VoiceLangType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for dict__string__enum__Torappu_VoiceLangType<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<enum__Torappu_VoiceLangType>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__enum__Torappu_VoiceLangTypeArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: enum__Torappu_VoiceLangType,
}
impl<'a> Default for dict__string__enum__Torappu_VoiceLangTypeArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__enum__Torappu_VoiceLangTypeArgs {
            key: None, // required field
            value: enum__Torappu_VoiceLangType::NONE,
        }
    }
}

impl Serialize for dict__string__enum__Torappu_VoiceLangType<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__enum__Torappu_VoiceLangType", 2)?;
        s.serialize_field("key", &self.key())?;
        s.serialize_field("value", &self.value())?;
        s.end()
    }
}

pub struct dict__string__enum__Torappu_VoiceLangTypeBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__enum__Torappu_VoiceLangTypeBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__enum__Torappu_VoiceLangType::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: enum__Torappu_VoiceLangType) {
        self.fbb_.push_slot::<enum__Torappu_VoiceLangType>(
            dict__string__enum__Torappu_VoiceLangType::VT_VALUE,
            value,
            enum__Torappu_VoiceLangType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__enum__Torappu_VoiceLangTypeBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__enum__Torappu_VoiceLangTypeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__enum__Torappu_VoiceLangType<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__enum__Torappu_VoiceLangType::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__enum__Torappu_VoiceLangType<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__enum__Torappu_VoiceLangType");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__enum__Torappu_VoiceLangTypeT {
    pub key: String,
    pub value: enum__Torappu_VoiceLangType,
}
impl Default for dict__string__enum__Torappu_VoiceLangTypeT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: enum__Torappu_VoiceLangType::NONE,
        }
    }
}
impl dict__string__enum__Torappu_VoiceLangTypeT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__enum__Torappu_VoiceLangType<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value;
        dict__string__enum__Torappu_VoiceLangType::create(
            _fbb,
            &dict__string__enum__Torappu_VoiceLangTypeArgs { key, value },
        )
    }
}
pub enum clz_Torappu_NewVoiceTimeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_NewVoiceTimeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_NewVoiceTimeData<'a> {
    type Inner = clz_Torappu_NewVoiceTimeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_NewVoiceTimeData<'a> {
    pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 4;
    pub const VT_CHARSET: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_NewVoiceTimeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_NewVoiceTimeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_NewVoiceTimeData<'bldr>> {
        let mut builder = clz_Torappu_NewVoiceTimeDataBuilder::new(_fbb);
        builder.add_timestamp(args.timestamp);
        if let Some(x) = args.charSet {
            builder.add_charSet(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_NewVoiceTimeDataT {
        let timestamp = self.timestamp();
        let charSet = self
            .charSet()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_NewVoiceTimeDataT { timestamp, charSet }
    }

    #[inline]
    pub fn timestamp(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_NewVoiceTimeData::VT_TIMESTAMP, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn charSet(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_NewVoiceTimeData::VT_CHARSET, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_NewVoiceTimeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("timestamp", Self::VT_TIMESTAMP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("charSet", Self::VT_CHARSET, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_NewVoiceTimeDataArgs<'a> {
    pub timestamp: i64,
    pub charSet: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_NewVoiceTimeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_NewVoiceTimeDataArgs {
            timestamp: 0,
            charSet: None,
        }
    }
}

impl Serialize for clz_Torappu_NewVoiceTimeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_NewVoiceTimeData", 2)?;
        s.serialize_field("timestamp", &self.timestamp())?;
        if let Some(f) = self.charSet() {
            s.serialize_field("charSet", &f)?;
        } else {
            s.skip_field("charSet")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_NewVoiceTimeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_NewVoiceTimeDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_timestamp(&mut self, timestamp: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_NewVoiceTimeData::VT_TIMESTAMP, timestamp, 0);
    }
    #[inline]
    pub fn add_charSet(
        &mut self,
        charSet: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_NewVoiceTimeData::VT_CHARSET,
            charSet,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_NewVoiceTimeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_NewVoiceTimeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_NewVoiceTimeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_NewVoiceTimeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_NewVoiceTimeData");
        ds.field("timestamp", &self.timestamp());
        ds.field("charSet", &self.charSet());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_NewVoiceTimeDataT {
    pub timestamp: i64,
    pub charSet: Option<Vec<String>>,
}
impl Default for clz_Torappu_NewVoiceTimeDataT {
    fn default() -> Self {
        Self {
            timestamp: 0,
            charSet: None,
        }
    }
}
impl clz_Torappu_NewVoiceTimeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_NewVoiceTimeData<'b>> {
        let timestamp = self.timestamp;
        let charSet = self.charSet.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_NewVoiceTimeData::create(
            _fbb,
            &clz_Torappu_NewVoiceTimeDataArgs { timestamp, charSet },
        )
    }
}
pub enum dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData<'a>
{
    type Inner = dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeDataArgs<
            'args,
        >,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData<'bldr>,
    > {
        let mut builder =
            dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeDataT {
        let key = self.key();
        let value = self.value().map(|x| x.iter().map(|t| t.unpack()).collect());
        dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_VoiceLangType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_VoiceLangType>(
                    dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData::VT_KEY,
                    Some(enum__Torappu_VoiceLangType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_VoiceLangType,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_NewVoiceTimeData<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_NewVoiceTimeData>>,
            >>(
                dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_VoiceLangType>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_NewVoiceTimeData>>,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeDataArgs<'a> {
    pub key: enum__Torappu_VoiceLangType,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_NewVoiceTimeData<'a>>>,
        >,
    >,
}
impl<'a> Default for dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeDataArgs {
            key: enum__Torappu_VoiceLangType::NONE,
            value: None,
        }
    }
}

impl Serialize for dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: enum__Torappu_VoiceLangType) {
        self.fbb_.push_slot::<enum__Torappu_VoiceLangType>(
            dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData::VT_KEY,
            key,
            enum__Torappu_VoiceLangType::NONE,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_NewVoiceTimeData<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeDataBuilder<'a, 'b, A>
    {
        let start = _fbb.start_table();
        dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeDataT {
    pub key: enum__Torappu_VoiceLangType,
    pub value: Option<Vec<clz_Torappu_NewVoiceTimeDataT>>,
}
impl Default for dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeDataT {
    fn default() -> Self {
        Self {
            key: enum__Torappu_VoiceLangType::NONE,
            value: None,
        }
    }
}
impl dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData<'b>,
    > {
        let key = self.key;
        let value = self.value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData::create(
            _fbb,
            &dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeDataArgs {
                key,
                value,
            },
        )
    }
}
pub enum clz_Torappu_FestivalTimeIntervalOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_FestivalTimeInterval<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_FestivalTimeInterval<'a> {
    type Inner = clz_Torappu_FestivalTimeInterval<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_FestivalTimeInterval<'a> {
    pub const VT_STARTTS: flatbuffers::VOffsetT = 4;
    pub const VT_ENDTS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_FestivalTimeInterval { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_FestivalTimeIntervalArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_FestivalTimeInterval<'bldr>> {
        let mut builder = clz_Torappu_FestivalTimeIntervalBuilder::new(_fbb);
        builder.add_endTs(args.endTs);
        builder.add_startTs(args.startTs);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_FestivalTimeIntervalT {
        let startTs = self.startTs();
        let endTs = self.endTs();
        clz_Torappu_FestivalTimeIntervalT { startTs, endTs }
    }

    #[inline]
    pub fn startTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_FestivalTimeInterval::VT_STARTTS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_FestivalTimeInterval::VT_ENDTS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_FestivalTimeInterval<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("startTs", Self::VT_STARTTS, false)?
            .visit_field::<i64>("endTs", Self::VT_ENDTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_FestivalTimeIntervalArgs {
    pub startTs: i64,
    pub endTs: i64,
}
impl<'a> Default for clz_Torappu_FestivalTimeIntervalArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_FestivalTimeIntervalArgs {
            startTs: 0,
            endTs: 0,
        }
    }
}

impl Serialize for clz_Torappu_FestivalTimeInterval<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_FestivalTimeInterval", 2)?;
        s.serialize_field("startTs", &self.startTs())?;
        s.serialize_field("endTs", &self.endTs())?;
        s.end()
    }
}

pub struct clz_Torappu_FestivalTimeIntervalBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_FestivalTimeIntervalBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_startTs(&mut self, startTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_FestivalTimeInterval::VT_STARTTS, startTs, 0);
    }
    #[inline]
    pub fn add_endTs(&mut self, endTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_FestivalTimeInterval::VT_ENDTS, endTs, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_FestivalTimeIntervalBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_FestivalTimeIntervalBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_FestivalTimeInterval<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_FestivalTimeInterval<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_FestivalTimeInterval");
        ds.field("startTs", &self.startTs());
        ds.field("endTs", &self.endTs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_FestivalTimeIntervalT {
    pub startTs: i64,
    pub endTs: i64,
}
impl Default for clz_Torappu_FestivalTimeIntervalT {
    fn default() -> Self {
        Self {
            startTs: 0,
            endTs: 0,
        }
    }
}
impl clz_Torappu_FestivalTimeIntervalT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_FestivalTimeInterval<'b>> {
        let startTs = self.startTs;
        let endTs = self.endTs;
        clz_Torappu_FestivalTimeInterval::create(
            _fbb,
            &clz_Torappu_FestivalTimeIntervalArgs { startTs, endTs },
        )
    }
}
pub enum clz_Torappu_FestivalTimeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_FestivalTimeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_FestivalTimeData<'a> {
    type Inner = clz_Torappu_FestivalTimeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_FestivalTimeData<'a> {
    pub const VT_TIMETYPE: flatbuffers::VOffsetT = 4;
    pub const VT_INTERVAL: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_FestivalTimeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_FestivalTimeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_FestivalTimeData<'bldr>> {
        let mut builder = clz_Torappu_FestivalTimeDataBuilder::new(_fbb);
        if let Some(x) = args.interval {
            builder.add_interval(x);
        }
        builder.add_timeType(args.timeType);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_FestivalTimeDataT {
        let timeType = self.timeType();
        let interval = self.interval().map(|x| Box::new(x.unpack()));
        clz_Torappu_FestivalTimeDataT { timeType, interval }
    }

    #[inline]
    pub fn timeType(&self) -> enum__Torappu_FestivalVoiceTimeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_FestivalVoiceTimeType>(
                    clz_Torappu_FestivalTimeData::VT_TIMETYPE,
                    Some(enum__Torappu_FestivalVoiceTimeType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn interval(&self) -> Option<clz_Torappu_FestivalTimeInterval<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_FestivalTimeInterval>>(
                    clz_Torappu_FestivalTimeData::VT_INTERVAL,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_FestivalTimeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_FestivalVoiceTimeType>(
                "timeType",
                Self::VT_TIMETYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_FestivalTimeInterval>>(
                "interval",
                Self::VT_INTERVAL,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_FestivalTimeDataArgs<'a> {
    pub timeType: enum__Torappu_FestivalVoiceTimeType,
    pub interval: Option<flatbuffers::WIPOffset<clz_Torappu_FestivalTimeInterval<'a>>>,
}
impl<'a> Default for clz_Torappu_FestivalTimeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_FestivalTimeDataArgs {
            timeType: enum__Torappu_FestivalVoiceTimeType::NONE,
            interval: None,
        }
    }
}

impl Serialize for clz_Torappu_FestivalTimeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_FestivalTimeData", 2)?;
        s.serialize_field("timeType", &self.timeType())?;
        if let Some(f) = self.interval() {
            s.serialize_field("interval", &f)?;
        } else {
            s.skip_field("interval")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_FestivalTimeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_FestivalTimeDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_timeType(&mut self, timeType: enum__Torappu_FestivalVoiceTimeType) {
        self.fbb_.push_slot::<enum__Torappu_FestivalVoiceTimeType>(
            clz_Torappu_FestivalTimeData::VT_TIMETYPE,
            timeType,
            enum__Torappu_FestivalVoiceTimeType::NONE,
        );
    }
    #[inline]
    pub fn add_interval(
        &mut self,
        interval: flatbuffers::WIPOffset<clz_Torappu_FestivalTimeInterval<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_FestivalTimeInterval>>(
                clz_Torappu_FestivalTimeData::VT_INTERVAL,
                interval,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_FestivalTimeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_FestivalTimeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_FestivalTimeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_FestivalTimeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_FestivalTimeData");
        ds.field("timeType", &self.timeType());
        ds.field("interval", &self.interval());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_FestivalTimeDataT {
    pub timeType: enum__Torappu_FestivalVoiceTimeType,
    pub interval: Option<Box<clz_Torappu_FestivalTimeIntervalT>>,
}
impl Default for clz_Torappu_FestivalTimeDataT {
    fn default() -> Self {
        Self {
            timeType: enum__Torappu_FestivalVoiceTimeType::NONE,
            interval: None,
        }
    }
}
impl clz_Torappu_FestivalTimeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_FestivalTimeData<'b>> {
        let timeType = self.timeType;
        let interval = self.interval.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_FestivalTimeData::create(
            _fbb,
            &clz_Torappu_FestivalTimeDataArgs { timeType, interval },
        )
    }
}
pub enum clz_Torappu_FestivalVoiceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_FestivalVoiceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_FestivalVoiceData<'a> {
    type Inner = clz_Torappu_FestivalVoiceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_FestivalVoiceData<'a> {
    pub const VT_SHOWTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_TIMEDATA: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_FestivalVoiceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_FestivalVoiceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_FestivalVoiceData<'bldr>> {
        let mut builder = clz_Torappu_FestivalVoiceDataBuilder::new(_fbb);
        if let Some(x) = args.timeData {
            builder.add_timeData(x);
        }
        builder.add_showType(args.showType);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_FestivalVoiceDataT {
        let showType = self.showType();
        let timeData = self
            .timeData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_FestivalVoiceDataT { showType, timeData }
    }

    #[inline]
    pub fn showType(&self) -> enum__Torappu_CharWordShowType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_CharWordShowType>(
                    clz_Torappu_FestivalVoiceData::VT_SHOWTYPE,
                    Some(enum__Torappu_CharWordShowType::HOME_SHOW),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn timeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_FestivalTimeData<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_FestivalTimeData>>,
            >>(clz_Torappu_FestivalVoiceData::VT_TIMEDATA, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_FestivalVoiceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_CharWordShowType>("showType", Self::VT_SHOWTYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_FestivalTimeData>>,
            >>("timeData", Self::VT_TIMEDATA, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_FestivalVoiceDataArgs<'a> {
    pub showType: enum__Torappu_CharWordShowType,
    pub timeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_FestivalTimeData<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_FestivalVoiceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_FestivalVoiceDataArgs {
            showType: enum__Torappu_CharWordShowType::HOME_SHOW,
            timeData: None,
        }
    }
}

impl Serialize for clz_Torappu_FestivalVoiceData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_FestivalVoiceData", 2)?;
        s.serialize_field("showType", &self.showType())?;
        if let Some(f) = self.timeData() {
            s.serialize_field("timeData", &f)?;
        } else {
            s.skip_field("timeData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_FestivalVoiceDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_FestivalVoiceDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_showType(&mut self, showType: enum__Torappu_CharWordShowType) {
        self.fbb_.push_slot::<enum__Torappu_CharWordShowType>(
            clz_Torappu_FestivalVoiceData::VT_SHOWTYPE,
            showType,
            enum__Torappu_CharWordShowType::HOME_SHOW,
        );
    }
    #[inline]
    pub fn add_timeData(
        &mut self,
        timeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_FestivalTimeData<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_FestivalVoiceData::VT_TIMEDATA,
            timeData,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_FestivalVoiceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_FestivalVoiceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_FestivalVoiceData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_FestivalVoiceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_FestivalVoiceData");
        ds.field("showType", &self.showType());
        ds.field("timeData", &self.timeData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_FestivalVoiceDataT {
    pub showType: enum__Torappu_CharWordShowType,
    pub timeData: Option<Vec<clz_Torappu_FestivalTimeDataT>>,
}
impl Default for clz_Torappu_FestivalVoiceDataT {
    fn default() -> Self {
        Self {
            showType: enum__Torappu_CharWordShowType::HOME_SHOW,
            timeData: None,
        }
    }
}
impl clz_Torappu_FestivalVoiceDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_FestivalVoiceData<'b>> {
        let showType = self.showType;
        let timeData = self.timeData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_FestivalVoiceData::create(
            _fbb,
            &clz_Torappu_FestivalVoiceDataArgs { showType, timeData },
        )
    }
}
pub enum dict__string__clz_Torappu_FestivalVoiceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_FestivalVoiceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_FestivalVoiceData<'a> {
    type Inner = dict__string__clz_Torappu_FestivalVoiceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_FestivalVoiceData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_FestivalVoiceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_FestivalVoiceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_FestivalVoiceData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_FestivalVoiceDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_FestivalVoiceDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_FestivalVoiceDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_FestivalVoiceData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_FestivalVoiceData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_FestivalVoiceData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_FestivalVoiceData>>(
                    dict__string__clz_Torappu_FestivalVoiceData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_FestivalVoiceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_FestivalVoiceData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_FestivalVoiceDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_FestivalVoiceData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_FestivalVoiceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_FestivalVoiceDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_FestivalVoiceData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_FestivalVoiceData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_FestivalVoiceDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_FestivalVoiceDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_FestivalVoiceData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_FestivalVoiceData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_FestivalVoiceData>>(
                dict__string__clz_Torappu_FestivalVoiceData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_FestivalVoiceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_FestivalVoiceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_FestivalVoiceData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_FestivalVoiceData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_FestivalVoiceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_FestivalVoiceData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_FestivalVoiceDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_FestivalVoiceDataT>>,
}
impl Default for dict__string__clz_Torappu_FestivalVoiceDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_FestivalVoiceDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_FestivalVoiceData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_FestivalVoiceData::create(
            _fbb,
            &dict__string__clz_Torappu_FestivalVoiceDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_FestivalVoiceWeightDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_FestivalVoiceWeightData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_FestivalVoiceWeightData<'a> {
    type Inner = clz_Torappu_FestivalVoiceWeightData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_FestivalVoiceWeightData<'a> {
    pub const VT_SHOWTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_WEIGHT: flatbuffers::VOffsetT = 6;
    pub const VT_PRIORITY: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_FestivalVoiceWeightData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_FestivalVoiceWeightDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_FestivalVoiceWeightData<'bldr>> {
        let mut builder = clz_Torappu_FestivalVoiceWeightDataBuilder::new(_fbb);
        builder.add_priority(args.priority);
        builder.add_weight(args.weight);
        builder.add_showType(args.showType);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_FestivalVoiceWeightDataT {
        let showType = self.showType();
        let weight = self.weight();
        let priority = self.priority();
        clz_Torappu_FestivalVoiceWeightDataT {
            showType,
            weight,
            priority,
        }
    }

    #[inline]
    pub fn showType(&self) -> enum__Torappu_CharWordShowType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_CharWordShowType>(
                    clz_Torappu_FestivalVoiceWeightData::VT_SHOWTYPE,
                    Some(enum__Torappu_CharWordShowType::HOME_SHOW),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn weight(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_FestivalVoiceWeightData::VT_WEIGHT, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn priority(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_FestivalVoiceWeightData::VT_PRIORITY, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_FestivalVoiceWeightData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_CharWordShowType>("showType", Self::VT_SHOWTYPE, false)?
            .visit_field::<f32>("weight", Self::VT_WEIGHT, false)?
            .visit_field::<i32>("priority", Self::VT_PRIORITY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_FestivalVoiceWeightDataArgs {
    pub showType: enum__Torappu_CharWordShowType,
    pub weight: f32,
    pub priority: i32,
}
impl<'a> Default for clz_Torappu_FestivalVoiceWeightDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_FestivalVoiceWeightDataArgs {
            showType: enum__Torappu_CharWordShowType::HOME_SHOW,
            weight: 0.0,
            priority: 0,
        }
    }
}

impl Serialize for clz_Torappu_FestivalVoiceWeightData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_FestivalVoiceWeightData", 3)?;
        s.serialize_field("showType", &self.showType())?;
        s.serialize_field("weight", &self.weight())?;
        s.serialize_field("priority", &self.priority())?;
        s.end()
    }
}

pub struct clz_Torappu_FestivalVoiceWeightDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_FestivalVoiceWeightDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_showType(&mut self, showType: enum__Torappu_CharWordShowType) {
        self.fbb_.push_slot::<enum__Torappu_CharWordShowType>(
            clz_Torappu_FestivalVoiceWeightData::VT_SHOWTYPE,
            showType,
            enum__Torappu_CharWordShowType::HOME_SHOW,
        );
    }
    #[inline]
    pub fn add_weight(&mut self, weight: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_FestivalVoiceWeightData::VT_WEIGHT, weight, 0.0);
    }
    #[inline]
    pub fn add_priority(&mut self, priority: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_FestivalVoiceWeightData::VT_PRIORITY,
            priority,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_FestivalVoiceWeightDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_FestivalVoiceWeightDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_FestivalVoiceWeightData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_FestivalVoiceWeightData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_FestivalVoiceWeightData");
        ds.field("showType", &self.showType());
        ds.field("weight", &self.weight());
        ds.field("priority", &self.priority());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_FestivalVoiceWeightDataT {
    pub showType: enum__Torappu_CharWordShowType,
    pub weight: f32,
    pub priority: i32,
}
impl Default for clz_Torappu_FestivalVoiceWeightDataT {
    fn default() -> Self {
        Self {
            showType: enum__Torappu_CharWordShowType::HOME_SHOW,
            weight: 0.0,
            priority: 0,
        }
    }
}
impl clz_Torappu_FestivalVoiceWeightDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_FestivalVoiceWeightData<'b>> {
        let showType = self.showType;
        let weight = self.weight;
        let priority = self.priority;
        clz_Torappu_FestivalVoiceWeightData::create(
            _fbb,
            &clz_Torappu_FestivalVoiceWeightDataArgs {
                showType,
                weight,
                priority,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_FestivalVoiceWeightDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_FestivalVoiceWeightData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_FestivalVoiceWeightData<'a> {
    type Inner = dict__string__clz_Torappu_FestivalVoiceWeightData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_FestivalVoiceWeightData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_FestivalVoiceWeightData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_FestivalVoiceWeightDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_FestivalVoiceWeightData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_FestivalVoiceWeightDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_FestivalVoiceWeightDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_FestivalVoiceWeightDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_FestivalVoiceWeightData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_FestivalVoiceWeightData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_FestivalVoiceWeightData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_FestivalVoiceWeightData>>(
                    dict__string__clz_Torappu_FestivalVoiceWeightData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_FestivalVoiceWeightData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_FestivalVoiceWeightData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_FestivalVoiceWeightDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_FestivalVoiceWeightData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_FestivalVoiceWeightDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_FestivalVoiceWeightDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_FestivalVoiceWeightData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_FestivalVoiceWeightData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_FestivalVoiceWeightDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_FestivalVoiceWeightDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_FestivalVoiceWeightData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_FestivalVoiceWeightData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_FestivalVoiceWeightData>>(
                dict__string__clz_Torappu_FestivalVoiceWeightData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_FestivalVoiceWeightDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_FestivalVoiceWeightDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_FestivalVoiceWeightData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_FestivalVoiceWeightData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_FestivalVoiceWeightData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_FestivalVoiceWeightData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_FestivalVoiceWeightDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_FestivalVoiceWeightDataT>>,
}
impl Default for dict__string__clz_Torappu_FestivalVoiceWeightDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_FestivalVoiceWeightDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_FestivalVoiceWeightData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_FestivalVoiceWeightData::create(
            _fbb,
            &dict__string__clz_Torappu_FestivalVoiceWeightDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ExtraVoiceConfigDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ExtraVoiceConfigData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ExtraVoiceConfigData<'a> {
    type Inner = clz_Torappu_ExtraVoiceConfigData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ExtraVoiceConfigData<'a> {
    pub const VT_VOICEID: flatbuffers::VOffsetT = 4;
    pub const VT_VALIDVOICELANG: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ExtraVoiceConfigData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ExtraVoiceConfigDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ExtraVoiceConfigData<'bldr>> {
        let mut builder = clz_Torappu_ExtraVoiceConfigDataBuilder::new(_fbb);
        if let Some(x) = args.validVoiceLang {
            builder.add_validVoiceLang(x);
        }
        if let Some(x) = args.voiceId {
            builder.add_voiceId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ExtraVoiceConfigDataT {
        let voiceId = self.voiceId().map(|x| x.to_string());
        let validVoiceLang = self.validVoiceLang().map(|x| x.into_iter().collect());
        clz_Torappu_ExtraVoiceConfigDataT {
            voiceId,
            validVoiceLang,
        }
    }

    #[inline]
    pub fn voiceId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ExtraVoiceConfigData::VT_VOICEID,
                None,
            )
        }
    }
    #[inline]
    pub fn validVoiceLang(&self) -> Option<flatbuffers::Vector<'a, enum__Torappu_VoiceLangType>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_VoiceLangType>,
            >>(clz_Torappu_ExtraVoiceConfigData::VT_VALIDVOICELANG, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ExtraVoiceConfigData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("voiceId", Self::VT_VOICEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_VoiceLangType>>>("validVoiceLang", Self::VT_VALIDVOICELANG, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ExtraVoiceConfigDataArgs<'a> {
    pub voiceId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub validVoiceLang:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_VoiceLangType>>>,
}
impl<'a> Default for clz_Torappu_ExtraVoiceConfigDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ExtraVoiceConfigDataArgs {
            voiceId: None,
            validVoiceLang: None,
        }
    }
}

impl Serialize for clz_Torappu_ExtraVoiceConfigData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ExtraVoiceConfigData", 2)?;
        if let Some(f) = self.voiceId() {
            s.serialize_field("voiceId", &f)?;
        } else {
            s.skip_field("voiceId")?;
        }
        if let Some(f) = self.validVoiceLang() {
            s.serialize_field("validVoiceLang", &f)?;
        } else {
            s.skip_field("validVoiceLang")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ExtraVoiceConfigDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ExtraVoiceConfigDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_voiceId(&mut self, voiceId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ExtraVoiceConfigData::VT_VOICEID,
            voiceId,
        );
    }
    #[inline]
    pub fn add_validVoiceLang(
        &mut self,
        validVoiceLang: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, enum__Torappu_VoiceLangType>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ExtraVoiceConfigData::VT_VALIDVOICELANG,
            validVoiceLang,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ExtraVoiceConfigDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ExtraVoiceConfigDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ExtraVoiceConfigData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ExtraVoiceConfigData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ExtraVoiceConfigData");
        ds.field("voiceId", &self.voiceId());
        ds.field("validVoiceLang", &self.validVoiceLang());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ExtraVoiceConfigDataT {
    pub voiceId: Option<String>,
    pub validVoiceLang: Option<Vec<enum__Torappu_VoiceLangType>>,
}
impl Default for clz_Torappu_ExtraVoiceConfigDataT {
    fn default() -> Self {
        Self {
            voiceId: None,
            validVoiceLang: None,
        }
    }
}
impl clz_Torappu_ExtraVoiceConfigDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ExtraVoiceConfigData<'b>> {
        let voiceId = self.voiceId.as_ref().map(|x| _fbb.create_string(x));
        let validVoiceLang = self.validVoiceLang.as_ref().map(|x| _fbb.create_vector(x));
        clz_Torappu_ExtraVoiceConfigData::create(
            _fbb,
            &clz_Torappu_ExtraVoiceConfigDataArgs {
                voiceId,
                validVoiceLang,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ExtraVoiceConfigDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ExtraVoiceConfigData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ExtraVoiceConfigData<'a> {
    type Inner = dict__string__clz_Torappu_ExtraVoiceConfigData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ExtraVoiceConfigData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ExtraVoiceConfigData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ExtraVoiceConfigDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ExtraVoiceConfigData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ExtraVoiceConfigDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ExtraVoiceConfigDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ExtraVoiceConfigDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ExtraVoiceConfigData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ExtraVoiceConfigData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ExtraVoiceConfigData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ExtraVoiceConfigData>>(
                    dict__string__clz_Torappu_ExtraVoiceConfigData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ExtraVoiceConfigData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ExtraVoiceConfigData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ExtraVoiceConfigDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ExtraVoiceConfigData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ExtraVoiceConfigDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ExtraVoiceConfigDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ExtraVoiceConfigData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ExtraVoiceConfigData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ExtraVoiceConfigDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ExtraVoiceConfigDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ExtraVoiceConfigData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ExtraVoiceConfigData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ExtraVoiceConfigData>>(
                dict__string__clz_Torappu_ExtraVoiceConfigData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ExtraVoiceConfigDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ExtraVoiceConfigDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ExtraVoiceConfigData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ExtraVoiceConfigData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ExtraVoiceConfigData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ExtraVoiceConfigData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ExtraVoiceConfigDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ExtraVoiceConfigDataT>>,
}
impl Default for dict__string__clz_Torappu_ExtraVoiceConfigDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ExtraVoiceConfigDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ExtraVoiceConfigData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ExtraVoiceConfigData::create(
            _fbb,
            &dict__string__clz_Torappu_ExtraVoiceConfigDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_CharWordTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharWordTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharWordTable<'a> {
    type Inner = clz_Torappu_CharWordTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharWordTable<'a> {
    pub const VT_CHARWORDS: flatbuffers::VOffsetT = 4;
    pub const VT_CHAREXTRAWORDS: flatbuffers::VOffsetT = 6;
    pub const VT_VOICELANGDICT: flatbuffers::VOffsetT = 8;
    pub const VT_DEFAULTLANGTYPE: flatbuffers::VOffsetT = 10;
    pub const VT_NEWTAGLIST: flatbuffers::VOffsetT = 12;
    pub const VT_VOICELANGTYPEDICT: flatbuffers::VOffsetT = 14;
    pub const VT_VOICELANGGROUPTYPEDICT: flatbuffers::VOffsetT = 16;
    pub const VT_CHARDEFAULTTYPEDICT: flatbuffers::VOffsetT = 18;
    pub const VT_STARTTIMEWITHTYPEDICT: flatbuffers::VOffsetT = 20;
    pub const VT_DISPLAYGROUPTYPELIST: flatbuffers::VOffsetT = 22;
    pub const VT_DISPLAYTYPELIST: flatbuffers::VOffsetT = 24;
    pub const VT_PLAYVOICERANGE: flatbuffers::VOffsetT = 26;
    pub const VT_FESVOICEDATA: flatbuffers::VOffsetT = 28;
    pub const VT_FESVOICEWEIGHT: flatbuffers::VOffsetT = 30;
    pub const VT_EXTRAVOICECONFIGDATA: flatbuffers::VOffsetT = 32;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharWordTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharWordTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharWordTable<'bldr>> {
        let mut builder = clz_Torappu_CharWordTableBuilder::new(_fbb);
        if let Some(x) = args.extraVoiceConfigData {
            builder.add_extraVoiceConfigData(x);
        }
        if let Some(x) = args.fesVoiceWeight {
            builder.add_fesVoiceWeight(x);
        }
        if let Some(x) = args.fesVoiceData {
            builder.add_fesVoiceData(x);
        }
        builder.add_playVoiceRange(args.playVoiceRange);
        if let Some(x) = args.displayTypeList {
            builder.add_displayTypeList(x);
        }
        if let Some(x) = args.displayGroupTypeList {
            builder.add_displayGroupTypeList(x);
        }
        if let Some(x) = args.startTimeWithTypeDict {
            builder.add_startTimeWithTypeDict(x);
        }
        if let Some(x) = args.charDefaultTypeDict {
            builder.add_charDefaultTypeDict(x);
        }
        if let Some(x) = args.voiceLangGroupTypeDict {
            builder.add_voiceLangGroupTypeDict(x);
        }
        if let Some(x) = args.voiceLangTypeDict {
            builder.add_voiceLangTypeDict(x);
        }
        if let Some(x) = args.newTagList {
            builder.add_newTagList(x);
        }
        builder.add_defaultLangType(args.defaultLangType);
        if let Some(x) = args.voiceLangDict {
            builder.add_voiceLangDict(x);
        }
        if let Some(x) = args.charExtraWords {
            builder.add_charExtraWords(x);
        }
        if let Some(x) = args.charWords {
            builder.add_charWords(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharWordTableT {
        let charWords = self
            .charWords()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let charExtraWords = self
            .charExtraWords()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let voiceLangDict = self
            .voiceLangDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let defaultLangType = self.defaultLangType();
        let newTagList = self
            .newTagList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let voiceLangTypeDict = self
            .voiceLangTypeDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let voiceLangGroupTypeDict = self
            .voiceLangGroupTypeDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let charDefaultTypeDict = self
            .charDefaultTypeDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let startTimeWithTypeDict = self
            .startTimeWithTypeDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let displayGroupTypeList = self.displayGroupTypeList().map(|x| x.into_iter().collect());
        let displayTypeList = self.displayTypeList().map(|x| x.into_iter().collect());
        let playVoiceRange = self.playVoiceRange();
        let fesVoiceData = self
            .fesVoiceData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let fesVoiceWeight = self
            .fesVoiceWeight()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let extraVoiceConfigData = self
            .extraVoiceConfigData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_CharWordTableT {
            charWords,
            charExtraWords,
            voiceLangDict,
            defaultLangType,
            newTagList,
            voiceLangTypeDict,
            voiceLangGroupTypeDict,
            charDefaultTypeDict,
            startTimeWithTypeDict,
            displayGroupTypeList,
            displayTypeList,
            playVoiceRange,
            fesVoiceData,
            fesVoiceWeight,
            extraVoiceConfigData,
        }
    }

    #[inline]
    pub fn charWords(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharWordData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharWordData>,
                >,
            >>(clz_Torappu_CharWordTable::VT_CHARWORDS, None)
        }
    }
    #[inline]
    pub fn charExtraWords(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharExtraWordData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharExtraWordData>,
                >,
            >>(clz_Torappu_CharWordTable::VT_CHAREXTRAWORDS, None)
        }
    }
    #[inline]
    pub fn voiceLangDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_VoiceLangData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_VoiceLangData>,
                >,
            >>(clz_Torappu_CharWordTable::VT_VOICELANGDICT, None)
        }
    }
    #[inline]
    pub fn defaultLangType(&self) -> enum__Torappu_VoiceLangType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_VoiceLangType>(
                    clz_Torappu_CharWordTable::VT_DEFAULTLANGTYPE,
                    Some(enum__Torappu_VoiceLangType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn newTagList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_CharWordTable::VT_NEWTAGLIST, None)
        }
    }
    #[inline]
    pub fn voiceLangTypeDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData,
                    >,
                >,
            >>(clz_Torappu_CharWordTable::VT_VOICELANGTYPEDICT, None)
        }
    }
    #[inline]
    pub fn voiceLangGroupTypeDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData,
                    >,
                >,
            >>(clz_Torappu_CharWordTable::VT_VOICELANGGROUPTYPEDICT, None)
        }
    }
    #[inline]
    pub fn charDefaultTypeDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__enum__Torappu_VoiceLangType<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__enum__Torappu_VoiceLangType>,
                >,
            >>(clz_Torappu_CharWordTable::VT_CHARDEFAULTTYPEDICT, None)
        }
    }
    #[inline]
    pub fn startTimeWithTypeDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData,
                    >,
                >,
            >>(clz_Torappu_CharWordTable::VT_STARTTIMEWITHTYPEDICT, None)
        }
    }
    #[inline]
    pub fn displayGroupTypeList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, enum__Torappu_VoiceLangGroupType>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_VoiceLangGroupType>,
            >>(clz_Torappu_CharWordTable::VT_DISPLAYGROUPTYPELIST, None)
        }
    }
    #[inline]
    pub fn displayTypeList(&self) -> Option<flatbuffers::Vector<'a, enum__Torappu_VoiceLangType>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_VoiceLangType>,
            >>(clz_Torappu_CharWordTable::VT_DISPLAYTYPELIST, None)
        }
    }
    #[inline]
    pub fn playVoiceRange(&self) -> enum__Torappu_CharWordShowType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_CharWordShowType>(
                    clz_Torappu_CharWordTable::VT_PLAYVOICERANGE,
                    Some(enum__Torappu_CharWordShowType::HOME_SHOW),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn fesVoiceData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_FestivalVoiceData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_FestivalVoiceData>,
                >,
            >>(clz_Torappu_CharWordTable::VT_FESVOICEDATA, None)
        }
    }
    #[inline]
    pub fn fesVoiceWeight(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_FestivalVoiceWeightData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_FestivalVoiceWeightData>,
                >,
            >>(clz_Torappu_CharWordTable::VT_FESVOICEWEIGHT, None)
        }
    }
    #[inline]
    pub fn extraVoiceConfigData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ExtraVoiceConfigData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ExtraVoiceConfigData>,
                >,
            >>(clz_Torappu_CharWordTable::VT_EXTRAVOICECONFIGDATA, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharWordTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharWordData>>>>("charWords", Self::VT_CHARWORDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharExtraWordData>>>>("charExtraWords", Self::VT_CHAREXTRAWORDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_VoiceLangData>>>>("voiceLangDict", Self::VT_VOICELANGDICT, false)?
     .visit_field::<enum__Torappu_VoiceLangType>("defaultLangType", Self::VT_DEFAULTLANGTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("newTagList", Self::VT_NEWTAGLIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData>>>>("voiceLangTypeDict", Self::VT_VOICELANGTYPEDICT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData>>>>("voiceLangGroupTypeDict", Self::VT_VOICELANGGROUPTYPEDICT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__enum__Torappu_VoiceLangType>>>>("charDefaultTypeDict", Self::VT_CHARDEFAULTTYPEDICT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData>>>>("startTimeWithTypeDict", Self::VT_STARTTIMEWITHTYPEDICT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_VoiceLangGroupType>>>("displayGroupTypeList", Self::VT_DISPLAYGROUPTYPELIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_VoiceLangType>>>("displayTypeList", Self::VT_DISPLAYTYPELIST, false)?
     .visit_field::<enum__Torappu_CharWordShowType>("playVoiceRange", Self::VT_PLAYVOICERANGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_FestivalVoiceData>>>>("fesVoiceData", Self::VT_FESVOICEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_FestivalVoiceWeightData>>>>("fesVoiceWeight", Self::VT_FESVOICEWEIGHT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ExtraVoiceConfigData>>>>("extraVoiceConfigData", Self::VT_EXTRAVOICECONFIGDATA, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharWordTableArgs<'a> {
    pub charWords: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharWordData<'a>>,
            >,
        >,
    >,
    pub charExtraWords: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharExtraWordData<'a>>,
            >,
        >,
    >,
    pub voiceLangDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_VoiceLangData<'a>>,
            >,
        >,
    >,
    pub defaultLangType: enum__Torappu_VoiceLangType,
    pub newTagList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub voiceLangTypeDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData<'a>,
                >,
            >,
        >,
    >,
    pub voiceLangGroupTypeDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData<'a>,
                >,
            >,
        >,
    >,
    pub charDefaultTypeDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__enum__Torappu_VoiceLangType<'a>>,
            >,
        >,
    >,
    pub startTimeWithTypeDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData<'a>,
                >,
            >,
        >,
    >,
    pub displayGroupTypeList:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_VoiceLangGroupType>>>,
    pub displayTypeList:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_VoiceLangType>>>,
    pub playVoiceRange: enum__Torappu_CharWordShowType,
    pub fesVoiceData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_FestivalVoiceData<'a>>,
            >,
        >,
    >,
    pub fesVoiceWeight: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_FestivalVoiceWeightData<'a>>,
            >,
        >,
    >,
    pub extraVoiceConfigData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ExtraVoiceConfigData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_CharWordTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharWordTableArgs {
            charWords: None,
            charExtraWords: None,
            voiceLangDict: None,
            defaultLangType: enum__Torappu_VoiceLangType::NONE,
            newTagList: None,
            voiceLangTypeDict: None,
            voiceLangGroupTypeDict: None,
            charDefaultTypeDict: None,
            startTimeWithTypeDict: None,
            displayGroupTypeList: None,
            displayTypeList: None,
            playVoiceRange: enum__Torappu_CharWordShowType::HOME_SHOW,
            fesVoiceData: None,
            fesVoiceWeight: None,
            extraVoiceConfigData: None,
        }
    }
}

impl Serialize for clz_Torappu_CharWordTable<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharWordTable", 15)?;
        if let Some(f) = self.charWords() {
            s.serialize_field("charWords", &f)?;
        } else {
            s.skip_field("charWords")?;
        }
        if let Some(f) = self.charExtraWords() {
            s.serialize_field("charExtraWords", &f)?;
        } else {
            s.skip_field("charExtraWords")?;
        }
        if let Some(f) = self.voiceLangDict() {
            s.serialize_field("voiceLangDict", &f)?;
        } else {
            s.skip_field("voiceLangDict")?;
        }
        s.serialize_field("defaultLangType", &self.defaultLangType())?;
        if let Some(f) = self.newTagList() {
            s.serialize_field("newTagList", &f)?;
        } else {
            s.skip_field("newTagList")?;
        }
        if let Some(f) = self.voiceLangTypeDict() {
            s.serialize_field("voiceLangTypeDict", &f)?;
        } else {
            s.skip_field("voiceLangTypeDict")?;
        }
        if let Some(f) = self.voiceLangGroupTypeDict() {
            s.serialize_field("voiceLangGroupTypeDict", &f)?;
        } else {
            s.skip_field("voiceLangGroupTypeDict")?;
        }
        if let Some(f) = self.charDefaultTypeDict() {
            s.serialize_field("charDefaultTypeDict", &f)?;
        } else {
            s.skip_field("charDefaultTypeDict")?;
        }
        if let Some(f) = self.startTimeWithTypeDict() {
            s.serialize_field("startTimeWithTypeDict", &f)?;
        } else {
            s.skip_field("startTimeWithTypeDict")?;
        }
        if let Some(f) = self.displayGroupTypeList() {
            s.serialize_field("displayGroupTypeList", &f)?;
        } else {
            s.skip_field("displayGroupTypeList")?;
        }
        if let Some(f) = self.displayTypeList() {
            s.serialize_field("displayTypeList", &f)?;
        } else {
            s.skip_field("displayTypeList")?;
        }
        s.serialize_field("playVoiceRange", &self.playVoiceRange())?;
        if let Some(f) = self.fesVoiceData() {
            s.serialize_field("fesVoiceData", &f)?;
        } else {
            s.skip_field("fesVoiceData")?;
        }
        if let Some(f) = self.fesVoiceWeight() {
            s.serialize_field("fesVoiceWeight", &f)?;
        } else {
            s.skip_field("fesVoiceWeight")?;
        }
        if let Some(f) = self.extraVoiceConfigData() {
            s.serialize_field("extraVoiceConfigData", &f)?;
        } else {
            s.skip_field("extraVoiceConfigData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CharWordTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_CharWordTableBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_charWords(
        &mut self,
        charWords: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharWordData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordTable::VT_CHARWORDS,
            charWords,
        );
    }
    #[inline]
    pub fn add_charExtraWords(
        &mut self,
        charExtraWords: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharExtraWordData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordTable::VT_CHAREXTRAWORDS,
            charExtraWords,
        );
    }
    #[inline]
    pub fn add_voiceLangDict(
        &mut self,
        voiceLangDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_VoiceLangData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordTable::VT_VOICELANGDICT,
            voiceLangDict,
        );
    }
    #[inline]
    pub fn add_defaultLangType(&mut self, defaultLangType: enum__Torappu_VoiceLangType) {
        self.fbb_.push_slot::<enum__Torappu_VoiceLangType>(
            clz_Torappu_CharWordTable::VT_DEFAULTLANGTYPE,
            defaultLangType,
            enum__Torappu_VoiceLangType::NONE,
        );
    }
    #[inline]
    pub fn add_newTagList(
        &mut self,
        newTagList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordTable::VT_NEWTAGLIST,
            newTagList,
        );
    }
    #[inline]
    pub fn add_voiceLangTypeDict(
        &mut self,
        voiceLangTypeDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordTable::VT_VOICELANGTYPEDICT,
            voiceLangTypeDict,
        );
    }
    #[inline]
    pub fn add_voiceLangGroupTypeDict(
        &mut self,
        voiceLangGroupTypeDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordTable::VT_VOICELANGGROUPTYPEDICT,
            voiceLangGroupTypeDict,
        );
    }
    #[inline]
    pub fn add_charDefaultTypeDict(
        &mut self,
        charDefaultTypeDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__enum__Torappu_VoiceLangType<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordTable::VT_CHARDEFAULTTYPEDICT,
            charDefaultTypeDict,
        );
    }
    #[inline]
    pub fn add_startTimeWithTypeDict(
        &mut self,
        startTimeWithTypeDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordTable::VT_STARTTIMEWITHTYPEDICT,
            startTimeWithTypeDict,
        );
    }
    #[inline]
    pub fn add_displayGroupTypeList(
        &mut self,
        displayGroupTypeList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, enum__Torappu_VoiceLangGroupType>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordTable::VT_DISPLAYGROUPTYPELIST,
            displayGroupTypeList,
        );
    }
    #[inline]
    pub fn add_displayTypeList(
        &mut self,
        displayTypeList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, enum__Torappu_VoiceLangType>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordTable::VT_DISPLAYTYPELIST,
            displayTypeList,
        );
    }
    #[inline]
    pub fn add_playVoiceRange(&mut self, playVoiceRange: enum__Torappu_CharWordShowType) {
        self.fbb_.push_slot::<enum__Torappu_CharWordShowType>(
            clz_Torappu_CharWordTable::VT_PLAYVOICERANGE,
            playVoiceRange,
            enum__Torappu_CharWordShowType::HOME_SHOW,
        );
    }
    #[inline]
    pub fn add_fesVoiceData(
        &mut self,
        fesVoiceData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_FestivalVoiceData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordTable::VT_FESVOICEDATA,
            fesVoiceData,
        );
    }
    #[inline]
    pub fn add_fesVoiceWeight(
        &mut self,
        fesVoiceWeight: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_FestivalVoiceWeightData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordTable::VT_FESVOICEWEIGHT,
            fesVoiceWeight,
        );
    }
    #[inline]
    pub fn add_extraVoiceConfigData(
        &mut self,
        extraVoiceConfigData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ExtraVoiceConfigData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharWordTable::VT_EXTRAVOICECONFIGDATA,
            extraVoiceConfigData,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharWordTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharWordTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharWordTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharWordTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharWordTable");
        ds.field("charWords", &self.charWords());
        ds.field("charExtraWords", &self.charExtraWords());
        ds.field("voiceLangDict", &self.voiceLangDict());
        ds.field("defaultLangType", &self.defaultLangType());
        ds.field("newTagList", &self.newTagList());
        ds.field("voiceLangTypeDict", &self.voiceLangTypeDict());
        ds.field("voiceLangGroupTypeDict", &self.voiceLangGroupTypeDict());
        ds.field("charDefaultTypeDict", &self.charDefaultTypeDict());
        ds.field("startTimeWithTypeDict", &self.startTimeWithTypeDict());
        ds.field("displayGroupTypeList", &self.displayGroupTypeList());
        ds.field("displayTypeList", &self.displayTypeList());
        ds.field("playVoiceRange", &self.playVoiceRange());
        ds.field("fesVoiceData", &self.fesVoiceData());
        ds.field("fesVoiceWeight", &self.fesVoiceWeight());
        ds.field("extraVoiceConfigData", &self.extraVoiceConfigData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharWordTableT {
    pub charWords: Option<Vec<dict__string__clz_Torappu_CharWordDataT>>,
    pub charExtraWords: Option<Vec<dict__string__clz_Torappu_CharExtraWordDataT>>,
    pub voiceLangDict: Option<Vec<dict__string__clz_Torappu_VoiceLangDataT>>,
    pub defaultLangType: enum__Torappu_VoiceLangType,
    pub newTagList: Option<Vec<String>>,
    pub voiceLangTypeDict:
        Option<Vec<dict__enum__Torappu_VoiceLangType__clz_Torappu_VoiceLangTypeDataT>>,
    pub voiceLangGroupTypeDict:
        Option<Vec<dict__enum__Torappu_VoiceLangGroupType__clz_Torappu_VoiceLangGroupDataT>>,
    pub charDefaultTypeDict: Option<Vec<dict__string__enum__Torappu_VoiceLangTypeT>>,
    pub startTimeWithTypeDict:
        Option<Vec<dict__enum__Torappu_VoiceLangType__list_clz_Torappu_NewVoiceTimeDataT>>,
    pub displayGroupTypeList: Option<Vec<enum__Torappu_VoiceLangGroupType>>,
    pub displayTypeList: Option<Vec<enum__Torappu_VoiceLangType>>,
    pub playVoiceRange: enum__Torappu_CharWordShowType,
    pub fesVoiceData: Option<Vec<dict__string__clz_Torappu_FestivalVoiceDataT>>,
    pub fesVoiceWeight: Option<Vec<dict__string__clz_Torappu_FestivalVoiceWeightDataT>>,
    pub extraVoiceConfigData: Option<Vec<dict__string__clz_Torappu_ExtraVoiceConfigDataT>>,
}
impl Default for clz_Torappu_CharWordTableT {
    fn default() -> Self {
        Self {
            charWords: None,
            charExtraWords: None,
            voiceLangDict: None,
            defaultLangType: enum__Torappu_VoiceLangType::NONE,
            newTagList: None,
            voiceLangTypeDict: None,
            voiceLangGroupTypeDict: None,
            charDefaultTypeDict: None,
            startTimeWithTypeDict: None,
            displayGroupTypeList: None,
            displayTypeList: None,
            playVoiceRange: enum__Torappu_CharWordShowType::HOME_SHOW,
            fesVoiceData: None,
            fesVoiceWeight: None,
            extraVoiceConfigData: None,
        }
    }
}
impl clz_Torappu_CharWordTableT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharWordTable<'b>> {
        let charWords = self.charWords.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let charExtraWords = self.charExtraWords.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let voiceLangDict = self.voiceLangDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let defaultLangType = self.defaultLangType;
        let newTagList = self.newTagList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let voiceLangTypeDict = self.voiceLangTypeDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let voiceLangGroupTypeDict = self.voiceLangGroupTypeDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let charDefaultTypeDict = self.charDefaultTypeDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let startTimeWithTypeDict = self.startTimeWithTypeDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let displayGroupTypeList = self
            .displayGroupTypeList
            .as_ref()
            .map(|x| _fbb.create_vector(x));
        let displayTypeList = self.displayTypeList.as_ref().map(|x| _fbb.create_vector(x));
        let playVoiceRange = self.playVoiceRange;
        let fesVoiceData = self.fesVoiceData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let fesVoiceWeight = self.fesVoiceWeight.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let extraVoiceConfigData = self.extraVoiceConfigData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_CharWordTable::create(
            _fbb,
            &clz_Torappu_CharWordTableArgs {
                charWords,
                charExtraWords,
                voiceLangDict,
                defaultLangType,
                newTagList,
                voiceLangTypeDict,
                voiceLangGroupTypeDict,
                charDefaultTypeDict,
                startTimeWithTypeDict,
                displayGroupTypeList,
                displayTypeList,
                playVoiceRange,
                fesVoiceData,
                fesVoiceWeight,
                extraVoiceConfigData,
            },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_CharWordTable`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_char_word_table_unchecked`.
pub fn root_as_clz_torappu_char_word_table(
    buf: &[u8],
) -> Result<clz_Torappu_CharWordTable, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_CharWordTable>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_CharWordTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_char_word_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_char_word_table(
    buf: &[u8],
) -> Result<clz_Torappu_CharWordTable, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_CharWordTable>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_CharWordTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_char_word_table_unchecked`.
pub fn root_as_clz_torappu_char_word_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_CharWordTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_CharWordTable<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_CharWordTable` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_char_word_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_char_word_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_CharWordTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_CharWordTable<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_CharWordTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_CharWordTable`.
pub unsafe fn root_as_clz_torappu_char_word_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_CharWordTable {
    unsafe { flatbuffers::root_unchecked::<clz_Torappu_CharWordTable>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_CharWordTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_CharWordTable`.
pub unsafe fn size_prefixed_root_as_clz_torappu_char_word_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_CharWordTable {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_CharWordTable>(buf) }
}
#[inline]
pub fn finish_clz_torappu_char_word_table_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_CharWordTable<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_char_word_table_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_CharWordTable<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
