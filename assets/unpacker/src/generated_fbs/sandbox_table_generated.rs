// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_TIP_DATA_CATEGORY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_TIP_DATA_CATEGORY: i32 = 31;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_TIP_DATA_CATEGORY: [enum__Torappu_TipData_Category; 7] = [
    enum__Torappu_TipData_Category::NONE,
    enum__Torappu_TipData_Category::BATTLE,
    enum__Torappu_TipData_Category::UI,
    enum__Torappu_TipData_Category::BUILDING,
    enum__Torappu_TipData_Category::GACHA,
    enum__Torappu_TipData_Category::MISC,
    enum__Torappu_TipData_Category::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_TipData_Category(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_TipData_Category {
    pub const NONE: Self = Self(0);
    pub const BATTLE: Self = Self(1);
    pub const UI: Self = Self(2);
    pub const BUILDING: Self = Self(4);
    pub const GACHA: Self = Self(8);
    pub const MISC: Self = Self(16);
    pub const ALL: Self = Self(31);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 31;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::BATTLE,
        Self::UI,
        Self::BUILDING,
        Self::GACHA,
        Self::MISC,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::BATTLE => Some("BATTLE"),
            Self::UI => Some("UI"),
            Self::BUILDING => Some("BUILDING"),
            Self::GACHA => Some("GACHA"),
            Self::MISC => Some("MISC"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_TipData_Category {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_TipData_Category {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_TipData_Category {
    type Output = enum__Torappu_TipData_Category;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_TipData_Category {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_TipData_Category {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_TipData_Category {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_FOOD_MAT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_FOOD_MAT_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_FOOD_MAT_TYPE: [enum__Torappu_SandboxFoodMatType; 2] = [
    enum__Torappu_SandboxFoodMatType::MAIN,
    enum__Torappu_SandboxFoodMatType::SUB,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxFoodMatType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxFoodMatType {
    pub const MAIN: Self = Self(0);
    pub const SUB: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::MAIN, Self::SUB];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::MAIN => Some("MAIN"),
            Self::SUB => Some("SUB"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxFoodMatType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxFoodMatType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxFoodMatType {
    type Output = enum__Torappu_SandboxFoodMatType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxFoodMatType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxFoodMatType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxFoodMatType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_BUILDING_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_BUILDING_ITEM_TYPE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_BUILDING_ITEM_TYPE:
    [enum__Torappu_SandboxBuildingItemType; 5] = [
    enum__Torappu_SandboxBuildingItemType::NONE,
    enum__Torappu_SandboxBuildingItemType::PRODUCTION,
    enum__Torappu_SandboxBuildingItemType::SCOUT,
    enum__Torappu_SandboxBuildingItemType::BATTLE,
    enum__Torappu_SandboxBuildingItemType::FUNCTION,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxBuildingItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxBuildingItemType {
    pub const NONE: Self = Self(0);
    pub const PRODUCTION: Self = Self(1);
    pub const SCOUT: Self = Self(2);
    pub const BATTLE: Self = Self(3);
    pub const FUNCTION: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::PRODUCTION,
        Self::SCOUT,
        Self::BATTLE,
        Self::FUNCTION,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::PRODUCTION => Some("PRODUCTION"),
            Self::SCOUT => Some("SCOUT"),
            Self::BATTLE => Some("BATTLE"),
            Self::FUNCTION => Some("FUNCTION"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxBuildingItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxBuildingItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxBuildingItemType {
    type Output = enum__Torappu_SandboxBuildingItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxBuildingItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxBuildingItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxBuildingItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_CRAFT_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_CRAFT_ITEM_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_CRAFT_ITEM_TYPE: [enum__Torappu_SandboxCraftItemType;
    2] = [
    enum__Torappu_SandboxCraftItemType::SHORT,
    enum__Torappu_SandboxCraftItemType::LONG,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxCraftItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxCraftItemType {
    pub const SHORT: Self = Self(0);
    pub const LONG: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::SHORT, Self::LONG];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::SHORT => Some("SHORT"),
            Self::LONG => Some("LONG"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxCraftItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxCraftItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxCraftItemType {
    type Output = enum__Torappu_SandboxCraftItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxCraftItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxCraftItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxCraftItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_ITEM_TYPE: i32 = 11;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_ITEM_TYPE: [enum__Torappu_SandboxItemType; 12] = [
    enum__Torappu_SandboxItemType::NONE,
    enum__Torappu_SandboxItemType::TACTICAL,
    enum__Torappu_SandboxItemType::STAMINA,
    enum__Torappu_SandboxItemType::STAMINAPOT,
    enum__Torappu_SandboxItemType::BUILDING,
    enum__Torappu_SandboxItemType::BUILDINGMAT,
    enum__Torappu_SandboxItemType::FOOD,
    enum__Torappu_SandboxItemType::FOODMAT,
    enum__Torappu_SandboxItemType::SPECIALMAT,
    enum__Torappu_SandboxItemType::GOLD,
    enum__Torappu_SandboxItemType::CRAFT,
    enum__Torappu_SandboxItemType::PLACEHOLDER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxItemType {
    pub const NONE: Self = Self(0);
    pub const TACTICAL: Self = Self(1);
    pub const STAMINA: Self = Self(2);
    pub const STAMINAPOT: Self = Self(3);
    pub const BUILDING: Self = Self(4);
    pub const BUILDINGMAT: Self = Self(5);
    pub const FOOD: Self = Self(6);
    pub const FOODMAT: Self = Self(7);
    pub const SPECIALMAT: Self = Self(8);
    pub const GOLD: Self = Self(9);
    pub const CRAFT: Self = Self(10);
    pub const PLACEHOLDER: Self = Self(11);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 11;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::TACTICAL,
        Self::STAMINA,
        Self::STAMINAPOT,
        Self::BUILDING,
        Self::BUILDINGMAT,
        Self::FOOD,
        Self::FOODMAT,
        Self::SPECIALMAT,
        Self::GOLD,
        Self::CRAFT,
        Self::PLACEHOLDER,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::TACTICAL => Some("TACTICAL"),
            Self::STAMINA => Some("STAMINA"),
            Self::STAMINAPOT => Some("STAMINAPOT"),
            Self::BUILDING => Some("BUILDING"),
            Self::BUILDINGMAT => Some("BUILDINGMAT"),
            Self::FOOD => Some("FOOD"),
            Self::FOODMAT => Some("FOODMAT"),
            Self::SPECIALMAT => Some("SPECIALMAT"),
            Self::GOLD => Some("GOLD"),
            Self::CRAFT => Some("CRAFT"),
            Self::PLACEHOLDER => Some("PLACEHOLDER"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxItemType {
    type Output = enum__Torappu_SandboxItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_REWARD_TRAP_DROP_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_REWARD_TRAP_DROP_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_REWARD_TRAP_DROP_TYPE:
    [enum__Torappu_SandboxRewardTrapDropType; 4] = [
    enum__Torappu_SandboxRewardTrapDropType::COLLECT,
    enum__Torappu_SandboxRewardTrapDropType::DAILY,
    enum__Torappu_SandboxRewardTrapDropType::ACTIVATE,
    enum__Torappu_SandboxRewardTrapDropType::DURATION,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxRewardTrapDropType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxRewardTrapDropType {
    pub const COLLECT: Self = Self(0);
    pub const DAILY: Self = Self(1);
    pub const ACTIVATE: Self = Self(2);
    pub const DURATION: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::COLLECT, Self::DAILY, Self::ACTIVATE, Self::DURATION];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::COLLECT => Some("COLLECT"),
            Self::DAILY => Some("DAILY"),
            Self::ACTIVATE => Some("ACTIVATE"),
            Self::DURATION => Some("DURATION"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxRewardTrapDropType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxRewardTrapDropType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxRewardTrapDropType {
    type Output = enum__Torappu_SandboxRewardTrapDropType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxRewardTrapDropType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxRewardTrapDropType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxRewardTrapDropType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_NODE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_NODE_TYPE: i32 = 9;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_NODE_TYPE: [enum__Torappu_SandboxNodeType; 10] = [
    enum__Torappu_SandboxNodeType::NONE,
    enum__Torappu_SandboxNodeType::HOME,
    enum__Torappu_SandboxNodeType::BATTLE,
    enum__Torappu_SandboxNodeType::NEST,
    enum__Torappu_SandboxNodeType::COLLECT,
    enum__Torappu_SandboxNodeType::HUNT,
    enum__Torappu_SandboxNodeType::CAVE,
    enum__Torappu_SandboxNodeType::EVENT,
    enum__Torappu_SandboxNodeType::MISSION,
    enum__Torappu_SandboxNodeType::MARKET,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxNodeType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxNodeType {
    pub const NONE: Self = Self(0);
    pub const HOME: Self = Self(1);
    pub const BATTLE: Self = Self(2);
    pub const NEST: Self = Self(3);
    pub const COLLECT: Self = Self(4);
    pub const HUNT: Self = Self(5);
    pub const CAVE: Self = Self(6);
    pub const EVENT: Self = Self(7);
    pub const MISSION: Self = Self(8);
    pub const MARKET: Self = Self(9);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 9;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::HOME,
        Self::BATTLE,
        Self::NEST,
        Self::COLLECT,
        Self::HUNT,
        Self::CAVE,
        Self::EVENT,
        Self::MISSION,
        Self::MARKET,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::HOME => Some("HOME"),
            Self::BATTLE => Some("BATTLE"),
            Self::NEST => Some("NEST"),
            Self::COLLECT => Some("COLLECT"),
            Self::HUNT => Some("HUNT"),
            Self::CAVE => Some("CAVE"),
            Self::EVENT => Some("EVENT"),
            Self::MISSION => Some("MISSION"),
            Self::MARKET => Some("MARKET"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxNodeType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxNodeType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxNodeType {
    type Output = enum__Torappu_SandboxNodeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxNodeType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxNodeType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxNodeType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_WEATHER_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_WEATHER_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_WEATHER_TYPE: [enum__Torappu_SandboxWeatherType; 4] = [
    enum__Torappu_SandboxWeatherType::NORMAL,
    enum__Torappu_SandboxWeatherType::RAINFOREST,
    enum__Torappu_SandboxWeatherType::VOLCANO,
    enum__Torappu_SandboxWeatherType::DESERT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxWeatherType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxWeatherType {
    pub const NORMAL: Self = Self(0);
    pub const RAINFOREST: Self = Self(1);
    pub const VOLCANO: Self = Self(2);
    pub const DESERT: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NORMAL, Self::RAINFOREST, Self::VOLCANO, Self::DESERT];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NORMAL => Some("NORMAL"),
            Self::RAINFOREST => Some("RAINFOREST"),
            Self::VOLCANO => Some("VOLCANO"),
            Self::DESERT => Some("DESERT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxWeatherType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxWeatherType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxWeatherType {
    type Output = enum__Torappu_SandboxWeatherType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxWeatherType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxWeatherType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxWeatherType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_EVENT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_EVENT_TYPE: i32 = 5;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_EVENT_TYPE: [enum__Torappu_SandboxEventType; 6] = [
    enum__Torappu_SandboxEventType::RESOURCE,
    enum__Torappu_SandboxEventType::FOOD,
    enum__Torappu_SandboxEventType::MISSION,
    enum__Torappu_SandboxEventType::BUSINESS,
    enum__Torappu_SandboxEventType::ADVENTURE,
    enum__Torappu_SandboxEventType::MYSTERY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxEventType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxEventType {
    pub const RESOURCE: Self = Self(0);
    pub const FOOD: Self = Self(1);
    pub const MISSION: Self = Self(2);
    pub const BUSINESS: Self = Self(3);
    pub const ADVENTURE: Self = Self(4);
    pub const MYSTERY: Self = Self(5);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 5;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::RESOURCE,
        Self::FOOD,
        Self::MISSION,
        Self::BUSINESS,
        Self::ADVENTURE,
        Self::MYSTERY,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::RESOURCE => Some("RESOURCE"),
            Self::FOOD => Some("FOOD"),
            Self::MISSION => Some("MISSION"),
            Self::BUSINESS => Some("BUSINESS"),
            Self::ADVENTURE => Some("ADVENTURE"),
            Self::MYSTERY => Some("MYSTERY"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxEventType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxEventType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxEventType {
    type Output = enum__Torappu_SandboxEventType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxEventType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxEventType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxEventType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_EVENT_CHOICE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_EVENT_CHOICE_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_EVENT_CHOICE_TYPE:
    [enum__Torappu_SandboxEventChoiceType; 4] = [
    enum__Torappu_SandboxEventChoiceType::LEAVE,
    enum__Torappu_SandboxEventChoiceType::TRADE,
    enum__Torappu_SandboxEventChoiceType::NEXT,
    enum__Torappu_SandboxEventChoiceType::MISSION,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxEventChoiceType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxEventChoiceType {
    pub const LEAVE: Self = Self(0);
    pub const TRADE: Self = Self(1);
    pub const NEXT: Self = Self(2);
    pub const MISSION: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::LEAVE, Self::TRADE, Self::NEXT, Self::MISSION];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::LEAVE => Some("LEAVE"),
            Self::TRADE => Some("TRADE"),
            Self::NEXT => Some("NEXT"),
            Self::MISSION => Some("MISSION"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxEventChoiceType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxEventChoiceType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxEventChoiceType {
    type Output = enum__Torappu_SandboxEventChoiceType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxEventChoiceType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxEventChoiceType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxEventChoiceType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_PROFESSION_ID: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_PROFESSION_ID: i32 = 9;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_PROFESSION_ID: [enum__Torappu_ProfessionID; 10] = [
    enum__Torappu_ProfessionID::WARRIOR,
    enum__Torappu_ProfessionID::SNIPER,
    enum__Torappu_ProfessionID::TANK,
    enum__Torappu_ProfessionID::MEDIC,
    enum__Torappu_ProfessionID::SUPPORT,
    enum__Torappu_ProfessionID::CASTER,
    enum__Torappu_ProfessionID::SPECIAL,
    enum__Torappu_ProfessionID::TOKEN,
    enum__Torappu_ProfessionID::TRAP,
    enum__Torappu_ProfessionID::PIONEER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ProfessionID(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ProfessionID {
    pub const WARRIOR: Self = Self(0);
    pub const SNIPER: Self = Self(1);
    pub const TANK: Self = Self(2);
    pub const MEDIC: Self = Self(3);
    pub const SUPPORT: Self = Self(4);
    pub const CASTER: Self = Self(5);
    pub const SPECIAL: Self = Self(6);
    pub const TOKEN: Self = Self(7);
    pub const TRAP: Self = Self(8);
    pub const PIONEER: Self = Self(9);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 9;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::WARRIOR,
        Self::SNIPER,
        Self::TANK,
        Self::MEDIC,
        Self::SUPPORT,
        Self::CASTER,
        Self::SPECIAL,
        Self::TOKEN,
        Self::TRAP,
        Self::PIONEER,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::WARRIOR => Some("WARRIOR"),
            Self::SNIPER => Some("SNIPER"),
            Self::TANK => Some("TANK"),
            Self::MEDIC => Some("MEDIC"),
            Self::SUPPORT => Some("SUPPORT"),
            Self::CASTER => Some("CASTER"),
            Self::SPECIAL => Some("SPECIAL"),
            Self::TOKEN => Some("TOKEN"),
            Self::TRAP => Some("TRAP"),
            Self::PIONEER => Some("PIONEER"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ProfessionID {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ProfessionID {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ProfessionID {
    type Output = enum__Torappu_ProfessionID;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ProfessionID {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ProfessionID {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ProfessionID {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_PROFESSION_CATEGORY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_PROFESSION_CATEGORY: i32 = 512;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_PROFESSION_CATEGORY: [enum__Torappu_ProfessionCategory; 11] = [
    enum__Torappu_ProfessionCategory::NONE,
    enum__Torappu_ProfessionCategory::WARRIOR,
    enum__Torappu_ProfessionCategory::SNIPER,
    enum__Torappu_ProfessionCategory::TANK,
    enum__Torappu_ProfessionCategory::MEDIC,
    enum__Torappu_ProfessionCategory::SUPPORT,
    enum__Torappu_ProfessionCategory::CASTER,
    enum__Torappu_ProfessionCategory::SPECIAL,
    enum__Torappu_ProfessionCategory::TOKEN,
    enum__Torappu_ProfessionCategory::TRAP,
    enum__Torappu_ProfessionCategory::PIONEER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ProfessionCategory(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ProfessionCategory {
    pub const NONE: Self = Self(0);
    pub const WARRIOR: Self = Self(1);
    pub const SNIPER: Self = Self(2);
    pub const TANK: Self = Self(4);
    pub const MEDIC: Self = Self(8);
    pub const SUPPORT: Self = Self(16);
    pub const CASTER: Self = Self(32);
    pub const SPECIAL: Self = Self(64);
    pub const TOKEN: Self = Self(128);
    pub const TRAP: Self = Self(256);
    pub const PIONEER: Self = Self(512);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 512;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::WARRIOR,
        Self::SNIPER,
        Self::TANK,
        Self::MEDIC,
        Self::SUPPORT,
        Self::CASTER,
        Self::SPECIAL,
        Self::TOKEN,
        Self::TRAP,
        Self::PIONEER,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::WARRIOR => Some("WARRIOR"),
            Self::SNIPER => Some("SNIPER"),
            Self::TANK => Some("TANK"),
            Self::MEDIC => Some("MEDIC"),
            Self::SUPPORT => Some("SUPPORT"),
            Self::CASTER => Some("CASTER"),
            Self::SPECIAL => Some("SPECIAL"),
            Self::TOKEN => Some("TOKEN"),
            Self::TRAP => Some("TRAP"),
            Self::PIONEER => Some("PIONEER"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ProfessionCategory {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ProfessionCategory {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ProfessionCategory {
    type Output = enum__Torappu_ProfessionCategory;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ProfessionCategory {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ProfessionCategory {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ProfessionCategory {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_DAILY_DESC_TEMPLATE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_DAILY_DESC_TEMPLATE_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_DAILY_DESC_TEMPLATE_TYPE:
    [enum__Torappu_SandboxDailyDescTemplateType; 4] = [
    enum__Torappu_SandboxDailyDescTemplateType::VISITOR,
    enum__Torappu_SandboxDailyDescTemplateType::RARE_ANIMAL,
    enum__Torappu_SandboxDailyDescTemplateType::WANDER,
    enum__Torappu_SandboxDailyDescTemplateType::MARKET,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxDailyDescTemplateType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxDailyDescTemplateType {
    pub const VISITOR: Self = Self(0);
    pub const RARE_ANIMAL: Self = Self(1);
    pub const WANDER: Self = Self(2);
    pub const MARKET: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::VISITOR, Self::RARE_ANIMAL, Self::WANDER, Self::MARKET];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::VISITOR => Some("VISITOR"),
            Self::RARE_ANIMAL => Some("RARE_ANIMAL"),
            Self::WANDER => Some("WANDER"),
            Self::MARKET => Some("MARKET"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxDailyDescTemplateType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxDailyDescTemplateType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxDailyDescTemplateType {
    type Output = enum__Torappu_SandboxDailyDescTemplateType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxDailyDescTemplateType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxDailyDescTemplateType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxDailyDescTemplateType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SANDBOX_ENEMY_RUSH_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SANDBOX_ENEMY_RUSH_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SANDBOX_ENEMY_RUSH_TYPE: [enum__Torappu_SandboxEnemyRushType;
    3] = [
    enum__Torappu_SandboxEnemyRushType::NORMAL,
    enum__Torappu_SandboxEnemyRushType::ELITE,
    enum__Torappu_SandboxEnemyRushType::BOSS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SandboxEnemyRushType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SandboxEnemyRushType {
    pub const NORMAL: Self = Self(0);
    pub const ELITE: Self = Self(1);
    pub const BOSS: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NORMAL, Self::ELITE, Self::BOSS];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NORMAL => Some("NORMAL"),
            Self::ELITE => Some("ELITE"),
            Self::BOSS => Some("BOSS"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SandboxEnemyRushType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SandboxEnemyRushType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SandboxEnemyRushType {
    type Output = enum__Torappu_SandboxEnemyRushType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SandboxEnemyRushType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SandboxEnemyRushType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SandboxEnemyRushType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUILDABLE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUILDABLE_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUILDABLE_TYPE: [enum__Torappu_BuildableType; 4] = [
    enum__Torappu_BuildableType::NONE,
    enum__Torappu_BuildableType::MELEE,
    enum__Torappu_BuildableType::RANGED,
    enum__Torappu_BuildableType::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuildableType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuildableType {
    pub const NONE: Self = Self(0);
    pub const MELEE: Self = Self(1);
    pub const RANGED: Self = Self(2);
    pub const ALL: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::MELEE, Self::RANGED, Self::ALL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MELEE => Some("MELEE"),
            Self::RANGED => Some("RANGED"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuildableType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuildableType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuildableType {
    type Output = enum__Torappu_BuildableType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuildableType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuildableType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuildableType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_LEVEL_DATA_DIFFICULTY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_LEVEL_DATA_DIFFICULTY: i32 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_LEVEL_DATA_DIFFICULTY: [enum__Torappu_LevelData_Difficulty; 5] = [
    enum__Torappu_LevelData_Difficulty::NONE,
    enum__Torappu_LevelData_Difficulty::NORMAL,
    enum__Torappu_LevelData_Difficulty::FOUR_STAR,
    enum__Torappu_LevelData_Difficulty::EASY,
    enum__Torappu_LevelData_Difficulty::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_LevelData_Difficulty(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_LevelData_Difficulty {
    pub const NONE: Self = Self(0);
    pub const NORMAL: Self = Self(1);
    pub const FOUR_STAR: Self = Self(2);
    pub const EASY: Self = Self(4);
    pub const ALL: Self = Self(7);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 7;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::NORMAL,
        Self::FOUR_STAR,
        Self::EASY,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::NORMAL => Some("NORMAL"),
            Self::FOUR_STAR => Some("FOUR_STAR"),
            Self::EASY => Some("EASY"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_LevelData_Difficulty {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_LevelData_Difficulty {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_LevelData_Difficulty {
    type Output = enum__Torappu_LevelData_Difficulty;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_LevelData_Difficulty {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_LevelData_Difficulty {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_LevelData_Difficulty {}
pub enum clz_Torappu_SandboxMapConstTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxMapConstTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxMapConstTable<'a> {
    type Inner = clz_Torappu_SandboxMapConstTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxMapConstTable<'a> {
    pub const VT_DIRECTIONNAMES: flatbuffers::VOffsetT = 4;
    pub const VT_HOMENODESTAGEID: flatbuffers::VOffsetT = 6;
    pub const VT_HOMERUSHSTAGECODE: flatbuffers::VOffsetT = 8;
    pub const VT_HOMERUSHSTAGENAME: flatbuffers::VOffsetT = 10;
    pub const VT_HOMERUSHDESC: flatbuffers::VOffsetT = 12;
    pub const VT_CRAZYREVENGERUSHGROUP: flatbuffers::VOffsetT = 14;
    pub const VT_HOMEBUILDMODEBGM: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxMapConstTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxMapConstTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxMapConstTable<'bldr>> {
        let mut builder = clz_Torappu_SandboxMapConstTableBuilder::new(_fbb);
        if let Some(x) = args.homeBuildModeBGM {
            builder.add_homeBuildModeBGM(x);
        }
        if let Some(x) = args.crazyRevengeRushGroup {
            builder.add_crazyRevengeRushGroup(x);
        }
        if let Some(x) = args.homeRushDesc {
            builder.add_homeRushDesc(x);
        }
        if let Some(x) = args.homeRushStageName {
            builder.add_homeRushStageName(x);
        }
        if let Some(x) = args.homeRushStageCode {
            builder.add_homeRushStageCode(x);
        }
        if let Some(x) = args.homeNodeStageId {
            builder.add_homeNodeStageId(x);
        }
        if let Some(x) = args.directionNames {
            builder.add_directionNames(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn directionNames(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxMapConstTable::VT_DIRECTIONNAMES, None)
        }
    }
    #[inline]
    pub fn homeNodeStageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxMapConstTable::VT_HOMENODESTAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn homeRushStageCode(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxMapConstTable::VT_HOMERUSHSTAGECODE,
                None,
            )
        }
    }
    #[inline]
    pub fn homeRushStageName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxMapConstTable::VT_HOMERUSHSTAGENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn homeRushDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxMapConstTable::VT_HOMERUSHDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn crazyRevengeRushGroup(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxMapConstTable::VT_CRAZYREVENGERUSHGROUP,
                None,
            )
        }
    }
    #[inline]
    pub fn homeBuildModeBGM(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxMapConstTable::VT_HOMEBUILDMODEBGM,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxMapConstTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("directionNames", Self::VT_DIRECTIONNAMES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "homeNodeStageId",
                Self::VT_HOMENODESTAGEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "homeRushStageCode",
                Self::VT_HOMERUSHSTAGECODE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "homeRushStageName",
                Self::VT_HOMERUSHSTAGENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "homeRushDesc",
                Self::VT_HOMERUSHDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "crazyRevengeRushGroup",
                Self::VT_CRAZYREVENGERUSHGROUP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "homeBuildModeBGM",
                Self::VT_HOMEBUILDMODEBGM,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxMapConstTableArgs<'a> {
    pub directionNames: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub homeNodeStageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub homeRushStageCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub homeRushStageName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub homeRushDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub crazyRevengeRushGroup: Option<flatbuffers::WIPOffset<&'a str>>,
    pub homeBuildModeBGM: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxMapConstTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxMapConstTableArgs {
            directionNames: None,
            homeNodeStageId: None,
            homeRushStageCode: None,
            homeRushStageName: None,
            homeRushDesc: None,
            crazyRevengeRushGroup: None,
            homeBuildModeBGM: None,
        }
    }
}

pub struct clz_Torappu_SandboxMapConstTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxMapConstTableBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_directionNames(
        &mut self,
        directionNames: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxMapConstTable::VT_DIRECTIONNAMES,
            directionNames,
        );
    }
    #[inline]
    pub fn add_homeNodeStageId(&mut self, homeNodeStageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxMapConstTable::VT_HOMENODESTAGEID,
            homeNodeStageId,
        );
    }
    #[inline]
    pub fn add_homeRushStageCode(&mut self, homeRushStageCode: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxMapConstTable::VT_HOMERUSHSTAGECODE,
            homeRushStageCode,
        );
    }
    #[inline]
    pub fn add_homeRushStageName(&mut self, homeRushStageName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxMapConstTable::VT_HOMERUSHSTAGENAME,
            homeRushStageName,
        );
    }
    #[inline]
    pub fn add_homeRushDesc(&mut self, homeRushDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxMapConstTable::VT_HOMERUSHDESC,
            homeRushDesc,
        );
    }
    #[inline]
    pub fn add_crazyRevengeRushGroup(
        &mut self,
        crazyRevengeRushGroup: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxMapConstTable::VT_CRAZYREVENGERUSHGROUP,
            crazyRevengeRushGroup,
        );
    }
    #[inline]
    pub fn add_homeBuildModeBGM(&mut self, homeBuildModeBGM: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxMapConstTable::VT_HOMEBUILDMODEBGM,
            homeBuildModeBGM,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxMapConstTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxMapConstTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxMapConstTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxMapConstTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxMapConstTable");
        ds.field("directionNames", &self.directionNames());
        ds.field("homeNodeStageId", &self.homeNodeStageId());
        ds.field("homeRushStageCode", &self.homeRushStageCode());
        ds.field("homeRushStageName", &self.homeRushStageName());
        ds.field("homeRushDesc", &self.homeRushDesc());
        ds.field("crazyRevengeRushGroup", &self.crazyRevengeRushGroup());
        ds.field("homeBuildModeBGM", &self.homeBuildModeBGM());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxBaseConstTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxBaseConstTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxBaseConstTable<'a> {
    type Inner = clz_Torappu_SandboxBaseConstTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxBaseConstTable<'a> {
    pub const VT_COOKREGULARCOSTITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_COOKREGULARCOSTITEMIDCNT: flatbuffers::VOffsetT = 6;
    pub const VT_SQUADTABNAMELIST: flatbuffers::VOffsetT = 8;
    pub const VT_CHARRARITYCOLORLIST: flatbuffers::VOffsetT = 10;
    pub const VT_SUMFOODLIMITEDCOUNT: flatbuffers::VOffsetT = 12;
    pub const VT_SUMBUILDINGLIMITEDCOUNT: flatbuffers::VOffsetT = 14;
    pub const VT_SUMTACTICALLIMITEDCOUNT: flatbuffers::VOffsetT = 16;
    pub const VT_SUMFOODMATLIMITEDCOUNT: flatbuffers::VOffsetT = 18;
    pub const VT_SUMBUILDINGMATLIMITEDCOUNT: flatbuffers::VOffsetT = 20;
    pub const VT_SUMSTAMINAPOTLIMITEDCOUNT: flatbuffers::VOffsetT = 22;
    pub const VT_SUMGOLDLIMITEDCOUNT: flatbuffers::VOffsetT = 24;
    pub const VT_ITEMLIMITEDCOUNT: flatbuffers::VOffsetT = 26;
    pub const VT_BLACKBOXSLOTCNT: flatbuffers::VOffsetT = 28;
    pub const VT_SCOUTNODEUPGRADEID: flatbuffers::VOffsetT = 30;
    pub const VT_BATTLENODEUPGRADEID: flatbuffers::VOffsetT = 32;
    pub const VT_STAMINAPOTCOSTONCE: flatbuffers::VOffsetT = 34;
    pub const VT_STAMINAPOTITEMID: flatbuffers::VOffsetT = 36;
    pub const VT_STAMINAPOTREDMINCNT: flatbuffers::VOffsetT = 38;
    pub const VT_STAMINAPOTYELLOWMINCNT: flatbuffers::VOffsetT = 40;
    pub const VT_STAMINAPOTGREENMINCNT: flatbuffers::VOffsetT = 42;
    pub const VT_STAMINAPOTMAXPERCENTCNT: flatbuffers::VOffsetT = 44;
    pub const VT_STAMINAPOTACTIONPOINT: flatbuffers::VOffsetT = 46;
    pub const VT_GOLDITEMID: flatbuffers::VOffsetT = 48;
    pub const VT_TOOLBOXSLOTCAPACITY: flatbuffers::VOffsetT = 50;
    pub const VT_TOOLBOXSLOTCNT: flatbuffers::VOffsetT = 52;
    pub const VT_TEAMPOPULATIONLIMIT: flatbuffers::VOffsetT = 54;
    pub const VT_RESEARCHINFORMATIONDESC: flatbuffers::VOffsetT = 56;
    pub const VT_SETTLEFAILDESC: flatbuffers::VOffsetT = 58;
    pub const VT_SETTLEABORTDESC: flatbuffers::VOffsetT = 60;
    pub const VT_SETTLESUCDESC: flatbuffers::VOffsetT = 62;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxBaseConstTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxBaseConstTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxBaseConstTable<'bldr>> {
        let mut builder = clz_Torappu_SandboxBaseConstTableBuilder::new(_fbb);
        if let Some(x) = args.settleSucDesc {
            builder.add_settleSucDesc(x);
        }
        if let Some(x) = args.settleAbortDesc {
            builder.add_settleAbortDesc(x);
        }
        if let Some(x) = args.settleFailDesc {
            builder.add_settleFailDesc(x);
        }
        if let Some(x) = args.researchInformationDesc {
            builder.add_researchInformationDesc(x);
        }
        builder.add_teamPopulationLimit(args.teamPopulationLimit);
        builder.add_toolboxSlotCnt(args.toolboxSlotCnt);
        builder.add_toolboxSlotCapacity(args.toolboxSlotCapacity);
        if let Some(x) = args.goldItemId {
            builder.add_goldItemId(x);
        }
        builder.add_staminaPotActionPoint(args.staminaPotActionPoint);
        builder.add_staminapotMaxPercentCnt(args.staminapotMaxPercentCnt);
        builder.add_staminapotGreenMinCnt(args.staminapotGreenMinCnt);
        builder.add_staminapotYellowMinCnt(args.staminapotYellowMinCnt);
        builder.add_staminapotRedMinCnt(args.staminapotRedMinCnt);
        if let Some(x) = args.staminaPotItemId {
            builder.add_staminaPotItemId(x);
        }
        builder.add_staminaPotCostOnce(args.staminaPotCostOnce);
        if let Some(x) = args.battleNodeUpgradeId {
            builder.add_battleNodeUpgradeId(x);
        }
        if let Some(x) = args.scoutNodeUpgradeId {
            builder.add_scoutNodeUpgradeId(x);
        }
        builder.add_blackBoxSlotCnt(args.blackBoxSlotCnt);
        builder.add_itemLimitedCount(args.itemLimitedCount);
        builder.add_sumGoldLimitedCount(args.sumGoldLimitedCount);
        builder.add_sumStaminaPotLimitedCount(args.sumStaminaPotLimitedCount);
        builder.add_sumBuildingMatLimitedCount(args.sumBuildingMatLimitedCount);
        builder.add_sumFoodMatLimitedCount(args.sumFoodMatLimitedCount);
        builder.add_sumTacticalLimitedCount(args.sumTacticalLimitedCount);
        builder.add_sumBuildingLimitedCount(args.sumBuildingLimitedCount);
        builder.add_sumFoodLimitedCount(args.sumFoodLimitedCount);
        if let Some(x) = args.charRarityColorList {
            builder.add_charRarityColorList(x);
        }
        if let Some(x) = args.squadTabNameList {
            builder.add_squadTabNameList(x);
        }
        builder.add_cookRegularCostItemIdCnt(args.cookRegularCostItemIdCnt);
        if let Some(x) = args.cookRegularCostItemId {
            builder.add_cookRegularCostItemId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn cookRegularCostItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxBaseConstTable::VT_COOKREGULARCOSTITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn cookRegularCostItemIdCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxBaseConstTable::VT_COOKREGULARCOSTITEMIDCNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn squadTabNameList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxBaseConstTable::VT_SQUADTABNAMELIST, None)
        }
    }
    #[inline]
    pub fn charRarityColorList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxBaseConstTable::VT_CHARRARITYCOLORLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn sumFoodLimitedCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxBaseConstTable::VT_SUMFOODLIMITEDCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sumBuildingLimitedCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxBaseConstTable::VT_SUMBUILDINGLIMITEDCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sumTacticalLimitedCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxBaseConstTable::VT_SUMTACTICALLIMITEDCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sumFoodMatLimitedCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxBaseConstTable::VT_SUMFOODMATLIMITEDCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sumBuildingMatLimitedCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxBaseConstTable::VT_SUMBUILDINGMATLIMITEDCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sumStaminaPotLimitedCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxBaseConstTable::VT_SUMSTAMINAPOTLIMITEDCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sumGoldLimitedCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxBaseConstTable::VT_SUMGOLDLIMITEDCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn itemLimitedCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxBaseConstTable::VT_ITEMLIMITEDCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn blackBoxSlotCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxBaseConstTable::VT_BLACKBOXSLOTCNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn scoutNodeUpgradeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxBaseConstTable::VT_SCOUTNODEUPGRADEID,
                None,
            )
        }
    }
    #[inline]
    pub fn battleNodeUpgradeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxBaseConstTable::VT_BATTLENODEUPGRADEID,
                None,
            )
        }
    }
    #[inline]
    pub fn staminaPotCostOnce(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxBaseConstTable::VT_STAMINAPOTCOSTONCE,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn staminaPotItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxBaseConstTable::VT_STAMINAPOTITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn staminapotRedMinCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxBaseConstTable::VT_STAMINAPOTREDMINCNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn staminapotYellowMinCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxBaseConstTable::VT_STAMINAPOTYELLOWMINCNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn staminapotGreenMinCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxBaseConstTable::VT_STAMINAPOTGREENMINCNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn staminapotMaxPercentCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxBaseConstTable::VT_STAMINAPOTMAXPERCENTCNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn staminaPotActionPoint(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxBaseConstTable::VT_STAMINAPOTACTIONPOINT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn goldItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxBaseConstTable::VT_GOLDITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn toolboxSlotCapacity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxBaseConstTable::VT_TOOLBOXSLOTCAPACITY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn toolboxSlotCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxBaseConstTable::VT_TOOLBOXSLOTCNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn teamPopulationLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxBaseConstTable::VT_TEAMPOPULATIONLIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn researchInformationDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxBaseConstTable::VT_RESEARCHINFORMATIONDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn settleFailDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxBaseConstTable::VT_SETTLEFAILDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn settleAbortDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxBaseConstTable::VT_SETTLEABORTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn settleSucDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxBaseConstTable::VT_SETTLESUCDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxBaseConstTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "cookRegularCostItemId",
                Self::VT_COOKREGULARCOSTITEMID,
                false,
            )?
            .visit_field::<i32>(
                "cookRegularCostItemIdCnt",
                Self::VT_COOKREGULARCOSTITEMIDCNT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("squadTabNameList", Self::VT_SQUADTABNAMELIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("charRarityColorList", Self::VT_CHARRARITYCOLORLIST, false)?
            .visit_field::<i32>("sumFoodLimitedCount", Self::VT_SUMFOODLIMITEDCOUNT, false)?
            .visit_field::<i32>(
                "sumBuildingLimitedCount",
                Self::VT_SUMBUILDINGLIMITEDCOUNT,
                false,
            )?
            .visit_field::<i32>(
                "sumTacticalLimitedCount",
                Self::VT_SUMTACTICALLIMITEDCOUNT,
                false,
            )?
            .visit_field::<i32>(
                "sumFoodMatLimitedCount",
                Self::VT_SUMFOODMATLIMITEDCOUNT,
                false,
            )?
            .visit_field::<i32>(
                "sumBuildingMatLimitedCount",
                Self::VT_SUMBUILDINGMATLIMITEDCOUNT,
                false,
            )?
            .visit_field::<i32>(
                "sumStaminaPotLimitedCount",
                Self::VT_SUMSTAMINAPOTLIMITEDCOUNT,
                false,
            )?
            .visit_field::<i32>("sumGoldLimitedCount", Self::VT_SUMGOLDLIMITEDCOUNT, false)?
            .visit_field::<i32>("itemLimitedCount", Self::VT_ITEMLIMITEDCOUNT, false)?
            .visit_field::<i32>("blackBoxSlotCnt", Self::VT_BLACKBOXSLOTCNT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "scoutNodeUpgradeId",
                Self::VT_SCOUTNODEUPGRADEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "battleNodeUpgradeId",
                Self::VT_BATTLENODEUPGRADEID,
                false,
            )?
            .visit_field::<i32>("staminaPotCostOnce", Self::VT_STAMINAPOTCOSTONCE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "staminaPotItemId",
                Self::VT_STAMINAPOTITEMID,
                false,
            )?
            .visit_field::<i32>("staminapotRedMinCnt", Self::VT_STAMINAPOTREDMINCNT, false)?
            .visit_field::<i32>(
                "staminapotYellowMinCnt",
                Self::VT_STAMINAPOTYELLOWMINCNT,
                false,
            )?
            .visit_field::<i32>(
                "staminapotGreenMinCnt",
                Self::VT_STAMINAPOTGREENMINCNT,
                false,
            )?
            .visit_field::<i32>(
                "staminapotMaxPercentCnt",
                Self::VT_STAMINAPOTMAXPERCENTCNT,
                false,
            )?
            .visit_field::<i32>(
                "staminaPotActionPoint",
                Self::VT_STAMINAPOTACTIONPOINT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "goldItemId",
                Self::VT_GOLDITEMID,
                false,
            )?
            .visit_field::<i32>("toolboxSlotCapacity", Self::VT_TOOLBOXSLOTCAPACITY, false)?
            .visit_field::<i32>("toolboxSlotCnt", Self::VT_TOOLBOXSLOTCNT, false)?
            .visit_field::<i32>("teamPopulationLimit", Self::VT_TEAMPOPULATIONLIMIT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "researchInformationDesc",
                Self::VT_RESEARCHINFORMATIONDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "settleFailDesc",
                Self::VT_SETTLEFAILDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "settleAbortDesc",
                Self::VT_SETTLEABORTDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "settleSucDesc",
                Self::VT_SETTLESUCDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxBaseConstTableArgs<'a> {
    pub cookRegularCostItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cookRegularCostItemIdCnt: i32,
    pub squadTabNameList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub charRarityColorList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub sumFoodLimitedCount: i32,
    pub sumBuildingLimitedCount: i32,
    pub sumTacticalLimitedCount: i32,
    pub sumFoodMatLimitedCount: i32,
    pub sumBuildingMatLimitedCount: i32,
    pub sumStaminaPotLimitedCount: i32,
    pub sumGoldLimitedCount: i32,
    pub itemLimitedCount: i32,
    pub blackBoxSlotCnt: i32,
    pub scoutNodeUpgradeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub battleNodeUpgradeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub staminaPotCostOnce: i32,
    pub staminaPotItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub staminapotRedMinCnt: i32,
    pub staminapotYellowMinCnt: i32,
    pub staminapotGreenMinCnt: i32,
    pub staminapotMaxPercentCnt: i32,
    pub staminaPotActionPoint: i32,
    pub goldItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub toolboxSlotCapacity: i32,
    pub toolboxSlotCnt: i32,
    pub teamPopulationLimit: i32,
    pub researchInformationDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub settleFailDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub settleAbortDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub settleSucDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxBaseConstTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxBaseConstTableArgs {
            cookRegularCostItemId: None,
            cookRegularCostItemIdCnt: 0,
            squadTabNameList: None,
            charRarityColorList: None,
            sumFoodLimitedCount: 0,
            sumBuildingLimitedCount: 0,
            sumTacticalLimitedCount: 0,
            sumFoodMatLimitedCount: 0,
            sumBuildingMatLimitedCount: 0,
            sumStaminaPotLimitedCount: 0,
            sumGoldLimitedCount: 0,
            itemLimitedCount: 0,
            blackBoxSlotCnt: 0,
            scoutNodeUpgradeId: None,
            battleNodeUpgradeId: None,
            staminaPotCostOnce: 0,
            staminaPotItemId: None,
            staminapotRedMinCnt: 0,
            staminapotYellowMinCnt: 0,
            staminapotGreenMinCnt: 0,
            staminapotMaxPercentCnt: 0,
            staminaPotActionPoint: 0,
            goldItemId: None,
            toolboxSlotCapacity: 0,
            toolboxSlotCnt: 0,
            teamPopulationLimit: 0,
            researchInformationDesc: None,
            settleFailDesc: None,
            settleAbortDesc: None,
            settleSucDesc: None,
        }
    }
}

pub struct clz_Torappu_SandboxBaseConstTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxBaseConstTableBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_cookRegularCostItemId(
        &mut self,
        cookRegularCostItemId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxBaseConstTable::VT_COOKREGULARCOSTITEMID,
            cookRegularCostItemId,
        );
    }
    #[inline]
    pub fn add_cookRegularCostItemIdCnt(&mut self, cookRegularCostItemIdCnt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxBaseConstTable::VT_COOKREGULARCOSTITEMIDCNT,
            cookRegularCostItemIdCnt,
            0,
        );
    }
    #[inline]
    pub fn add_squadTabNameList(
        &mut self,
        squadTabNameList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxBaseConstTable::VT_SQUADTABNAMELIST,
            squadTabNameList,
        );
    }
    #[inline]
    pub fn add_charRarityColorList(
        &mut self,
        charRarityColorList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxBaseConstTable::VT_CHARRARITYCOLORLIST,
            charRarityColorList,
        );
    }
    #[inline]
    pub fn add_sumFoodLimitedCount(&mut self, sumFoodLimitedCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxBaseConstTable::VT_SUMFOODLIMITEDCOUNT,
            sumFoodLimitedCount,
            0,
        );
    }
    #[inline]
    pub fn add_sumBuildingLimitedCount(&mut self, sumBuildingLimitedCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxBaseConstTable::VT_SUMBUILDINGLIMITEDCOUNT,
            sumBuildingLimitedCount,
            0,
        );
    }
    #[inline]
    pub fn add_sumTacticalLimitedCount(&mut self, sumTacticalLimitedCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxBaseConstTable::VT_SUMTACTICALLIMITEDCOUNT,
            sumTacticalLimitedCount,
            0,
        );
    }
    #[inline]
    pub fn add_sumFoodMatLimitedCount(&mut self, sumFoodMatLimitedCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxBaseConstTable::VT_SUMFOODMATLIMITEDCOUNT,
            sumFoodMatLimitedCount,
            0,
        );
    }
    #[inline]
    pub fn add_sumBuildingMatLimitedCount(&mut self, sumBuildingMatLimitedCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxBaseConstTable::VT_SUMBUILDINGMATLIMITEDCOUNT,
            sumBuildingMatLimitedCount,
            0,
        );
    }
    #[inline]
    pub fn add_sumStaminaPotLimitedCount(&mut self, sumStaminaPotLimitedCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxBaseConstTable::VT_SUMSTAMINAPOTLIMITEDCOUNT,
            sumStaminaPotLimitedCount,
            0,
        );
    }
    #[inline]
    pub fn add_sumGoldLimitedCount(&mut self, sumGoldLimitedCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxBaseConstTable::VT_SUMGOLDLIMITEDCOUNT,
            sumGoldLimitedCount,
            0,
        );
    }
    #[inline]
    pub fn add_itemLimitedCount(&mut self, itemLimitedCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxBaseConstTable::VT_ITEMLIMITEDCOUNT,
            itemLimitedCount,
            0,
        );
    }
    #[inline]
    pub fn add_blackBoxSlotCnt(&mut self, blackBoxSlotCnt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxBaseConstTable::VT_BLACKBOXSLOTCNT,
            blackBoxSlotCnt,
            0,
        );
    }
    #[inline]
    pub fn add_scoutNodeUpgradeId(&mut self, scoutNodeUpgradeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxBaseConstTable::VT_SCOUTNODEUPGRADEID,
            scoutNodeUpgradeId,
        );
    }
    #[inline]
    pub fn add_battleNodeUpgradeId(
        &mut self,
        battleNodeUpgradeId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxBaseConstTable::VT_BATTLENODEUPGRADEID,
            battleNodeUpgradeId,
        );
    }
    #[inline]
    pub fn add_staminaPotCostOnce(&mut self, staminaPotCostOnce: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxBaseConstTable::VT_STAMINAPOTCOSTONCE,
            staminaPotCostOnce,
            0,
        );
    }
    #[inline]
    pub fn add_staminaPotItemId(&mut self, staminaPotItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxBaseConstTable::VT_STAMINAPOTITEMID,
            staminaPotItemId,
        );
    }
    #[inline]
    pub fn add_staminapotRedMinCnt(&mut self, staminapotRedMinCnt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxBaseConstTable::VT_STAMINAPOTREDMINCNT,
            staminapotRedMinCnt,
            0,
        );
    }
    #[inline]
    pub fn add_staminapotYellowMinCnt(&mut self, staminapotYellowMinCnt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxBaseConstTable::VT_STAMINAPOTYELLOWMINCNT,
            staminapotYellowMinCnt,
            0,
        );
    }
    #[inline]
    pub fn add_staminapotGreenMinCnt(&mut self, staminapotGreenMinCnt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxBaseConstTable::VT_STAMINAPOTGREENMINCNT,
            staminapotGreenMinCnt,
            0,
        );
    }
    #[inline]
    pub fn add_staminapotMaxPercentCnt(&mut self, staminapotMaxPercentCnt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxBaseConstTable::VT_STAMINAPOTMAXPERCENTCNT,
            staminapotMaxPercentCnt,
            0,
        );
    }
    #[inline]
    pub fn add_staminaPotActionPoint(&mut self, staminaPotActionPoint: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxBaseConstTable::VT_STAMINAPOTACTIONPOINT,
            staminaPotActionPoint,
            0,
        );
    }
    #[inline]
    pub fn add_goldItemId(&mut self, goldItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxBaseConstTable::VT_GOLDITEMID,
            goldItemId,
        );
    }
    #[inline]
    pub fn add_toolboxSlotCapacity(&mut self, toolboxSlotCapacity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxBaseConstTable::VT_TOOLBOXSLOTCAPACITY,
            toolboxSlotCapacity,
            0,
        );
    }
    #[inline]
    pub fn add_toolboxSlotCnt(&mut self, toolboxSlotCnt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxBaseConstTable::VT_TOOLBOXSLOTCNT,
            toolboxSlotCnt,
            0,
        );
    }
    #[inline]
    pub fn add_teamPopulationLimit(&mut self, teamPopulationLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxBaseConstTable::VT_TEAMPOPULATIONLIMIT,
            teamPopulationLimit,
            0,
        );
    }
    #[inline]
    pub fn add_researchInformationDesc(
        &mut self,
        researchInformationDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxBaseConstTable::VT_RESEARCHINFORMATIONDESC,
            researchInformationDesc,
        );
    }
    #[inline]
    pub fn add_settleFailDesc(&mut self, settleFailDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxBaseConstTable::VT_SETTLEFAILDESC,
            settleFailDesc,
        );
    }
    #[inline]
    pub fn add_settleAbortDesc(&mut self, settleAbortDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxBaseConstTable::VT_SETTLEABORTDESC,
            settleAbortDesc,
        );
    }
    #[inline]
    pub fn add_settleSucDesc(&mut self, settleSucDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxBaseConstTable::VT_SETTLESUCDESC,
            settleSucDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxBaseConstTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxBaseConstTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxBaseConstTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxBaseConstTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxBaseConstTable");
        ds.field("cookRegularCostItemId", &self.cookRegularCostItemId());
        ds.field("cookRegularCostItemIdCnt", &self.cookRegularCostItemIdCnt());
        ds.field("squadTabNameList", &self.squadTabNameList());
        ds.field("charRarityColorList", &self.charRarityColorList());
        ds.field("sumFoodLimitedCount", &self.sumFoodLimitedCount());
        ds.field("sumBuildingLimitedCount", &self.sumBuildingLimitedCount());
        ds.field("sumTacticalLimitedCount", &self.sumTacticalLimitedCount());
        ds.field("sumFoodMatLimitedCount", &self.sumFoodMatLimitedCount());
        ds.field(
            "sumBuildingMatLimitedCount",
            &self.sumBuildingMatLimitedCount(),
        );
        ds.field(
            "sumStaminaPotLimitedCount",
            &self.sumStaminaPotLimitedCount(),
        );
        ds.field("sumGoldLimitedCount", &self.sumGoldLimitedCount());
        ds.field("itemLimitedCount", &self.itemLimitedCount());
        ds.field("blackBoxSlotCnt", &self.blackBoxSlotCnt());
        ds.field("scoutNodeUpgradeId", &self.scoutNodeUpgradeId());
        ds.field("battleNodeUpgradeId", &self.battleNodeUpgradeId());
        ds.field("staminaPotCostOnce", &self.staminaPotCostOnce());
        ds.field("staminaPotItemId", &self.staminaPotItemId());
        ds.field("staminapotRedMinCnt", &self.staminapotRedMinCnt());
        ds.field("staminapotYellowMinCnt", &self.staminapotYellowMinCnt());
        ds.field("staminapotGreenMinCnt", &self.staminapotGreenMinCnt());
        ds.field("staminapotMaxPercentCnt", &self.staminapotMaxPercentCnt());
        ds.field("staminaPotActionPoint", &self.staminaPotActionPoint());
        ds.field("goldItemId", &self.goldItemId());
        ds.field("toolboxSlotCapacity", &self.toolboxSlotCapacity());
        ds.field("toolboxSlotCnt", &self.toolboxSlotCnt());
        ds.field("teamPopulationLimit", &self.teamPopulationLimit());
        ds.field("researchInformationDesc", &self.researchInformationDesc());
        ds.field("settleFailDesc", &self.settleFailDesc());
        ds.field("settleAbortDesc", &self.settleAbortDesc());
        ds.field("settleSucDesc", &self.settleSucDesc());
        ds.finish()
    }
}
pub enum clz_Torappu_TipDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_TipData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_TipData<'a> {
    type Inner = clz_Torappu_TipData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_TipData<'a> {
    pub const VT_TIP: flatbuffers::VOffsetT = 4;
    pub const VT_WEIGHT: flatbuffers::VOffsetT = 6;
    pub const VT_CATEGORY: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_TipData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_TipDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TipData<'bldr>> {
        let mut builder = clz_Torappu_TipDataBuilder::new(_fbb);
        builder.add_category(args.category);
        builder.add_weight(args.weight);
        if let Some(x) = args.tip {
            builder.add_tip(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn tip(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_TipData::VT_TIP, None)
        }
    }
    #[inline]
    pub fn weight(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_TipData::VT_WEIGHT, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn category(&self) -> enum__Torappu_TipData_Category {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_TipData_Category>(
                    clz_Torappu_TipData::VT_CATEGORY,
                    Some(enum__Torappu_TipData_Category::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_TipData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tip", Self::VT_TIP, false)?
            .visit_field::<f32>("weight", Self::VT_WEIGHT, false)?
            .visit_field::<enum__Torappu_TipData_Category>("category", Self::VT_CATEGORY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_TipDataArgs<'a> {
    pub tip: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weight: f32,
    pub category: enum__Torappu_TipData_Category,
}
impl<'a> Default for clz_Torappu_TipDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_TipDataArgs {
            tip: None,
            weight: 0.0,
            category: enum__Torappu_TipData_Category::NONE,
        }
    }
}

pub struct clz_Torappu_TipDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_TipDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_tip(&mut self, tip: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_TipData::VT_TIP, tip);
    }
    #[inline]
    pub fn add_weight(&mut self, weight: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_TipData::VT_WEIGHT, weight, 0.0);
    }
    #[inline]
    pub fn add_category(&mut self, category: enum__Torappu_TipData_Category) {
        self.fbb_.push_slot::<enum__Torappu_TipData_Category>(
            clz_Torappu_TipData::VT_CATEGORY,
            category,
            enum__Torappu_TipData_Category::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_TipDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_TipDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_TipData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_TipData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_TipData");
        ds.field("tip", &self.tip());
        ds.field("weight", &self.weight());
        ds.field("category", &self.category());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxFoodProduceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxFoodProduceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxFoodProduceData<'a> {
    type Inner = clz_Torappu_SandboxFoodProduceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxFoodProduceData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_MAINMATERIALITEMS: flatbuffers::VOffsetT = 6;
    pub const VT_BUFFID: flatbuffers::VOffsetT = 8;
    pub const VT_UNLOCKDESC: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxFoodProduceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxFoodProduceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxFoodProduceData<'bldr>> {
        let mut builder = clz_Torappu_SandboxFoodProduceDataBuilder::new(_fbb);
        if let Some(x) = args.unlockDesc {
            builder.add_unlockDesc(x);
        }
        if let Some(x) = args.buffId {
            builder.add_buffId(x);
        }
        if let Some(x) = args.mainMaterialItems {
            builder.add_mainMaterialItems(x);
        }
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxFoodProduceData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn mainMaterialItems(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxFoodProduceData::VT_MAINMATERIALITEMS,
                None,
            )
        }
    }
    #[inline]
    pub fn buffId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxFoodProduceData::VT_BUFFID,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxFoodProduceData::VT_UNLOCKDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxFoodProduceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("mainMaterialItems", Self::VT_MAINMATERIALITEMS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buffId", Self::VT_BUFFID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockDesc",
                Self::VT_UNLOCKDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxFoodProduceDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mainMaterialItems: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub buffId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxFoodProduceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxFoodProduceDataArgs {
            itemId: None,
            mainMaterialItems: None,
            buffId: None,
            unlockDesc: None,
        }
    }
}

pub struct clz_Torappu_SandboxFoodProduceDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxFoodProduceDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxFoodProduceData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_mainMaterialItems(
        &mut self,
        mainMaterialItems: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxFoodProduceData::VT_MAINMATERIALITEMS,
            mainMaterialItems,
        );
    }
    #[inline]
    pub fn add_buffId(&mut self, buffId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxFoodProduceData::VT_BUFFID,
            buffId,
        );
    }
    #[inline]
    pub fn add_unlockDesc(&mut self, unlockDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxFoodProduceData::VT_UNLOCKDESC,
            unlockDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxFoodProduceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxFoodProduceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxFoodProduceData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxFoodProduceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxFoodProduceData");
        ds.field("itemId", &self.itemId());
        ds.field("mainMaterialItems", &self.mainMaterialItems());
        ds.field("buffId", &self.buffId());
        ds.field("unlockDesc", &self.unlockDesc());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxFoodProduceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxFoodProduceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxFoodProduceData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxFoodProduceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxFoodProduceData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxFoodProduceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxFoodProduceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxFoodProduceData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxFoodProduceDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxFoodProduceData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxFoodProduceData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxFoodProduceData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxFoodProduceData>>(
                    dict__string__clz_Torappu_SandboxFoodProduceData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxFoodProduceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxFoodProduceData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxFoodProduceDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxFoodProduceData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxFoodProduceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxFoodProduceDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxFoodProduceDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxFoodProduceDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxFoodProduceData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxFoodProduceData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxFoodProduceData>>(
                dict__string__clz_Torappu_SandboxFoodProduceData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxFoodProduceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxFoodProduceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxFoodProduceData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxFoodProduceData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxFoodProduceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxFoodProduceData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxFoodmatBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxFoodmatBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxFoodmatBuffData<'a> {
    type Inner = clz_Torappu_SandboxFoodmatBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxFoodmatBuffData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_BUFFID: flatbuffers::VOffsetT = 6;
    pub const VT_BUFFDESC: flatbuffers::VOffsetT = 8;
    pub const VT_MATTYPE: flatbuffers::VOffsetT = 10;
    pub const VT_SORTID: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxFoodmatBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxFoodmatBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxFoodmatBuffData<'bldr>> {
        let mut builder = clz_Torappu_SandboxFoodmatBuffDataBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        builder.add_matType(args.matType);
        if let Some(x) = args.buffDesc {
            builder.add_buffDesc(x);
        }
        if let Some(x) = args.buffId {
            builder.add_buffId(x);
        }
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxFoodmatBuffData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn buffId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxFoodmatBuffData::VT_BUFFID,
                None,
            )
        }
    }
    #[inline]
    pub fn buffDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxFoodmatBuffData::VT_BUFFDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn matType(&self) -> enum__Torappu_SandboxFoodMatType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxFoodMatType>(
                    clz_Torappu_SandboxFoodmatBuffData::VT_MATTYPE,
                    Some(enum__Torappu_SandboxFoodMatType::MAIN),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxFoodmatBuffData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxFoodmatBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buffId", Self::VT_BUFFID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffDesc",
                Self::VT_BUFFDESC,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxFoodMatType>("matType", Self::VT_MATTYPE, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxFoodmatBuffDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub matType: enum__Torappu_SandboxFoodMatType,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_SandboxFoodmatBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxFoodmatBuffDataArgs {
            itemId: None,
            buffId: None,
            buffDesc: None,
            matType: enum__Torappu_SandboxFoodMatType::MAIN,
            sortId: 0,
        }
    }
}

pub struct clz_Torappu_SandboxFoodmatBuffDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxFoodmatBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxFoodmatBuffData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_buffId(&mut self, buffId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxFoodmatBuffData::VT_BUFFID,
            buffId,
        );
    }
    #[inline]
    pub fn add_buffDesc(&mut self, buffDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxFoodmatBuffData::VT_BUFFDESC,
            buffDesc,
        );
    }
    #[inline]
    pub fn add_matType(&mut self, matType: enum__Torappu_SandboxFoodMatType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxFoodMatType>(
            clz_Torappu_SandboxFoodmatBuffData::VT_MATTYPE,
            matType,
            enum__Torappu_SandboxFoodMatType::MAIN,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxFoodmatBuffData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxFoodmatBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxFoodmatBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxFoodmatBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxFoodmatBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxFoodmatBuffData");
        ds.field("itemId", &self.itemId());
        ds.field("buffId", &self.buffId());
        ds.field("buffDesc", &self.buffDesc());
        ds.field("matType", &self.matType());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxFoodmatBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxFoodmatBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxFoodmatBuffData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxFoodmatBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxFoodmatBuffData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxFoodmatBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxFoodmatBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxFoodmatBuffData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxFoodmatBuffDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxFoodmatBuffData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxFoodmatBuffData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxFoodmatBuffData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxFoodmatBuffData>>(
                    dict__string__clz_Torappu_SandboxFoodmatBuffData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxFoodmatBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxFoodmatBuffData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxFoodmatBuffDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxFoodmatBuffData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxFoodmatBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxFoodmatBuffDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxFoodmatBuffDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxFoodmatBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxFoodmatBuffData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxFoodmatBuffData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxFoodmatBuffData>>(
                dict__string__clz_Torappu_SandboxFoodmatBuffData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxFoodmatBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxFoodmatBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxFoodmatBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxFoodmatBuffData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxFoodmatBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxFoodmatBuffData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxFoodStaminaDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxFoodStaminaData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxFoodStaminaData<'a> {
    type Inner = clz_Torappu_SandboxFoodStaminaData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxFoodStaminaData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_POTCNT: flatbuffers::VOffsetT = 6;
    pub const VT_FOODSTAMINACNT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxFoodStaminaData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxFoodStaminaDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxFoodStaminaData<'bldr>> {
        let mut builder = clz_Torappu_SandboxFoodStaminaDataBuilder::new(_fbb);
        builder.add_foodStaminaCnt(args.foodStaminaCnt);
        builder.add_potCnt(args.potCnt);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxFoodStaminaData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn potCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxFoodStaminaData::VT_POTCNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn foodStaminaCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxFoodStaminaData::VT_FOODSTAMINACNT,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxFoodStaminaData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<i32>("potCnt", Self::VT_POTCNT, false)?
            .visit_field::<i32>("foodStaminaCnt", Self::VT_FOODSTAMINACNT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxFoodStaminaDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub potCnt: i32,
    pub foodStaminaCnt: i32,
}
impl<'a> Default for clz_Torappu_SandboxFoodStaminaDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxFoodStaminaDataArgs {
            itemId: None,
            potCnt: 0,
            foodStaminaCnt: 0,
        }
    }
}

pub struct clz_Torappu_SandboxFoodStaminaDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxFoodStaminaDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxFoodStaminaData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_potCnt(&mut self, potCnt: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxFoodStaminaData::VT_POTCNT, potCnt, 0);
    }
    #[inline]
    pub fn add_foodStaminaCnt(&mut self, foodStaminaCnt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxFoodStaminaData::VT_FOODSTAMINACNT,
            foodStaminaCnt,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxFoodStaminaDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxFoodStaminaDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxFoodStaminaData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxFoodStaminaData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxFoodStaminaData");
        ds.field("itemId", &self.itemId());
        ds.field("potCnt", &self.potCnt());
        ds.field("foodStaminaCnt", &self.foodStaminaCnt());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxFoodStaminaDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxFoodStaminaData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxFoodStaminaData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxFoodStaminaData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxFoodStaminaData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxFoodStaminaData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxFoodStaminaDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxFoodStaminaData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxFoodStaminaDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxFoodStaminaData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxFoodStaminaData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxFoodStaminaData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxFoodStaminaData>>(
                    dict__string__clz_Torappu_SandboxFoodStaminaData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxFoodStaminaData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxFoodStaminaData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxFoodStaminaDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxFoodStaminaData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxFoodStaminaDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxFoodStaminaDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxFoodStaminaDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxFoodStaminaDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxFoodStaminaData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxFoodStaminaData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxFoodStaminaData>>(
                dict__string__clz_Torappu_SandboxFoodStaminaData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxFoodStaminaDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxFoodStaminaDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxFoodStaminaData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxFoodStaminaData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxFoodStaminaData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxFoodStaminaData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum dict__string__intOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__int<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__int<'a> {
    type Inner = dict__string__int<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__int<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__int { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__intArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__int<'bldr>> {
        let mut builder = dict__string__intBuilder::new(_fbb);
        builder.add_value(args.value);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__int::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__int) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(dict__string__int::VT_VALUE, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for dict__string__int<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<i32>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__intArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: i32,
}
impl<'a> Default for dict__string__intArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__intArgs {
            key: None, // required field
            value: 0,
        }
    }
}

pub struct dict__string__intBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__intBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__int::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(&mut self, value: i32) {
        self.fbb_
            .push_slot::<i32>(dict__string__int::VT_VALUE, value, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__intBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__intBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__int<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, dict__string__int::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__int<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__int");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxBuildProduceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxBuildProduceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxBuildProduceData<'a> {
    type Inner = clz_Torappu_SandboxBuildProduceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxBuildProduceData<'a> {
    pub const VT_ITEMPRODUCEID: flatbuffers::VOffsetT = 4;
    pub const VT_ITEMID: flatbuffers::VOffsetT = 6;
    pub const VT_ITEMTYPETEXT: flatbuffers::VOffsetT = 8;
    pub const VT_MATERIALITEMS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxBuildProduceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxBuildProduceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxBuildProduceData<'bldr>> {
        let mut builder = clz_Torappu_SandboxBuildProduceDataBuilder::new(_fbb);
        if let Some(x) = args.materialItems {
            builder.add_materialItems(x);
        }
        if let Some(x) = args.itemTypeText {
            builder.add_itemTypeText(x);
        }
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        if let Some(x) = args.itemProduceId {
            builder.add_itemProduceId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn itemProduceId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxBuildProduceData::VT_ITEMPRODUCEID,
                None,
            )
        }
    }
    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxBuildProduceData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn itemTypeText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxBuildProduceData::VT_ITEMTYPETEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn materialItems(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>(clz_Torappu_SandboxBuildProduceData::VT_MATERIALITEMS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxBuildProduceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "itemProduceId",
                Self::VT_ITEMPRODUCEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "itemTypeText",
                Self::VT_ITEMTYPETEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>("materialItems", Self::VT_MATERIALITEMS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxBuildProduceDataArgs<'a> {
    pub itemProduceId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemTypeText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub materialItems: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SandboxBuildProduceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxBuildProduceDataArgs {
            itemProduceId: None,
            itemId: None,
            itemTypeText: None,
            materialItems: None,
        }
    }
}

pub struct clz_Torappu_SandboxBuildProduceDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxBuildProduceDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemProduceId(&mut self, itemProduceId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxBuildProduceData::VT_ITEMPRODUCEID,
            itemProduceId,
        );
    }
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxBuildProduceData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_itemTypeText(&mut self, itemTypeText: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxBuildProduceData::VT_ITEMTYPETEXT,
            itemTypeText,
        );
    }
    #[inline]
    pub fn add_materialItems(
        &mut self,
        materialItems: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__int<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxBuildProduceData::VT_MATERIALITEMS,
            materialItems,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxBuildProduceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxBuildProduceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxBuildProduceData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxBuildProduceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxBuildProduceData");
        ds.field("itemProduceId", &self.itemProduceId());
        ds.field("itemId", &self.itemId());
        ds.field("itemTypeText", &self.itemTypeText());
        ds.field("materialItems", &self.materialItems());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxBuildProduceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxBuildProduceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxBuildProduceData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxBuildProduceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxBuildProduceData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxBuildProduceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxBuildProduceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxBuildProduceData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxBuildProduceDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxBuildProduceData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxBuildProduceData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxBuildProduceData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxBuildProduceData>>(
                    dict__string__clz_Torappu_SandboxBuildProduceData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxBuildProduceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxBuildProduceData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxBuildProduceDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxBuildProduceData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxBuildProduceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxBuildProduceDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxBuildProduceDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxBuildProduceDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxBuildProduceData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxBuildProduceData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxBuildProduceData>>(
                dict__string__clz_Torappu_SandboxBuildProduceData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxBuildProduceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxBuildProduceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxBuildProduceData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxBuildProduceData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxBuildProduceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxBuildProduceData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxBuildGoldRatioDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxBuildGoldRatioData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxBuildGoldRatioData<'a> {
    type Inner = clz_Torappu_SandboxBuildGoldRatioData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxBuildGoldRatioData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_RATIO: flatbuffers::VOffsetT = 6;
    pub const VT_EFFECTDESC: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxBuildGoldRatioData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxBuildGoldRatioDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxBuildGoldRatioData<'bldr>> {
        let mut builder = clz_Torappu_SandboxBuildGoldRatioDataBuilder::new(_fbb);
        if let Some(x) = args.effectDesc {
            builder.add_effectDesc(x);
        }
        builder.add_ratio(args.ratio);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxBuildGoldRatioData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn ratio(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxBuildGoldRatioData::VT_RATIO, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn effectDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxBuildGoldRatioData::VT_EFFECTDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxBuildGoldRatioData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<i32>("ratio", Self::VT_RATIO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "effectDesc",
                Self::VT_EFFECTDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxBuildGoldRatioDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ratio: i32,
    pub effectDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxBuildGoldRatioDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxBuildGoldRatioDataArgs {
            itemId: None,
            ratio: 0,
            effectDesc: None,
        }
    }
}

pub struct clz_Torappu_SandboxBuildGoldRatioDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxBuildGoldRatioDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxBuildGoldRatioData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_ratio(&mut self, ratio: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxBuildGoldRatioData::VT_RATIO, ratio, 0);
    }
    #[inline]
    pub fn add_effectDesc(&mut self, effectDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxBuildGoldRatioData::VT_EFFECTDESC,
            effectDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxBuildGoldRatioDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxBuildGoldRatioDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxBuildGoldRatioData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxBuildGoldRatioData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxBuildGoldRatioData");
        ds.field("itemId", &self.itemId());
        ds.field("ratio", &self.ratio());
        ds.field("effectDesc", &self.effectDesc());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxBuildingItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxBuildingItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxBuildingItemData<'a> {
    type Inner = clz_Torappu_SandboxBuildingItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxBuildingItemData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_ITEMSUBTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_ITEMRARITY: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxBuildingItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxBuildingItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxBuildingItemData<'bldr>> {
        let mut builder = clz_Torappu_SandboxBuildingItemDataBuilder::new(_fbb);
        builder.add_itemRarity(args.itemRarity);
        builder.add_itemSubType(args.itemSubType);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxBuildingItemData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn itemSubType(&self) -> enum__Torappu_SandboxBuildingItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxBuildingItemType>(
                    clz_Torappu_SandboxBuildingItemData::VT_ITEMSUBTYPE,
                    Some(enum__Torappu_SandboxBuildingItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn itemRarity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxBuildingItemData::VT_ITEMRARITY, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxBuildingItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<enum__Torappu_SandboxBuildingItemType>(
                "itemSubType",
                Self::VT_ITEMSUBTYPE,
                false,
            )?
            .visit_field::<i32>("itemRarity", Self::VT_ITEMRARITY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxBuildingItemDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemSubType: enum__Torappu_SandboxBuildingItemType,
    pub itemRarity: i32,
}
impl<'a> Default for clz_Torappu_SandboxBuildingItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxBuildingItemDataArgs {
            itemId: None,
            itemSubType: enum__Torappu_SandboxBuildingItemType::NONE,
            itemRarity: 0,
        }
    }
}

pub struct clz_Torappu_SandboxBuildingItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxBuildingItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxBuildingItemData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_itemSubType(&mut self, itemSubType: enum__Torappu_SandboxBuildingItemType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxBuildingItemType>(
                clz_Torappu_SandboxBuildingItemData::VT_ITEMSUBTYPE,
                itemSubType,
                enum__Torappu_SandboxBuildingItemType::NONE,
            );
    }
    #[inline]
    pub fn add_itemRarity(&mut self, itemRarity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxBuildingItemData::VT_ITEMRARITY,
            itemRarity,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxBuildingItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxBuildingItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxBuildingItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxBuildingItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxBuildingItemData");
        ds.field("itemId", &self.itemId());
        ds.field("itemSubType", &self.itemSubType());
        ds.field("itemRarity", &self.itemRarity());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxBuildingItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxBuildingItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxBuildingItemData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxBuildingItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxBuildingItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxBuildingItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxBuildingItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxBuildingItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxBuildingItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxBuildingItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxBuildingItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxBuildingItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxBuildingItemData>>(
                    dict__string__clz_Torappu_SandboxBuildingItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxBuildingItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxBuildingItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxBuildingItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxBuildingItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxBuildingItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxBuildingItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxBuildingItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxBuildingItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxBuildingItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxBuildingItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxBuildingItemData>>(
                dict__string__clz_Torappu_SandboxBuildingItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxBuildingItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxBuildingItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxBuildingItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxBuildingItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxBuildingItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxBuildingItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxBuildProduceUnlockDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxBuildProduceUnlockData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxBuildProduceUnlockData<'a> {
    type Inner = clz_Torappu_SandboxBuildProduceUnlockData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxBuildProduceUnlockData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_BUILDINGEFFECTDESC: flatbuffers::VOffsetT = 6;
    pub const VT_BUILDINGITEMDESC: flatbuffers::VOffsetT = 8;
    pub const VT_BUILDINGUNLOCKDESC: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxBuildProduceUnlockData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxBuildProduceUnlockDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxBuildProduceUnlockData<'bldr>> {
        let mut builder = clz_Torappu_SandboxBuildProduceUnlockDataBuilder::new(_fbb);
        if let Some(x) = args.buildingUnlockDesc {
            builder.add_buildingUnlockDesc(x);
        }
        if let Some(x) = args.buildingItemDesc {
            builder.add_buildingItemDesc(x);
        }
        if let Some(x) = args.buildingEffectDesc {
            builder.add_buildingEffectDesc(x);
        }
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxBuildProduceUnlockData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn buildingEffectDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxBuildProduceUnlockData::VT_BUILDINGEFFECTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn buildingItemDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxBuildProduceUnlockData::VT_BUILDINGITEMDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn buildingUnlockDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxBuildProduceUnlockData::VT_BUILDINGUNLOCKDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxBuildProduceUnlockData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buildingEffectDesc",
                Self::VT_BUILDINGEFFECTDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buildingItemDesc",
                Self::VT_BUILDINGITEMDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buildingUnlockDesc",
                Self::VT_BUILDINGUNLOCKDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxBuildProduceUnlockDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buildingEffectDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buildingItemDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buildingUnlockDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxBuildProduceUnlockDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxBuildProduceUnlockDataArgs {
            itemId: None,
            buildingEffectDesc: None,
            buildingItemDesc: None,
            buildingUnlockDesc: None,
        }
    }
}

pub struct clz_Torappu_SandboxBuildProduceUnlockDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxBuildProduceUnlockDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxBuildProduceUnlockData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_buildingEffectDesc(&mut self, buildingEffectDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxBuildProduceUnlockData::VT_BUILDINGEFFECTDESC,
            buildingEffectDesc,
        );
    }
    #[inline]
    pub fn add_buildingItemDesc(&mut self, buildingItemDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxBuildProduceUnlockData::VT_BUILDINGITEMDESC,
            buildingItemDesc,
        );
    }
    #[inline]
    pub fn add_buildingUnlockDesc(&mut self, buildingUnlockDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxBuildProduceUnlockData::VT_BUILDINGUNLOCKDESC,
            buildingUnlockDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxBuildProduceUnlockDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxBuildProduceUnlockDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxBuildProduceUnlockData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxBuildProduceUnlockData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxBuildProduceUnlockData");
        ds.field("itemId", &self.itemId());
        ds.field("buildingEffectDesc", &self.buildingEffectDesc());
        ds.field("buildingItemDesc", &self.buildingItemDesc());
        ds.field("buildingUnlockDesc", &self.buildingUnlockDesc());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxBuildProduceUnlockDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxBuildProduceUnlockData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxBuildProduceUnlockData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxBuildProduceUnlockData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxBuildProduceUnlockData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxBuildProduceUnlockData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxBuildProduceUnlockDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxBuildProduceUnlockData<'bldr>>
    {
        let mut builder = dict__string__clz_Torappu_SandboxBuildProduceUnlockDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxBuildProduceUnlockData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxBuildProduceUnlockData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxBuildProduceUnlockData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxBuildProduceUnlockData>>(
                    dict__string__clz_Torappu_SandboxBuildProduceUnlockData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxBuildProduceUnlockData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxBuildProduceUnlockData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxBuildProduceUnlockDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxBuildProduceUnlockData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxBuildProduceUnlockDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxBuildProduceUnlockDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxBuildProduceUnlockDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxBuildProduceUnlockDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxBuildProduceUnlockData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxBuildProduceUnlockData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxBuildProduceUnlockData>>(
                dict__string__clz_Torappu_SandboxBuildProduceUnlockData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxBuildProduceUnlockDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxBuildProduceUnlockDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxBuildProduceUnlockData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxBuildProduceUnlockData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxBuildProduceUnlockData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxBuildProduceUnlockData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxCraftItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxCraftItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxCraftItemData<'a> {
    type Inner = clz_Torappu_SandboxCraftItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxCraftItemData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_GETFROM: flatbuffers::VOffsetT = 8;
    pub const VT_NPCID: flatbuffers::VOffsetT = 10;
    pub const VT_NOTOBTAINEDDESC: flatbuffers::VOffsetT = 12;
    pub const VT_ITEMTYPE: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxCraftItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxCraftItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxCraftItemData<'bldr>> {
        let mut builder = clz_Torappu_SandboxCraftItemDataBuilder::new(_fbb);
        builder.add_itemType(args.itemType);
        if let Some(x) = args.notObtainedDesc {
            builder.add_notObtainedDesc(x);
        }
        if let Some(x) = args.npcId {
            builder.add_npcId(x);
        }
        if let Some(x) = args.getFrom {
            builder.add_getFrom(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxCraftItemData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxCraftItemData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn getFrom(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxCraftItemData::VT_GETFROM,
                None,
            )
        }
    }
    #[inline]
    pub fn npcId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxCraftItemData::VT_NPCID,
                None,
            )
        }
    }
    #[inline]
    pub fn notObtainedDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxCraftItemData::VT_NOTOBTAINEDDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn itemType(&self) -> enum__Torappu_SandboxCraftItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxCraftItemType>(
                    clz_Torappu_SandboxCraftItemData::VT_ITEMTYPE,
                    Some(enum__Torappu_SandboxCraftItemType::SHORT),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxCraftItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("getFrom", Self::VT_GETFROM, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("npcId", Self::VT_NPCID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "notObtainedDesc",
                Self::VT_NOTOBTAINEDDESC,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxCraftItemType>(
                "itemType",
                Self::VT_ITEMTYPE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxCraftItemDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub getFrom: Option<flatbuffers::WIPOffset<&'a str>>,
    pub npcId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub notObtainedDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemType: enum__Torappu_SandboxCraftItemType,
}
impl<'a> Default for clz_Torappu_SandboxCraftItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxCraftItemDataArgs {
            itemId: None,
            sortId: 0,
            getFrom: None,
            npcId: None,
            notObtainedDesc: None,
            itemType: enum__Torappu_SandboxCraftItemType::SHORT,
        }
    }
}

pub struct clz_Torappu_SandboxCraftItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxCraftItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxCraftItemData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxCraftItemData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_getFrom(&mut self, getFrom: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxCraftItemData::VT_GETFROM,
            getFrom,
        );
    }
    #[inline]
    pub fn add_npcId(&mut self, npcId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxCraftItemData::VT_NPCID,
            npcId,
        );
    }
    #[inline]
    pub fn add_notObtainedDesc(&mut self, notObtainedDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxCraftItemData::VT_NOTOBTAINEDDESC,
            notObtainedDesc,
        );
    }
    #[inline]
    pub fn add_itemType(&mut self, itemType: enum__Torappu_SandboxCraftItemType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxCraftItemType>(
            clz_Torappu_SandboxCraftItemData::VT_ITEMTYPE,
            itemType,
            enum__Torappu_SandboxCraftItemType::SHORT,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxCraftItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxCraftItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxCraftItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxCraftItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxCraftItemData");
        ds.field("itemId", &self.itemId());
        ds.field("sortId", &self.sortId());
        ds.field("getFrom", &self.getFrom());
        ds.field("npcId", &self.npcId());
        ds.field("notObtainedDesc", &self.notObtainedDesc());
        ds.field("itemType", &self.itemType());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxCraftItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxCraftItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxCraftItemData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxCraftItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxCraftItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxCraftItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxCraftItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxCraftItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxCraftItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxCraftItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxCraftItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxCraftItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxCraftItemData>>(
                    dict__string__clz_Torappu_SandboxCraftItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxCraftItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxCraftItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxCraftItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxCraftItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxCraftItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxCraftItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxCraftItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxCraftItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxCraftItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxCraftItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxCraftItemData>>(
                dict__string__clz_Torappu_SandboxCraftItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxCraftItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxCraftItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxCraftItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxCraftItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxCraftItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxCraftItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxItemTrapDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxItemTrapData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxItemTrapData<'a> {
    type Inner = clz_Torappu_SandboxItemTrapData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxItemTrapData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_TRAPID: flatbuffers::VOffsetT = 6;
    pub const VT_TRAPPHASE: flatbuffers::VOffsetT = 8;
    pub const VT_TRAPLEVEL: flatbuffers::VOffsetT = 10;
    pub const VT_SKILLINDEX: flatbuffers::VOffsetT = 12;
    pub const VT_SKILLLEVEL: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxItemTrapData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxItemTrapDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxItemTrapData<'bldr>> {
        let mut builder = clz_Torappu_SandboxItemTrapDataBuilder::new(_fbb);
        builder.add_skillLevel(args.skillLevel);
        builder.add_skillIndex(args.skillIndex);
        builder.add_trapLevel(args.trapLevel);
        builder.add_trapPhase(args.trapPhase);
        if let Some(x) = args.trapId {
            builder.add_trapId(x);
        }
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxItemTrapData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn trapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxItemTrapData::VT_TRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn trapPhase(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxItemTrapData::VT_TRAPPHASE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn trapLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxItemTrapData::VT_TRAPLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn skillIndex(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxItemTrapData::VT_SKILLINDEX, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn skillLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxItemTrapData::VT_SKILLLEVEL, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxItemTrapData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("trapId", Self::VT_TRAPID, false)?
            .visit_field::<i32>("trapPhase", Self::VT_TRAPPHASE, false)?
            .visit_field::<i32>("trapLevel", Self::VT_TRAPLEVEL, false)?
            .visit_field::<i32>("skillIndex", Self::VT_SKILLINDEX, false)?
            .visit_field::<i32>("skillLevel", Self::VT_SKILLLEVEL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxItemTrapDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trapPhase: i32,
    pub trapLevel: i32,
    pub skillIndex: i32,
    pub skillLevel: i32,
}
impl<'a> Default for clz_Torappu_SandboxItemTrapDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxItemTrapDataArgs {
            itemId: None,
            trapId: None,
            trapPhase: 0,
            trapLevel: 0,
            skillIndex: 0,
            skillLevel: 0,
        }
    }
}

pub struct clz_Torappu_SandboxItemTrapDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxItemTrapDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxItemTrapData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_trapId(&mut self, trapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxItemTrapData::VT_TRAPID,
            trapId,
        );
    }
    #[inline]
    pub fn add_trapPhase(&mut self, trapPhase: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxItemTrapData::VT_TRAPPHASE, trapPhase, 0);
    }
    #[inline]
    pub fn add_trapLevel(&mut self, trapLevel: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxItemTrapData::VT_TRAPLEVEL, trapLevel, 0);
    }
    #[inline]
    pub fn add_skillIndex(&mut self, skillIndex: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxItemTrapData::VT_SKILLINDEX,
            skillIndex,
            0,
        );
    }
    #[inline]
    pub fn add_skillLevel(&mut self, skillLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxItemTrapData::VT_SKILLLEVEL,
            skillLevel,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxItemTrapDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxItemTrapDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxItemTrapData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxItemTrapData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxItemTrapData");
        ds.field("itemId", &self.itemId());
        ds.field("trapId", &self.trapId());
        ds.field("trapPhase", &self.trapPhase());
        ds.field("trapLevel", &self.trapLevel());
        ds.field("skillIndex", &self.skillIndex());
        ds.field("skillLevel", &self.skillLevel());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxItemTrapDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxItemTrapData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxItemTrapData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxItemTrapData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxItemTrapData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxItemTrapData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxItemTrapDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxItemTrapData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxItemTrapDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxItemTrapData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxItemTrapData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxItemTrapData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxItemTrapData>>(
                    dict__string__clz_Torappu_SandboxItemTrapData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxItemTrapData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxItemTrapData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxItemTrapDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxItemTrapData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxItemTrapDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxItemTrapDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxItemTrapDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxItemTrapDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxItemTrapData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxItemTrapData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxItemTrapData>>(
                dict__string__clz_Torappu_SandboxItemTrapData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxItemTrapDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxItemTrapDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxItemTrapData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxItemTrapData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxItemTrapData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxItemTrapData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxDevelopmentDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxDevelopmentData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxDevelopmentData<'a> {
    type Inner = clz_Torappu_SandboxDevelopmentData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxDevelopmentData<'a> {
    pub const VT_BUFFID: flatbuffers::VOffsetT = 4;
    pub const VT_POSITIONX: flatbuffers::VOffsetT = 6;
    pub const VT_POSITIONY: flatbuffers::VOffsetT = 8;
    pub const VT_FRONTNODEID: flatbuffers::VOffsetT = 10;
    pub const VT_NEXTNODEIDS: flatbuffers::VOffsetT = 12;
    pub const VT_BUFFLIMITEDID: flatbuffers::VOffsetT = 14;
    pub const VT_TOKENCOST: flatbuffers::VOffsetT = 16;
    pub const VT_CANBUFFRESEARCH: flatbuffers::VOffsetT = 18;
    pub const VT_BUFFRESEARCHDESC: flatbuffers::VOffsetT = 20;
    pub const VT_BUFFNAME: flatbuffers::VOffsetT = 22;
    pub const VT_BUFFICONID: flatbuffers::VOffsetT = 24;
    pub const VT_NODETITLE: flatbuffers::VOffsetT = 26;
    pub const VT_BUFFEFFECTDESC: flatbuffers::VOffsetT = 28;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxDevelopmentData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxDevelopmentDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxDevelopmentData<'bldr>> {
        let mut builder = clz_Torappu_SandboxDevelopmentDataBuilder::new(_fbb);
        if let Some(x) = args.buffEffectDesc {
            builder.add_buffEffectDesc(x);
        }
        if let Some(x) = args.nodeTitle {
            builder.add_nodeTitle(x);
        }
        if let Some(x) = args.buffIconId {
            builder.add_buffIconId(x);
        }
        if let Some(x) = args.buffName {
            builder.add_buffName(x);
        }
        if let Some(x) = args.buffResearchDesc {
            builder.add_buffResearchDesc(x);
        }
        builder.add_tokenCost(args.tokenCost);
        if let Some(x) = args.buffLimitedId {
            builder.add_buffLimitedId(x);
        }
        if let Some(x) = args.nextNodeIds {
            builder.add_nextNodeIds(x);
        }
        if let Some(x) = args.frontNodeId {
            builder.add_frontNodeId(x);
        }
        builder.add_positionY(args.positionY);
        builder.add_positionX(args.positionX);
        if let Some(x) = args.buffId {
            builder.add_buffId(x);
        }
        builder.add_canBuffResearch(args.canBuffResearch);
        builder.finish()
    }

    #[inline]
    pub fn buffId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxDevelopmentData::VT_BUFFID,
                None,
            )
        }
    }
    #[inline]
    pub fn positionX(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxDevelopmentData::VT_POSITIONX, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn positionY(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxDevelopmentData::VT_POSITIONY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn frontNodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxDevelopmentData::VT_FRONTNODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn nextNodeIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxDevelopmentData::VT_NEXTNODEIDS, None)
        }
    }
    #[inline]
    pub fn buffLimitedId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxDevelopmentData::VT_BUFFLIMITEDID,
                None,
            )
        }
    }
    #[inline]
    pub fn tokenCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxDevelopmentData::VT_TOKENCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn canBuffResearch(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_SandboxDevelopmentData::VT_CANBUFFRESEARCH,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn buffResearchDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxDevelopmentData::VT_BUFFRESEARCHDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn buffName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxDevelopmentData::VT_BUFFNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn buffIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxDevelopmentData::VT_BUFFICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeTitle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxDevelopmentData::VT_NODETITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn buffEffectDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxDevelopmentData::VT_BUFFEFFECTDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxDevelopmentData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buffId", Self::VT_BUFFID, false)?
            .visit_field::<i32>("positionX", Self::VT_POSITIONX, false)?
            .visit_field::<i32>("positionY", Self::VT_POSITIONY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "frontNodeId",
                Self::VT_FRONTNODEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("nextNodeIds", Self::VT_NEXTNODEIDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffLimitedId",
                Self::VT_BUFFLIMITEDID,
                false,
            )?
            .visit_field::<i32>("tokenCost", Self::VT_TOKENCOST, false)?
            .visit_field::<bool>("canBuffResearch", Self::VT_CANBUFFRESEARCH, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffResearchDesc",
                Self::VT_BUFFRESEARCHDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffName",
                Self::VT_BUFFNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffIconId",
                Self::VT_BUFFICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nodeTitle",
                Self::VT_NODETITLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffEffectDesc",
                Self::VT_BUFFEFFECTDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxDevelopmentDataArgs<'a> {
    pub buffId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub positionX: i32,
    pub positionY: i32,
    pub frontNodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nextNodeIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub buffLimitedId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tokenCost: i32,
    pub canBuffResearch: bool,
    pub buffResearchDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nodeTitle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffEffectDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxDevelopmentDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxDevelopmentDataArgs {
            buffId: None,
            positionX: 0,
            positionY: 0,
            frontNodeId: None,
            nextNodeIds: None,
            buffLimitedId: None,
            tokenCost: 0,
            canBuffResearch: false,
            buffResearchDesc: None,
            buffName: None,
            buffIconId: None,
            nodeTitle: None,
            buffEffectDesc: None,
        }
    }
}

pub struct clz_Torappu_SandboxDevelopmentDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxDevelopmentDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_buffId(&mut self, buffId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxDevelopmentData::VT_BUFFID,
            buffId,
        );
    }
    #[inline]
    pub fn add_positionX(&mut self, positionX: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxDevelopmentData::VT_POSITIONX,
            positionX,
            0,
        );
    }
    #[inline]
    pub fn add_positionY(&mut self, positionY: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxDevelopmentData::VT_POSITIONY,
            positionY,
            0,
        );
    }
    #[inline]
    pub fn add_frontNodeId(&mut self, frontNodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxDevelopmentData::VT_FRONTNODEID,
            frontNodeId,
        );
    }
    #[inline]
    pub fn add_nextNodeIds(
        &mut self,
        nextNodeIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxDevelopmentData::VT_NEXTNODEIDS,
            nextNodeIds,
        );
    }
    #[inline]
    pub fn add_buffLimitedId(&mut self, buffLimitedId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxDevelopmentData::VT_BUFFLIMITEDID,
            buffLimitedId,
        );
    }
    #[inline]
    pub fn add_tokenCost(&mut self, tokenCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxDevelopmentData::VT_TOKENCOST,
            tokenCost,
            0,
        );
    }
    #[inline]
    pub fn add_canBuffResearch(&mut self, canBuffResearch: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SandboxDevelopmentData::VT_CANBUFFRESEARCH,
            canBuffResearch,
            false,
        );
    }
    #[inline]
    pub fn add_buffResearchDesc(&mut self, buffResearchDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxDevelopmentData::VT_BUFFRESEARCHDESC,
            buffResearchDesc,
        );
    }
    #[inline]
    pub fn add_buffName(&mut self, buffName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxDevelopmentData::VT_BUFFNAME,
            buffName,
        );
    }
    #[inline]
    pub fn add_buffIconId(&mut self, buffIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxDevelopmentData::VT_BUFFICONID,
            buffIconId,
        );
    }
    #[inline]
    pub fn add_nodeTitle(&mut self, nodeTitle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxDevelopmentData::VT_NODETITLE,
            nodeTitle,
        );
    }
    #[inline]
    pub fn add_buffEffectDesc(&mut self, buffEffectDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxDevelopmentData::VT_BUFFEFFECTDESC,
            buffEffectDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxDevelopmentDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxDevelopmentDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxDevelopmentData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxDevelopmentData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxDevelopmentData");
        ds.field("buffId", &self.buffId());
        ds.field("positionX", &self.positionX());
        ds.field("positionY", &self.positionY());
        ds.field("frontNodeId", &self.frontNodeId());
        ds.field("nextNodeIds", &self.nextNodeIds());
        ds.field("buffLimitedId", &self.buffLimitedId());
        ds.field("tokenCost", &self.tokenCost());
        ds.field("canBuffResearch", &self.canBuffResearch());
        ds.field("buffResearchDesc", &self.buffResearchDesc());
        ds.field("buffName", &self.buffName());
        ds.field("buffIconId", &self.buffIconId());
        ds.field("nodeTitle", &self.nodeTitle());
        ds.field("buffEffectDesc", &self.buffEffectDesc());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxDevelopmentDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxDevelopmentData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxDevelopmentData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxDevelopmentData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxDevelopmentData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxDevelopmentData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxDevelopmentDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxDevelopmentData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxDevelopmentDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxDevelopmentData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxDevelopmentData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxDevelopmentData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxDevelopmentData>>(
                    dict__string__clz_Torappu_SandboxDevelopmentData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxDevelopmentData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxDevelopmentData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxDevelopmentDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxDevelopmentData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxDevelopmentDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxDevelopmentDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxDevelopmentDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxDevelopmentDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxDevelopmentData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxDevelopmentData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxDevelopmentData>>(
                dict__string__clz_Torappu_SandboxDevelopmentData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxDevelopmentDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxDevelopmentDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxDevelopmentData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxDevelopmentData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxDevelopmentData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxDevelopmentData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxDevelopmentLimitDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxDevelopmentLimitData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxDevelopmentLimitData<'a> {
    type Inner = clz_Torappu_SandboxDevelopmentLimitData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxDevelopmentLimitData<'a> {
    pub const VT_BUFFLIMITEDID: flatbuffers::VOffsetT = 4;
    pub const VT_POSITIONX: flatbuffers::VOffsetT = 6;
    pub const VT_BUFFCOSTLIMITEDCOUNT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxDevelopmentLimitData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxDevelopmentLimitDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxDevelopmentLimitData<'bldr>> {
        let mut builder = clz_Torappu_SandboxDevelopmentLimitDataBuilder::new(_fbb);
        builder.add_buffCostLimitedCount(args.buffCostLimitedCount);
        builder.add_positionX(args.positionX);
        if let Some(x) = args.buffLimitedId {
            builder.add_buffLimitedId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn buffLimitedId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxDevelopmentLimitData::VT_BUFFLIMITEDID,
                None,
            )
        }
    }
    #[inline]
    pub fn positionX(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxDevelopmentLimitData::VT_POSITIONX,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn buffCostLimitedCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxDevelopmentLimitData::VT_BUFFCOSTLIMITEDCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxDevelopmentLimitData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffLimitedId",
                Self::VT_BUFFLIMITEDID,
                false,
            )?
            .visit_field::<i32>("positionX", Self::VT_POSITIONX, false)?
            .visit_field::<i32>("buffCostLimitedCount", Self::VT_BUFFCOSTLIMITEDCOUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxDevelopmentLimitDataArgs<'a> {
    pub buffLimitedId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub positionX: i32,
    pub buffCostLimitedCount: i32,
}
impl<'a> Default for clz_Torappu_SandboxDevelopmentLimitDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxDevelopmentLimitDataArgs {
            buffLimitedId: None,
            positionX: 0,
            buffCostLimitedCount: 0,
        }
    }
}

pub struct clz_Torappu_SandboxDevelopmentLimitDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxDevelopmentLimitDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_buffLimitedId(&mut self, buffLimitedId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxDevelopmentLimitData::VT_BUFFLIMITEDID,
            buffLimitedId,
        );
    }
    #[inline]
    pub fn add_positionX(&mut self, positionX: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxDevelopmentLimitData::VT_POSITIONX,
            positionX,
            0,
        );
    }
    #[inline]
    pub fn add_buffCostLimitedCount(&mut self, buffCostLimitedCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxDevelopmentLimitData::VT_BUFFCOSTLIMITEDCOUNT,
            buffCostLimitedCount,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxDevelopmentLimitDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxDevelopmentLimitDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxDevelopmentLimitData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxDevelopmentLimitData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxDevelopmentLimitData");
        ds.field("buffLimitedId", &self.buffLimitedId());
        ds.field("positionX", &self.positionX());
        ds.field("buffCostLimitedCount", &self.buffCostLimitedCount());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxDevelopmentLimitDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxDevelopmentLimitData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxDevelopmentLimitData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxDevelopmentLimitData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxDevelopmentLimitData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxDevelopmentLimitData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxDevelopmentLimitDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxDevelopmentLimitData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxDevelopmentLimitDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxDevelopmentLimitData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxDevelopmentLimitData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxDevelopmentLimitData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxDevelopmentLimitData>>(
                    dict__string__clz_Torappu_SandboxDevelopmentLimitData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxDevelopmentLimitData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxDevelopmentLimitData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxDevelopmentLimitDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxDevelopmentLimitData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxDevelopmentLimitDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxDevelopmentLimitDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxDevelopmentLimitDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxDevelopmentLimitDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxDevelopmentLimitData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxDevelopmentLimitData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxDevelopmentLimitData>>(
                dict__string__clz_Torappu_SandboxDevelopmentLimitData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxDevelopmentLimitDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxDevelopmentLimitDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxDevelopmentLimitData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxDevelopmentLimitData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxDevelopmentLimitData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxDevelopmentLimitData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxItemToastDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxItemToastData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxItemToastData<'a> {
    type Inner = clz_Torappu_SandboxItemToastData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxItemToastData<'a> {
    pub const VT_ITEMTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_TOASTDESC: flatbuffers::VOffsetT = 6;
    pub const VT_COLOR: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxItemToastData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxItemToastDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxItemToastData<'bldr>> {
        let mut builder = clz_Torappu_SandboxItemToastDataBuilder::new(_fbb);
        if let Some(x) = args.color {
            builder.add_color(x);
        }
        if let Some(x) = args.toastDesc {
            builder.add_toastDesc(x);
        }
        builder.add_itemType(args.itemType);
        builder.finish()
    }

    #[inline]
    pub fn itemType(&self) -> enum__Torappu_SandboxItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxItemType>(
                    clz_Torappu_SandboxItemToastData::VT_ITEMTYPE,
                    Some(enum__Torappu_SandboxItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn toastDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxItemToastData::VT_TOASTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn color(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxItemToastData::VT_COLOR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxItemToastData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxItemType>("itemType", Self::VT_ITEMTYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "toastDesc",
                Self::VT_TOASTDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("color", Self::VT_COLOR, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxItemToastDataArgs<'a> {
    pub itemType: enum__Torappu_SandboxItemType,
    pub toastDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub color: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxItemToastDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxItemToastDataArgs {
            itemType: enum__Torappu_SandboxItemType::NONE,
            toastDesc: None,
            color: None,
        }
    }
}

pub struct clz_Torappu_SandboxItemToastDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxItemToastDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemType(&mut self, itemType: enum__Torappu_SandboxItemType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxItemType>(
            clz_Torappu_SandboxItemToastData::VT_ITEMTYPE,
            itemType,
            enum__Torappu_SandboxItemType::NONE,
        );
    }
    #[inline]
    pub fn add_toastDesc(&mut self, toastDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxItemToastData::VT_TOASTDESC,
            toastDesc,
        );
    }
    #[inline]
    pub fn add_color(&mut self, color: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxItemToastData::VT_COLOR,
            color,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxItemToastDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxItemToastDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxItemToastData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxItemToastData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxItemToastData");
        ds.field("itemType", &self.itemType());
        ds.field("toastDesc", &self.toastDesc());
        ds.field("color", &self.color());
        ds.finish()
    }
}
pub enum dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastData<'a>
{
    type Inner = dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastDataArgs<
            'args,
        >,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastData<'bldr>,
    > {
        let mut builder =
            dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_SandboxItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxItemType>(
                    dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastData::VT_KEY,
                    Some(enum__Torappu_SandboxItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_SandboxItemType,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxItemToastData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxItemToastData>>(
                    dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxItemType>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxItemToastData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastDataArgs<'a> {
    pub key: enum__Torappu_SandboxItemType,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxItemToastData<'a>>>,
}
impl<'a> Default for dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastDataArgs {
            key: enum__Torappu_SandboxItemType::NONE,
            value: None,
        }
    }
}

pub struct dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: enum__Torappu_SandboxItemType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxItemType>(
            dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastData::VT_KEY,
            key,
            enum__Torappu_SandboxItemType::NONE,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxItemToastData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxItemToastData>>(
                dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastDataBuilder<'a, 'b, A>
    {
        let start = _fbb.start_table();
        dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastData<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastData<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxDevelopmentLineSegmentDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxDevelopmentLineSegmentData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxDevelopmentLineSegmentData<'a> {
    type Inner = clz_Torappu_SandboxDevelopmentLineSegmentData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxDevelopmentLineSegmentData<'a> {
    pub const VT_FROMNODEID: flatbuffers::VOffsetT = 4;
    pub const VT_PASSINGNODEIDS: flatbuffers::VOffsetT = 6;
    pub const VT_FROMAXISPOSX: flatbuffers::VOffsetT = 8;
    pub const VT_FROMAXISPOSY: flatbuffers::VOffsetT = 10;
    pub const VT_TOAXISPOSX: flatbuffers::VOffsetT = 12;
    pub const VT_TOAXISPOSY: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxDevelopmentLineSegmentData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxDevelopmentLineSegmentDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxDevelopmentLineSegmentData<'bldr>> {
        let mut builder = clz_Torappu_SandboxDevelopmentLineSegmentDataBuilder::new(_fbb);
        builder.add_toAxisPosY(args.toAxisPosY);
        builder.add_toAxisPosX(args.toAxisPosX);
        builder.add_fromAxisPosY(args.fromAxisPosY);
        builder.add_fromAxisPosX(args.fromAxisPosX);
        if let Some(x) = args.passingNodeIds {
            builder.add_passingNodeIds(x);
        }
        if let Some(x) = args.fromNodeId {
            builder.add_fromNodeId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn fromNodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxDevelopmentLineSegmentData::VT_FROMNODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn passingNodeIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxDevelopmentLineSegmentData::VT_PASSINGNODEIDS,
                None,
            )
        }
    }
    #[inline]
    pub fn fromAxisPosX(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxDevelopmentLineSegmentData::VT_FROMAXISPOSX,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn fromAxisPosY(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxDevelopmentLineSegmentData::VT_FROMAXISPOSY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn toAxisPosX(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxDevelopmentLineSegmentData::VT_TOAXISPOSX,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn toAxisPosY(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxDevelopmentLineSegmentData::VT_TOAXISPOSY,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxDevelopmentLineSegmentData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "fromNodeId",
                Self::VT_FROMNODEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("passingNodeIds", Self::VT_PASSINGNODEIDS, false)?
            .visit_field::<i32>("fromAxisPosX", Self::VT_FROMAXISPOSX, false)?
            .visit_field::<i32>("fromAxisPosY", Self::VT_FROMAXISPOSY, false)?
            .visit_field::<i32>("toAxisPosX", Self::VT_TOAXISPOSX, false)?
            .visit_field::<i32>("toAxisPosY", Self::VT_TOAXISPOSY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxDevelopmentLineSegmentDataArgs<'a> {
    pub fromNodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub passingNodeIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub fromAxisPosX: i32,
    pub fromAxisPosY: i32,
    pub toAxisPosX: i32,
    pub toAxisPosY: i32,
}
impl<'a> Default for clz_Torappu_SandboxDevelopmentLineSegmentDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxDevelopmentLineSegmentDataArgs {
            fromNodeId: None,
            passingNodeIds: None,
            fromAxisPosX: 0,
            fromAxisPosY: 0,
            toAxisPosX: 0,
            toAxisPosY: 0,
        }
    }
}

pub struct clz_Torappu_SandboxDevelopmentLineSegmentDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxDevelopmentLineSegmentDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_fromNodeId(&mut self, fromNodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxDevelopmentLineSegmentData::VT_FROMNODEID,
            fromNodeId,
        );
    }
    #[inline]
    pub fn add_passingNodeIds(
        &mut self,
        passingNodeIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxDevelopmentLineSegmentData::VT_PASSINGNODEIDS,
            passingNodeIds,
        );
    }
    #[inline]
    pub fn add_fromAxisPosX(&mut self, fromAxisPosX: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxDevelopmentLineSegmentData::VT_FROMAXISPOSX,
            fromAxisPosX,
            0,
        );
    }
    #[inline]
    pub fn add_fromAxisPosY(&mut self, fromAxisPosY: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxDevelopmentLineSegmentData::VT_FROMAXISPOSY,
            fromAxisPosY,
            0,
        );
    }
    #[inline]
    pub fn add_toAxisPosX(&mut self, toAxisPosX: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxDevelopmentLineSegmentData::VT_TOAXISPOSX,
            toAxisPosX,
            0,
        );
    }
    #[inline]
    pub fn add_toAxisPosY(&mut self, toAxisPosY: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxDevelopmentLineSegmentData::VT_TOAXISPOSY,
            toAxisPosY,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxDevelopmentLineSegmentDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxDevelopmentLineSegmentDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxDevelopmentLineSegmentData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxDevelopmentLineSegmentData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxDevelopmentLineSegmentData");
        ds.field("fromNodeId", &self.fromNodeId());
        ds.field("passingNodeIds", &self.passingNodeIds());
        ds.field("fromAxisPosX", &self.fromAxisPosX());
        ds.field("fromAxisPosY", &self.fromAxisPosY());
        ds.field("toAxisPosX", &self.toAxisPosX());
        ds.field("toAxisPosY", &self.toAxisPosY());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxRewardItemConfigDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxRewardItemConfigData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxRewardItemConfigData<'a> {
    type Inner = clz_Torappu_SandboxRewardItemConfigData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxRewardItemConfigData<'a> {
    pub const VT_REWARDITEM: flatbuffers::VOffsetT = 4;
    pub const VT_REWARDTYPE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxRewardItemConfigData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxRewardItemConfigDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxRewardItemConfigData<'bldr>> {
        let mut builder = clz_Torappu_SandboxRewardItemConfigDataBuilder::new(_fbb);
        builder.add_rewardType(args.rewardType);
        if let Some(x) = args.rewardItem {
            builder.add_rewardItem(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn rewardItem(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxRewardItemConfigData::VT_REWARDITEM,
                None,
            )
        }
    }
    #[inline]
    pub fn rewardType(&self) -> enum__Torappu_SandboxItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxItemType>(
                    clz_Torappu_SandboxRewardItemConfigData::VT_REWARDTYPE,
                    Some(enum__Torappu_SandboxItemType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxRewardItemConfigData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rewardItem",
                Self::VT_REWARDITEM,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxItemType>("rewardType", Self::VT_REWARDTYPE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxRewardItemConfigDataArgs<'a> {
    pub rewardItem: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewardType: enum__Torappu_SandboxItemType,
}
impl<'a> Default for clz_Torappu_SandboxRewardItemConfigDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxRewardItemConfigDataArgs {
            rewardItem: None,
            rewardType: enum__Torappu_SandboxItemType::NONE,
        }
    }
}

pub struct clz_Torappu_SandboxRewardItemConfigDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxRewardItemConfigDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_rewardItem(&mut self, rewardItem: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxRewardItemConfigData::VT_REWARDITEM,
            rewardItem,
        );
    }
    #[inline]
    pub fn add_rewardType(&mut self, rewardType: enum__Torappu_SandboxItemType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxItemType>(
            clz_Torappu_SandboxRewardItemConfigData::VT_REWARDTYPE,
            rewardType,
            enum__Torappu_SandboxItemType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxRewardItemConfigDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxRewardItemConfigDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxRewardItemConfigData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxRewardItemConfigData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxRewardItemConfigData");
        ds.field("rewardItem", &self.rewardItem());
        ds.field("rewardType", &self.rewardType());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxRewardDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxRewardData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxRewardData<'a> {
    type Inner = clz_Torappu_SandboxRewardData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxRewardData<'a> {
    pub const VT_REWARDLIST: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxRewardData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxRewardDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxRewardData<'bldr>> {
        let mut builder = clz_Torappu_SandboxRewardDataBuilder::new(_fbb);
        if let Some(x) = args.rewardList {
            builder.add_rewardList(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn rewardList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxRewardItemConfigData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxRewardItemConfigData>,
                >,
            >>(clz_Torappu_SandboxRewardData::VT_REWARDLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxRewardData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxRewardItemConfigData>,
                >,
            >>("rewardList", Self::VT_REWARDLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxRewardDataArgs<'a> {
    pub rewardList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxRewardItemConfigData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SandboxRewardDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxRewardDataArgs { rewardList: None }
    }
}

pub struct clz_Torappu_SandboxRewardDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxRewardDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_rewardList(
        &mut self,
        rewardList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxRewardItemConfigData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxRewardData::VT_REWARDLIST,
            rewardList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxRewardDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxRewardDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxRewardData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxRewardData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxRewardData");
        ds.field("rewardList", &self.rewardList());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxRewardDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxRewardData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxRewardData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxRewardData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxRewardData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxRewardData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxRewardDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxRewardData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxRewardDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxRewardData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxRewardData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxRewardData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxRewardData>>(
                    dict__string__clz_Torappu_SandboxRewardData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxRewardData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxRewardData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxRewardDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxRewardData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxRewardDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxRewardDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxRewardDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxRewardDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxRewardData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxRewardData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxRewardData>>(
                dict__string__clz_Torappu_SandboxRewardData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxRewardDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxRewardDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxRewardData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxRewardData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxRewardData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxRewardData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxTrapRewardConfigDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxTrapRewardConfigData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxTrapRewardConfigData<'a> {
    type Inner = clz_Torappu_SandboxTrapRewardConfigData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxTrapRewardConfigData<'a> {
    pub const VT_DROPTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_REWARDITEMID: flatbuffers::VOffsetT = 6;
    pub const VT_REWARDITEMTYPE: flatbuffers::VOffsetT = 8;
    pub const VT_COUNT: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxTrapRewardConfigData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxTrapRewardConfigDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxTrapRewardConfigData<'bldr>> {
        let mut builder = clz_Torappu_SandboxTrapRewardConfigDataBuilder::new(_fbb);
        builder.add_count(args.count);
        builder.add_rewardItemType(args.rewardItemType);
        if let Some(x) = args.rewardItemId {
            builder.add_rewardItemId(x);
        }
        builder.add_dropType(args.dropType);
        builder.finish()
    }

    #[inline]
    pub fn dropType(&self) -> enum__Torappu_SandboxRewardTrapDropType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxRewardTrapDropType>(
                    clz_Torappu_SandboxTrapRewardConfigData::VT_DROPTYPE,
                    Some(enum__Torappu_SandboxRewardTrapDropType::COLLECT),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rewardItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxTrapRewardConfigData::VT_REWARDITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn rewardItemType(&self) -> enum__Torappu_SandboxItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxItemType>(
                    clz_Torappu_SandboxTrapRewardConfigData::VT_REWARDITEMTYPE,
                    Some(enum__Torappu_SandboxItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxTrapRewardConfigData::VT_COUNT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxTrapRewardConfigData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxRewardTrapDropType>(
                "dropType",
                Self::VT_DROPTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rewardItemId",
                Self::VT_REWARDITEMID,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxItemType>(
                "rewardItemType",
                Self::VT_REWARDITEMTYPE,
                false,
            )?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxTrapRewardConfigDataArgs<'a> {
    pub dropType: enum__Torappu_SandboxRewardTrapDropType,
    pub rewardItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewardItemType: enum__Torappu_SandboxItemType,
    pub count: i32,
}
impl<'a> Default for clz_Torappu_SandboxTrapRewardConfigDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxTrapRewardConfigDataArgs {
            dropType: enum__Torappu_SandboxRewardTrapDropType::COLLECT,
            rewardItemId: None,
            rewardItemType: enum__Torappu_SandboxItemType::NONE,
            count: 0,
        }
    }
}

pub struct clz_Torappu_SandboxTrapRewardConfigDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxTrapRewardConfigDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_dropType(&mut self, dropType: enum__Torappu_SandboxRewardTrapDropType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxRewardTrapDropType>(
                clz_Torappu_SandboxTrapRewardConfigData::VT_DROPTYPE,
                dropType,
                enum__Torappu_SandboxRewardTrapDropType::COLLECT,
            );
    }
    #[inline]
    pub fn add_rewardItemId(&mut self, rewardItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxTrapRewardConfigData::VT_REWARDITEMID,
            rewardItemId,
        );
    }
    #[inline]
    pub fn add_rewardItemType(&mut self, rewardItemType: enum__Torappu_SandboxItemType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxItemType>(
            clz_Torappu_SandboxTrapRewardConfigData::VT_REWARDITEMTYPE,
            rewardItemType,
            enum__Torappu_SandboxItemType::NONE,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxTrapRewardConfigData::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxTrapRewardConfigDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxTrapRewardConfigDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxTrapRewardConfigData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxTrapRewardConfigData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxTrapRewardConfigData");
        ds.field("dropType", &self.dropType());
        ds.field("rewardItemId", &self.rewardItemId());
        ds.field("rewardItemType", &self.rewardItemType());
        ds.field("count", &self.count());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxTrapRewardConfigDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxTrapRewardConfigData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxTrapRewardConfigData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxTrapRewardConfigData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxTrapRewardConfigData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxTrapRewardConfigData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxTrapRewardConfigDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxTrapRewardConfigData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxTrapRewardConfigDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxTrapRewardConfigData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxTrapRewardConfigData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxTrapRewardConfigData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxTrapRewardConfigData>>(
                    dict__string__clz_Torappu_SandboxTrapRewardConfigData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxTrapRewardConfigData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxTrapRewardConfigData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxTrapRewardConfigDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxTrapRewardConfigData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxTrapRewardConfigDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxTrapRewardConfigDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxTrapRewardConfigDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxTrapRewardConfigDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxTrapRewardConfigData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxTrapRewardConfigData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxTrapRewardConfigData>>(
                dict__string__clz_Torappu_SandboxTrapRewardConfigData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxTrapRewardConfigDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxTrapRewardConfigDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxTrapRewardConfigData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxTrapRewardConfigData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxTrapRewardConfigData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxTrapRewardConfigData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxRewardCommonConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxRewardCommonConfig<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxRewardCommonConfig<'a> {
    type Inner = clz_Torappu_SandboxRewardCommonConfig<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxRewardCommonConfig<'a> {
    pub const VT_REWARDITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_REWARDITEMTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_COUNT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxRewardCommonConfig { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxRewardCommonConfigArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxRewardCommonConfig<'bldr>> {
        let mut builder = clz_Torappu_SandboxRewardCommonConfigBuilder::new(_fbb);
        builder.add_count(args.count);
        builder.add_rewardItemType(args.rewardItemType);
        if let Some(x) = args.rewardItemId {
            builder.add_rewardItemId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn rewardItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxRewardCommonConfig::VT_REWARDITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn rewardItemType(&self) -> enum__Torappu_SandboxItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxItemType>(
                    clz_Torappu_SandboxRewardCommonConfig::VT_REWARDITEMTYPE,
                    Some(enum__Torappu_SandboxItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxRewardCommonConfig::VT_COUNT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxRewardCommonConfig<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rewardItemId",
                Self::VT_REWARDITEMID,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxItemType>(
                "rewardItemType",
                Self::VT_REWARDITEMTYPE,
                false,
            )?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxRewardCommonConfigArgs<'a> {
    pub rewardItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewardItemType: enum__Torappu_SandboxItemType,
    pub count: i32,
}
impl<'a> Default for clz_Torappu_SandboxRewardCommonConfigArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxRewardCommonConfigArgs {
            rewardItemId: None,
            rewardItemType: enum__Torappu_SandboxItemType::NONE,
            count: 0,
        }
    }
}

pub struct clz_Torappu_SandboxRewardCommonConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxRewardCommonConfigBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_rewardItemId(&mut self, rewardItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxRewardCommonConfig::VT_REWARDITEMID,
            rewardItemId,
        );
    }
    #[inline]
    pub fn add_rewardItemType(&mut self, rewardItemType: enum__Torappu_SandboxItemType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxItemType>(
            clz_Torappu_SandboxRewardCommonConfig::VT_REWARDITEMTYPE,
            rewardItemType,
            enum__Torappu_SandboxItemType::NONE,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxRewardCommonConfig::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxRewardCommonConfigBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxRewardCommonConfigBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxRewardCommonConfig<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxRewardCommonConfig<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxRewardCommonConfig");
        ds.field("rewardItemId", &self.rewardItemId());
        ds.field("rewardItemType", &self.rewardItemType());
        ds.field("count", &self.count());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxRewardCommonConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxRewardCommonConfig<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxRewardCommonConfig<'a> {
    type Inner = dict__string__clz_Torappu_SandboxRewardCommonConfig<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxRewardCommonConfig<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxRewardCommonConfig { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxRewardCommonConfigArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxRewardCommonConfig<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxRewardCommonConfigBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxRewardCommonConfig::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxRewardCommonConfig,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxRewardCommonConfig<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxRewardCommonConfig>>(
                    dict__string__clz_Torappu_SandboxRewardCommonConfig::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxRewardCommonConfig<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxRewardCommonConfig>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxRewardCommonConfigArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxRewardCommonConfig<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxRewardCommonConfigArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxRewardCommonConfigArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxRewardCommonConfigBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxRewardCommonConfigBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxRewardCommonConfig::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxRewardCommonConfig<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxRewardCommonConfig>>(
                dict__string__clz_Torappu_SandboxRewardCommonConfig::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxRewardCommonConfigBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxRewardCommonConfigBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxRewardCommonConfig<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxRewardCommonConfig::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxRewardCommonConfig<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxRewardCommonConfig");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum dict__string__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__string<'a> {
    type Inner = dict__string__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__string<'bldr>> {
        let mut builder = dict__string__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__string::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__string::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__stringArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for dict__string__stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__stringArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__stringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__stringBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__string::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__string::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, dict__string__string::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxRewardConfigGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxRewardConfigGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxRewardConfigGroupData<'a> {
    type Inner = clz_Torappu_SandboxRewardConfigGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxRewardConfigGroupData<'a> {
    pub const VT_STAGEPREVIEWREWARDDICT: flatbuffers::VOffsetT = 4;
    pub const VT_STAGEDEFAULTPREVIEWREWARDDICT: flatbuffers::VOffsetT = 6;
    pub const VT_RUSHPREVIEWREWARDDICT: flatbuffers::VOffsetT = 8;
    pub const VT_STAGEREWARDDICT: flatbuffers::VOffsetT = 10;
    pub const VT_RUSHREWARDDICT: flatbuffers::VOffsetT = 12;
    pub const VT_TRAPREWARDDICT: flatbuffers::VOffsetT = 14;
    pub const VT_ENEMYREWARDDICT: flatbuffers::VOffsetT = 16;
    pub const VT_KEYWORDDATA: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxRewardConfigGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxRewardConfigGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxRewardConfigGroupData<'bldr>> {
        let mut builder = clz_Torappu_SandboxRewardConfigGroupDataBuilder::new(_fbb);
        if let Some(x) = args.keyWordData {
            builder.add_keyWordData(x);
        }
        if let Some(x) = args.enemyRewardDict {
            builder.add_enemyRewardDict(x);
        }
        if let Some(x) = args.trapRewardDict {
            builder.add_trapRewardDict(x);
        }
        if let Some(x) = args.rushRewardDict {
            builder.add_rushRewardDict(x);
        }
        if let Some(x) = args.stageRewardDict {
            builder.add_stageRewardDict(x);
        }
        if let Some(x) = args.rushPreviewRewardDict {
            builder.add_rushPreviewRewardDict(x);
        }
        if let Some(x) = args.stageDefaultPreviewRewardDict {
            builder.add_stageDefaultPreviewRewardDict(x);
        }
        if let Some(x) = args.stagePreviewRewardDict {
            builder.add_stagePreviewRewardDict(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn stagePreviewRewardDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData>,
                >,
            >>(
                clz_Torappu_SandboxRewardConfigGroupData::VT_STAGEPREVIEWREWARDDICT,
                None,
            )
        }
    }
    #[inline]
    pub fn stageDefaultPreviewRewardDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData>,
                >,
            >>(
                clz_Torappu_SandboxRewardConfigGroupData::VT_STAGEDEFAULTPREVIEWREWARDDICT,
                None,
            )
        }
    }
    #[inline]
    pub fn rushPreviewRewardDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData>,
                >,
            >>(
                clz_Torappu_SandboxRewardConfigGroupData::VT_RUSHPREVIEWREWARDDICT,
                None,
            )
        }
    }
    #[inline]
    pub fn stageRewardDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData>,
                >,
            >>(
                clz_Torappu_SandboxRewardConfigGroupData::VT_STAGEREWARDDICT,
                None,
            )
        }
    }
    #[inline]
    pub fn rushRewardDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData>,
                >,
            >>(
                clz_Torappu_SandboxRewardConfigGroupData::VT_RUSHREWARDDICT,
                None,
            )
        }
    }
    #[inline]
    pub fn trapRewardDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxTrapRewardConfigData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxTrapRewardConfigData,
                    >,
                >,
            >>(
                clz_Torappu_SandboxRewardConfigGroupData::VT_TRAPREWARDDICT,
                None,
            )
        }
    }
    #[inline]
    pub fn enemyRewardDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardCommonConfig<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxRewardCommonConfig,
                    >,
                >,
            >>(
                clz_Torappu_SandboxRewardConfigGroupData::VT_ENEMYREWARDDICT,
                None,
            )
        }
    }
    #[inline]
    pub fn keyWordData(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(
                clz_Torappu_SandboxRewardConfigGroupData::VT_KEYWORDDATA,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxRewardConfigGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData>,
                >,
            >>(
                "stagePreviewRewardDict",
                Self::VT_STAGEPREVIEWREWARDDICT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData>,
                >,
            >>(
                "stageDefaultPreviewRewardDict",
                Self::VT_STAGEDEFAULTPREVIEWREWARDDICT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData>,
                >,
            >>(
                "rushPreviewRewardDict",
                Self::VT_RUSHPREVIEWREWARDDICT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData>,
                >,
            >>("stageRewardDict", Self::VT_STAGEREWARDDICT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData>,
                >,
            >>("rushRewardDict", Self::VT_RUSHREWARDDICT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxTrapRewardConfigData,
                    >,
                >,
            >>("trapRewardDict", Self::VT_TRAPREWARDDICT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxRewardCommonConfig,
                    >,
                >,
            >>("enemyRewardDict", Self::VT_ENEMYREWARDDICT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>("keyWordData", Self::VT_KEYWORDDATA, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxRewardConfigGroupDataArgs<'a> {
    pub stagePreviewRewardDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData<'a>>,
            >,
        >,
    >,
    pub stageDefaultPreviewRewardDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData<'a>>,
            >,
        >,
    >,
    pub rushPreviewRewardDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData<'a>>,
            >,
        >,
    >,
    pub stageRewardDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData<'a>>,
            >,
        >,
    >,
    pub rushRewardDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData<'a>>,
            >,
        >,
    >,
    pub trapRewardDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxTrapRewardConfigData<'a>,
                >,
            >,
        >,
    >,
    pub enemyRewardDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxRewardCommonConfig<'a>,
                >,
            >,
        >,
    >,
    pub keyWordData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SandboxRewardConfigGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxRewardConfigGroupDataArgs {
            stagePreviewRewardDict: None,
            stageDefaultPreviewRewardDict: None,
            rushPreviewRewardDict: None,
            stageRewardDict: None,
            rushRewardDict: None,
            trapRewardDict: None,
            enemyRewardDict: None,
            keyWordData: None,
        }
    }
}

pub struct clz_Torappu_SandboxRewardConfigGroupDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxRewardConfigGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_stagePreviewRewardDict(
        &mut self,
        stagePreviewRewardDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxRewardConfigGroupData::VT_STAGEPREVIEWREWARDDICT,
            stagePreviewRewardDict,
        );
    }
    #[inline]
    pub fn add_stageDefaultPreviewRewardDict(
        &mut self,
        stageDefaultPreviewRewardDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxRewardConfigGroupData::VT_STAGEDEFAULTPREVIEWREWARDDICT,
            stageDefaultPreviewRewardDict,
        );
    }
    #[inline]
    pub fn add_rushPreviewRewardDict(
        &mut self,
        rushPreviewRewardDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxRewardConfigGroupData::VT_RUSHPREVIEWREWARDDICT,
            rushPreviewRewardDict,
        );
    }
    #[inline]
    pub fn add_stageRewardDict(
        &mut self,
        stageRewardDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxRewardConfigGroupData::VT_STAGEREWARDDICT,
            stageRewardDict,
        );
    }
    #[inline]
    pub fn add_rushRewardDict(
        &mut self,
        rushRewardDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxRewardData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxRewardConfigGroupData::VT_RUSHREWARDDICT,
            rushRewardDict,
        );
    }
    #[inline]
    pub fn add_trapRewardDict(
        &mut self,
        trapRewardDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxTrapRewardConfigData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxRewardConfigGroupData::VT_TRAPREWARDDICT,
            trapRewardDict,
        );
    }
    #[inline]
    pub fn add_enemyRewardDict(
        &mut self,
        enemyRewardDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxRewardCommonConfig<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxRewardConfigGroupData::VT_ENEMYREWARDDICT,
            enemyRewardDict,
        );
    }
    #[inline]
    pub fn add_keyWordData(
        &mut self,
        keyWordData: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxRewardConfigGroupData::VT_KEYWORDDATA,
            keyWordData,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxRewardConfigGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxRewardConfigGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxRewardConfigGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxRewardConfigGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxRewardConfigGroupData");
        ds.field("stagePreviewRewardDict", &self.stagePreviewRewardDict());
        ds.field(
            "stageDefaultPreviewRewardDict",
            &self.stageDefaultPreviewRewardDict(),
        );
        ds.field("rushPreviewRewardDict", &self.rushPreviewRewardDict());
        ds.field("stageRewardDict", &self.stageRewardDict());
        ds.field("rushRewardDict", &self.rushRewardDict());
        ds.field("trapRewardDict", &self.trapRewardDict());
        ds.field("enemyRewardDict", &self.enemyRewardDict());
        ds.field("keyWordData", &self.keyWordData());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxStaminaDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxStaminaData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxStaminaData<'a> {
    type Inner = clz_Torappu_SandboxStaminaData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxStaminaData<'a> {
    pub const VT_LEVELUPPERLIMIT: flatbuffers::VOffsetT = 4;
    pub const VT_STAMINAUPPERLIMIT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxStaminaData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxStaminaDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxStaminaData<'bldr>> {
        let mut builder = clz_Torappu_SandboxStaminaDataBuilder::new(_fbb);
        builder.add_staminaUpperLimit(args.staminaUpperLimit);
        builder.add_levelUpperLimit(args.levelUpperLimit);
        builder.finish()
    }

    #[inline]
    pub fn levelUpperLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxStaminaData::VT_LEVELUPPERLIMIT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn staminaUpperLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SandboxStaminaData::VT_STAMINAUPPERLIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxStaminaData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("levelUpperLimit", Self::VT_LEVELUPPERLIMIT, false)?
            .visit_field::<i32>("staminaUpperLimit", Self::VT_STAMINAUPPERLIMIT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxStaminaDataArgs {
    pub levelUpperLimit: i32,
    pub staminaUpperLimit: i32,
}
impl<'a> Default for clz_Torappu_SandboxStaminaDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxStaminaDataArgs {
            levelUpperLimit: 0,
            staminaUpperLimit: 0,
        }
    }
}

pub struct clz_Torappu_SandboxStaminaDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxStaminaDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_levelUpperLimit(&mut self, levelUpperLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxStaminaData::VT_LEVELUPPERLIMIT,
            levelUpperLimit,
            0,
        );
    }
    #[inline]
    pub fn add_staminaUpperLimit(&mut self, staminaUpperLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxStaminaData::VT_STAMINAUPPERLIMIT,
            staminaUpperLimit,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxStaminaDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxStaminaDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxStaminaData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxStaminaData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxStaminaData");
        ds.field("levelUpperLimit", &self.levelUpperLimit());
        ds.field("staminaUpperLimit", &self.staminaUpperLimit());
        ds.finish()
    }
}
pub enum dict__int__list_clz_Torappu_SandboxStaminaDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__list_clz_Torappu_SandboxStaminaData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__int__list_clz_Torappu_SandboxStaminaData<'a> {
    type Inner = dict__int__list_clz_Torappu_SandboxStaminaData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__int__list_clz_Torappu_SandboxStaminaData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__list_clz_Torappu_SandboxStaminaData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__list_clz_Torappu_SandboxStaminaDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__int__list_clz_Torappu_SandboxStaminaData<'bldr>> {
        let mut builder = dict__int__list_clz_Torappu_SandboxStaminaDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    dict__int__list_clz_Torappu_SandboxStaminaData::VT_KEY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__int__list_clz_Torappu_SandboxStaminaData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxStaminaData<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxStaminaData>,
                >,
            >>(
                dict__int__list_clz_Torappu_SandboxStaminaData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for dict__int__list_clz_Torappu_SandboxStaminaData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxStaminaData>,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__int__list_clz_Torappu_SandboxStaminaDataArgs<'a> {
    pub key: i32,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxStaminaData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for dict__int__list_clz_Torappu_SandboxStaminaDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__int__list_clz_Torappu_SandboxStaminaDataArgs {
            key: 0,
            value: None,
        }
    }
}

pub struct dict__int__list_clz_Torappu_SandboxStaminaDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__int__list_clz_Torappu_SandboxStaminaDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_.push_slot::<i32>(
            dict__int__list_clz_Torappu_SandboxStaminaData::VT_KEY,
            key,
            0,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxStaminaData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__int__list_clz_Torappu_SandboxStaminaData::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__list_clz_Torappu_SandboxStaminaDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__int__list_clz_Torappu_SandboxStaminaDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__int__list_clz_Torappu_SandboxStaminaData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__int__list_clz_Torappu_SandboxStaminaData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__int__list_clz_Torappu_SandboxStaminaData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaData<'a>
{
    type Inner = dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaData<'bldr>>
    {
        let mut builder =
            dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaData::VT_KEY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__int__list_clz_Torappu_SandboxStaminaData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__int__list_clz_Torappu_SandboxStaminaData>,
                >,
            >>(
                dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__int__list_clz_Torappu_SandboxStaminaData>,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaDataArgs<'a> {
    pub key: i32,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__int__list_clz_Torappu_SandboxStaminaData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaDataArgs {
            key: 0,
            value: None,
        }
    }
}

pub struct dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_.push_slot::<i32>(
            dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaData::VT_KEY,
            key,
            0,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__int__list_clz_Torappu_SandboxStaminaData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaData::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxNodeTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxNodeTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxNodeTypeData<'a> {
    type Inner = clz_Torappu_SandboxNodeTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxNodeTypeData<'a> {
    pub const VT_NODETYPE: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_SUBNAME: flatbuffers::VOffsetT = 8;
    pub const VT_ICONID: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxNodeTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxNodeTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxNodeTypeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxNodeTypeDataBuilder::new(_fbb);
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.subName {
            builder.add_subName(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_nodeType(args.nodeType);
        builder.finish()
    }

    #[inline]
    pub fn nodeType(&self) -> enum__Torappu_SandboxNodeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxNodeType>(
                    clz_Torappu_SandboxNodeTypeData::VT_NODETYPE,
                    Some(enum__Torappu_SandboxNodeType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxNodeTypeData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn subName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxNodeTypeData::VT_SUBNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxNodeTypeData::VT_ICONID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxNodeTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxNodeType>("nodeType", Self::VT_NODETYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("subName", Self::VT_SUBNAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxNodeTypeDataArgs<'a> {
    pub nodeType: enum__Torappu_SandboxNodeType,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub subName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxNodeTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxNodeTypeDataArgs {
            nodeType: enum__Torappu_SandboxNodeType::NONE,
            name: None,
            subName: None,
            iconId: None,
        }
    }
}

pub struct clz_Torappu_SandboxNodeTypeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxNodeTypeDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_nodeType(&mut self, nodeType: enum__Torappu_SandboxNodeType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxNodeType>(
            clz_Torappu_SandboxNodeTypeData::VT_NODETYPE,
            nodeType,
            enum__Torappu_SandboxNodeType::NONE,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxNodeTypeData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_subName(&mut self, subName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxNodeTypeData::VT_SUBNAME,
            subName,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxNodeTypeData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxNodeTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxNodeTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxNodeTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxNodeTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxNodeTypeData");
        ds.field("nodeType", &self.nodeType());
        ds.field("name", &self.name());
        ds.field("subName", &self.subName());
        ds.field("iconId", &self.iconId());
        ds.finish()
    }
}
pub enum dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeData<'a>
{
    type Inner = dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeDataArgs<
            'args,
        >,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeData<'bldr>,
    > {
        let mut builder =
            dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_SandboxNodeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxNodeType>(
                    dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeData::VT_KEY,
                    Some(enum__Torappu_SandboxNodeType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_SandboxNodeType,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxNodeTypeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxNodeTypeData>>(
                    dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxNodeType>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxNodeTypeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeDataArgs<'a> {
    pub key: enum__Torappu_SandboxNodeType,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxNodeTypeData<'a>>>,
}
impl<'a> Default for dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeDataArgs {
            key: enum__Torappu_SandboxNodeType::NONE,
            value: None,
        }
    }
}

pub struct dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: enum__Torappu_SandboxNodeType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxNodeType>(
            dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeData::VT_KEY,
            key,
            enum__Torappu_SandboxNodeType::NONE,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxNodeTypeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxNodeTypeData>>(
                dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeDataBuilder<'a, 'b, A>
    {
        let start = _fbb.start_table();
        dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeData<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxNodeUpgradeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxNodeUpgradeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxNodeUpgradeData<'a> {
    type Inner = clz_Torappu_SandboxNodeUpgradeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxNodeUpgradeData<'a> {
    pub const VT_NODEUPDRADEID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 8;
    pub const VT_UPGRADEDESC: flatbuffers::VOffsetT = 10;
    pub const VT_ITEMTYPE: flatbuffers::VOffsetT = 12;
    pub const VT_ITEMSUBTYPE: flatbuffers::VOffsetT = 14;
    pub const VT_ITEMCNT: flatbuffers::VOffsetT = 16;
    pub const VT_ITEMRARITY: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxNodeUpgradeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxNodeUpgradeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxNodeUpgradeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxNodeUpgradeDataBuilder::new(_fbb);
        builder.add_itemRarity(args.itemRarity);
        builder.add_itemCnt(args.itemCnt);
        builder.add_itemSubType(args.itemSubType);
        builder.add_itemType(args.itemType);
        if let Some(x) = args.upgradeDesc {
            builder.add_upgradeDesc(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.nodeUpdradeId {
            builder.add_nodeUpdradeId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn nodeUpdradeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxNodeUpgradeData::VT_NODEUPDRADEID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxNodeUpgradeData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxNodeUpgradeData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn upgradeDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxNodeUpgradeData::VT_UPGRADEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn itemType(&self) -> enum__Torappu_SandboxItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxItemType>(
                    clz_Torappu_SandboxNodeUpgradeData::VT_ITEMTYPE,
                    Some(enum__Torappu_SandboxItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn itemSubType(&self) -> enum__Torappu_SandboxBuildingItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxBuildingItemType>(
                    clz_Torappu_SandboxNodeUpgradeData::VT_ITEMSUBTYPE,
                    Some(enum__Torappu_SandboxBuildingItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn itemCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxNodeUpgradeData::VT_ITEMCNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn itemRarity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxNodeUpgradeData::VT_ITEMRARITY, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxNodeUpgradeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nodeUpdradeId",
                Self::VT_NODEUPDRADEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "upgradeDesc",
                Self::VT_UPGRADEDESC,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxItemType>("itemType", Self::VT_ITEMTYPE, false)?
            .visit_field::<enum__Torappu_SandboxBuildingItemType>(
                "itemSubType",
                Self::VT_ITEMSUBTYPE,
                false,
            )?
            .visit_field::<i32>("itemCnt", Self::VT_ITEMCNT, false)?
            .visit_field::<i32>("itemRarity", Self::VT_ITEMRARITY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxNodeUpgradeDataArgs<'a> {
    pub nodeUpdradeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub upgradeDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemType: enum__Torappu_SandboxItemType,
    pub itemSubType: enum__Torappu_SandboxBuildingItemType,
    pub itemCnt: i32,
    pub itemRarity: i32,
}
impl<'a> Default for clz_Torappu_SandboxNodeUpgradeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxNodeUpgradeDataArgs {
            nodeUpdradeId: None,
            name: None,
            description: None,
            upgradeDesc: None,
            itemType: enum__Torappu_SandboxItemType::NONE,
            itemSubType: enum__Torappu_SandboxBuildingItemType::NONE,
            itemCnt: 0,
            itemRarity: 0,
        }
    }
}

pub struct clz_Torappu_SandboxNodeUpgradeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxNodeUpgradeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeUpdradeId(&mut self, nodeUpdradeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxNodeUpgradeData::VT_NODEUPDRADEID,
            nodeUpdradeId,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxNodeUpgradeData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxNodeUpgradeData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_upgradeDesc(&mut self, upgradeDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxNodeUpgradeData::VT_UPGRADEDESC,
            upgradeDesc,
        );
    }
    #[inline]
    pub fn add_itemType(&mut self, itemType: enum__Torappu_SandboxItemType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxItemType>(
            clz_Torappu_SandboxNodeUpgradeData::VT_ITEMTYPE,
            itemType,
            enum__Torappu_SandboxItemType::NONE,
        );
    }
    #[inline]
    pub fn add_itemSubType(&mut self, itemSubType: enum__Torappu_SandboxBuildingItemType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxBuildingItemType>(
                clz_Torappu_SandboxNodeUpgradeData::VT_ITEMSUBTYPE,
                itemSubType,
                enum__Torappu_SandboxBuildingItemType::NONE,
            );
    }
    #[inline]
    pub fn add_itemCnt(&mut self, itemCnt: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxNodeUpgradeData::VT_ITEMCNT, itemCnt, 0);
    }
    #[inline]
    pub fn add_itemRarity(&mut self, itemRarity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxNodeUpgradeData::VT_ITEMRARITY,
            itemRarity,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxNodeUpgradeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxNodeUpgradeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxNodeUpgradeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxNodeUpgradeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxNodeUpgradeData");
        ds.field("nodeUpdradeId", &self.nodeUpdradeId());
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.field("upgradeDesc", &self.upgradeDesc());
        ds.field("itemType", &self.itemType());
        ds.field("itemSubType", &self.itemSubType());
        ds.field("itemCnt", &self.itemCnt());
        ds.field("itemRarity", &self.itemRarity());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxNodeUpgradeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxNodeUpgradeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxNodeUpgradeData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxNodeUpgradeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxNodeUpgradeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxNodeUpgradeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxNodeUpgradeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxNodeUpgradeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxNodeUpgradeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxNodeUpgradeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxNodeUpgradeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxNodeUpgradeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxNodeUpgradeData>>(
                    dict__string__clz_Torappu_SandboxNodeUpgradeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxNodeUpgradeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxNodeUpgradeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxNodeUpgradeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxNodeUpgradeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxNodeUpgradeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxNodeUpgradeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxNodeUpgradeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxNodeUpgradeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxNodeUpgradeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxNodeUpgradeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxNodeUpgradeData>>(
                dict__string__clz_Torappu_SandboxNodeUpgradeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxNodeUpgradeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxNodeUpgradeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxNodeUpgradeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxNodeUpgradeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxNodeUpgradeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxNodeUpgradeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxWeatherDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxWeatherData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxWeatherData<'a> {
    type Inner = clz_Torappu_SandboxWeatherData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxWeatherData<'a> {
    pub const VT_WEATHERID: flatbuffers::VOffsetT = 4;
    pub const VT_WEATHERTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_WEATHERLEVEL: flatbuffers::VOffsetT = 8;
    pub const VT_NAME: flatbuffers::VOffsetT = 10;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 12;
    pub const VT_WEATHERTYPENAME: flatbuffers::VOffsetT = 14;
    pub const VT_WEATHERTYPEICONID: flatbuffers::VOffsetT = 16;
    pub const VT_FUNCTIONDESC: flatbuffers::VOffsetT = 18;
    pub const VT_BUFFID: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxWeatherData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxWeatherDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxWeatherData<'bldr>> {
        let mut builder = clz_Torappu_SandboxWeatherDataBuilder::new(_fbb);
        if let Some(x) = args.buffId {
            builder.add_buffId(x);
        }
        if let Some(x) = args.functionDesc {
            builder.add_functionDesc(x);
        }
        if let Some(x) = args.weatherTypeIconId {
            builder.add_weatherTypeIconId(x);
        }
        if let Some(x) = args.weatherTypeName {
            builder.add_weatherTypeName(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_weatherLevel(args.weatherLevel);
        builder.add_weatherType(args.weatherType);
        if let Some(x) = args.weatherId {
            builder.add_weatherId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn weatherId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxWeatherData::VT_WEATHERID,
                None,
            )
        }
    }
    #[inline]
    pub fn weatherType(&self) -> enum__Torappu_SandboxWeatherType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxWeatherType>(
                    clz_Torappu_SandboxWeatherData::VT_WEATHERTYPE,
                    Some(enum__Torappu_SandboxWeatherType::NORMAL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn weatherLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxWeatherData::VT_WEATHERLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxWeatherData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxWeatherData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn weatherTypeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxWeatherData::VT_WEATHERTYPENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn weatherTypeIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxWeatherData::VT_WEATHERTYPEICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn functionDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxWeatherData::VT_FUNCTIONDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn buffId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxWeatherData::VT_BUFFID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxWeatherData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "weatherId",
                Self::VT_WEATHERID,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxWeatherType>(
                "weatherType",
                Self::VT_WEATHERTYPE,
                false,
            )?
            .visit_field::<i32>("weatherLevel", Self::VT_WEATHERLEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "weatherTypeName",
                Self::VT_WEATHERTYPENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "weatherTypeIconId",
                Self::VT_WEATHERTYPEICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "functionDesc",
                Self::VT_FUNCTIONDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buffId", Self::VT_BUFFID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxWeatherDataArgs<'a> {
    pub weatherId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weatherType: enum__Torappu_SandboxWeatherType,
    pub weatherLevel: i32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weatherTypeName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weatherTypeIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub functionDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxWeatherDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxWeatherDataArgs {
            weatherId: None,
            weatherType: enum__Torappu_SandboxWeatherType::NORMAL,
            weatherLevel: 0,
            name: None,
            description: None,
            weatherTypeName: None,
            weatherTypeIconId: None,
            functionDesc: None,
            buffId: None,
        }
    }
}

pub struct clz_Torappu_SandboxWeatherDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxWeatherDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_weatherId(&mut self, weatherId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxWeatherData::VT_WEATHERID,
            weatherId,
        );
    }
    #[inline]
    pub fn add_weatherType(&mut self, weatherType: enum__Torappu_SandboxWeatherType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxWeatherType>(
            clz_Torappu_SandboxWeatherData::VT_WEATHERTYPE,
            weatherType,
            enum__Torappu_SandboxWeatherType::NORMAL,
        );
    }
    #[inline]
    pub fn add_weatherLevel(&mut self, weatherLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxWeatherData::VT_WEATHERLEVEL,
            weatherLevel,
            0,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxWeatherData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxWeatherData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_weatherTypeName(&mut self, weatherTypeName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxWeatherData::VT_WEATHERTYPENAME,
            weatherTypeName,
        );
    }
    #[inline]
    pub fn add_weatherTypeIconId(&mut self, weatherTypeIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxWeatherData::VT_WEATHERTYPEICONID,
            weatherTypeIconId,
        );
    }
    #[inline]
    pub fn add_functionDesc(&mut self, functionDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxWeatherData::VT_FUNCTIONDESC,
            functionDesc,
        );
    }
    #[inline]
    pub fn add_buffId(&mut self, buffId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxWeatherData::VT_BUFFID,
            buffId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxWeatherDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxWeatherDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxWeatherData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxWeatherData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxWeatherData");
        ds.field("weatherId", &self.weatherId());
        ds.field("weatherType", &self.weatherType());
        ds.field("weatherLevel", &self.weatherLevel());
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.field("weatherTypeName", &self.weatherTypeName());
        ds.field("weatherTypeIconId", &self.weatherTypeIconId());
        ds.field("functionDesc", &self.functionDesc());
        ds.field("buffId", &self.buffId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxWeatherDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxWeatherData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxWeatherData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxWeatherData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxWeatherData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxWeatherData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxWeatherDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxWeatherData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxWeatherDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxWeatherData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxWeatherData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxWeatherData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxWeatherData>>(
                    dict__string__clz_Torappu_SandboxWeatherData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxWeatherData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxWeatherData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxWeatherDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxWeatherData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxWeatherDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxWeatherDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxWeatherDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxWeatherDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxWeatherData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxWeatherData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxWeatherData>>(
                dict__string__clz_Torappu_SandboxWeatherData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxWeatherDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxWeatherDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxWeatherData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxWeatherData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxWeatherData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxWeatherData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxStageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxStageData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxStageData<'a> {
    type Inner = clz_Torappu_SandboxStageData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxStageData<'a> {
    pub const VT_STAGEID: flatbuffers::VOffsetT = 4;
    pub const VT_LEVELID: flatbuffers::VOffsetT = 6;
    pub const VT_CODE: flatbuffers::VOffsetT = 8;
    pub const VT_NAME: flatbuffers::VOffsetT = 10;
    pub const VT_LOADINGPICID: flatbuffers::VOffsetT = 12;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 14;
    pub const VT_ACTIONCOST: flatbuffers::VOffsetT = 16;
    pub const VT_POWERCOST: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxStageData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxStageDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxStageData<'bldr>> {
        let mut builder = clz_Torappu_SandboxStageDataBuilder::new(_fbb);
        builder.add_powerCost(args.powerCost);
        builder.add_actionCost(args.actionCost);
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.loadingPicId {
            builder.add_loadingPicId(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.code {
            builder.add_code(x);
        }
        if let Some(x) = args.levelId {
            builder.add_levelId(x);
        }
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxStageData::VT_STAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn levelId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxStageData::VT_LEVELID,
                None,
            )
        }
    }
    #[inline]
    pub fn code(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxStageData::VT_CODE,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxStageData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn loadingPicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxStageData::VT_LOADINGPICID,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxStageData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn actionCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxStageData::VT_ACTIONCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn powerCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxStageData::VT_POWERCOST, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxStageData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("levelId", Self::VT_LEVELID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("code", Self::VT_CODE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "loadingPicId",
                Self::VT_LOADINGPICID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<i32>("actionCost", Self::VT_ACTIONCOST, false)?
            .visit_field::<i32>("powerCost", Self::VT_POWERCOST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxStageDataArgs<'a> {
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub levelId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub code: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub loadingPicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub actionCost: i32,
    pub powerCost: i32,
}
impl<'a> Default for clz_Torappu_SandboxStageDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxStageDataArgs {
            stageId: None,
            levelId: None,
            code: None,
            name: None,
            loadingPicId: None,
            description: None,
            actionCost: 0,
            powerCost: 0,
        }
    }
}

pub struct clz_Torappu_SandboxStageDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxStageDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxStageData::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn add_levelId(&mut self, levelId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxStageData::VT_LEVELID,
            levelId,
        );
    }
    #[inline]
    pub fn add_code(&mut self, code: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxStageData::VT_CODE,
            code,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxStageData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_loadingPicId(&mut self, loadingPicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxStageData::VT_LOADINGPICID,
            loadingPicId,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxStageData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_actionCost(&mut self, actionCost: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxStageData::VT_ACTIONCOST, actionCost, 0);
    }
    #[inline]
    pub fn add_powerCost(&mut self, powerCost: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxStageData::VT_POWERCOST, powerCost, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxStageDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxStageDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxStageData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxStageData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxStageData");
        ds.field("stageId", &self.stageId());
        ds.field("levelId", &self.levelId());
        ds.field("code", &self.code());
        ds.field("name", &self.name());
        ds.field("loadingPicId", &self.loadingPicId());
        ds.field("description", &self.description());
        ds.field("actionCost", &self.actionCost());
        ds.field("powerCost", &self.powerCost());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxStageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxStageData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxStageData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxStageData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxStageData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxStageData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxStageDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxStageData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxStageDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxStageData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxStageData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxStageData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxStageData>>(
                    dict__string__clz_Torappu_SandboxStageData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxStageData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxStageData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxStageDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxStageData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxStageDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxStageDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxStageDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxStageDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxStageData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxStageData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxStageData>>(
                dict__string__clz_Torappu_SandboxStageData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxStageDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxStageDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxStageData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_SandboxStageData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxStageData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxStageData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxEventDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxEventData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxEventData<'a> {
    type Inner = clz_Torappu_SandboxEventData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxEventData<'a> {
    pub const VT_EVENTSCENEID: flatbuffers::VOffsetT = 4;
    pub const VT_HASTHUMBTACK: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxEventData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxEventDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxEventData<'bldr>> {
        let mut builder = clz_Torappu_SandboxEventDataBuilder::new(_fbb);
        if let Some(x) = args.eventSceneId {
            builder.add_eventSceneId(x);
        }
        builder.add_hasThumbtack(args.hasThumbtack);
        builder.finish()
    }

    #[inline]
    pub fn eventSceneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxEventData::VT_EVENTSCENEID,
                None,
            )
        }
    }
    #[inline]
    pub fn hasThumbtack(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_SandboxEventData::VT_HASTHUMBTACK, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxEventData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "eventSceneId",
                Self::VT_EVENTSCENEID,
                false,
            )?
            .visit_field::<bool>("hasThumbtack", Self::VT_HASTHUMBTACK, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxEventDataArgs<'a> {
    pub eventSceneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hasThumbtack: bool,
}
impl<'a> Default for clz_Torappu_SandboxEventDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxEventDataArgs {
            eventSceneId: None,
            hasThumbtack: false,
        }
    }
}

pub struct clz_Torappu_SandboxEventDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxEventDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_eventSceneId(&mut self, eventSceneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxEventData::VT_EVENTSCENEID,
            eventSceneId,
        );
    }
    #[inline]
    pub fn add_hasThumbtack(&mut self, hasThumbtack: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SandboxEventData::VT_HASTHUMBTACK,
            hasThumbtack,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxEventDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxEventDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxEventData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxEventData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxEventData");
        ds.field("eventSceneId", &self.eventSceneId());
        ds.field("hasThumbtack", &self.hasThumbtack());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxEventDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxEventData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxEventData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxEventData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxEventData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxEventData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxEventDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxEventData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxEventDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxEventData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxEventData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxEventData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxEventData>>(
                    dict__string__clz_Torappu_SandboxEventData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxEventData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxEventData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxEventDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxEventData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxEventDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxEventDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxEventDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxEventDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxEventData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxEventData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxEventData>>(
                dict__string__clz_Torappu_SandboxEventData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxEventDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxEventDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxEventData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_SandboxEventData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxEventData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxEventData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxEventSceneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxEventSceneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxEventSceneData<'a> {
    type Inner = clz_Torappu_SandboxEventSceneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxEventSceneData<'a> {
    pub const VT_CHOICESCENEID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_TITLE: flatbuffers::VOffsetT = 8;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
    pub const VT_CHOICES: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxEventSceneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxEventSceneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxEventSceneData<'bldr>> {
        let mut builder = clz_Torappu_SandboxEventSceneDataBuilder::new(_fbb);
        if let Some(x) = args.choices {
            builder.add_choices(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.title {
            builder.add_title(x);
        }
        builder.add_type_(args.type_);
        if let Some(x) = args.choiceSceneId {
            builder.add_choiceSceneId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn choiceSceneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxEventSceneData::VT_CHOICESCENEID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_SandboxEventType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxEventType>(
                    clz_Torappu_SandboxEventSceneData::VT_TYPE_,
                    Some(enum__Torappu_SandboxEventType::RESOURCE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn title(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxEventSceneData::VT_TITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxEventSceneData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn choices(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SandboxEventSceneData::VT_CHOICES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxEventSceneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "choiceSceneId",
                Self::VT_CHOICESCENEID,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxEventType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("choices", Self::VT_CHOICES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxEventSceneDataArgs<'a> {
    pub choiceSceneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_SandboxEventType,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub choices: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxEventSceneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxEventSceneDataArgs {
            choiceSceneId: None,
            type_: enum__Torappu_SandboxEventType::RESOURCE,
            title: None,
            description: None,
            choices: None,
        }
    }
}

pub struct clz_Torappu_SandboxEventSceneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxEventSceneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_choiceSceneId(&mut self, choiceSceneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxEventSceneData::VT_CHOICESCENEID,
            choiceSceneId,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_SandboxEventType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxEventType>(
            clz_Torappu_SandboxEventSceneData::VT_TYPE_,
            type_,
            enum__Torappu_SandboxEventType::RESOURCE,
        );
    }
    #[inline]
    pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxEventSceneData::VT_TITLE,
            title,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxEventSceneData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_choices(
        &mut self,
        choices: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxEventSceneData::VT_CHOICES,
            choices,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxEventSceneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxEventSceneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxEventSceneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxEventSceneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxEventSceneData");
        ds.field("choiceSceneId", &self.choiceSceneId());
        ds.field("type_", &self.type_());
        ds.field("title", &self.title());
        ds.field("description", &self.description());
        ds.field("choices", &self.choices());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxEventSceneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxEventSceneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxEventSceneData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxEventSceneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxEventSceneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxEventSceneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxEventSceneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxEventSceneData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxEventSceneDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxEventSceneData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxEventSceneData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxEventSceneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxEventSceneData>>(
                    dict__string__clz_Torappu_SandboxEventSceneData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxEventSceneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxEventSceneData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxEventSceneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxEventSceneData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxEventSceneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxEventSceneDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxEventSceneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxEventSceneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxEventSceneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxEventSceneData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxEventSceneData>>(
                dict__string__clz_Torappu_SandboxEventSceneData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxEventSceneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxEventSceneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxEventSceneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxEventSceneData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxEventSceneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxEventSceneData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxEventChoiceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxEventChoiceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxEventChoiceData<'a> {
    type Inner = clz_Torappu_SandboxEventChoiceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxEventChoiceData<'a> {
    pub const VT_CHOICEID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_COSTACTION: flatbuffers::VOffsetT = 8;
    pub const VT_FINISHSCENE: flatbuffers::VOffsetT = 10;
    pub const VT_TITLE: flatbuffers::VOffsetT = 12;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxEventChoiceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxEventChoiceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxEventChoiceData<'bldr>> {
        let mut builder = clz_Torappu_SandboxEventChoiceDataBuilder::new(_fbb);
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.title {
            builder.add_title(x);
        }
        builder.add_costAction(args.costAction);
        builder.add_type_(args.type_);
        if let Some(x) = args.choiceId {
            builder.add_choiceId(x);
        }
        builder.add_finishScene(args.finishScene);
        builder.finish()
    }

    #[inline]
    pub fn choiceId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxEventChoiceData::VT_CHOICEID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_SandboxEventChoiceType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxEventChoiceType>(
                    clz_Torappu_SandboxEventChoiceData::VT_TYPE_,
                    Some(enum__Torappu_SandboxEventChoiceType::LEAVE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn costAction(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxEventChoiceData::VT_COSTACTION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn finishScene(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_SandboxEventChoiceData::VT_FINISHSCENE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn title(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxEventChoiceData::VT_TITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxEventChoiceData::VT_DESCRIPTION,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxEventChoiceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "choiceId",
                Self::VT_CHOICEID,
                false,
            )?
            .visit_field::<enum__Torappu_SandboxEventChoiceType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<i32>("costAction", Self::VT_COSTACTION, false)?
            .visit_field::<bool>("finishScene", Self::VT_FINISHSCENE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxEventChoiceDataArgs<'a> {
    pub choiceId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_SandboxEventChoiceType,
    pub costAction: i32,
    pub finishScene: bool,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxEventChoiceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxEventChoiceDataArgs {
            choiceId: None,
            type_: enum__Torappu_SandboxEventChoiceType::LEAVE,
            costAction: 0,
            finishScene: false,
            title: None,
            description: None,
        }
    }
}

pub struct clz_Torappu_SandboxEventChoiceDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxEventChoiceDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_choiceId(&mut self, choiceId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxEventChoiceData::VT_CHOICEID,
            choiceId,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_SandboxEventChoiceType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxEventChoiceType>(
            clz_Torappu_SandboxEventChoiceData::VT_TYPE_,
            type_,
            enum__Torappu_SandboxEventChoiceType::LEAVE,
        );
    }
    #[inline]
    pub fn add_costAction(&mut self, costAction: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxEventChoiceData::VT_COSTACTION,
            costAction,
            0,
        );
    }
    #[inline]
    pub fn add_finishScene(&mut self, finishScene: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SandboxEventChoiceData::VT_FINISHSCENE,
            finishScene,
            false,
        );
    }
    #[inline]
    pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxEventChoiceData::VT_TITLE,
            title,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxEventChoiceData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxEventChoiceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxEventChoiceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxEventChoiceData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxEventChoiceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxEventChoiceData");
        ds.field("choiceId", &self.choiceId());
        ds.field("type_", &self.type_());
        ds.field("costAction", &self.costAction());
        ds.field("finishScene", &self.finishScene());
        ds.field("title", &self.title());
        ds.field("description", &self.description());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxEventChoiceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxEventChoiceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxEventChoiceData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxEventChoiceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxEventChoiceData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxEventChoiceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxEventChoiceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxEventChoiceData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxEventChoiceDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxEventChoiceData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SandboxEventChoiceData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxEventChoiceData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxEventChoiceData>>(
                    dict__string__clz_Torappu_SandboxEventChoiceData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxEventChoiceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxEventChoiceData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxEventChoiceDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxEventChoiceData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxEventChoiceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxEventChoiceDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxEventChoiceDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxEventChoiceDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxEventChoiceData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxEventChoiceData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxEventChoiceData>>(
                dict__string__clz_Torappu_SandboxEventChoiceData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxEventChoiceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxEventChoiceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxEventChoiceData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxEventChoiceData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxEventChoiceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxEventChoiceData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxEventTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxEventTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxEventTypeData<'a> {
    type Inner = clz_Torappu_SandboxEventTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxEventTypeData<'a> {
    pub const VT_EVENTTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_ICONID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxEventTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxEventTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxEventTypeData<'bldr>> {
        let mut builder = clz_Torappu_SandboxEventTypeDataBuilder::new(_fbb);
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        builder.add_eventType(args.eventType);
        builder.finish()
    }

    #[inline]
    pub fn eventType(&self) -> enum__Torappu_SandboxEventType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxEventType>(
                    clz_Torappu_SandboxEventTypeData::VT_EVENTTYPE,
                    Some(enum__Torappu_SandboxEventType::RESOURCE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxEventTypeData::VT_ICONID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxEventTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxEventType>("eventType", Self::VT_EVENTTYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxEventTypeDataArgs<'a> {
    pub eventType: enum__Torappu_SandboxEventType,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxEventTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxEventTypeDataArgs {
            eventType: enum__Torappu_SandboxEventType::RESOURCE,
            iconId: None,
        }
    }
}

pub struct clz_Torappu_SandboxEventTypeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxEventTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_eventType(&mut self, eventType: enum__Torappu_SandboxEventType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxEventType>(
            clz_Torappu_SandboxEventTypeData::VT_EVENTTYPE,
            eventType,
            enum__Torappu_SandboxEventType::RESOURCE,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxEventTypeData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxEventTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxEventTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxEventTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxEventTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxEventTypeData");
        ds.field("eventType", &self.eventType());
        ds.field("iconId", &self.iconId());
        ds.finish()
    }
}
pub enum dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeData<'a>
{
    type Inner = dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeDataArgs<
            'args,
        >,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeData<'bldr>,
    > {
        let mut builder =
            dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeDataBuilder::new(
                _fbb,
            );
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_SandboxEventType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxEventType>(
                    dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeData::VT_KEY,
                    Some(enum__Torappu_SandboxEventType::RESOURCE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_SandboxEventType,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxEventTypeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxEventTypeData>>(
                dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxEventType>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxEventTypeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeDataArgs<'a> {
    pub key: enum__Torappu_SandboxEventType,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxEventTypeData<'a>>>,
}
impl<'a> Default
    for dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeDataArgs<'a>
{
    #[inline]
    fn default() -> Self {
        dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeDataArgs {
            key: enum__Torappu_SandboxEventType::RESOURCE,
            value: None,
        }
    }
}

pub struct dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: enum__Torappu_SandboxEventType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxEventType>(
            dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeData::VT_KEY,
            key,
            enum__Torappu_SandboxEventType::RESOURCE,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SandboxEventTypeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxEventTypeData>>(
                dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeDataBuilder<'a, 'b, A>
    {
        let start = _fbb.start_table();
        dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeData<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeData<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f
            .debug_struct("dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxMissionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxMissionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxMissionData<'a> {
    type Inner = clz_Torappu_SandboxMissionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxMissionData<'a> {
    pub const VT_MISSIONID: flatbuffers::VOffsetT = 4;
    pub const VT_DESC: flatbuffers::VOffsetT = 6;
    pub const VT_EFFECTDESC: flatbuffers::VOffsetT = 8;
    pub const VT_COSTACTION: flatbuffers::VOffsetT = 10;
    pub const VT_CHARCNT: flatbuffers::VOffsetT = 12;
    pub const VT_PROFESSIONIDS: flatbuffers::VOffsetT = 14;
    pub const VT_PROFESSION: flatbuffers::VOffsetT = 16;
    pub const VT_COSTSTAMINA: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxMissionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxMissionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxMissionData<'bldr>> {
        let mut builder = clz_Torappu_SandboxMissionDataBuilder::new(_fbb);
        builder.add_costStamina(args.costStamina);
        builder.add_profession(args.profession);
        if let Some(x) = args.professionIds {
            builder.add_professionIds(x);
        }
        builder.add_charCnt(args.charCnt);
        builder.add_costAction(args.costAction);
        if let Some(x) = args.effectDesc {
            builder.add_effectDesc(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.missionId {
            builder.add_missionId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn missionId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxMissionData::VT_MISSIONID,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxMissionData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn effectDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxMissionData::VT_EFFECTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn costAction(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxMissionData::VT_COSTACTION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn charCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxMissionData::VT_CHARCNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn professionIds(&self) -> Option<flatbuffers::Vector<'a, enum__Torappu_ProfessionID>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_ProfessionID>,
            >>(clz_Torappu_SandboxMissionData::VT_PROFESSIONIDS, None)
        }
    }
    #[inline]
    pub fn profession(&self) -> enum__Torappu_ProfessionCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ProfessionCategory>(
                    clz_Torappu_SandboxMissionData::VT_PROFESSION,
                    Some(enum__Torappu_ProfessionCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn costStamina(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxMissionData::VT_COSTSTAMINA, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxMissionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("missionId", Self::VT_MISSIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("effectDesc", Self::VT_EFFECTDESC, false)?
     .visit_field::<i32>("costAction", Self::VT_COSTACTION, false)?
     .visit_field::<i32>("charCnt", Self::VT_CHARCNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_ProfessionID>>>("professionIds", Self::VT_PROFESSIONIDS, false)?
     .visit_field::<enum__Torappu_ProfessionCategory>("profession", Self::VT_PROFESSION, false)?
     .visit_field::<i32>("costStamina", Self::VT_COSTSTAMINA, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxMissionDataArgs<'a> {
    pub missionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub effectDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub costAction: i32,
    pub charCnt: i32,
    pub professionIds:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_ProfessionID>>>,
    pub profession: enum__Torappu_ProfessionCategory,
    pub costStamina: i32,
}
impl<'a> Default for clz_Torappu_SandboxMissionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxMissionDataArgs {
            missionId: None,
            desc: None,
            effectDesc: None,
            costAction: 0,
            charCnt: 0,
            professionIds: None,
            profession: enum__Torappu_ProfessionCategory::NONE,
            costStamina: 0,
        }
    }
}

pub struct clz_Torappu_SandboxMissionDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxMissionDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_missionId(&mut self, missionId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxMissionData::VT_MISSIONID,
            missionId,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxMissionData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_effectDesc(&mut self, effectDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxMissionData::VT_EFFECTDESC,
            effectDesc,
        );
    }
    #[inline]
    pub fn add_costAction(&mut self, costAction: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxMissionData::VT_COSTACTION, costAction, 0);
    }
    #[inline]
    pub fn add_charCnt(&mut self, charCnt: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxMissionData::VT_CHARCNT, charCnt, 0);
    }
    #[inline]
    pub fn add_professionIds(
        &mut self,
        professionIds: flatbuffers::WIPOffset<flatbuffers::Vector<'b, enum__Torappu_ProfessionID>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxMissionData::VT_PROFESSIONIDS,
            professionIds,
        );
    }
    #[inline]
    pub fn add_profession(&mut self, profession: enum__Torappu_ProfessionCategory) {
        self.fbb_.push_slot::<enum__Torappu_ProfessionCategory>(
            clz_Torappu_SandboxMissionData::VT_PROFESSION,
            profession,
            enum__Torappu_ProfessionCategory::NONE,
        );
    }
    #[inline]
    pub fn add_costStamina(&mut self, costStamina: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxMissionData::VT_COSTSTAMINA,
            costStamina,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxMissionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxMissionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxMissionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxMissionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxMissionData");
        ds.field("missionId", &self.missionId());
        ds.field("desc", &self.desc());
        ds.field("effectDesc", &self.effectDesc());
        ds.field("costAction", &self.costAction());
        ds.field("charCnt", &self.charCnt());
        ds.field("professionIds", &self.professionIds());
        ds.field("profession", &self.profession());
        ds.field("costStamina", &self.costStamina());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxMissionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxMissionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxMissionData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxMissionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxMissionData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxMissionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxMissionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxMissionData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxMissionDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxMissionData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxMissionData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxMissionData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxMissionData>>(
                    dict__string__clz_Torappu_SandboxMissionData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxMissionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxMissionData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxMissionDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxMissionData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxMissionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxMissionDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxMissionDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxMissionDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxMissionData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxMissionData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxMissionData>>(
                dict__string__clz_Torappu_SandboxMissionData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxMissionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxMissionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxMissionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SandboxMissionData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxMissionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxMissionData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxUnitDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxUnitData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxUnitData<'a> {
    type Inner = clz_Torappu_SandboxUnitData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxUnitData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxUnitData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxUnitDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxUnitData<'bldr>> {
        let mut builder = clz_Torappu_SandboxUnitDataBuilder::new(_fbb);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_SandboxUnitData::VT_ID, None)
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxUnitData::VT_NAME,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxUnitData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxUnitDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxUnitDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxUnitDataArgs {
            id: None,
            name: None,
        }
    }
}

pub struct clz_Torappu_SandboxUnitDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxUnitDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_SandboxUnitData::VT_ID, id);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxUnitData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxUnitDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxUnitDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxUnitData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxUnitData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxUnitData");
        ds.field("id", &self.id());
        ds.field("name", &self.name());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxUnitDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxUnitData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxUnitData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxUnitData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxUnitData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxUnitData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxUnitDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxUnitData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxUnitDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxUnitData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxUnitData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxUnitData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxUnitData>>(
                    dict__string__clz_Torappu_SandboxUnitData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxUnitData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxUnitData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxUnitDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxUnitData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxUnitDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxUnitDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxUnitDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxUnitDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxUnitData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxUnitData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxUnitData>>(
                dict__string__clz_Torappu_SandboxUnitData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxUnitDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxUnitDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxUnitData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_SandboxUnitData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxUnitData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxUnitData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxDailyDescTemplateDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxDailyDescTemplateData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxDailyDescTemplateData<'a> {
    type Inner = clz_Torappu_SandboxDailyDescTemplateData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxDailyDescTemplateData<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_TEMPLATEDESC: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxDailyDescTemplateData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxDailyDescTemplateDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxDailyDescTemplateData<'bldr>> {
        let mut builder = clz_Torappu_SandboxDailyDescTemplateDataBuilder::new(_fbb);
        if let Some(x) = args.templateDesc {
            builder.add_templateDesc(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    #[inline]
    pub fn type_(&self) -> enum__Torappu_SandboxDailyDescTemplateType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxDailyDescTemplateType>(
                    clz_Torappu_SandboxDailyDescTemplateData::VT_TYPE_,
                    Some(enum__Torappu_SandboxDailyDescTemplateType::VISITOR),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn templateDesc(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SandboxDailyDescTemplateData::VT_TEMPLATEDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxDailyDescTemplateData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxDailyDescTemplateType>(
                "type_",
                Self::VT_TYPE_,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("templateDesc", Self::VT_TEMPLATEDESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxDailyDescTemplateDataArgs<'a> {
    pub type_: enum__Torappu_SandboxDailyDescTemplateType,
    pub templateDesc: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SandboxDailyDescTemplateDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxDailyDescTemplateDataArgs {
            type_: enum__Torappu_SandboxDailyDescTemplateType::VISITOR,
            templateDesc: None,
        }
    }
}

pub struct clz_Torappu_SandboxDailyDescTemplateDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SandboxDailyDescTemplateDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_SandboxDailyDescTemplateType) {
        self.fbb_
            .push_slot::<enum__Torappu_SandboxDailyDescTemplateType>(
                clz_Torappu_SandboxDailyDescTemplateData::VT_TYPE_,
                type_,
                enum__Torappu_SandboxDailyDescTemplateType::VISITOR,
            );
    }
    #[inline]
    pub fn add_templateDesc(
        &mut self,
        templateDesc: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxDailyDescTemplateData::VT_TEMPLATEDESC,
            templateDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxDailyDescTemplateDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxDailyDescTemplateDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxDailyDescTemplateData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxDailyDescTemplateData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxDailyDescTemplateData");
        ds.field("type_", &self.type_());
        ds.field("templateDesc", &self.templateDesc());
        ds.finish()
    }
}
pub enum dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateDataOffset
{}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateData<
    'a,
> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateData<
        'a,
    >
{
    type Inner =
        dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateData<
            'a,
        >;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a>
    dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateData<'a>
{
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateData {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateData<
            'bldr,
        >,
    > {
        let mut builder = dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_SandboxDailyDescTemplateType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<enum__Torappu_SandboxDailyDescTemplateType>(dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateData::VT_KEY, Some(enum__Torappu_SandboxDailyDescTemplateType::VISITOR)).unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_SandboxDailyDescTemplateType,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxDailyDescTemplateData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxDailyDescTemplateData>>(dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateData::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable
    for dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateData<
        '_,
    >
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SandboxDailyDescTemplateType>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxDailyDescTemplateData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateDataArgs<
    'a,
> {
    pub key: enum__Torappu_SandboxDailyDescTemplateType,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxDailyDescTemplateData<'a>>>,
}
impl<'a> Default for dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateDataArgs {
      key: enum__Torappu_SandboxDailyDescTemplateType::VISITOR,
      value: None,
    }
  }
}

pub struct dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: enum__Torappu_SandboxDailyDescTemplateType) {
    self.fbb_.push_slot::<enum__Torappu_SandboxDailyDescTemplateType>(dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateData::VT_KEY, key, enum__Torappu_SandboxDailyDescTemplateType::VISITOR);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxDailyDescTemplateData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxDailyDescTemplateData>>(dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateData::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug
    for dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateData<
        '_,
    >
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_Battle_Sandbox_RushEnemyConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Battle_Sandbox_RushEnemyConfig<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Battle_Sandbox_RushEnemyConfig<'a> {
    type Inner = clz_Torappu_Battle_Sandbox_RushEnemyConfig<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_Battle_Sandbox_RushEnemyConfig<'a> {
    pub const VT_ENEMYKEY: flatbuffers::VOffsetT = 4;
    pub const VT_BRANCHID: flatbuffers::VOffsetT = 6;
    pub const VT_COUNT: flatbuffers::VOffsetT = 8;
    pub const VT_INTERVAL: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Battle_Sandbox_RushEnemyConfig { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Battle_Sandbox_RushEnemyConfigArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Sandbox_RushEnemyConfig<'bldr>> {
        let mut builder = clz_Torappu_Battle_Sandbox_RushEnemyConfigBuilder::new(_fbb);
        builder.add_interval(args.interval);
        builder.add_count(args.count);
        if let Some(x) = args.branchId {
            builder.add_branchId(x);
        }
        if let Some(x) = args.enemyKey {
            builder.add_enemyKey(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn enemyKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Battle_Sandbox_RushEnemyConfig::VT_ENEMYKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn branchId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Battle_Sandbox_RushEnemyConfig::VT_BRANCHID,
                None,
            )
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_Battle_Sandbox_RushEnemyConfig::VT_COUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn interval(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_Battle_Sandbox_RushEnemyConfig::VT_INTERVAL,
                    Some(0.0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Battle_Sandbox_RushEnemyConfig<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enemyKey",
                Self::VT_ENEMYKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "branchId",
                Self::VT_BRANCHID,
                false,
            )?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<f32>("interval", Self::VT_INTERVAL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Battle_Sandbox_RushEnemyConfigArgs<'a> {
    pub enemyKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub branchId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
    pub interval: f32,
}
impl<'a> Default for clz_Torappu_Battle_Sandbox_RushEnemyConfigArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Battle_Sandbox_RushEnemyConfigArgs {
            enemyKey: None,
            branchId: None,
            count: 0,
            interval: 0.0,
        }
    }
}

pub struct clz_Torappu_Battle_Sandbox_RushEnemyConfigBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Battle_Sandbox_RushEnemyConfigBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_enemyKey(&mut self, enemyKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Battle_Sandbox_RushEnemyConfig::VT_ENEMYKEY,
            enemyKey,
        );
    }
    #[inline]
    pub fn add_branchId(&mut self, branchId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Battle_Sandbox_RushEnemyConfig::VT_BRANCHID,
            branchId,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_Battle_Sandbox_RushEnemyConfig::VT_COUNT,
            count,
            0,
        );
    }
    #[inline]
    pub fn add_interval(&mut self, interval: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_Battle_Sandbox_RushEnemyConfig::VT_INTERVAL,
            interval,
            0.0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Battle_Sandbox_RushEnemyConfigBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Battle_Sandbox_RushEnemyConfigBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Sandbox_RushEnemyConfig<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Battle_Sandbox_RushEnemyConfig<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Battle_Sandbox_RushEnemyConfig");
        ds.field("enemyKey", &self.enemyKey());
        ds.field("branchId", &self.branchId());
        ds.field("count", &self.count());
        ds.field("interval", &self.interval());
        ds.finish()
    }
}
pub enum clz_Torappu_Battle_Sandbox_RushEnemyGroupConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig<'a> {
    type Inner = clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig<'a> {
    pub const VT_ENEMYGROUPKEY: flatbuffers::VOffsetT = 4;
    pub const VT_WEIGHT: flatbuffers::VOffsetT = 6;
    pub const VT_ENEMY: flatbuffers::VOffsetT = 8;
    pub const VT_DYNAMICENEMY: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Battle_Sandbox_RushEnemyGroupConfigArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig<'bldr>> {
        let mut builder = clz_Torappu_Battle_Sandbox_RushEnemyGroupConfigBuilder::new(_fbb);
        if let Some(x) = args.dynamicEnemy {
            builder.add_dynamicEnemy(x);
        }
        if let Some(x) = args.enemy {
            builder.add_enemy(x);
        }
        builder.add_weight(args.weight);
        if let Some(x) = args.enemyGroupKey {
            builder.add_enemyGroupKey(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn enemyGroupKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig::VT_ENEMYGROUPKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn weight(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig::VT_WEIGHT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn enemy(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Sandbox_RushEnemyConfig<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Sandbox_RushEnemyConfig>,
                >,
            >>(
                clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig::VT_ENEMY,
                None,
            )
        }
    }
    #[inline]
    pub fn dynamicEnemy(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig::VT_DYNAMICENEMY,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enemyGroupKey",
                Self::VT_ENEMYGROUPKEY,
                false,
            )?
            .visit_field::<i32>("weight", Self::VT_WEIGHT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Sandbox_RushEnemyConfig>,
                >,
            >>("enemy", Self::VT_ENEMY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("dynamicEnemy", Self::VT_DYNAMICENEMY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Battle_Sandbox_RushEnemyGroupConfigArgs<'a> {
    pub enemyGroupKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weight: i32,
    pub enemy: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Sandbox_RushEnemyConfig<'a>>,
            >,
        >,
    >,
    pub dynamicEnemy: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_Battle_Sandbox_RushEnemyGroupConfigArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Battle_Sandbox_RushEnemyGroupConfigArgs {
            enemyGroupKey: None,
            weight: 0,
            enemy: None,
            dynamicEnemy: None,
        }
    }
}

pub struct clz_Torappu_Battle_Sandbox_RushEnemyGroupConfigBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Battle_Sandbox_RushEnemyGroupConfigBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_enemyGroupKey(&mut self, enemyGroupKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig::VT_ENEMYGROUPKEY,
            enemyGroupKey,
        );
    }
    #[inline]
    pub fn add_weight(&mut self, weight: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig::VT_WEIGHT,
            weight,
            0,
        );
    }
    #[inline]
    pub fn add_enemy(
        &mut self,
        enemy: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Sandbox_RushEnemyConfig<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig::VT_ENEMY,
            enemy,
        );
    }
    #[inline]
    pub fn add_dynamicEnemy(
        &mut self,
        dynamicEnemy: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig::VT_DYNAMICENEMY,
            dynamicEnemy,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Battle_Sandbox_RushEnemyGroupConfigBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Battle_Sandbox_RushEnemyGroupConfigBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig");
        ds.field("enemyGroupKey", &self.enemyGroupKey());
        ds.field("weight", &self.weight());
        ds.field("enemy", &self.enemy());
        ds.field("dynamicEnemy", &self.dynamicEnemy());
        ds.finish()
    }
}
pub enum dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfigOffset
{}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig<
    'a,
> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig<'a> {
  type Inner = dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a>
    dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig<
        'a,
    >
{
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig { _tab: table }
    }
    #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfigArgs<'args>
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig<'bldr>>{
        let mut builder = dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfigBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_SandboxEnemyRushType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<enum__Torappu_SandboxEnemyRushType>(dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig::VT_KEY, Some(enum__Torappu_SandboxEnemyRushType::NORMAL)).unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_SandboxEnemyRushType,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig>>>>(dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<enum__Torappu_SandboxEnemyRushType>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig>>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfigArgs<
    'a,
> {
    pub key: enum__Torappu_SandboxEnemyRushType,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfigArgs<'a> {
  #[inline]
  fn default() -> Self {
    dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfigArgs {
      key: enum__Torappu_SandboxEnemyRushType::NORMAL,
      value: None,
    }
  }
}

pub struct dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfigBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfigBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: enum__Torappu_SandboxEnemyRushType) {
    self.fbb_.push_slot::<enum__Torappu_SandboxEnemyRushType>(dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig::VT_KEY, key, enum__Torappu_SandboxEnemyRushType::NORMAL);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfigBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRefOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRef<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRef<'a> {
    type Inner = clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRef<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRef<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRef { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRefArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRef<'bldr>>
    {
        let mut builder =
            clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRefBuilder::new(_fbb);
        builder.add_level(args.level);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRef::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRef::VT_LEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRef<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRefArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub level: i32,
}
impl<'a> Default for clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRefArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRefArgs { id: None, level: 0 }
    }
}

pub struct clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRefBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRefBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRef::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRef::VT_LEVEL,
            level,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRefBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRefBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRef<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRef<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRef");
        ds.field("id", &self.id());
        ds.field("level", &self.level());
        ds.finish()
    }
}
pub enum clz_Torappu_Battle_Sandbox_RushEnemyGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Battle_Sandbox_RushEnemyGroup<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Battle_Sandbox_RushEnemyGroup<'a> {
    type Inner = clz_Torappu_Battle_Sandbox_RushEnemyGroup<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_Battle_Sandbox_RushEnemyGroup<'a> {
    pub const VT_RUSHENEMYGROUPCONFIGS: flatbuffers::VOffsetT = 4;
    pub const VT_RUSHENEMYDBREF: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Battle_Sandbox_RushEnemyGroup { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Battle_Sandbox_RushEnemyGroupArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Sandbox_RushEnemyGroup<'bldr>> {
        let mut builder = clz_Torappu_Battle_Sandbox_RushEnemyGroupBuilder::new(_fbb);
        if let Some(x) = args.rushEnemyDbRef {
            builder.add_rushEnemyDbRef(x);
        }
        if let Some(x) = args.rushEnemyGroupConfigs {
            builder.add_rushEnemyGroupConfigs(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn rushEnemyGroupConfigs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig<'a>>>>{
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig>>>>(clz_Torappu_Battle_Sandbox_RushEnemyGroup::VT_RUSHENEMYGROUPCONFIGS, None)
        }
    }
    #[inline]
    pub fn rushEnemyDbRef(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRef<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRef,
                    >,
                >,
            >>(
                clz_Torappu_Battle_Sandbox_RushEnemyGroup::VT_RUSHENEMYDBREF,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Battle_Sandbox_RushEnemyGroup<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig>>>>("rushEnemyGroupConfigs", Self::VT_RUSHENEMYGROUPCONFIGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRef>>>>("rushEnemyDbRef", Self::VT_RUSHENEMYDBREF, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Battle_Sandbox_RushEnemyGroupArgs<'a> {
    pub rushEnemyGroupConfigs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig<'a>>>>>,
    pub rushEnemyDbRef: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRef<'a>>>>>,
}
impl<'a> Default for clz_Torappu_Battle_Sandbox_RushEnemyGroupArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Battle_Sandbox_RushEnemyGroupArgs {
            rushEnemyGroupConfigs: None,
            rushEnemyDbRef: None,
        }
    }
}

pub struct clz_Torappu_Battle_Sandbox_RushEnemyGroupBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Battle_Sandbox_RushEnemyGroupBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_rushEnemyGroupConfigs(
        &mut self,
        rushEnemyGroupConfigs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxEnemyRushType__list_clz_Torappu_Battle_Sandbox_RushEnemyGroupConfig<'b >>>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Battle_Sandbox_RushEnemyGroup::VT_RUSHENEMYGROUPCONFIGS,
            rushEnemyGroupConfigs,
        );
    }
    #[inline]
    pub fn add_rushEnemyDbRef(
        &mut self,
        rushEnemyDbRef: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_Battle_Sandbox_RushEnemyGroup_RushEnemyDBRef<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Battle_Sandbox_RushEnemyGroup::VT_RUSHENEMYDBREF,
            rushEnemyDbRef,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Battle_Sandbox_RushEnemyGroupBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Battle_Sandbox_RushEnemyGroupBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Sandbox_RushEnemyGroup<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Battle_Sandbox_RushEnemyGroup<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Battle_Sandbox_RushEnemyGroup");
        ds.field("rushEnemyGroupConfigs", &self.rushEnemyGroupConfigs());
        ds.field("rushEnemyDbRef", &self.rushEnemyDbRef());
        ds.finish()
    }
}
pub enum clz_Torappu_RuneData_SelectorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RuneData_Selector<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RuneData_Selector<'a> {
    type Inner = clz_Torappu_RuneData_Selector<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_RuneData_Selector<'a> {
    pub const VT_PROFESSIONMASK: flatbuffers::VOffsetT = 4;
    pub const VT_BUILDABLEMASK: flatbuffers::VOffsetT = 6;
    pub const VT_CHARIDFILTER: flatbuffers::VOffsetT = 8;
    pub const VT_ENEMYIDFILTER: flatbuffers::VOffsetT = 10;
    pub const VT_ENEMYIDEXCLUDEFILTER: flatbuffers::VOffsetT = 12;
    pub const VT_SKILLIDFILTER: flatbuffers::VOffsetT = 14;
    pub const VT_TILEKEYFILTER: flatbuffers::VOffsetT = 16;
    pub const VT_GROUPTAGFILTER: flatbuffers::VOffsetT = 18;
    pub const VT_FILTERTAGFILTER: flatbuffers::VOffsetT = 20;
    pub const VT_SUBPROFESSIONEXCLUDEFILTER: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RuneData_Selector { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RuneData_SelectorArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'bldr>> {
        let mut builder = clz_Torappu_RuneData_SelectorBuilder::new(_fbb);
        if let Some(x) = args.subProfessionExcludeFilter {
            builder.add_subProfessionExcludeFilter(x);
        }
        if let Some(x) = args.filterTagFilter {
            builder.add_filterTagFilter(x);
        }
        if let Some(x) = args.groupTagFilter {
            builder.add_groupTagFilter(x);
        }
        if let Some(x) = args.tileKeyFilter {
            builder.add_tileKeyFilter(x);
        }
        if let Some(x) = args.skillIdFilter {
            builder.add_skillIdFilter(x);
        }
        if let Some(x) = args.enemyIdExcludeFilter {
            builder.add_enemyIdExcludeFilter(x);
        }
        if let Some(x) = args.enemyIdFilter {
            builder.add_enemyIdFilter(x);
        }
        if let Some(x) = args.charIdFilter {
            builder.add_charIdFilter(x);
        }
        builder.add_buildableMask(args.buildableMask);
        builder.add_professionMask(args.professionMask);
        builder.finish()
    }

    #[inline]
    pub fn professionMask(&self) -> enum__Torappu_ProfessionCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ProfessionCategory>(
                    clz_Torappu_RuneData_Selector::VT_PROFESSIONMASK,
                    Some(enum__Torappu_ProfessionCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn buildableMask(&self) -> enum__Torappu_BuildableType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildableType>(
                    clz_Torappu_RuneData_Selector::VT_BUILDABLEMASK,
                    Some(enum__Torappu_BuildableType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn charIdFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_CHARIDFILTER, None)
        }
    }
    #[inline]
    pub fn enemyIdFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_ENEMYIDFILTER, None)
        }
    }
    #[inline]
    pub fn enemyIdExcludeFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_ENEMYIDEXCLUDEFILTER, None)
        }
    }
    #[inline]
    pub fn skillIdFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_SKILLIDFILTER, None)
        }
    }
    #[inline]
    pub fn tileKeyFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_TILEKEYFILTER, None)
        }
    }
    #[inline]
    pub fn groupTagFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_GROUPTAGFILTER, None)
        }
    }
    #[inline]
    pub fn filterTagFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_FILTERTAGFILTER, None)
        }
    }
    #[inline]
    pub fn subProfessionExcludeFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RuneData_Selector::VT_SUBPROFESSIONEXCLUDEFILTER,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RuneData_Selector<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_ProfessionCategory>(
                "professionMask",
                Self::VT_PROFESSIONMASK,
                false,
            )?
            .visit_field::<enum__Torappu_BuildableType>(
                "buildableMask",
                Self::VT_BUILDABLEMASK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("charIdFilter", Self::VT_CHARIDFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("enemyIdFilter", Self::VT_ENEMYIDFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("enemyIdExcludeFilter", Self::VT_ENEMYIDEXCLUDEFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("skillIdFilter", Self::VT_SKILLIDFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("tileKeyFilter", Self::VT_TILEKEYFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("groupTagFilter", Self::VT_GROUPTAGFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("filterTagFilter", Self::VT_FILTERTAGFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "subProfessionExcludeFilter",
                Self::VT_SUBPROFESSIONEXCLUDEFILTER,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RuneData_SelectorArgs<'a> {
    pub professionMask: enum__Torappu_ProfessionCategory,
    pub buildableMask: enum__Torappu_BuildableType,
    pub charIdFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub enemyIdFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub enemyIdExcludeFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub skillIdFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub tileKeyFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub groupTagFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub filterTagFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub subProfessionExcludeFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_RuneData_SelectorArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RuneData_SelectorArgs {
            professionMask: enum__Torappu_ProfessionCategory::NONE,
            buildableMask: enum__Torappu_BuildableType::NONE,
            charIdFilter: None,
            enemyIdFilter: None,
            enemyIdExcludeFilter: None,
            skillIdFilter: None,
            tileKeyFilter: None,
            groupTagFilter: None,
            filterTagFilter: None,
            subProfessionExcludeFilter: None,
        }
    }
}

pub struct clz_Torappu_RuneData_SelectorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RuneData_SelectorBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_professionMask(&mut self, professionMask: enum__Torappu_ProfessionCategory) {
        self.fbb_.push_slot::<enum__Torappu_ProfessionCategory>(
            clz_Torappu_RuneData_Selector::VT_PROFESSIONMASK,
            professionMask,
            enum__Torappu_ProfessionCategory::NONE,
        );
    }
    #[inline]
    pub fn add_buildableMask(&mut self, buildableMask: enum__Torappu_BuildableType) {
        self.fbb_.push_slot::<enum__Torappu_BuildableType>(
            clz_Torappu_RuneData_Selector::VT_BUILDABLEMASK,
            buildableMask,
            enum__Torappu_BuildableType::NONE,
        );
    }
    #[inline]
    pub fn add_charIdFilter(
        &mut self,
        charIdFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_CHARIDFILTER,
            charIdFilter,
        );
    }
    #[inline]
    pub fn add_enemyIdFilter(
        &mut self,
        enemyIdFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_ENEMYIDFILTER,
            enemyIdFilter,
        );
    }
    #[inline]
    pub fn add_enemyIdExcludeFilter(
        &mut self,
        enemyIdExcludeFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_ENEMYIDEXCLUDEFILTER,
            enemyIdExcludeFilter,
        );
    }
    #[inline]
    pub fn add_skillIdFilter(
        &mut self,
        skillIdFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_SKILLIDFILTER,
            skillIdFilter,
        );
    }
    #[inline]
    pub fn add_tileKeyFilter(
        &mut self,
        tileKeyFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_TILEKEYFILTER,
            tileKeyFilter,
        );
    }
    #[inline]
    pub fn add_groupTagFilter(
        &mut self,
        groupTagFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_GROUPTAGFILTER,
            groupTagFilter,
        );
    }
    #[inline]
    pub fn add_filterTagFilter(
        &mut self,
        filterTagFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_FILTERTAGFILTER,
            filterTagFilter,
        );
    }
    #[inline]
    pub fn add_subProfessionExcludeFilter(
        &mut self,
        subProfessionExcludeFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_SUBPROFESSIONEXCLUDEFILTER,
            subProfessionExcludeFilter,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RuneData_SelectorBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RuneData_SelectorBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RuneData_Selector<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RuneData_Selector");
        ds.field("professionMask", &self.professionMask());
        ds.field("buildableMask", &self.buildableMask());
        ds.field("charIdFilter", &self.charIdFilter());
        ds.field("enemyIdFilter", &self.enemyIdFilter());
        ds.field("enemyIdExcludeFilter", &self.enemyIdExcludeFilter());
        ds.field("skillIdFilter", &self.skillIdFilter());
        ds.field("tileKeyFilter", &self.tileKeyFilter());
        ds.field("groupTagFilter", &self.groupTagFilter());
        ds.field("filterTagFilter", &self.filterTagFilter());
        ds.field(
            "subProfessionExcludeFilter",
            &self.subProfessionExcludeFilter(),
        );
        ds.finish()
    }
}
pub enum clz_Torappu_Blackboard_DataPairOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Blackboard_DataPair<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Blackboard_DataPair<'a> {
    type Inner = clz_Torappu_Blackboard_DataPair<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_Blackboard_DataPair<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;
    pub const VT_VALUESTR: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Blackboard_DataPair { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Blackboard_DataPairArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'bldr>> {
        let mut builder = clz_Torappu_Blackboard_DataPairBuilder::new(_fbb);
        if let Some(x) = args.valueStr {
            builder.add_valueStr(x);
        }
        builder.add_value(args.value);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_KEY,
                None,
            )
        }
    }
    #[inline]
    pub fn value(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn valueStr(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Blackboard_DataPair<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<f32>("value", Self::VT_VALUE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "valueStr",
                Self::VT_VALUESTR,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Blackboard_DataPairArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: f32,
    pub valueStr: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Blackboard_DataPairArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Blackboard_DataPairArgs {
            key: None,
            value: 0.0,
            valueStr: None,
        }
    }
}

pub struct clz_Torappu_Blackboard_DataPairBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, value, 0.0);
    }
    #[inline]
    pub fn add_valueStr(&mut self, valueStr: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
            valueStr,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Blackboard_DataPairBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Blackboard_DataPair<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Blackboard_DataPair");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.field("valueStr", &self.valueStr());
        ds.finish()
    }
}
pub enum clz_Torappu_RuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RuneData<'a> {
    type Inner = clz_Torappu_RuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_RuneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_SELECTOR: flatbuffers::VOffsetT = 6;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneData<'bldr>> {
        let mut builder = clz_Torappu_RuneDataBuilder::new(_fbb);
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        if let Some(x) = args.selector {
            builder.add_selector(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_RuneData::VT_KEY, None)
        }
    }
    #[inline]
    pub fn selector(&self) -> Option<clz_Torappu_RuneData_Selector<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneData_Selector>>(
                    clz_Torappu_RuneData::VT_SELECTOR,
                    None,
                )
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(clz_Torappu_RuneData::VT_BLACKBOARD, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneData_Selector>>(
                "selector",
                Self::VT_SELECTOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RuneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub selector: Option<flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'a>>>,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RuneDataArgs {
            key: None,
            selector: None,
            blackboard: None,
        }
    }
}

pub struct clz_Torappu_RuneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RuneDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_RuneData::VT_KEY, key);
    }
    #[inline]
    pub fn add_selector(
        &mut self,
        selector: flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector>>(
                clz_Torappu_RuneData::VT_SELECTOR,
                selector,
            );
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RuneData");
        ds.field("key", &self.key());
        ds.field("selector", &self.selector());
        ds.field("blackboard", &self.blackboard());
        ds.finish()
    }
}
pub enum clz_Torappu_RuneTable_PackedRuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RuneTable_PackedRuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RuneTable_PackedRuneData<'a> {
    type Inner = clz_Torappu_RuneTable_PackedRuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_RuneTable_PackedRuneData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_POINTS: flatbuffers::VOffsetT = 6;
    pub const VT_MUTEXGROUPKEY: flatbuffers::VOffsetT = 8;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
    pub const VT_RUNES: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RuneTable_PackedRuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RuneTable_PackedRuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'bldr>> {
        let mut builder = clz_Torappu_RuneTable_PackedRuneDataBuilder::new(_fbb);
        if let Some(x) = args.runes {
            builder.add_runes(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.mutexGroupKey {
            builder.add_mutexGroupKey(x);
        }
        builder.add_points(args.points);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RuneTable_PackedRuneData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn points(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_RuneTable_PackedRuneData::VT_POINTS, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn mutexGroupKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RuneTable_PackedRuneData::VT_MUTEXGROUPKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RuneTable_PackedRuneData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn runes(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData>>,
            >>(clz_Torappu_RuneTable_PackedRuneData::VT_RUNES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RuneTable_PackedRuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<f32>("points", Self::VT_POINTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "mutexGroupKey",
                Self::VT_MUTEXGROUPKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData>>,
            >>("runes", Self::VT_RUNES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RuneTable_PackedRuneDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub points: f32,
    pub mutexGroupKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub runes: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RuneTable_PackedRuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RuneTable_PackedRuneDataArgs {
            id: None,
            points: 0.0,
            mutexGroupKey: None,
            description: None,
            runes: None,
        }
    }
}

pub struct clz_Torappu_RuneTable_PackedRuneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RuneTable_PackedRuneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneTable_PackedRuneData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_points(&mut self, points: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_RuneTable_PackedRuneData::VT_POINTS, points, 0.0);
    }
    #[inline]
    pub fn add_mutexGroupKey(&mut self, mutexGroupKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneTable_PackedRuneData::VT_MUTEXGROUPKEY,
            mutexGroupKey,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneTable_PackedRuneData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_runes(
        &mut self,
        runes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneTable_PackedRuneData::VT_RUNES,
            runes,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RuneTable_PackedRuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RuneTable_PackedRuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RuneTable_PackedRuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RuneTable_PackedRuneData");
        ds.field("id", &self.id());
        ds.field("points", &self.points());
        ds.field("mutexGroupKey", &self.mutexGroupKey());
        ds.field("description", &self.description());
        ds.field("runes", &self.runes());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_RuneTable_PackedRuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RuneTable_PackedRuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RuneTable_PackedRuneData<'a> {
    type Inner = dict__string__clz_Torappu_RuneTable_PackedRuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_RuneTable_PackedRuneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RuneTable_PackedRuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RuneTable_PackedRuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RuneTable_PackedRuneData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RuneTable_PackedRuneDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RuneTable_PackedRuneData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RuneTable_PackedRuneData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RuneTable_PackedRuneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneTable_PackedRuneData>>(
                    dict__string__clz_Torappu_RuneTable_PackedRuneData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RuneTable_PackedRuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneTable_PackedRuneData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RuneTable_PackedRuneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RuneTable_PackedRuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RuneTable_PackedRuneDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_RuneTable_PackedRuneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RuneTable_PackedRuneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RuneTable_PackedRuneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData>>(
                dict__string__clz_Torappu_RuneTable_PackedRuneData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RuneTable_PackedRuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RuneTable_PackedRuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RuneTable_PackedRuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RuneTable_PackedRuneData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RuneTable_PackedRuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RuneTable_PackedRuneData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_LegacyInLevelRuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LegacyInLevelRuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LegacyInLevelRuneData<'a> {
    type Inner = clz_Torappu_LegacyInLevelRuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_LegacyInLevelRuneData<'a> {
    pub const VT_DIFFICULTYMASK: flatbuffers::VOffsetT = 4;
    pub const VT_KEY: flatbuffers::VOffsetT = 6;
    pub const VT_PROFESSIONMASK: flatbuffers::VOffsetT = 8;
    pub const VT_BUILDABLEMASK: flatbuffers::VOffsetT = 10;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LegacyInLevelRuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LegacyInLevelRuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LegacyInLevelRuneData<'bldr>> {
        let mut builder = clz_Torappu_LegacyInLevelRuneDataBuilder::new(_fbb);
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        builder.add_buildableMask(args.buildableMask);
        builder.add_professionMask(args.professionMask);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.add_difficultyMask(args.difficultyMask);
        builder.finish()
    }

    #[inline]
    pub fn difficultyMask(&self) -> enum__Torappu_LevelData_Difficulty {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_LevelData_Difficulty>(
                    clz_Torappu_LegacyInLevelRuneData::VT_DIFFICULTYMASK,
                    Some(enum__Torappu_LevelData_Difficulty::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LegacyInLevelRuneData::VT_KEY,
                None,
            )
        }
    }
    #[inline]
    pub fn professionMask(&self) -> enum__Torappu_ProfessionCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ProfessionCategory>(
                    clz_Torappu_LegacyInLevelRuneData::VT_PROFESSIONMASK,
                    Some(enum__Torappu_ProfessionCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn buildableMask(&self) -> enum__Torappu_BuildableType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildableType>(
                    clz_Torappu_LegacyInLevelRuneData::VT_BUILDABLEMASK,
                    Some(enum__Torappu_BuildableType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(clz_Torappu_LegacyInLevelRuneData::VT_BLACKBOARD, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LegacyInLevelRuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_LevelData_Difficulty>(
                "difficultyMask",
                Self::VT_DIFFICULTYMASK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<enum__Torappu_ProfessionCategory>(
                "professionMask",
                Self::VT_PROFESSIONMASK,
                false,
            )?
            .visit_field::<enum__Torappu_BuildableType>(
                "buildableMask",
                Self::VT_BUILDABLEMASK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LegacyInLevelRuneDataArgs<'a> {
    pub difficultyMask: enum__Torappu_LevelData_Difficulty,
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub professionMask: enum__Torappu_ProfessionCategory,
    pub buildableMask: enum__Torappu_BuildableType,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_LegacyInLevelRuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LegacyInLevelRuneDataArgs {
            difficultyMask: enum__Torappu_LevelData_Difficulty::NONE,
            key: None,
            professionMask: enum__Torappu_ProfessionCategory::NONE,
            buildableMask: enum__Torappu_BuildableType::NONE,
            blackboard: None,
        }
    }
}

pub struct clz_Torappu_LegacyInLevelRuneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_LegacyInLevelRuneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_difficultyMask(&mut self, difficultyMask: enum__Torappu_LevelData_Difficulty) {
        self.fbb_.push_slot::<enum__Torappu_LevelData_Difficulty>(
            clz_Torappu_LegacyInLevelRuneData::VT_DIFFICULTYMASK,
            difficultyMask,
            enum__Torappu_LevelData_Difficulty::NONE,
        );
    }
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LegacyInLevelRuneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_professionMask(&mut self, professionMask: enum__Torappu_ProfessionCategory) {
        self.fbb_.push_slot::<enum__Torappu_ProfessionCategory>(
            clz_Torappu_LegacyInLevelRuneData::VT_PROFESSIONMASK,
            professionMask,
            enum__Torappu_ProfessionCategory::NONE,
        );
    }
    #[inline]
    pub fn add_buildableMask(&mut self, buildableMask: enum__Torappu_BuildableType) {
        self.fbb_.push_slot::<enum__Torappu_BuildableType>(
            clz_Torappu_LegacyInLevelRuneData::VT_BUILDABLEMASK,
            buildableMask,
            enum__Torappu_BuildableType::NONE,
        );
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LegacyInLevelRuneData::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LegacyInLevelRuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LegacyInLevelRuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_LegacyInLevelRuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LegacyInLevelRuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LegacyInLevelRuneData");
        ds.field("difficultyMask", &self.difficultyMask());
        ds.field("key", &self.key());
        ds.field("professionMask", &self.professionMask());
        ds.field("buildableMask", &self.buildableMask());
        ds.field("blackboard", &self.blackboard());
        ds.finish()
    }
}
pub enum dict__string__list_clz_Torappu_LegacyInLevelRuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a> {
    type Inner = dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_clz_Torappu_LegacyInLevelRuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_clz_Torappu_LegacyInLevelRuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_LegacyInLevelRuneData<'bldr>> {
        let mut builder = dict__string__list_clz_Torappu_LegacyInLevelRuneDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__list_clz_Torappu_LegacyInLevelRuneData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__list_clz_Torappu_LegacyInLevelRuneData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData>,
                >,
            >>(
                dict__string__list_clz_Torappu_LegacyInLevelRuneData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__list_clz_Torappu_LegacyInLevelRuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData>,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_clz_Torappu_LegacyInLevelRuneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for dict__string__list_clz_Torappu_LegacyInLevelRuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__list_clz_Torappu_LegacyInLevelRuneDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__list_clz_Torappu_LegacyInLevelRuneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__list_clz_Torappu_LegacyInLevelRuneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_clz_Torappu_LegacyInLevelRuneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_clz_Torappu_LegacyInLevelRuneData::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__list_clz_Torappu_LegacyInLevelRuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__list_clz_Torappu_LegacyInLevelRuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__list_clz_Torappu_LegacyInLevelRuneData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__list_clz_Torappu_LegacyInLevelRuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__list_clz_Torappu_LegacyInLevelRuneData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxActTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxActTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxActTable<'a> {
    type Inner = clz_Torappu_SandboxActTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxActTable<'a> {
    pub const VT_MAPCONSTTABLE: flatbuffers::VOffsetT = 4;
    pub const VT_BASECONSTTABLE: flatbuffers::VOffsetT = 6;
    pub const VT_BATTLELOADINGTIPS: flatbuffers::VOffsetT = 8;
    pub const VT_FOODPRODUCEDATAS: flatbuffers::VOffsetT = 10;
    pub const VT_FOODMATDATAS: flatbuffers::VOffsetT = 12;
    pub const VT_FOODMATBUFFDATAS: flatbuffers::VOffsetT = 14;
    pub const VT_FOODSTAMINADATAS: flatbuffers::VOffsetT = 16;
    pub const VT_BUILDPRODUCEDATAS: flatbuffers::VOffsetT = 18;
    pub const VT_BUILDGOLDRATIODATAS: flatbuffers::VOffsetT = 20;
    pub const VT_BUILDINGITEMDATAS: flatbuffers::VOffsetT = 22;
    pub const VT_BUILDPRODUCEUNLOCKDATAS: flatbuffers::VOffsetT = 24;
    pub const VT_CRAFTITEMDATAS: flatbuffers::VOffsetT = 26;
    pub const VT_ITEMTRAPDATAS: flatbuffers::VOffsetT = 28;
    pub const VT_TRAPDEPLOYLIMITDATAS: flatbuffers::VOffsetT = 30;
    pub const VT_DEVELOPMENTDATAS: flatbuffers::VOffsetT = 32;
    pub const VT_DEVELOPMENTLIMITDATAS: flatbuffers::VOffsetT = 34;
    pub const VT_ITEMTOASTDATAS: flatbuffers::VOffsetT = 36;
    pub const VT_DEVELOPMENTLINESEGMENTDATAS: flatbuffers::VOffsetT = 38;
    pub const VT_REWARDCONFIGDATAS: flatbuffers::VOffsetT = 40;
    pub const VT_CHARSTAMINAMAPPING: flatbuffers::VOffsetT = 42;
    pub const VT_NODETYPEDATAS: flatbuffers::VOffsetT = 44;
    pub const VT_NODEUPGRADEDATAS: flatbuffers::VOffsetT = 46;
    pub const VT_WEATHERDATAS: flatbuffers::VOffsetT = 48;
    pub const VT_STAGEDATAS: flatbuffers::VOffsetT = 50;
    pub const VT_EVENTDATAS: flatbuffers::VOffsetT = 52;
    pub const VT_EVENTSCENEDATAS: flatbuffers::VOffsetT = 54;
    pub const VT_EVENTCHOICEDATAS: flatbuffers::VOffsetT = 56;
    pub const VT_EVENTTYPEDATAS: flatbuffers::VOffsetT = 58;
    pub const VT_MISSIONDATAS: flatbuffers::VOffsetT = 60;
    pub const VT_UNITDATA: flatbuffers::VOffsetT = 62;
    pub const VT_DAILYDESCTEMPLATEDATAS: flatbuffers::VOffsetT = 64;
    pub const VT_RUSHAVGDICT: flatbuffers::VOffsetT = 66;
    pub const VT_RUSHENEMYGROUP: flatbuffers::VOffsetT = 68;
    pub const VT_RUNEDATAS: flatbuffers::VOffsetT = 70;
    pub const VT_ITEMRUNELIST: flatbuffers::VOffsetT = 72;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxActTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxActTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxActTable<'bldr>> {
        let mut builder = clz_Torappu_SandboxActTableBuilder::new(_fbb);
        if let Some(x) = args.itemRuneList {
            builder.add_itemRuneList(x);
        }
        if let Some(x) = args.runeDatas {
            builder.add_runeDatas(x);
        }
        if let Some(x) = args.rushEnemyGroup {
            builder.add_rushEnemyGroup(x);
        }
        if let Some(x) = args.rushAvgDict {
            builder.add_rushAvgDict(x);
        }
        if let Some(x) = args.dailyDescTemplateDatas {
            builder.add_dailyDescTemplateDatas(x);
        }
        if let Some(x) = args.unitData {
            builder.add_unitData(x);
        }
        if let Some(x) = args.missionDatas {
            builder.add_missionDatas(x);
        }
        if let Some(x) = args.eventTypeDatas {
            builder.add_eventTypeDatas(x);
        }
        if let Some(x) = args.eventChoiceDatas {
            builder.add_eventChoiceDatas(x);
        }
        if let Some(x) = args.eventSceneDatas {
            builder.add_eventSceneDatas(x);
        }
        if let Some(x) = args.eventDatas {
            builder.add_eventDatas(x);
        }
        if let Some(x) = args.stageDatas {
            builder.add_stageDatas(x);
        }
        if let Some(x) = args.weatherDatas {
            builder.add_weatherDatas(x);
        }
        if let Some(x) = args.nodeUpgradeDatas {
            builder.add_nodeUpgradeDatas(x);
        }
        if let Some(x) = args.nodeTypeDatas {
            builder.add_nodeTypeDatas(x);
        }
        if let Some(x) = args.charStaminaMapping {
            builder.add_charStaminaMapping(x);
        }
        if let Some(x) = args.rewardConfigDatas {
            builder.add_rewardConfigDatas(x);
        }
        if let Some(x) = args.developmentLineSegmentDatas {
            builder.add_developmentLineSegmentDatas(x);
        }
        if let Some(x) = args.itemToastDatas {
            builder.add_itemToastDatas(x);
        }
        if let Some(x) = args.developmentLimitDatas {
            builder.add_developmentLimitDatas(x);
        }
        if let Some(x) = args.developmentDatas {
            builder.add_developmentDatas(x);
        }
        if let Some(x) = args.trapDeployLimitDatas {
            builder.add_trapDeployLimitDatas(x);
        }
        if let Some(x) = args.itemTrapDatas {
            builder.add_itemTrapDatas(x);
        }
        if let Some(x) = args.craftItemDatas {
            builder.add_craftItemDatas(x);
        }
        if let Some(x) = args.buildProduceUnlockDatas {
            builder.add_buildProduceUnlockDatas(x);
        }
        if let Some(x) = args.buildingItemDatas {
            builder.add_buildingItemDatas(x);
        }
        if let Some(x) = args.buildGoldRatioDatas {
            builder.add_buildGoldRatioDatas(x);
        }
        if let Some(x) = args.buildProduceDatas {
            builder.add_buildProduceDatas(x);
        }
        if let Some(x) = args.foodStaminaDatas {
            builder.add_foodStaminaDatas(x);
        }
        if let Some(x) = args.foodmatBuffDatas {
            builder.add_foodmatBuffDatas(x);
        }
        if let Some(x) = args.foodmatDatas {
            builder.add_foodmatDatas(x);
        }
        if let Some(x) = args.foodProduceDatas {
            builder.add_foodProduceDatas(x);
        }
        if let Some(x) = args.battleLoadingTips {
            builder.add_battleLoadingTips(x);
        }
        if let Some(x) = args.baseConstTable {
            builder.add_baseConstTable(x);
        }
        if let Some(x) = args.mapConstTable {
            builder.add_mapConstTable(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn mapConstTable(&self) -> Option<clz_Torappu_SandboxMapConstTable<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxMapConstTable>>(
                    clz_Torappu_SandboxActTable::VT_MAPCONSTTABLE,
                    None,
                )
        }
    }
    #[inline]
    pub fn baseConstTable(&self) -> Option<clz_Torappu_SandboxBaseConstTable<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxBaseConstTable>>(
                    clz_Torappu_SandboxActTable::VT_BASECONSTTABLE,
                    None,
                )
        }
    }
    #[inline]
    pub fn battleLoadingTips(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TipData<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TipData>>,
            >>(clz_Torappu_SandboxActTable::VT_BATTLELOADINGTIPS, None)
        }
    }
    #[inline]
    pub fn foodProduceDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxFoodProduceData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxFoodProduceData>,
                >,
            >>(clz_Torappu_SandboxActTable::VT_FOODPRODUCEDATAS, None)
        }
    }
    #[inline]
    pub fn foodmatDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxFoodmatBuffData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxFoodmatBuffData>,
                >,
            >>(clz_Torappu_SandboxActTable::VT_FOODMATDATAS, None)
        }
    }
    #[inline]
    pub fn foodmatBuffDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxFoodmatBuffData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxFoodmatBuffData>,
                >,
            >>(clz_Torappu_SandboxActTable::VT_FOODMATBUFFDATAS, None)
        }
    }
    #[inline]
    pub fn foodStaminaDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxFoodStaminaData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxFoodStaminaData>,
                >,
            >>(clz_Torappu_SandboxActTable::VT_FOODSTAMINADATAS, None)
        }
    }
    #[inline]
    pub fn buildProduceDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxBuildProduceData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxBuildProduceData>,
                >,
            >>(clz_Torappu_SandboxActTable::VT_BUILDPRODUCEDATAS, None)
        }
    }
    #[inline]
    pub fn buildGoldRatioDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxBuildGoldRatioData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxBuildGoldRatioData>,
                >,
            >>(clz_Torappu_SandboxActTable::VT_BUILDGOLDRATIODATAS, None)
        }
    }
    #[inline]
    pub fn buildingItemDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxBuildingItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxBuildingItemData>,
                >,
            >>(clz_Torappu_SandboxActTable::VT_BUILDINGITEMDATAS, None)
        }
    }
    #[inline]
    pub fn buildProduceUnlockDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SandboxBuildProduceUnlockData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxBuildProduceUnlockData,
                    >,
                >,
            >>(
                clz_Torappu_SandboxActTable::VT_BUILDPRODUCEUNLOCKDATAS,
                None,
            )
        }
    }
    #[inline]
    pub fn craftItemDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxCraftItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxCraftItemData>,
                >,
            >>(clz_Torappu_SandboxActTable::VT_CRAFTITEMDATAS, None)
        }
    }
    #[inline]
    pub fn itemTrapDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxItemTrapData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxItemTrapData>,
                >,
            >>(clz_Torappu_SandboxActTable::VT_ITEMTRAPDATAS, None)
        }
    }
    #[inline]
    pub fn trapDeployLimitDatas(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>(clz_Torappu_SandboxActTable::VT_TRAPDEPLOYLIMITDATAS, None)
        }
    }
    #[inline]
    pub fn developmentDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxDevelopmentData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxDevelopmentData>,
                >,
            >>(clz_Torappu_SandboxActTable::VT_DEVELOPMENTDATAS, None)
        }
    }
    #[inline]
    pub fn developmentLimitDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxDevelopmentLimitData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SandboxDevelopmentLimitData,
                    >,
                >,
            >>(clz_Torappu_SandboxActTable::VT_DEVELOPMENTLIMITDATAS, None)
        }
    }
    #[inline]
    pub fn itemToastDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastData,
                    >,
                >,
            >>(clz_Torappu_SandboxActTable::VT_ITEMTOASTDATAS, None)
        }
    }
    #[inline]
    pub fn developmentLineSegmentDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SandboxDevelopmentLineSegmentData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SandboxDevelopmentLineSegmentData>,
                >,
            >>(
                clz_Torappu_SandboxActTable::VT_DEVELOPMENTLINESEGMENTDATAS,
                None,
            )
        }
    }
    #[inline]
    pub fn rewardConfigDatas(&self) -> Option<clz_Torappu_SandboxRewardConfigGroupData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxRewardConfigGroupData>>(
                    clz_Torappu_SandboxActTable::VT_REWARDCONFIGDATAS,
                    None,
                )
        }
    }
    #[inline]
    pub fn charStaminaMapping(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaData,
                    >,
                >,
            >>(clz_Torappu_SandboxActTable::VT_CHARSTAMINAMAPPING, None)
        }
    }
    #[inline]
    pub fn nodeTypeDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeData,
                    >,
                >,
            >>(clz_Torappu_SandboxActTable::VT_NODETYPEDATAS, None)
        }
    }
    #[inline]
    pub fn nodeUpgradeDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxNodeUpgradeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxNodeUpgradeData>,
                >,
            >>(clz_Torappu_SandboxActTable::VT_NODEUPGRADEDATAS, None)
        }
    }
    #[inline]
    pub fn weatherDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxWeatherData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxWeatherData>,
                >,
            >>(clz_Torappu_SandboxActTable::VT_WEATHERDATAS, None)
        }
    }
    #[inline]
    pub fn stageDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxStageData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxStageData>,
                >,
            >>(clz_Torappu_SandboxActTable::VT_STAGEDATAS, None)
        }
    }
    #[inline]
    pub fn eventDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxEventData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxEventData>,
                >,
            >>(clz_Torappu_SandboxActTable::VT_EVENTDATAS, None)
        }
    }
    #[inline]
    pub fn eventSceneDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxEventSceneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxEventSceneData>,
                >,
            >>(clz_Torappu_SandboxActTable::VT_EVENTSCENEDATAS, None)
        }
    }
    #[inline]
    pub fn eventChoiceDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxEventChoiceData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxEventChoiceData>,
                >,
            >>(clz_Torappu_SandboxActTable::VT_EVENTCHOICEDATAS, None)
        }
    }
    #[inline]
    pub fn eventTypeDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeData,
                    >,
                >,
            >>(clz_Torappu_SandboxActTable::VT_EVENTTYPEDATAS, None)
        }
    }
    #[inline]
    pub fn missionDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxMissionData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxMissionData>,
                >,
            >>(clz_Torappu_SandboxActTable::VT_MISSIONDATAS, None)
        }
    }
    #[inline]
    pub fn unitData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxUnitData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxUnitData>,
                >,
            >>(clz_Torappu_SandboxActTable::VT_UNITDATA, None)
        }
    }
    #[inline]
    pub fn dailyDescTemplateDatas(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateData<'a>>>>{
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateData>>>>(clz_Torappu_SandboxActTable::VT_DAILYDESCTEMPLATEDATAS, None)
        }
    }
    #[inline]
    pub fn rushAvgDict(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(clz_Torappu_SandboxActTable::VT_RUSHAVGDICT, None)
        }
    }
    #[inline]
    pub fn rushEnemyGroup(&self) -> Option<clz_Torappu_Battle_Sandbox_RushEnemyGroup<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Sandbox_RushEnemyGroup>>(
                    clz_Torappu_SandboxActTable::VT_RUSHENEMYGROUP,
                    None,
                )
        }
    }
    #[inline]
    pub fn runeDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RuneTable_PackedRuneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RuneTable_PackedRuneData,
                    >,
                >,
            >>(clz_Torappu_SandboxActTable::VT_RUNEDATAS, None)
        }
    }
    #[inline]
    pub fn itemRuneList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__list_clz_Torappu_LegacyInLevelRuneData,
                    >,
                >,
            >>(clz_Torappu_SandboxActTable::VT_ITEMRUNELIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxActTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxMapConstTable>>("mapConstTable", Self::VT_MAPCONSTTABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxBaseConstTable>>("baseConstTable", Self::VT_BASECONSTTABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_TipData>>>>("battleLoadingTips", Self::VT_BATTLELOADINGTIPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxFoodProduceData>>>>("foodProduceDatas", Self::VT_FOODPRODUCEDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxFoodmatBuffData>>>>("foodmatDatas", Self::VT_FOODMATDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxFoodmatBuffData>>>>("foodmatBuffDatas", Self::VT_FOODMATBUFFDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxFoodStaminaData>>>>("foodStaminaDatas", Self::VT_FOODSTAMINADATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxBuildProduceData>>>>("buildProduceDatas", Self::VT_BUILDPRODUCEDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxBuildGoldRatioData>>>>("buildGoldRatioDatas", Self::VT_BUILDGOLDRATIODATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxBuildingItemData>>>>("buildingItemDatas", Self::VT_BUILDINGITEMDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxBuildProduceUnlockData>>>>("buildProduceUnlockDatas", Self::VT_BUILDPRODUCEUNLOCKDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxCraftItemData>>>>("craftItemDatas", Self::VT_CRAFTITEMDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxItemTrapData>>>>("itemTrapDatas", Self::VT_ITEMTRAPDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__int>>>>("trapDeployLimitDatas", Self::VT_TRAPDEPLOYLIMITDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxDevelopmentData>>>>("developmentDatas", Self::VT_DEVELOPMENTDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxDevelopmentLimitData>>>>("developmentLimitDatas", Self::VT_DEVELOPMENTLIMITDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastData>>>>("itemToastDatas", Self::VT_ITEMTOASTDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxDevelopmentLineSegmentData>>>>("developmentLineSegmentDatas", Self::VT_DEVELOPMENTLINESEGMENTDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxRewardConfigGroupData>>("rewardConfigDatas", Self::VT_REWARDCONFIGDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaData>>>>("charStaminaMapping", Self::VT_CHARSTAMINAMAPPING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeData>>>>("nodeTypeDatas", Self::VT_NODETYPEDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxNodeUpgradeData>>>>("nodeUpgradeDatas", Self::VT_NODEUPGRADEDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxWeatherData>>>>("weatherDatas", Self::VT_WEATHERDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxStageData>>>>("stageDatas", Self::VT_STAGEDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxEventData>>>>("eventDatas", Self::VT_EVENTDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxEventSceneData>>>>("eventSceneDatas", Self::VT_EVENTSCENEDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxEventChoiceData>>>>("eventChoiceDatas", Self::VT_EVENTCHOICEDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeData>>>>("eventTypeDatas", Self::VT_EVENTTYPEDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxMissionData>>>>("missionDatas", Self::VT_MISSIONDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxUnitData>>>>("unitData", Self::VT_UNITDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateData>>>>("dailyDescTemplateDatas", Self::VT_DAILYDESCTEMPLATEDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>>>("rushAvgDict", Self::VT_RUSHAVGDICT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Sandbox_RushEnemyGroup>>("rushEnemyGroup", Self::VT_RUSHENEMYGROUP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RuneTable_PackedRuneData>>>>("runeDatas", Self::VT_RUNEDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__list_clz_Torappu_LegacyInLevelRuneData>>>>("itemRuneList", Self::VT_ITEMRUNELIST, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxActTableArgs<'a> {
    pub mapConstTable: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxMapConstTable<'a>>>,
    pub baseConstTable: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxBaseConstTable<'a>>>,
    pub battleLoadingTips: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TipData<'a>>>>>,
    pub foodProduceDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxFoodProduceData<'a>>>>>,
    pub foodmatDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxFoodmatBuffData<'a>>>>>,
    pub foodmatBuffDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxFoodmatBuffData<'a>>>>>,
    pub foodStaminaDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxFoodStaminaData<'a>>>>>,
    pub buildProduceDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxBuildProduceData<'a>>>>>,
    pub buildGoldRatioDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxBuildGoldRatioData<'a>>>>>,
    pub buildingItemDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxBuildingItemData<'a>>>>>,
    pub buildProduceUnlockDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxBuildProduceUnlockData<'a>>>>>,
    pub craftItemDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxCraftItemData<'a>>>>>,
    pub itemTrapDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxItemTrapData<'a>>>>>,
    pub trapDeployLimitDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>>>,
    pub developmentDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxDevelopmentData<'a>>>>>,
    pub developmentLimitDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxDevelopmentLimitData<'a>>>>>,
    pub itemToastDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastData<'a>>>>>,
    pub developmentLineSegmentDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_SandboxDevelopmentLineSegmentData<'a>>>>>,
    pub rewardConfigDatas: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxRewardConfigGroupData<'a>>>,
    pub charStaminaMapping: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaData<'a>>>>>,
    pub nodeTypeDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeData<'a>>>>>,
    pub nodeUpgradeDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxNodeUpgradeData<'a>>>>>,
    pub weatherDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxWeatherData<'a>>>>>,
    pub stageDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxStageData<'a>>>>>,
    pub eventDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxEventData<'a>>>>>,
    pub eventSceneDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxEventSceneData<'a>>>>>,
    pub eventChoiceDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxEventChoiceData<'a>>>>>,
    pub eventTypeDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeData<'a>>>>>,
    pub missionDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxMissionData<'a>>>>>,
    pub unitData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxUnitData<'a>>>>>,
    pub dailyDescTemplateDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateData<'a>>>>>,
    pub rushAvgDict: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>>,
    pub rushEnemyGroup: Option<flatbuffers::WIPOffset<clz_Torappu_Battle_Sandbox_RushEnemyGroup<'a>>>,
    pub runeDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RuneTable_PackedRuneData<'a>>>>>,
    pub itemRuneList: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a>>>>>,
}
impl<'a> Default for clz_Torappu_SandboxActTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxActTableArgs {
            mapConstTable: None,
            baseConstTable: None,
            battleLoadingTips: None,
            foodProduceDatas: None,
            foodmatDatas: None,
            foodmatBuffDatas: None,
            foodStaminaDatas: None,
            buildProduceDatas: None,
            buildGoldRatioDatas: None,
            buildingItemDatas: None,
            buildProduceUnlockDatas: None,
            craftItemDatas: None,
            itemTrapDatas: None,
            trapDeployLimitDatas: None,
            developmentDatas: None,
            developmentLimitDatas: None,
            itemToastDatas: None,
            developmentLineSegmentDatas: None,
            rewardConfigDatas: None,
            charStaminaMapping: None,
            nodeTypeDatas: None,
            nodeUpgradeDatas: None,
            weatherDatas: None,
            stageDatas: None,
            eventDatas: None,
            eventSceneDatas: None,
            eventChoiceDatas: None,
            eventTypeDatas: None,
            missionDatas: None,
            unitData: None,
            dailyDescTemplateDatas: None,
            rushAvgDict: None,
            rushEnemyGroup: None,
            runeDatas: None,
            itemRuneList: None,
        }
    }
}

pub struct clz_Torappu_SandboxActTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxActTableBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_mapConstTable(
        &mut self,
        mapConstTable: flatbuffers::WIPOffset<clz_Torappu_SandboxMapConstTable<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxMapConstTable>>(
                clz_Torappu_SandboxActTable::VT_MAPCONSTTABLE,
                mapConstTable,
            );
    }
    #[inline]
    pub fn add_baseConstTable(
        &mut self,
        baseConstTable: flatbuffers::WIPOffset<clz_Torappu_SandboxBaseConstTable<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxBaseConstTable>>(
                clz_Torappu_SandboxActTable::VT_BASECONSTTABLE,
                baseConstTable,
            );
    }
    #[inline]
    pub fn add_battleLoadingTips(
        &mut self,
        battleLoadingTips: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_TipData<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_BATTLELOADINGTIPS,
            battleLoadingTips,
        );
    }
    #[inline]
    pub fn add_foodProduceDatas(
        &mut self,
        foodProduceDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxFoodProduceData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_FOODPRODUCEDATAS,
            foodProduceDatas,
        );
    }
    #[inline]
    pub fn add_foodmatDatas(
        &mut self,
        foodmatDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxFoodmatBuffData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_FOODMATDATAS,
            foodmatDatas,
        );
    }
    #[inline]
    pub fn add_foodmatBuffDatas(
        &mut self,
        foodmatBuffDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxFoodmatBuffData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_FOODMATBUFFDATAS,
            foodmatBuffDatas,
        );
    }
    #[inline]
    pub fn add_foodStaminaDatas(
        &mut self,
        foodStaminaDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxFoodStaminaData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_FOODSTAMINADATAS,
            foodStaminaDatas,
        );
    }
    #[inline]
    pub fn add_buildProduceDatas(
        &mut self,
        buildProduceDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxBuildProduceData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_BUILDPRODUCEDATAS,
            buildProduceDatas,
        );
    }
    #[inline]
    pub fn add_buildGoldRatioDatas(
        &mut self,
        buildGoldRatioDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxBuildGoldRatioData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_BUILDGOLDRATIODATAS,
            buildGoldRatioDatas,
        );
    }
    #[inline]
    pub fn add_buildingItemDatas(
        &mut self,
        buildingItemDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxBuildingItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_BUILDINGITEMDATAS,
            buildingItemDatas,
        );
    }
    #[inline]
    pub fn add_buildProduceUnlockDatas(
        &mut self,
        buildProduceUnlockDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxBuildProduceUnlockData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_BUILDPRODUCEUNLOCKDATAS,
            buildProduceUnlockDatas,
        );
    }
    #[inline]
    pub fn add_craftItemDatas(
        &mut self,
        craftItemDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxCraftItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_CRAFTITEMDATAS,
            craftItemDatas,
        );
    }
    #[inline]
    pub fn add_itemTrapDatas(
        &mut self,
        itemTrapDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxItemTrapData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_ITEMTRAPDATAS,
            itemTrapDatas,
        );
    }
    #[inline]
    pub fn add_trapDeployLimitDatas(
        &mut self,
        trapDeployLimitDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__int<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_TRAPDEPLOYLIMITDATAS,
            trapDeployLimitDatas,
        );
    }
    #[inline]
    pub fn add_developmentDatas(
        &mut self,
        developmentDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxDevelopmentData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_DEVELOPMENTDATAS,
            developmentDatas,
        );
    }
    #[inline]
    pub fn add_developmentLimitDatas(
        &mut self,
        developmentLimitDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SandboxDevelopmentLimitData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_DEVELOPMENTLIMITDATAS,
            developmentLimitDatas,
        );
    }
    #[inline]
    pub fn add_itemToastDatas(
        &mut self,
        itemToastDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_SandboxItemType__clz_Torappu_SandboxItemToastData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_ITEMTOASTDATAS,
            itemToastDatas,
        );
    }
    #[inline]
    pub fn add_developmentLineSegmentDatas(
        &mut self,
        developmentLineSegmentDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SandboxDevelopmentLineSegmentData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_DEVELOPMENTLINESEGMENTDATAS,
            developmentLineSegmentDatas,
        );
    }
    #[inline]
    pub fn add_rewardConfigDatas(
        &mut self,
        rewardConfigDatas: flatbuffers::WIPOffset<clz_Torappu_SandboxRewardConfigGroupData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxRewardConfigGroupData>>(
                clz_Torappu_SandboxActTable::VT_REWARDCONFIGDATAS,
                rewardConfigDatas,
            );
    }
    #[inline]
    pub fn add_charStaminaMapping(
        &mut self,
        charStaminaMapping: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__int__list_dict__int__list_clz_Torappu_SandboxStaminaData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_CHARSTAMINAMAPPING,
            charStaminaMapping,
        );
    }
    #[inline]
    pub fn add_nodeTypeDatas(
        &mut self,
        nodeTypeDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_SandboxNodeType__clz_Torappu_SandboxNodeTypeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_NODETYPEDATAS,
            nodeTypeDatas,
        );
    }
    #[inline]
    pub fn add_nodeUpgradeDatas(
        &mut self,
        nodeUpgradeDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxNodeUpgradeData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_NODEUPGRADEDATAS,
            nodeUpgradeDatas,
        );
    }
    #[inline]
    pub fn add_weatherDatas(
        &mut self,
        weatherDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxWeatherData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_WEATHERDATAS,
            weatherDatas,
        );
    }
    #[inline]
    pub fn add_stageDatas(
        &mut self,
        stageDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxStageData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_STAGEDATAS,
            stageDatas,
        );
    }
    #[inline]
    pub fn add_eventDatas(
        &mut self,
        eventDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxEventData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_EVENTDATAS,
            eventDatas,
        );
    }
    #[inline]
    pub fn add_eventSceneDatas(
        &mut self,
        eventSceneDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxEventSceneData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_EVENTSCENEDATAS,
            eventSceneDatas,
        );
    }
    #[inline]
    pub fn add_eventChoiceDatas(
        &mut self,
        eventChoiceDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxEventChoiceData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_EVENTCHOICEDATAS,
            eventChoiceDatas,
        );
    }
    #[inline]
    pub fn add_eventTypeDatas(
        &mut self,
        eventTypeDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_SandboxEventType__clz_Torappu_SandboxEventTypeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_EVENTTYPEDATAS,
            eventTypeDatas,
        );
    }
    #[inline]
    pub fn add_missionDatas(
        &mut self,
        missionDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxMissionData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_MISSIONDATAS,
            missionDatas,
        );
    }
    #[inline]
    pub fn add_unitData(
        &mut self,
        unitData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxUnitData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_UNITDATA,
            unitData,
        );
    }
    #[inline]
    pub fn add_dailyDescTemplateDatas(
        &mut self,
        dailyDescTemplateDatas: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<dict__enum__Torappu_SandboxDailyDescTemplateType__clz_Torappu_SandboxDailyDescTemplateData<'b >>>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_DAILYDESCTEMPLATEDATAS,
            dailyDescTemplateDatas,
        );
    }
    #[inline]
    pub fn add_rushAvgDict(
        &mut self,
        rushAvgDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_RUSHAVGDICT,
            rushAvgDict,
        );
    }
    #[inline]
    pub fn add_rushEnemyGroup(
        &mut self,
        rushEnemyGroup: flatbuffers::WIPOffset<clz_Torappu_Battle_Sandbox_RushEnemyGroup<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Battle_Sandbox_RushEnemyGroup>>(
                clz_Torappu_SandboxActTable::VT_RUSHENEMYGROUP,
                rushEnemyGroup,
            );
    }
    #[inline]
    pub fn add_runeDatas(
        &mut self,
        runeDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RuneTable_PackedRuneData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_RUNEDATAS,
            runeDatas,
        );
    }
    #[inline]
    pub fn add_itemRuneList(
        &mut self,
        itemRuneList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_clz_Torappu_LegacyInLevelRuneData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxActTable::VT_ITEMRUNELIST,
            itemRuneList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxActTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxActTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxActTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxActTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxActTable");
        ds.field("mapConstTable", &self.mapConstTable());
        ds.field("baseConstTable", &self.baseConstTable());
        ds.field("battleLoadingTips", &self.battleLoadingTips());
        ds.field("foodProduceDatas", &self.foodProduceDatas());
        ds.field("foodmatDatas", &self.foodmatDatas());
        ds.field("foodmatBuffDatas", &self.foodmatBuffDatas());
        ds.field("foodStaminaDatas", &self.foodStaminaDatas());
        ds.field("buildProduceDatas", &self.buildProduceDatas());
        ds.field("buildGoldRatioDatas", &self.buildGoldRatioDatas());
        ds.field("buildingItemDatas", &self.buildingItemDatas());
        ds.field("buildProduceUnlockDatas", &self.buildProduceUnlockDatas());
        ds.field("craftItemDatas", &self.craftItemDatas());
        ds.field("itemTrapDatas", &self.itemTrapDatas());
        ds.field("trapDeployLimitDatas", &self.trapDeployLimitDatas());
        ds.field("developmentDatas", &self.developmentDatas());
        ds.field("developmentLimitDatas", &self.developmentLimitDatas());
        ds.field("itemToastDatas", &self.itemToastDatas());
        ds.field(
            "developmentLineSegmentDatas",
            &self.developmentLineSegmentDatas(),
        );
        ds.field("rewardConfigDatas", &self.rewardConfigDatas());
        ds.field("charStaminaMapping", &self.charStaminaMapping());
        ds.field("nodeTypeDatas", &self.nodeTypeDatas());
        ds.field("nodeUpgradeDatas", &self.nodeUpgradeDatas());
        ds.field("weatherDatas", &self.weatherDatas());
        ds.field("stageDatas", &self.stageDatas());
        ds.field("eventDatas", &self.eventDatas());
        ds.field("eventSceneDatas", &self.eventSceneDatas());
        ds.field("eventChoiceDatas", &self.eventChoiceDatas());
        ds.field("eventTypeDatas", &self.eventTypeDatas());
        ds.field("missionDatas", &self.missionDatas());
        ds.field("unitData", &self.unitData());
        ds.field("dailyDescTemplateDatas", &self.dailyDescTemplateDatas());
        ds.field("rushAvgDict", &self.rushAvgDict());
        ds.field("rushEnemyGroup", &self.rushEnemyGroup());
        ds.field("runeDatas", &self.runeDatas());
        ds.field("itemRuneList", &self.itemRuneList());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxActTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxActTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxActTable<'a> {
    type Inner = dict__string__clz_Torappu_SandboxActTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxActTable<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxActTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxActTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxActTable<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxActTableBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxActTable::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxActTable) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxActTable<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxActTable>>(
                    dict__string__clz_Torappu_SandboxActTable::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxActTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxActTable>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxActTableArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxActTable<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxActTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxActTableArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxActTableBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxActTableBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxActTable::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxActTable<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxActTable>>(
                dict__string__clz_Torappu_SandboxActTable::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxActTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxActTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxActTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_SandboxActTable::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxActTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxActTable");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxItemData<'a> {
    type Inner = clz_Torappu_SandboxItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxItemData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_ITEMTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_ITEMNAME: flatbuffers::VOffsetT = 8;
    pub const VT_ITEMUSAGE: flatbuffers::VOffsetT = 10;
    pub const VT_ITEMDESC: flatbuffers::VOffsetT = 12;
    pub const VT_ITEMRARITY: flatbuffers::VOffsetT = 14;
    pub const VT_SORTID: flatbuffers::VOffsetT = 16;
    pub const VT_RECOMMENDTYPELIST: flatbuffers::VOffsetT = 18;
    pub const VT_RECOMMENDPRIORITY: flatbuffers::VOffsetT = 20;
    pub const VT_OBTAINAPPROACH: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxItemData<'bldr>> {
        let mut builder = clz_Torappu_SandboxItemDataBuilder::new(_fbb);
        if let Some(x) = args.obtainApproach {
            builder.add_obtainApproach(x);
        }
        builder.add_recommendPriority(args.recommendPriority);
        if let Some(x) = args.recommendTypeList {
            builder.add_recommendTypeList(x);
        }
        builder.add_sortId(args.sortId);
        builder.add_itemRarity(args.itemRarity);
        if let Some(x) = args.itemDesc {
            builder.add_itemDesc(x);
        }
        if let Some(x) = args.itemUsage {
            builder.add_itemUsage(x);
        }
        if let Some(x) = args.itemName {
            builder.add_itemName(x);
        }
        builder.add_itemType(args.itemType);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxItemData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn itemType(&self) -> enum__Torappu_SandboxItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SandboxItemType>(
                    clz_Torappu_SandboxItemData::VT_ITEMTYPE,
                    Some(enum__Torappu_SandboxItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn itemName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxItemData::VT_ITEMNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn itemUsage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxItemData::VT_ITEMUSAGE,
                None,
            )
        }
    }
    #[inline]
    pub fn itemDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxItemData::VT_ITEMDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn itemRarity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxItemData::VT_ITEMRARITY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxItemData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn recommendTypeList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, enum__Torappu_SandboxNodeType>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_SandboxNodeType>,
            >>(clz_Torappu_SandboxItemData::VT_RECOMMENDTYPELIST, None)
        }
    }
    #[inline]
    pub fn recommendPriority(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SandboxItemData::VT_RECOMMENDPRIORITY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn obtainApproach(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SandboxItemData::VT_OBTAINAPPROACH,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
     .visit_field::<enum__Torappu_SandboxItemType>("itemType", Self::VT_ITEMTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemName", Self::VT_ITEMNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemUsage", Self::VT_ITEMUSAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemDesc", Self::VT_ITEMDESC, false)?
     .visit_field::<i32>("itemRarity", Self::VT_ITEMRARITY, false)?
     .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_SandboxNodeType>>>("recommendTypeList", Self::VT_RECOMMENDTYPELIST, false)?
     .visit_field::<i32>("recommendPriority", Self::VT_RECOMMENDPRIORITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("obtainApproach", Self::VT_OBTAINAPPROACH, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxItemDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemType: enum__Torappu_SandboxItemType,
    pub itemName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemUsage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemRarity: i32,
    pub sortId: i32,
    pub recommendTypeList:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_SandboxNodeType>>>,
    pub recommendPriority: i32,
    pub obtainApproach: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SandboxItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxItemDataArgs {
            itemId: None,
            itemType: enum__Torappu_SandboxItemType::NONE,
            itemName: None,
            itemUsage: None,
            itemDesc: None,
            itemRarity: 0,
            sortId: 0,
            recommendTypeList: None,
            recommendPriority: 0,
            obtainApproach: None,
        }
    }
}

pub struct clz_Torappu_SandboxItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxItemDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxItemData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_itemType(&mut self, itemType: enum__Torappu_SandboxItemType) {
        self.fbb_.push_slot::<enum__Torappu_SandboxItemType>(
            clz_Torappu_SandboxItemData::VT_ITEMTYPE,
            itemType,
            enum__Torappu_SandboxItemType::NONE,
        );
    }
    #[inline]
    pub fn add_itemName(&mut self, itemName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxItemData::VT_ITEMNAME,
            itemName,
        );
    }
    #[inline]
    pub fn add_itemUsage(&mut self, itemUsage: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxItemData::VT_ITEMUSAGE,
            itemUsage,
        );
    }
    #[inline]
    pub fn add_itemDesc(&mut self, itemDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxItemData::VT_ITEMDESC,
            itemDesc,
        );
    }
    #[inline]
    pub fn add_itemRarity(&mut self, itemRarity: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxItemData::VT_ITEMRARITY, itemRarity, 0);
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SandboxItemData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_recommendTypeList(
        &mut self,
        recommendTypeList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, enum__Torappu_SandboxNodeType>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxItemData::VT_RECOMMENDTYPELIST,
            recommendTypeList,
        );
    }
    #[inline]
    pub fn add_recommendPriority(&mut self, recommendPriority: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SandboxItemData::VT_RECOMMENDPRIORITY,
            recommendPriority,
            0,
        );
    }
    #[inline]
    pub fn add_obtainApproach(&mut self, obtainApproach: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxItemData::VT_OBTAINAPPROACH,
            obtainApproach,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxItemData");
        ds.field("itemId", &self.itemId());
        ds.field("itemType", &self.itemType());
        ds.field("itemName", &self.itemName());
        ds.field("itemUsage", &self.itemUsage());
        ds.field("itemDesc", &self.itemDesc());
        ds.field("itemRarity", &self.itemRarity());
        ds.field("sortId", &self.sortId());
        ds.field("recommendTypeList", &self.recommendTypeList());
        ds.field("recommendPriority", &self.recommendPriority());
        ds.field("obtainApproach", &self.obtainApproach());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_SandboxItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SandboxItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SandboxItemData<'a> {
    type Inner = dict__string__clz_Torappu_SandboxItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_SandboxItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SandboxItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SandboxItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SandboxItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SandboxItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SandboxItemData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SandboxItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxItemData>>(
                    dict__string__clz_Torappu_SandboxItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SandboxItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SandboxItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SandboxItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SandboxItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SandboxItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SandboxItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_SandboxItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SandboxItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SandboxItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SandboxItemData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SandboxItemData>>(
                dict__string__clz_Torappu_SandboxItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SandboxItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SandboxItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SandboxItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_SandboxItemData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SandboxItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SandboxItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_SandboxTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SandboxTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SandboxTable<'a> {
    type Inner = clz_Torappu_SandboxTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_SandboxTable<'a> {
    pub const VT_SANDBOXACTTABLES: flatbuffers::VOffsetT = 4;
    pub const VT_ITEMDATAS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SandboxTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SandboxTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SandboxTable<'bldr>> {
        let mut builder = clz_Torappu_SandboxTableBuilder::new(_fbb);
        if let Some(x) = args.itemDatas {
            builder.add_itemDatas(x);
        }
        if let Some(x) = args.sandboxActTables {
            builder.add_sandboxActTables(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn sandboxActTables(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxActTable<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxActTable>,
                >,
            >>(clz_Torappu_SandboxTable::VT_SANDBOXACTTABLES, None)
        }
    }
    #[inline]
    pub fn itemDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxItemData>,
                >,
            >>(clz_Torappu_SandboxTable::VT_ITEMDATAS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SandboxTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxActTable>,
                >,
            >>("sandboxActTables", Self::VT_SANDBOXACTTABLES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxItemData>,
                >,
            >>("itemDatas", Self::VT_ITEMDATAS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SandboxTableArgs<'a> {
    pub sandboxActTables: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxActTable<'a>>,
            >,
        >,
    >,
    pub itemDatas: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxItemData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SandboxTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SandboxTableArgs {
            sandboxActTables: None,
            itemDatas: None,
        }
    }
}

pub struct clz_Torappu_SandboxTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SandboxTableBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_sandboxActTables(
        &mut self,
        sandboxActTables: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxActTable<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxTable::VT_SANDBOXACTTABLES,
            sandboxActTables,
        );
    }
    #[inline]
    pub fn add_itemDatas(
        &mut self,
        itemDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SandboxItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SandboxTable::VT_ITEMDATAS,
            itemDatas,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SandboxTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SandboxTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SandboxTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SandboxTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SandboxTable");
        ds.field("sandboxActTables", &self.sandboxActTables());
        ds.field("itemDatas", &self.itemDatas());
        ds.finish()
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_SandboxTable`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_sandbox_table_unchecked`.
pub fn root_as_clz_torappu_sandbox_table(
    buf: &[u8],
) -> Result<clz_Torappu_SandboxTable, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_SandboxTable>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_SandboxTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_sandbox_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_sandbox_table(
    buf: &[u8],
) -> Result<clz_Torappu_SandboxTable, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_SandboxTable>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_SandboxTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_sandbox_table_unchecked`.
pub fn root_as_clz_torappu_sandbox_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_SandboxTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_SandboxTable<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_SandboxTable` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_sandbox_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_sandbox_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_SandboxTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_SandboxTable<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_SandboxTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_SandboxTable`.
pub unsafe fn root_as_clz_torappu_sandbox_table_unchecked(buf: &[u8]) -> clz_Torappu_SandboxTable {
    flatbuffers::root_unchecked::<clz_Torappu_SandboxTable>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_SandboxTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_SandboxTable`.
pub unsafe fn size_prefixed_root_as_clz_torappu_sandbox_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_SandboxTable {
    flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_SandboxTable>(buf)
}
#[inline]
pub fn finish_clz_torappu_sandbox_table_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_SandboxTable<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_sandbox_table_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_SandboxTable<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
