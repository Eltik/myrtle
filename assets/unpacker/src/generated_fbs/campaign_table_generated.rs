// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ITEM_TYPE: i32 = 90;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ITEM_TYPE: [enum__Torappu_ItemType; 91] = [
    enum__Torappu_ItemType::NONE,
    enum__Torappu_ItemType::CHAR,
    enum__Torappu_ItemType::CARD_EXP,
    enum__Torappu_ItemType::MATERIAL,
    enum__Torappu_ItemType::GOLD,
    enum__Torappu_ItemType::EXP_PLAYER,
    enum__Torappu_ItemType::TKT_TRY,
    enum__Torappu_ItemType::TKT_RECRUIT,
    enum__Torappu_ItemType::TKT_INST_FIN,
    enum__Torappu_ItemType::TKT_GACHA,
    enum__Torappu_ItemType::ACTIVITY_COIN,
    enum__Torappu_ItemType::DIAMOND,
    enum__Torappu_ItemType::DIAMOND_SHD,
    enum__Torappu_ItemType::HGG_SHD,
    enum__Torappu_ItemType::LGG_SHD,
    enum__Torappu_ItemType::FURN,
    enum__Torappu_ItemType::AP_GAMEPLAY,
    enum__Torappu_ItemType::AP_BASE,
    enum__Torappu_ItemType::SOCIAL_PT,
    enum__Torappu_ItemType::CHAR_SKIN,
    enum__Torappu_ItemType::TKT_GACHA_10,
    enum__Torappu_ItemType::TKT_GACHA_PRSV,
    enum__Torappu_ItemType::AP_ITEM,
    enum__Torappu_ItemType::AP_SUPPLY,
    enum__Torappu_ItemType::RENAMING_CARD,
    enum__Torappu_ItemType::RENAMING_CARD_2,
    enum__Torappu_ItemType::ET_STAGE,
    enum__Torappu_ItemType::ACTIVITY_ITEM,
    enum__Torappu_ItemType::VOUCHER_PICK,
    enum__Torappu_ItemType::VOUCHER_CGACHA,
    enum__Torappu_ItemType::VOUCHER_MGACHA,
    enum__Torappu_ItemType::CRS_SHOP_COIN,
    enum__Torappu_ItemType::CRS_RUNE_COIN,
    enum__Torappu_ItemType::LMTGS_COIN,
    enum__Torappu_ItemType::EPGS_COIN,
    enum__Torappu_ItemType::LIMITED_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_FREE_GACHA,
    enum__Torappu_ItemType::REP_COIN,
    enum__Torappu_ItemType::ROGUELIKE,
    enum__Torappu_ItemType::LINKAGE_TKT_GACHA_10,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_4,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_5,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_6,
    enum__Torappu_ItemType::VOUCHER_SKIN,
    enum__Torappu_ItemType::RETRO_COIN,
    enum__Torappu_ItemType::PLAYER_AVATAR,
    enum__Torappu_ItemType::UNI_COLLECTION,
    enum__Torappu_ItemType::VOUCHER_FULL_POTENTIAL,
    enum__Torappu_ItemType::RL_COIN,
    enum__Torappu_ItemType::RETURN_CREDIT,
    enum__Torappu_ItemType::MEDAL,
    enum__Torappu_ItemType::CHARM,
    enum__Torappu_ItemType::HOME_BACKGROUND,
    enum__Torappu_ItemType::EXTERMINATION_AGENT,
    enum__Torappu_ItemType::OPTIONAL_VOUCHER_PICK,
    enum__Torappu_ItemType::ACT_CART_COMPONENT,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_4,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_4,
    enum__Torappu_ItemType::ACTIVITY_POTENTIAL,
    enum__Torappu_ItemType::ITEM_PACK,
    enum__Torappu_ItemType::SANDBOX,
    enum__Torappu_ItemType::FAVOR_ADD_ITEM,
    enum__Torappu_ItemType::CLASSIC_SHD,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_BUFF,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_5,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_6,
    enum__Torappu_ItemType::RETURN_PROGRESS,
    enum__Torappu_ItemType::NEW_PROGRESS,
    enum__Torappu_ItemType::MCARD_VOUCHER,
    enum__Torappu_ItemType::MATERIAL_ISSUE_VOUCHER,
    enum__Torappu_ItemType::CRS_SHOP_COIN_V2,
    enum__Torappu_ItemType::HOME_THEME,
    enum__Torappu_ItemType::SANDBOX_PERM,
    enum__Torappu_ItemType::SANDBOX_TOKEN,
    enum__Torappu_ItemType::TEMPLATE_TRAP,
    enum__Torappu_ItemType::NAME_CARD_SKIN,
    enum__Torappu_ItemType::EMOTICON_SET,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA_10,
    enum__Torappu_ItemType::SO_CHAR_EXP,
    enum__Torappu_ItemType::GIFTPACKAGE_TKT,
    enum__Torappu_ItemType::VOUCHER_SKIN_V2,
    enum__Torappu_ItemType::RANDOM_VOUCHER_SKIN,
    enum__Torappu_ItemType::ACT1VHALFIDLE_ITEM,
    enum__Torappu_ItemType::PLOT_ITEM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ItemType {
    pub const NONE: Self = Self(0);
    pub const CHAR: Self = Self(1);
    pub const CARD_EXP: Self = Self(2);
    pub const MATERIAL: Self = Self(3);
    pub const GOLD: Self = Self(4);
    pub const EXP_PLAYER: Self = Self(5);
    pub const TKT_TRY: Self = Self(6);
    pub const TKT_RECRUIT: Self = Self(7);
    pub const TKT_INST_FIN: Self = Self(8);
    pub const TKT_GACHA: Self = Self(9);
    pub const ACTIVITY_COIN: Self = Self(10);
    pub const DIAMOND: Self = Self(11);
    pub const DIAMOND_SHD: Self = Self(12);
    pub const HGG_SHD: Self = Self(13);
    pub const LGG_SHD: Self = Self(14);
    pub const FURN: Self = Self(15);
    pub const AP_GAMEPLAY: Self = Self(16);
    pub const AP_BASE: Self = Self(17);
    pub const SOCIAL_PT: Self = Self(18);
    pub const CHAR_SKIN: Self = Self(19);
    pub const TKT_GACHA_10: Self = Self(20);
    pub const TKT_GACHA_PRSV: Self = Self(21);
    pub const AP_ITEM: Self = Self(22);
    pub const AP_SUPPLY: Self = Self(23);
    pub const RENAMING_CARD: Self = Self(24);
    pub const RENAMING_CARD_2: Self = Self(25);
    pub const ET_STAGE: Self = Self(26);
    pub const ACTIVITY_ITEM: Self = Self(27);
    pub const VOUCHER_PICK: Self = Self(28);
    pub const VOUCHER_CGACHA: Self = Self(29);
    pub const VOUCHER_MGACHA: Self = Self(30);
    pub const CRS_SHOP_COIN: Self = Self(31);
    pub const CRS_RUNE_COIN: Self = Self(32);
    pub const LMTGS_COIN: Self = Self(33);
    pub const EPGS_COIN: Self = Self(34);
    pub const LIMITED_TKT_GACHA_10: Self = Self(35);
    pub const LIMITED_FREE_GACHA: Self = Self(36);
    pub const REP_COIN: Self = Self(37);
    pub const ROGUELIKE: Self = Self(38);
    pub const LINKAGE_TKT_GACHA_10: Self = Self(39);
    pub const VOUCHER_ELITE_II_4: Self = Self(40);
    pub const VOUCHER_ELITE_II_5: Self = Self(41);
    pub const VOUCHER_ELITE_II_6: Self = Self(42);
    pub const VOUCHER_SKIN: Self = Self(43);
    pub const RETRO_COIN: Self = Self(44);
    pub const PLAYER_AVATAR: Self = Self(45);
    pub const UNI_COLLECTION: Self = Self(46);
    pub const VOUCHER_FULL_POTENTIAL: Self = Self(47);
    pub const RL_COIN: Self = Self(48);
    pub const RETURN_CREDIT: Self = Self(49);
    pub const MEDAL: Self = Self(50);
    pub const CHARM: Self = Self(51);
    pub const HOME_BACKGROUND: Self = Self(52);
    pub const EXTERMINATION_AGENT: Self = Self(53);
    pub const OPTIONAL_VOUCHER_PICK: Self = Self(54);
    pub const ACT_CART_COMPONENT: Self = Self(55);
    pub const VOUCHER_LEVELMAX_6: Self = Self(56);
    pub const VOUCHER_LEVELMAX_5: Self = Self(57);
    pub const VOUCHER_LEVELMAX_4: Self = Self(58);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_6: Self = Self(59);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_5: Self = Self(60);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_4: Self = Self(61);
    pub const ACTIVITY_POTENTIAL: Self = Self(62);
    pub const ITEM_PACK: Self = Self(63);
    pub const SANDBOX: Self = Self(64);
    pub const FAVOR_ADD_ITEM: Self = Self(65);
    pub const CLASSIC_SHD: Self = Self(66);
    pub const CLASSIC_TKT_GACHA: Self = Self(67);
    pub const CLASSIC_TKT_GACHA_10: Self = Self(68);
    pub const LIMITED_BUFF: Self = Self(69);
    pub const CLASSIC_FES_PICK_TIER_5: Self = Self(70);
    pub const CLASSIC_FES_PICK_TIER_6: Self = Self(71);
    pub const RETURN_PROGRESS: Self = Self(72);
    pub const NEW_PROGRESS: Self = Self(73);
    pub const MCARD_VOUCHER: Self = Self(74);
    pub const MATERIAL_ISSUE_VOUCHER: Self = Self(75);
    pub const CRS_SHOP_COIN_V2: Self = Self(76);
    pub const HOME_THEME: Self = Self(77);
    pub const SANDBOX_PERM: Self = Self(78);
    pub const SANDBOX_TOKEN: Self = Self(79);
    pub const TEMPLATE_TRAP: Self = Self(80);
    pub const NAME_CARD_SKIN: Self = Self(81);
    pub const EMOTICON_SET: Self = Self(82);
    pub const EXCLUSIVE_TKT_GACHA: Self = Self(83);
    pub const EXCLUSIVE_TKT_GACHA_10: Self = Self(84);
    pub const SO_CHAR_EXP: Self = Self(85);
    pub const GIFTPACKAGE_TKT: Self = Self(86);
    pub const VOUCHER_SKIN_V2: Self = Self(87);
    pub const RANDOM_VOUCHER_SKIN: Self = Self(88);
    pub const ACT1VHALFIDLE_ITEM: Self = Self(89);
    pub const PLOT_ITEM: Self = Self(90);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 90;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::CHAR,
        Self::CARD_EXP,
        Self::MATERIAL,
        Self::GOLD,
        Self::EXP_PLAYER,
        Self::TKT_TRY,
        Self::TKT_RECRUIT,
        Self::TKT_INST_FIN,
        Self::TKT_GACHA,
        Self::ACTIVITY_COIN,
        Self::DIAMOND,
        Self::DIAMOND_SHD,
        Self::HGG_SHD,
        Self::LGG_SHD,
        Self::FURN,
        Self::AP_GAMEPLAY,
        Self::AP_BASE,
        Self::SOCIAL_PT,
        Self::CHAR_SKIN,
        Self::TKT_GACHA_10,
        Self::TKT_GACHA_PRSV,
        Self::AP_ITEM,
        Self::AP_SUPPLY,
        Self::RENAMING_CARD,
        Self::RENAMING_CARD_2,
        Self::ET_STAGE,
        Self::ACTIVITY_ITEM,
        Self::VOUCHER_PICK,
        Self::VOUCHER_CGACHA,
        Self::VOUCHER_MGACHA,
        Self::CRS_SHOP_COIN,
        Self::CRS_RUNE_COIN,
        Self::LMTGS_COIN,
        Self::EPGS_COIN,
        Self::LIMITED_TKT_GACHA_10,
        Self::LIMITED_FREE_GACHA,
        Self::REP_COIN,
        Self::ROGUELIKE,
        Self::LINKAGE_TKT_GACHA_10,
        Self::VOUCHER_ELITE_II_4,
        Self::VOUCHER_ELITE_II_5,
        Self::VOUCHER_ELITE_II_6,
        Self::VOUCHER_SKIN,
        Self::RETRO_COIN,
        Self::PLAYER_AVATAR,
        Self::UNI_COLLECTION,
        Self::VOUCHER_FULL_POTENTIAL,
        Self::RL_COIN,
        Self::RETURN_CREDIT,
        Self::MEDAL,
        Self::CHARM,
        Self::HOME_BACKGROUND,
        Self::EXTERMINATION_AGENT,
        Self::OPTIONAL_VOUCHER_PICK,
        Self::ACT_CART_COMPONENT,
        Self::VOUCHER_LEVELMAX_6,
        Self::VOUCHER_LEVELMAX_5,
        Self::VOUCHER_LEVELMAX_4,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_6,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_5,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_4,
        Self::ACTIVITY_POTENTIAL,
        Self::ITEM_PACK,
        Self::SANDBOX,
        Self::FAVOR_ADD_ITEM,
        Self::CLASSIC_SHD,
        Self::CLASSIC_TKT_GACHA,
        Self::CLASSIC_TKT_GACHA_10,
        Self::LIMITED_BUFF,
        Self::CLASSIC_FES_PICK_TIER_5,
        Self::CLASSIC_FES_PICK_TIER_6,
        Self::RETURN_PROGRESS,
        Self::NEW_PROGRESS,
        Self::MCARD_VOUCHER,
        Self::MATERIAL_ISSUE_VOUCHER,
        Self::CRS_SHOP_COIN_V2,
        Self::HOME_THEME,
        Self::SANDBOX_PERM,
        Self::SANDBOX_TOKEN,
        Self::TEMPLATE_TRAP,
        Self::NAME_CARD_SKIN,
        Self::EMOTICON_SET,
        Self::EXCLUSIVE_TKT_GACHA,
        Self::EXCLUSIVE_TKT_GACHA_10,
        Self::SO_CHAR_EXP,
        Self::GIFTPACKAGE_TKT,
        Self::VOUCHER_SKIN_V2,
        Self::RANDOM_VOUCHER_SKIN,
        Self::ACT1VHALFIDLE_ITEM,
        Self::PLOT_ITEM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::CHAR => Some("CHAR"),
            Self::CARD_EXP => Some("CARD_EXP"),
            Self::MATERIAL => Some("MATERIAL"),
            Self::GOLD => Some("GOLD"),
            Self::EXP_PLAYER => Some("EXP_PLAYER"),
            Self::TKT_TRY => Some("TKT_TRY"),
            Self::TKT_RECRUIT => Some("TKT_RECRUIT"),
            Self::TKT_INST_FIN => Some("TKT_INST_FIN"),
            Self::TKT_GACHA => Some("TKT_GACHA"),
            Self::ACTIVITY_COIN => Some("ACTIVITY_COIN"),
            Self::DIAMOND => Some("DIAMOND"),
            Self::DIAMOND_SHD => Some("DIAMOND_SHD"),
            Self::HGG_SHD => Some("HGG_SHD"),
            Self::LGG_SHD => Some("LGG_SHD"),
            Self::FURN => Some("FURN"),
            Self::AP_GAMEPLAY => Some("AP_GAMEPLAY"),
            Self::AP_BASE => Some("AP_BASE"),
            Self::SOCIAL_PT => Some("SOCIAL_PT"),
            Self::CHAR_SKIN => Some("CHAR_SKIN"),
            Self::TKT_GACHA_10 => Some("TKT_GACHA_10"),
            Self::TKT_GACHA_PRSV => Some("TKT_GACHA_PRSV"),
            Self::AP_ITEM => Some("AP_ITEM"),
            Self::AP_SUPPLY => Some("AP_SUPPLY"),
            Self::RENAMING_CARD => Some("RENAMING_CARD"),
            Self::RENAMING_CARD_2 => Some("RENAMING_CARD_2"),
            Self::ET_STAGE => Some("ET_STAGE"),
            Self::ACTIVITY_ITEM => Some("ACTIVITY_ITEM"),
            Self::VOUCHER_PICK => Some("VOUCHER_PICK"),
            Self::VOUCHER_CGACHA => Some("VOUCHER_CGACHA"),
            Self::VOUCHER_MGACHA => Some("VOUCHER_MGACHA"),
            Self::CRS_SHOP_COIN => Some("CRS_SHOP_COIN"),
            Self::CRS_RUNE_COIN => Some("CRS_RUNE_COIN"),
            Self::LMTGS_COIN => Some("LMTGS_COIN"),
            Self::EPGS_COIN => Some("EPGS_COIN"),
            Self::LIMITED_TKT_GACHA_10 => Some("LIMITED_TKT_GACHA_10"),
            Self::LIMITED_FREE_GACHA => Some("LIMITED_FREE_GACHA"),
            Self::REP_COIN => Some("REP_COIN"),
            Self::ROGUELIKE => Some("ROGUELIKE"),
            Self::LINKAGE_TKT_GACHA_10 => Some("LINKAGE_TKT_GACHA_10"),
            Self::VOUCHER_ELITE_II_4 => Some("VOUCHER_ELITE_II_4"),
            Self::VOUCHER_ELITE_II_5 => Some("VOUCHER_ELITE_II_5"),
            Self::VOUCHER_ELITE_II_6 => Some("VOUCHER_ELITE_II_6"),
            Self::VOUCHER_SKIN => Some("VOUCHER_SKIN"),
            Self::RETRO_COIN => Some("RETRO_COIN"),
            Self::PLAYER_AVATAR => Some("PLAYER_AVATAR"),
            Self::UNI_COLLECTION => Some("UNI_COLLECTION"),
            Self::VOUCHER_FULL_POTENTIAL => Some("VOUCHER_FULL_POTENTIAL"),
            Self::RL_COIN => Some("RL_COIN"),
            Self::RETURN_CREDIT => Some("RETURN_CREDIT"),
            Self::MEDAL => Some("MEDAL"),
            Self::CHARM => Some("CHARM"),
            Self::HOME_BACKGROUND => Some("HOME_BACKGROUND"),
            Self::EXTERMINATION_AGENT => Some("EXTERMINATION_AGENT"),
            Self::OPTIONAL_VOUCHER_PICK => Some("OPTIONAL_VOUCHER_PICK"),
            Self::ACT_CART_COMPONENT => Some("ACT_CART_COMPONENT"),
            Self::VOUCHER_LEVELMAX_6 => Some("VOUCHER_LEVELMAX_6"),
            Self::VOUCHER_LEVELMAX_5 => Some("VOUCHER_LEVELMAX_5"),
            Self::VOUCHER_LEVELMAX_4 => Some("VOUCHER_LEVELMAX_4"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_6 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_6"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_5 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_5"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_4 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_4"),
            Self::ACTIVITY_POTENTIAL => Some("ACTIVITY_POTENTIAL"),
            Self::ITEM_PACK => Some("ITEM_PACK"),
            Self::SANDBOX => Some("SANDBOX"),
            Self::FAVOR_ADD_ITEM => Some("FAVOR_ADD_ITEM"),
            Self::CLASSIC_SHD => Some("CLASSIC_SHD"),
            Self::CLASSIC_TKT_GACHA => Some("CLASSIC_TKT_GACHA"),
            Self::CLASSIC_TKT_GACHA_10 => Some("CLASSIC_TKT_GACHA_10"),
            Self::LIMITED_BUFF => Some("LIMITED_BUFF"),
            Self::CLASSIC_FES_PICK_TIER_5 => Some("CLASSIC_FES_PICK_TIER_5"),
            Self::CLASSIC_FES_PICK_TIER_6 => Some("CLASSIC_FES_PICK_TIER_6"),
            Self::RETURN_PROGRESS => Some("RETURN_PROGRESS"),
            Self::NEW_PROGRESS => Some("NEW_PROGRESS"),
            Self::MCARD_VOUCHER => Some("MCARD_VOUCHER"),
            Self::MATERIAL_ISSUE_VOUCHER => Some("MATERIAL_ISSUE_VOUCHER"),
            Self::CRS_SHOP_COIN_V2 => Some("CRS_SHOP_COIN_V2"),
            Self::HOME_THEME => Some("HOME_THEME"),
            Self::SANDBOX_PERM => Some("SANDBOX_PERM"),
            Self::SANDBOX_TOKEN => Some("SANDBOX_TOKEN"),
            Self::TEMPLATE_TRAP => Some("TEMPLATE_TRAP"),
            Self::NAME_CARD_SKIN => Some("NAME_CARD_SKIN"),
            Self::EMOTICON_SET => Some("EMOTICON_SET"),
            Self::EXCLUSIVE_TKT_GACHA => Some("EXCLUSIVE_TKT_GACHA"),
            Self::EXCLUSIVE_TKT_GACHA_10 => Some("EXCLUSIVE_TKT_GACHA_10"),
            Self::SO_CHAR_EXP => Some("SO_CHAR_EXP"),
            Self::GIFTPACKAGE_TKT => Some("GIFTPACKAGE_TKT"),
            Self::VOUCHER_SKIN_V2 => Some("VOUCHER_SKIN_V2"),
            Self::RANDOM_VOUCHER_SKIN => Some("RANDOM_VOUCHER_SKIN"),
            Self::ACT1VHALFIDLE_ITEM => Some("ACT1VHALFIDLE_ITEM"),
            Self::PLOT_ITEM => Some("PLOT_ITEM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ItemType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ItemType {
    type Output = enum__Torappu_ItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_CAMPAIGN_STAGE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_CAMPAIGN_STAGE_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_CAMPAIGN_STAGE_TYPE: [enum__Torappu_CampaignStageType; 4] = [
    enum__Torappu_CampaignStageType::NONE,
    enum__Torappu_CampaignStageType::PERMANENT,
    enum__Torappu_CampaignStageType::ROTATE,
    enum__Torappu_CampaignStageType::TRAINING,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_CampaignStageType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_CampaignStageType {
    pub const NONE: Self = Self(0);
    pub const PERMANENT: Self = Self(1);
    pub const ROTATE: Self = Self(2);
    pub const TRAINING: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::PERMANENT, Self::ROTATE, Self::TRAINING];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::PERMANENT => Some("PERMANENT"),
            Self::ROTATE => Some("ROTATE"),
            Self::TRAINING => Some("TRAINING"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_CampaignStageType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_CampaignStageType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_CampaignStageType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_CampaignStageType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_CampaignStageType {
    type Output = enum__Torappu_CampaignStageType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_CampaignStageType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_CampaignStageType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_CampaignStageType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_STAGE_DROP_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_STAGE_DROP_TYPE: i32 = 12;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_STAGE_DROP_TYPE: [enum__Torappu_StageDropType; 13] = [
    enum__Torappu_StageDropType::NONE,
    enum__Torappu_StageDropType::ONCE,
    enum__Torappu_StageDropType::NORMAL,
    enum__Torappu_StageDropType::SPECIAL,
    enum__Torappu_StageDropType::ADDITIONAL,
    enum__Torappu_StageDropType::APRETURN,
    enum__Torappu_StageDropType::DIAMOND_MATERIAL,
    enum__Torappu_StageDropType::FUNITURE_DROP,
    enum__Torappu_StageDropType::COMPLETE,
    enum__Torappu_StageDropType::CHARM_DROP,
    enum__Torappu_StageDropType::OVERRIDE_DROP,
    enum__Torappu_StageDropType::ITEM_RETURN,
    enum__Torappu_StageDropType::CONDITION_DROP,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_StageDropType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_StageDropType {
    pub const NONE: Self = Self(0);
    pub const ONCE: Self = Self(1);
    pub const NORMAL: Self = Self(2);
    pub const SPECIAL: Self = Self(3);
    pub const ADDITIONAL: Self = Self(4);
    pub const APRETURN: Self = Self(5);
    pub const DIAMOND_MATERIAL: Self = Self(6);
    pub const FUNITURE_DROP: Self = Self(7);
    pub const COMPLETE: Self = Self(8);
    pub const CHARM_DROP: Self = Self(9);
    pub const OVERRIDE_DROP: Self = Self(10);
    pub const ITEM_RETURN: Self = Self(11);
    pub const CONDITION_DROP: Self = Self(12);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 12;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ONCE,
        Self::NORMAL,
        Self::SPECIAL,
        Self::ADDITIONAL,
        Self::APRETURN,
        Self::DIAMOND_MATERIAL,
        Self::FUNITURE_DROP,
        Self::COMPLETE,
        Self::CHARM_DROP,
        Self::OVERRIDE_DROP,
        Self::ITEM_RETURN,
        Self::CONDITION_DROP,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ONCE => Some("ONCE"),
            Self::NORMAL => Some("NORMAL"),
            Self::SPECIAL => Some("SPECIAL"),
            Self::ADDITIONAL => Some("ADDITIONAL"),
            Self::APRETURN => Some("APRETURN"),
            Self::DIAMOND_MATERIAL => Some("DIAMOND_MATERIAL"),
            Self::FUNITURE_DROP => Some("FUNITURE_DROP"),
            Self::COMPLETE => Some("COMPLETE"),
            Self::CHARM_DROP => Some("CHARM_DROP"),
            Self::OVERRIDE_DROP => Some("OVERRIDE_DROP"),
            Self::ITEM_RETURN => Some("ITEM_RETURN"),
            Self::CONDITION_DROP => Some("CONDITION_DROP"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_StageDropType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_StageDropType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_StageDropType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_StageDropType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_StageDropType {
    type Output = enum__Torappu_StageDropType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_StageDropType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_StageDropType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_StageDropType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_OCC_PER: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_OCC_PER: i32 = 6;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_OCC_PER: [enum__Torappu_OccPer; 7] = [
    enum__Torappu_OccPer::ALWAYS,
    enum__Torappu_OccPer::ALMOST,
    enum__Torappu_OccPer::USUAL,
    enum__Torappu_OccPer::OFTEN,
    enum__Torappu_OccPer::SOMETIMES,
    enum__Torappu_OccPer::NEVER,
    enum__Torappu_OccPer::DEFINITELY_BUFF,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_OccPer(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_OccPer {
    pub const ALWAYS: Self = Self(0);
    pub const ALMOST: Self = Self(1);
    pub const USUAL: Self = Self(2);
    pub const OFTEN: Self = Self(3);
    pub const SOMETIMES: Self = Self(4);
    pub const NEVER: Self = Self(5);
    pub const DEFINITELY_BUFF: Self = Self(6);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 6;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::ALWAYS,
        Self::ALMOST,
        Self::USUAL,
        Self::OFTEN,
        Self::SOMETIMES,
        Self::NEVER,
        Self::DEFINITELY_BUFF,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ALWAYS => Some("ALWAYS"),
            Self::ALMOST => Some("ALMOST"),
            Self::USUAL => Some("USUAL"),
            Self::OFTEN => Some("OFTEN"),
            Self::SOMETIMES => Some("SOMETIMES"),
            Self::NEVER => Some("NEVER"),
            Self::DEFINITELY_BUFF => Some("DEFINITELY_BUFF"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_OccPer {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_OccPer {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_OccPer",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_OccPer {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_OccPer {
    type Output = enum__Torappu_OccPer;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_OccPer {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_OccPer {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_OccPer {}
pub enum clz_Torappu_ItemBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ItemBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ItemBundle<'a> {
    type Inner = clz_Torappu_ItemBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ItemBundle<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_COUNT: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ItemBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ItemBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'bldr>> {
        let mut builder = clz_Torappu_ItemBundleBuilder::new(_fbb);
        builder.add_type_(args.type_);
        builder.add_count(args.count);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ItemBundleT {
        let id = self.id().map(|x| x.to_string());
        let count = self.count();
        let type_ = self.type_();
        clz_Torappu_ItemBundleT { id, count, type_ }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_ItemBundle::VT_ID, None)
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ItemBundle::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_ItemBundle::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ItemBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ItemBundleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl<'a> Default for clz_Torappu_ItemBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ItemBundleArgs {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_ItemBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ItemBundle", 3)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("count", &self.count())?;
        s.serialize_field("type_", &self.type_())?;
        s.end()
    }
}

pub struct clz_Torappu_ItemBundleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ItemBundle::VT_ID, id);
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ItemBundle::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_ItemBundle::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ItemBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ItemBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ItemBundle");
        ds.field("id", &self.id());
        ds.field("count", &self.count());
        ds.field("type_", &self.type_());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ItemBundleT {
    pub id: Option<String>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl Default for clz_Torappu_ItemBundleT {
    fn default() -> Self {
        Self {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}
impl clz_Torappu_ItemBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let count = self.count;
        let type_ = self.type_;
        clz_Torappu_ItemBundle::create(_fbb, &clz_Torappu_ItemBundleArgs { id, count, type_ })
    }
}
pub enum clz_Torappu_CampaignData_BreakRewardLadderOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CampaignData_BreakRewardLadder<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CampaignData_BreakRewardLadder<'a> {
    type Inner = clz_Torappu_CampaignData_BreakRewardLadder<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CampaignData_BreakRewardLadder<'a> {
    pub const VT_KILLCNT: flatbuffers::VOffsetT = 4;
    pub const VT_BREAKFEEADD: flatbuffers::VOffsetT = 6;
    pub const VT_REWARDS: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CampaignData_BreakRewardLadder { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CampaignData_BreakRewardLadderArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignData_BreakRewardLadder<'bldr>> {
        let mut builder = clz_Torappu_CampaignData_BreakRewardLadderBuilder::new(_fbb);
        if let Some(x) = args.rewards {
            builder.add_rewards(x);
        }
        builder.add_breakFeeAdd(args.breakFeeAdd);
        builder.add_killCnt(args.killCnt);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CampaignData_BreakRewardLadderT {
        let killCnt = self.killCnt();
        let breakFeeAdd = self.breakFeeAdd();
        let rewards = self
            .rewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_CampaignData_BreakRewardLadderT {
            killCnt,
            breakFeeAdd,
            rewards,
        }
    }

    #[inline]
    pub fn killCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_CampaignData_BreakRewardLadder::VT_KILLCNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn breakFeeAdd(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_CampaignData_BreakRewardLadder::VT_BREAKFEEADD,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rewards(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(clz_Torappu_CampaignData_BreakRewardLadder::VT_REWARDS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CampaignData_BreakRewardLadder<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("killCnt", Self::VT_KILLCNT, false)?
            .visit_field::<i32>("breakFeeAdd", Self::VT_BREAKFEEADD, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("rewards", Self::VT_REWARDS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CampaignData_BreakRewardLadderArgs<'a> {
    pub killCnt: i32,
    pub breakFeeAdd: i32,
    pub rewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_CampaignData_BreakRewardLadderArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CampaignData_BreakRewardLadderArgs {
            killCnt: 0,
            breakFeeAdd: 0,
            rewards: None,
        }
    }
}

impl Serialize for clz_Torappu_CampaignData_BreakRewardLadder<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CampaignData_BreakRewardLadder", 3)?;
        s.serialize_field("killCnt", &self.killCnt())?;
        s.serialize_field("breakFeeAdd", &self.breakFeeAdd())?;
        if let Some(f) = self.rewards() {
            s.serialize_field("rewards", &f)?;
        } else {
            s.skip_field("rewards")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CampaignData_BreakRewardLadderBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CampaignData_BreakRewardLadderBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_killCnt(&mut self, killCnt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_CampaignData_BreakRewardLadder::VT_KILLCNT,
            killCnt,
            0,
        );
    }
    #[inline]
    pub fn add_breakFeeAdd(&mut self, breakFeeAdd: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_CampaignData_BreakRewardLadder::VT_BREAKFEEADD,
            breakFeeAdd,
            0,
        );
    }
    #[inline]
    pub fn add_rewards(
        &mut self,
        rewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignData_BreakRewardLadder::VT_REWARDS,
            rewards,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CampaignData_BreakRewardLadderBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CampaignData_BreakRewardLadderBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CampaignData_BreakRewardLadder<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CampaignData_BreakRewardLadder<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CampaignData_BreakRewardLadder");
        ds.field("killCnt", &self.killCnt());
        ds.field("breakFeeAdd", &self.breakFeeAdd());
        ds.field("rewards", &self.rewards());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CampaignData_BreakRewardLadderT {
    pub killCnt: i32,
    pub breakFeeAdd: i32,
    pub rewards: Option<Vec<clz_Torappu_ItemBundleT>>,
}
impl Default for clz_Torappu_CampaignData_BreakRewardLadderT {
    fn default() -> Self {
        Self {
            killCnt: 0,
            breakFeeAdd: 0,
            rewards: None,
        }
    }
}
impl clz_Torappu_CampaignData_BreakRewardLadderT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignData_BreakRewardLadder<'b>> {
        let killCnt = self.killCnt;
        let breakFeeAdd = self.breakFeeAdd;
        let rewards = self.rewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_CampaignData_BreakRewardLadder::create(
            _fbb,
            &clz_Torappu_CampaignData_BreakRewardLadderArgs {
                killCnt,
                breakFeeAdd,
                rewards,
            },
        )
    }
}
pub enum clz_Torappu_WeightItemBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_WeightItemBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_WeightItemBundle<'a> {
    type Inner = clz_Torappu_WeightItemBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_WeightItemBundle<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_DROPTYPE: flatbuffers::VOffsetT = 8;
    pub const VT_COUNT: flatbuffers::VOffsetT = 10;
    pub const VT_WEIGHT: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_WeightItemBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_WeightItemBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_WeightItemBundle<'bldr>> {
        let mut builder = clz_Torappu_WeightItemBundleBuilder::new(_fbb);
        builder.add_weight(args.weight);
        builder.add_count(args.count);
        builder.add_dropType(args.dropType);
        builder.add_type_(args.type_);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_WeightItemBundleT {
        let id = self.id().map(|x| x.to_string());
        let type_ = self.type_();
        let dropType = self.dropType();
        let count = self.count();
        let weight = self.weight();
        clz_Torappu_WeightItemBundleT {
            id,
            type_,
            dropType,
            count,
            weight,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_WeightItemBundle::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_WeightItemBundle::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn dropType(&self) -> enum__Torappu_StageDropType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageDropType>(
                    clz_Torappu_WeightItemBundle::VT_DROPTYPE,
                    Some(enum__Torappu_StageDropType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_WeightItemBundle::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn weight(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_WeightItemBundle::VT_WEIGHT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_WeightItemBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<enum__Torappu_StageDropType>("dropType", Self::VT_DROPTYPE, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<i32>("weight", Self::VT_WEIGHT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_WeightItemBundleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_ItemType,
    pub dropType: enum__Torappu_StageDropType,
    pub count: i32,
    pub weight: i32,
}
impl<'a> Default for clz_Torappu_WeightItemBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_WeightItemBundleArgs {
            id: None,
            type_: enum__Torappu_ItemType::NONE,
            dropType: enum__Torappu_StageDropType::NONE,
            count: 0,
            weight: 0,
        }
    }
}

impl Serialize for clz_Torappu_WeightItemBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_WeightItemBundle", 5)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("type_", &self.type_())?;
        s.serialize_field("dropType", &self.dropType())?;
        s.serialize_field("count", &self.count())?;
        s.serialize_field("weight", &self.weight())?;
        s.end()
    }
}

pub struct clz_Torappu_WeightItemBundleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_WeightItemBundleBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_WeightItemBundle::VT_ID, id);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_WeightItemBundle::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn add_dropType(&mut self, dropType: enum__Torappu_StageDropType) {
        self.fbb_.push_slot::<enum__Torappu_StageDropType>(
            clz_Torappu_WeightItemBundle::VT_DROPTYPE,
            dropType,
            enum__Torappu_StageDropType::NONE,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_WeightItemBundle::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_weight(&mut self, weight: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_WeightItemBundle::VT_WEIGHT, weight, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_WeightItemBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_WeightItemBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_WeightItemBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_WeightItemBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_WeightItemBundle");
        ds.field("id", &self.id());
        ds.field("type_", &self.type_());
        ds.field("dropType", &self.dropType());
        ds.field("count", &self.count());
        ds.field("weight", &self.weight());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_WeightItemBundleT {
    pub id: Option<String>,
    pub type_: enum__Torappu_ItemType,
    pub dropType: enum__Torappu_StageDropType,
    pub count: i32,
    pub weight: i32,
}
impl Default for clz_Torappu_WeightItemBundleT {
    fn default() -> Self {
        Self {
            id: None,
            type_: enum__Torappu_ItemType::NONE,
            dropType: enum__Torappu_StageDropType::NONE,
            count: 0,
            weight: 0,
        }
    }
}
impl clz_Torappu_WeightItemBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_WeightItemBundle<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let dropType = self.dropType;
        let count = self.count;
        let weight = self.weight;
        clz_Torappu_WeightItemBundle::create(
            _fbb,
            &clz_Torappu_WeightItemBundleArgs {
                id,
                type_,
                dropType,
                count,
                weight,
            },
        )
    }
}
pub enum list_clz_Torappu_WeightItemBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct list_clz_Torappu_WeightItemBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for list_clz_Torappu_WeightItemBundle<'a> {
    type Inner = list_clz_Torappu_WeightItemBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> list_clz_Torappu_WeightItemBundle<'a> {
    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        list_clz_Torappu_WeightItemBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args list_clz_Torappu_WeightItemBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<list_clz_Torappu_WeightItemBundle<'bldr>> {
        let mut builder = list_clz_Torappu_WeightItemBundleBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> list_clz_Torappu_WeightItemBundleT {
        let values = self
            .values()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        list_clz_Torappu_WeightItemBundleT { values }
    }

    #[inline]
    pub fn values(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_WeightItemBundle<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_WeightItemBundle>>,
            >>(list_clz_Torappu_WeightItemBundle::VT_VALUES, None)
        }
    }
}

impl flatbuffers::Verifiable for list_clz_Torappu_WeightItemBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_WeightItemBundle>>,
            >>("values", Self::VT_VALUES, false)?
            .finish();
        Ok(())
    }
}
pub struct list_clz_Torappu_WeightItemBundleArgs<'a> {
    pub values: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_WeightItemBundle<'a>>>,
        >,
    >,
}
impl<'a> Default for list_clz_Torappu_WeightItemBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        list_clz_Torappu_WeightItemBundleArgs { values: None }
    }
}

impl Serialize for list_clz_Torappu_WeightItemBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("list_clz_Torappu_WeightItemBundle", 1)?;
        if let Some(f) = self.values() {
            s.serialize_field("values", &f)?;
        } else {
            s.skip_field("values")?;
        }
        s.end()
    }
}

pub struct list_clz_Torappu_WeightItemBundleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    list_clz_Torappu_WeightItemBundleBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_values(
        &mut self,
        values: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_WeightItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            list_clz_Torappu_WeightItemBundle::VT_VALUES,
            values,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> list_clz_Torappu_WeightItemBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        list_clz_Torappu_WeightItemBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<list_clz_Torappu_WeightItemBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for list_clz_Torappu_WeightItemBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("list_clz_Torappu_WeightItemBundle");
        ds.field("values", &self.values());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct list_clz_Torappu_WeightItemBundleT {
    pub values: Option<Vec<clz_Torappu_WeightItemBundleT>>,
}
impl Default for list_clz_Torappu_WeightItemBundleT {
    fn default() -> Self {
        Self { values: None }
    }
}
impl list_clz_Torappu_WeightItemBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<list_clz_Torappu_WeightItemBundle<'b>> {
        let values = self.values.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        list_clz_Torappu_WeightItemBundle::create(
            _fbb,
            &list_clz_Torappu_WeightItemBundleArgs { values },
        )
    }
}
pub enum clz_Torappu_StageData_DisplayDetailRewardsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageData_DisplayDetailRewards<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageData_DisplayDetailRewards<'a> {
    type Inner = clz_Torappu_StageData_DisplayDetailRewards<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageData_DisplayDetailRewards<'a> {
    pub const VT_OCCPERCENT: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_ID: flatbuffers::VOffsetT = 8;
    pub const VT_DROPTYPE: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageData_DisplayDetailRewards { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageData_DisplayDetailRewardsArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayDetailRewards<'bldr>> {
        let mut builder = clz_Torappu_StageData_DisplayDetailRewardsBuilder::new(_fbb);
        builder.add_dropType(args.dropType);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_type_(args.type_);
        builder.add_occPercent(args.occPercent);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageData_DisplayDetailRewardsT {
        let occPercent = self.occPercent();
        let type_ = self.type_();
        let id = self.id().map(|x| x.to_string());
        let dropType = self.dropType();
        clz_Torappu_StageData_DisplayDetailRewardsT {
            occPercent,
            type_,
            id,
            dropType,
        }
    }

    #[inline]
    pub fn occPercent(&self) -> enum__Torappu_OccPer {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_OccPer>(
                    clz_Torappu_StageData_DisplayDetailRewards::VT_OCCPERCENT,
                    Some(enum__Torappu_OccPer::ALWAYS),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_StageData_DisplayDetailRewards::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData_DisplayDetailRewards::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn dropType(&self) -> enum__Torappu_StageDropType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageDropType>(
                    clz_Torappu_StageData_DisplayDetailRewards::VT_DROPTYPE,
                    Some(enum__Torappu_StageDropType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageData_DisplayDetailRewards<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_OccPer>("occPercent", Self::VT_OCCPERCENT, false)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_StageDropType>("dropType", Self::VT_DROPTYPE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageData_DisplayDetailRewardsArgs<'a> {
    pub occPercent: enum__Torappu_OccPer,
    pub type_: enum__Torappu_ItemType,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dropType: enum__Torappu_StageDropType,
}
impl<'a> Default for clz_Torappu_StageData_DisplayDetailRewardsArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageData_DisplayDetailRewardsArgs {
            occPercent: enum__Torappu_OccPer::ALWAYS,
            type_: enum__Torappu_ItemType::NONE,
            id: None,
            dropType: enum__Torappu_StageDropType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_StageData_DisplayDetailRewards<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageData_DisplayDetailRewards", 4)?;
        s.serialize_field("occPercent", &self.occPercent())?;
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("dropType", &self.dropType())?;
        s.end()
    }
}

pub struct clz_Torappu_StageData_DisplayDetailRewardsBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StageData_DisplayDetailRewardsBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_occPercent(&mut self, occPercent: enum__Torappu_OccPer) {
        self.fbb_.push_slot::<enum__Torappu_OccPer>(
            clz_Torappu_StageData_DisplayDetailRewards::VT_OCCPERCENT,
            occPercent,
            enum__Torappu_OccPer::ALWAYS,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_StageData_DisplayDetailRewards::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_DisplayDetailRewards::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_dropType(&mut self, dropType: enum__Torappu_StageDropType) {
        self.fbb_.push_slot::<enum__Torappu_StageDropType>(
            clz_Torappu_StageData_DisplayDetailRewards::VT_DROPTYPE,
            dropType,
            enum__Torappu_StageDropType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageData_DisplayDetailRewardsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageData_DisplayDetailRewardsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayDetailRewards<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageData_DisplayDetailRewards<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageData_DisplayDetailRewards");
        ds.field("occPercent", &self.occPercent());
        ds.field("type_", &self.type_());
        ds.field("id", &self.id());
        ds.field("dropType", &self.dropType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageData_DisplayDetailRewardsT {
    pub occPercent: enum__Torappu_OccPer,
    pub type_: enum__Torappu_ItemType,
    pub id: Option<String>,
    pub dropType: enum__Torappu_StageDropType,
}
impl Default for clz_Torappu_StageData_DisplayDetailRewardsT {
    fn default() -> Self {
        Self {
            occPercent: enum__Torappu_OccPer::ALWAYS,
            type_: enum__Torappu_ItemType::NONE,
            id: None,
            dropType: enum__Torappu_StageDropType::NONE,
        }
    }
}
impl clz_Torappu_StageData_DisplayDetailRewardsT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayDetailRewards<'b>> {
        let occPercent = self.occPercent;
        let type_ = self.type_;
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let dropType = self.dropType;
        clz_Torappu_StageData_DisplayDetailRewards::create(
            _fbb,
            &clz_Torappu_StageData_DisplayDetailRewardsArgs {
                occPercent,
                type_,
                id,
                dropType,
            },
        )
    }
}
pub enum clz_Torappu_CampaignData_CampaignDropInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CampaignData_CampaignDropInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CampaignData_CampaignDropInfo<'a> {
    type Inner = clz_Torappu_CampaignData_CampaignDropInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CampaignData_CampaignDropInfo<'a> {
    pub const VT_FIRSTPASSREWARDS: flatbuffers::VOffsetT = 4;
    pub const VT_PASSREWARDS: flatbuffers::VOffsetT = 6;
    pub const VT_DISPLAYDETAILREWARDS: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CampaignData_CampaignDropInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CampaignData_CampaignDropInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignData_CampaignDropInfo<'bldr>> {
        let mut builder = clz_Torappu_CampaignData_CampaignDropInfoBuilder::new(_fbb);
        if let Some(x) = args.displayDetailRewards {
            builder.add_displayDetailRewards(x);
        }
        if let Some(x) = args.passRewards {
            builder.add_passRewards(x);
        }
        if let Some(x) = args.firstPassRewards {
            builder.add_firstPassRewards(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CampaignData_CampaignDropInfoT {
        let firstPassRewards = self
            .firstPassRewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let passRewards = self
            .passRewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let displayDetailRewards = self
            .displayDetailRewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_CampaignData_CampaignDropInfoT {
            firstPassRewards,
            passRewards,
            displayDetailRewards,
        }
    }

    #[inline]
    pub fn firstPassRewards(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(
                clz_Torappu_CampaignData_CampaignDropInfo::VT_FIRSTPASSREWARDS,
                None,
            )
        }
    }
    #[inline]
    pub fn passRewards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle>,
                >,
            >>(
                clz_Torappu_CampaignData_CampaignDropInfo::VT_PASSREWARDS,
                None,
            )
        }
    }
    #[inline]
    pub fn displayDetailRewards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards>,
                >,
            >>(
                clz_Torappu_CampaignData_CampaignDropInfo::VT_DISPLAYDETAILREWARDS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CampaignData_CampaignDropInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("firstPassRewards", Self::VT_FIRSTPASSREWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle>,
                >,
            >>("passRewards", Self::VT_PASSREWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards>,
                >,
            >>("displayDetailRewards", Self::VT_DISPLAYDETAILREWARDS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CampaignData_CampaignDropInfoArgs<'a> {
    pub firstPassRewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
    pub passRewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle<'a>>,
            >,
        >,
    >,
    pub displayDetailRewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_CampaignData_CampaignDropInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CampaignData_CampaignDropInfoArgs {
            firstPassRewards: None,
            passRewards: None,
            displayDetailRewards: None,
        }
    }
}

impl Serialize for clz_Torappu_CampaignData_CampaignDropInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CampaignData_CampaignDropInfo", 3)?;
        if let Some(f) = self.firstPassRewards() {
            s.serialize_field("firstPassRewards", &f)?;
        } else {
            s.skip_field("firstPassRewards")?;
        }
        if let Some(f) = self.passRewards() {
            s.serialize_field("passRewards", &f)?;
        } else {
            s.skip_field("passRewards")?;
        }
        if let Some(f) = self.displayDetailRewards() {
            s.serialize_field("displayDetailRewards", &f)?;
        } else {
            s.skip_field("displayDetailRewards")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CampaignData_CampaignDropInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CampaignData_CampaignDropInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_firstPassRewards(
        &mut self,
        firstPassRewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignData_CampaignDropInfo::VT_FIRSTPASSREWARDS,
            firstPassRewards,
        );
    }
    #[inline]
    pub fn add_passRewards(
        &mut self,
        passRewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignData_CampaignDropInfo::VT_PASSREWARDS,
            passRewards,
        );
    }
    #[inline]
    pub fn add_displayDetailRewards(
        &mut self,
        displayDetailRewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignData_CampaignDropInfo::VT_DISPLAYDETAILREWARDS,
            displayDetailRewards,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CampaignData_CampaignDropInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CampaignData_CampaignDropInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CampaignData_CampaignDropInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CampaignData_CampaignDropInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CampaignData_CampaignDropInfo");
        ds.field("firstPassRewards", &self.firstPassRewards());
        ds.field("passRewards", &self.passRewards());
        ds.field("displayDetailRewards", &self.displayDetailRewards());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CampaignData_CampaignDropInfoT {
    pub firstPassRewards: Option<Vec<clz_Torappu_ItemBundleT>>,
    pub passRewards: Option<Vec<list_clz_Torappu_WeightItemBundleT>>,
    pub displayDetailRewards: Option<Vec<clz_Torappu_StageData_DisplayDetailRewardsT>>,
}
impl Default for clz_Torappu_CampaignData_CampaignDropInfoT {
    fn default() -> Self {
        Self {
            firstPassRewards: None,
            passRewards: None,
            displayDetailRewards: None,
        }
    }
}
impl clz_Torappu_CampaignData_CampaignDropInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignData_CampaignDropInfo<'b>> {
        let firstPassRewards = self.firstPassRewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let passRewards = self.passRewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let displayDetailRewards = self.displayDetailRewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_CampaignData_CampaignDropInfo::create(
            _fbb,
            &clz_Torappu_CampaignData_CampaignDropInfoArgs {
                firstPassRewards,
                passRewards,
                displayDetailRewards,
            },
        )
    }
}
pub enum clz_Torappu_CampaignData_DropLadderOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CampaignData_DropLadder<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CampaignData_DropLadder<'a> {
    type Inner = clz_Torappu_CampaignData_DropLadder<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CampaignData_DropLadder<'a> {
    pub const VT_KILLCNT: flatbuffers::VOffsetT = 4;
    pub const VT_DROPINFO: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CampaignData_DropLadder { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CampaignData_DropLadderArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignData_DropLadder<'bldr>> {
        let mut builder = clz_Torappu_CampaignData_DropLadderBuilder::new(_fbb);
        if let Some(x) = args.dropInfo {
            builder.add_dropInfo(x);
        }
        builder.add_killCnt(args.killCnt);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CampaignData_DropLadderT {
        let killCnt = self.killCnt();
        let dropInfo = self.dropInfo().map(|x| Box::new(x.unpack()));
        clz_Torappu_CampaignData_DropLadderT { killCnt, dropInfo }
    }

    #[inline]
    pub fn killCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CampaignData_DropLadder::VT_KILLCNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn dropInfo(&self) -> Option<clz_Torappu_CampaignData_CampaignDropInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CampaignData_CampaignDropInfo>>(
                    clz_Torappu_CampaignData_DropLadder::VT_DROPINFO,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CampaignData_DropLadder<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("killCnt", Self::VT_KILLCNT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CampaignData_CampaignDropInfo>>(
                "dropInfo",
                Self::VT_DROPINFO,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CampaignData_DropLadderArgs<'a> {
    pub killCnt: i32,
    pub dropInfo: Option<flatbuffers::WIPOffset<clz_Torappu_CampaignData_CampaignDropInfo<'a>>>,
}
impl<'a> Default for clz_Torappu_CampaignData_DropLadderArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CampaignData_DropLadderArgs {
            killCnt: 0,
            dropInfo: None,
        }
    }
}

impl Serialize for clz_Torappu_CampaignData_DropLadder<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CampaignData_DropLadder", 2)?;
        s.serialize_field("killCnt", &self.killCnt())?;
        if let Some(f) = self.dropInfo() {
            s.serialize_field("dropInfo", &f)?;
        } else {
            s.skip_field("dropInfo")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CampaignData_DropLadderBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CampaignData_DropLadderBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_killCnt(&mut self, killCnt: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_CampaignData_DropLadder::VT_KILLCNT, killCnt, 0);
    }
    #[inline]
    pub fn add_dropInfo(
        &mut self,
        dropInfo: flatbuffers::WIPOffset<clz_Torappu_CampaignData_CampaignDropInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CampaignData_CampaignDropInfo>>(
                clz_Torappu_CampaignData_DropLadder::VT_DROPINFO,
                dropInfo,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CampaignData_DropLadderBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CampaignData_DropLadderBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CampaignData_DropLadder<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CampaignData_DropLadder<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CampaignData_DropLadder");
        ds.field("killCnt", &self.killCnt());
        ds.field("dropInfo", &self.dropInfo());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CampaignData_DropLadderT {
    pub killCnt: i32,
    pub dropInfo: Option<Box<clz_Torappu_CampaignData_CampaignDropInfoT>>,
}
impl Default for clz_Torappu_CampaignData_DropLadderT {
    fn default() -> Self {
        Self {
            killCnt: 0,
            dropInfo: None,
        }
    }
}
impl clz_Torappu_CampaignData_DropLadderT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignData_DropLadder<'b>> {
        let killCnt = self.killCnt;
        let dropInfo = self.dropInfo.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_CampaignData_DropLadder::create(
            _fbb,
            &clz_Torappu_CampaignData_DropLadderArgs { killCnt, dropInfo },
        )
    }
}
pub enum clz_Torappu_CampaignData_GainLadderOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CampaignData_GainLadder<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CampaignData_GainLadder<'a> {
    type Inner = clz_Torappu_CampaignData_GainLadder<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CampaignData_GainLadder<'a> {
    pub const VT_KILLCNT: flatbuffers::VOffsetT = 4;
    pub const VT_APFAILRETURN: flatbuffers::VOffsetT = 6;
    pub const VT_FAVOR: flatbuffers::VOffsetT = 8;
    pub const VT_EXPGAIN: flatbuffers::VOffsetT = 10;
    pub const VT_GOLDGAIN: flatbuffers::VOffsetT = 12;
    pub const VT_DISPLAYDIAMONDSHDNUM: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CampaignData_GainLadder { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CampaignData_GainLadderArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignData_GainLadder<'bldr>> {
        let mut builder = clz_Torappu_CampaignData_GainLadderBuilder::new(_fbb);
        builder.add_displayDiamondShdNum(args.displayDiamondShdNum);
        builder.add_goldGain(args.goldGain);
        builder.add_expGain(args.expGain);
        builder.add_favor(args.favor);
        builder.add_apFailReturn(args.apFailReturn);
        builder.add_killCnt(args.killCnt);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CampaignData_GainLadderT {
        let killCnt = self.killCnt();
        let apFailReturn = self.apFailReturn();
        let favor = self.favor();
        let expGain = self.expGain();
        let goldGain = self.goldGain();
        let displayDiamondShdNum = self.displayDiamondShdNum();
        clz_Torappu_CampaignData_GainLadderT {
            killCnt,
            apFailReturn,
            favor,
            expGain,
            goldGain,
            displayDiamondShdNum,
        }
    }

    #[inline]
    pub fn killCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CampaignData_GainLadder::VT_KILLCNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn apFailReturn(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_CampaignData_GainLadder::VT_APFAILRETURN,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn favor(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CampaignData_GainLadder::VT_FAVOR, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn expGain(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CampaignData_GainLadder::VT_EXPGAIN, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn goldGain(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CampaignData_GainLadder::VT_GOLDGAIN, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn displayDiamondShdNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_CampaignData_GainLadder::VT_DISPLAYDIAMONDSHDNUM,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CampaignData_GainLadder<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("killCnt", Self::VT_KILLCNT, false)?
            .visit_field::<i32>("apFailReturn", Self::VT_APFAILRETURN, false)?
            .visit_field::<i32>("favor", Self::VT_FAVOR, false)?
            .visit_field::<i32>("expGain", Self::VT_EXPGAIN, false)?
            .visit_field::<i32>("goldGain", Self::VT_GOLDGAIN, false)?
            .visit_field::<i32>("displayDiamondShdNum", Self::VT_DISPLAYDIAMONDSHDNUM, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CampaignData_GainLadderArgs {
    pub killCnt: i32,
    pub apFailReturn: i32,
    pub favor: i32,
    pub expGain: i32,
    pub goldGain: i32,
    pub displayDiamondShdNum: i32,
}
impl<'a> Default for clz_Torappu_CampaignData_GainLadderArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CampaignData_GainLadderArgs {
            killCnt: 0,
            apFailReturn: 0,
            favor: 0,
            expGain: 0,
            goldGain: 0,
            displayDiamondShdNum: 0,
        }
    }
}

impl Serialize for clz_Torappu_CampaignData_GainLadder<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CampaignData_GainLadder", 6)?;
        s.serialize_field("killCnt", &self.killCnt())?;
        s.serialize_field("apFailReturn", &self.apFailReturn())?;
        s.serialize_field("favor", &self.favor())?;
        s.serialize_field("expGain", &self.expGain())?;
        s.serialize_field("goldGain", &self.goldGain())?;
        s.serialize_field("displayDiamondShdNum", &self.displayDiamondShdNum())?;
        s.end()
    }
}

pub struct clz_Torappu_CampaignData_GainLadderBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CampaignData_GainLadderBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_killCnt(&mut self, killCnt: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_CampaignData_GainLadder::VT_KILLCNT, killCnt, 0);
    }
    #[inline]
    pub fn add_apFailReturn(&mut self, apFailReturn: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_CampaignData_GainLadder::VT_APFAILRETURN,
            apFailReturn,
            0,
        );
    }
    #[inline]
    pub fn add_favor(&mut self, favor: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_CampaignData_GainLadder::VT_FAVOR, favor, 0);
    }
    #[inline]
    pub fn add_expGain(&mut self, expGain: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_CampaignData_GainLadder::VT_EXPGAIN, expGain, 0);
    }
    #[inline]
    pub fn add_goldGain(&mut self, goldGain: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_CampaignData_GainLadder::VT_GOLDGAIN,
            goldGain,
            0,
        );
    }
    #[inline]
    pub fn add_displayDiamondShdNum(&mut self, displayDiamondShdNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_CampaignData_GainLadder::VT_DISPLAYDIAMONDSHDNUM,
            displayDiamondShdNum,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CampaignData_GainLadderBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CampaignData_GainLadderBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CampaignData_GainLadder<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CampaignData_GainLadder<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CampaignData_GainLadder");
        ds.field("killCnt", &self.killCnt());
        ds.field("apFailReturn", &self.apFailReturn());
        ds.field("favor", &self.favor());
        ds.field("expGain", &self.expGain());
        ds.field("goldGain", &self.goldGain());
        ds.field("displayDiamondShdNum", &self.displayDiamondShdNum());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CampaignData_GainLadderT {
    pub killCnt: i32,
    pub apFailReturn: i32,
    pub favor: i32,
    pub expGain: i32,
    pub goldGain: i32,
    pub displayDiamondShdNum: i32,
}
impl Default for clz_Torappu_CampaignData_GainLadderT {
    fn default() -> Self {
        Self {
            killCnt: 0,
            apFailReturn: 0,
            favor: 0,
            expGain: 0,
            goldGain: 0,
            displayDiamondShdNum: 0,
        }
    }
}
impl clz_Torappu_CampaignData_GainLadderT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignData_GainLadder<'b>> {
        let killCnt = self.killCnt;
        let apFailReturn = self.apFailReturn;
        let favor = self.favor;
        let expGain = self.expGain;
        let goldGain = self.goldGain;
        let displayDiamondShdNum = self.displayDiamondShdNum;
        clz_Torappu_CampaignData_GainLadder::create(
            _fbb,
            &clz_Torappu_CampaignData_GainLadderArgs {
                killCnt,
                apFailReturn,
                favor,
                expGain,
                goldGain,
                displayDiamondShdNum,
            },
        )
    }
}
pub enum clz_Torappu_StageData_DisplayRewardsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageData_DisplayRewards<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageData_DisplayRewards<'a> {
    type Inner = clz_Torappu_StageData_DisplayRewards<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageData_DisplayRewards<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_ID: flatbuffers::VOffsetT = 6;
    pub const VT_DROPTYPE: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageData_DisplayRewards { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageData_DisplayRewardsArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayRewards<'bldr>> {
        let mut builder = clz_Torappu_StageData_DisplayRewardsBuilder::new(_fbb);
        builder.add_dropType(args.dropType);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageData_DisplayRewardsT {
        let type_ = self.type_();
        let id = self.id().map(|x| x.to_string());
        let dropType = self.dropType();
        clz_Torappu_StageData_DisplayRewardsT {
            type_,
            id,
            dropType,
        }
    }

    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_StageData_DisplayRewards::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData_DisplayRewards::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn dropType(&self) -> enum__Torappu_StageDropType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageDropType>(
                    clz_Torappu_StageData_DisplayRewards::VT_DROPTYPE,
                    Some(enum__Torappu_StageDropType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageData_DisplayRewards<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_StageDropType>("dropType", Self::VT_DROPTYPE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageData_DisplayRewardsArgs<'a> {
    pub type_: enum__Torappu_ItemType,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dropType: enum__Torappu_StageDropType,
}
impl<'a> Default for clz_Torappu_StageData_DisplayRewardsArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageData_DisplayRewardsArgs {
            type_: enum__Torappu_ItemType::NONE,
            id: None,
            dropType: enum__Torappu_StageDropType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_StageData_DisplayRewards<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageData_DisplayRewards", 3)?;
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("dropType", &self.dropType())?;
        s.end()
    }
}

pub struct clz_Torappu_StageData_DisplayRewardsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StageData_DisplayRewardsBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_StageData_DisplayRewards::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_DisplayRewards::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_dropType(&mut self, dropType: enum__Torappu_StageDropType) {
        self.fbb_.push_slot::<enum__Torappu_StageDropType>(
            clz_Torappu_StageData_DisplayRewards::VT_DROPTYPE,
            dropType,
            enum__Torappu_StageDropType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageData_DisplayRewardsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageData_DisplayRewardsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayRewards<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageData_DisplayRewards<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageData_DisplayRewards");
        ds.field("type_", &self.type_());
        ds.field("id", &self.id());
        ds.field("dropType", &self.dropType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageData_DisplayRewardsT {
    pub type_: enum__Torappu_ItemType,
    pub id: Option<String>,
    pub dropType: enum__Torappu_StageDropType,
}
impl Default for clz_Torappu_StageData_DisplayRewardsT {
    fn default() -> Self {
        Self {
            type_: enum__Torappu_ItemType::NONE,
            id: None,
            dropType: enum__Torappu_StageDropType::NONE,
        }
    }
}
impl clz_Torappu_StageData_DisplayRewardsT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayRewards<'b>> {
        let type_ = self.type_;
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let dropType = self.dropType;
        clz_Torappu_StageData_DisplayRewards::create(
            _fbb,
            &clz_Torappu_StageData_DisplayRewardsArgs {
                type_,
                id,
                dropType,
            },
        )
    }
}
pub enum clz_Torappu_CampaignData_DropGainInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CampaignData_DropGainInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CampaignData_DropGainInfo<'a> {
    type Inner = clz_Torappu_CampaignData_DropGainInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CampaignData_DropGainInfo<'a> {
    pub const VT_DROPLADDERS: flatbuffers::VOffsetT = 4;
    pub const VT_GAINLADDERS: flatbuffers::VOffsetT = 6;
    pub const VT_DISPLAYREWARDS: flatbuffers::VOffsetT = 8;
    pub const VT_DISPLAYDETAILREWARDS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CampaignData_DropGainInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CampaignData_DropGainInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignData_DropGainInfo<'bldr>> {
        let mut builder = clz_Torappu_CampaignData_DropGainInfoBuilder::new(_fbb);
        if let Some(x) = args.displayDetailRewards {
            builder.add_displayDetailRewards(x);
        }
        if let Some(x) = args.displayRewards {
            builder.add_displayRewards(x);
        }
        if let Some(x) = args.gainLadders {
            builder.add_gainLadders(x);
        }
        if let Some(x) = args.dropLadders {
            builder.add_dropLadders(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CampaignData_DropGainInfoT {
        let dropLadders = self
            .dropLadders()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let gainLadders = self
            .gainLadders()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let displayRewards = self
            .displayRewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let displayDetailRewards = self
            .displayDetailRewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_CampaignData_DropGainInfoT {
            dropLadders,
            gainLadders,
            displayRewards,
            displayDetailRewards,
        }
    }

    #[inline]
    pub fn dropLadders(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_CampaignData_DropLadder<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CampaignData_DropLadder>,
                >,
            >>(clz_Torappu_CampaignData_DropGainInfo::VT_DROPLADDERS, None)
        }
    }
    #[inline]
    pub fn gainLadders(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_CampaignData_GainLadder<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CampaignData_GainLadder>,
                >,
            >>(clz_Torappu_CampaignData_DropGainInfo::VT_GAINLADDERS, None)
        }
    }
    #[inline]
    pub fn displayRewards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayRewards<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayRewards>,
                >,
            >>(
                clz_Torappu_CampaignData_DropGainInfo::VT_DISPLAYREWARDS,
                None,
            )
        }
    }
    #[inline]
    pub fn displayDetailRewards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards>,
                >,
            >>(
                clz_Torappu_CampaignData_DropGainInfo::VT_DISPLAYDETAILREWARDS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CampaignData_DropGainInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CampaignData_DropLadder>,
                >,
            >>("dropLadders", Self::VT_DROPLADDERS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CampaignData_GainLadder>,
                >,
            >>("gainLadders", Self::VT_GAINLADDERS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayRewards>,
                >,
            >>("displayRewards", Self::VT_DISPLAYREWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards>,
                >,
            >>("displayDetailRewards", Self::VT_DISPLAYDETAILREWARDS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CampaignData_DropGainInfoArgs<'a> {
    pub dropLadders: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_CampaignData_DropLadder<'a>>,
            >,
        >,
    >,
    pub gainLadders: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_CampaignData_GainLadder<'a>>,
            >,
        >,
    >,
    pub displayRewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayRewards<'a>>,
            >,
        >,
    >,
    pub displayDetailRewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_CampaignData_DropGainInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CampaignData_DropGainInfoArgs {
            dropLadders: None,
            gainLadders: None,
            displayRewards: None,
            displayDetailRewards: None,
        }
    }
}

impl Serialize for clz_Torappu_CampaignData_DropGainInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CampaignData_DropGainInfo", 4)?;
        if let Some(f) = self.dropLadders() {
            s.serialize_field("dropLadders", &f)?;
        } else {
            s.skip_field("dropLadders")?;
        }
        if let Some(f) = self.gainLadders() {
            s.serialize_field("gainLadders", &f)?;
        } else {
            s.skip_field("gainLadders")?;
        }
        if let Some(f) = self.displayRewards() {
            s.serialize_field("displayRewards", &f)?;
        } else {
            s.skip_field("displayRewards")?;
        }
        if let Some(f) = self.displayDetailRewards() {
            s.serialize_field("displayDetailRewards", &f)?;
        } else {
            s.skip_field("displayDetailRewards")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CampaignData_DropGainInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CampaignData_DropGainInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_dropLadders(
        &mut self,
        dropLadders: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CampaignData_DropLadder<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignData_DropGainInfo::VT_DROPLADDERS,
            dropLadders,
        );
    }
    #[inline]
    pub fn add_gainLadders(
        &mut self,
        gainLadders: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CampaignData_GainLadder<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignData_DropGainInfo::VT_GAINLADDERS,
            gainLadders,
        );
    }
    #[inline]
    pub fn add_displayRewards(
        &mut self,
        displayRewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayRewards<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignData_DropGainInfo::VT_DISPLAYREWARDS,
            displayRewards,
        );
    }
    #[inline]
    pub fn add_displayDetailRewards(
        &mut self,
        displayDetailRewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignData_DropGainInfo::VT_DISPLAYDETAILREWARDS,
            displayDetailRewards,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CampaignData_DropGainInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CampaignData_DropGainInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CampaignData_DropGainInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CampaignData_DropGainInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CampaignData_DropGainInfo");
        ds.field("dropLadders", &self.dropLadders());
        ds.field("gainLadders", &self.gainLadders());
        ds.field("displayRewards", &self.displayRewards());
        ds.field("displayDetailRewards", &self.displayDetailRewards());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CampaignData_DropGainInfoT {
    pub dropLadders: Option<Vec<clz_Torappu_CampaignData_DropLadderT>>,
    pub gainLadders: Option<Vec<clz_Torappu_CampaignData_GainLadderT>>,
    pub displayRewards: Option<Vec<clz_Torappu_StageData_DisplayRewardsT>>,
    pub displayDetailRewards: Option<Vec<clz_Torappu_StageData_DisplayDetailRewardsT>>,
}
impl Default for clz_Torappu_CampaignData_DropGainInfoT {
    fn default() -> Self {
        Self {
            dropLadders: None,
            gainLadders: None,
            displayRewards: None,
            displayDetailRewards: None,
        }
    }
}
impl clz_Torappu_CampaignData_DropGainInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignData_DropGainInfo<'b>> {
        let dropLadders = self.dropLadders.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let gainLadders = self.gainLadders.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let displayRewards = self.displayRewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let displayDetailRewards = self.displayDetailRewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_CampaignData_DropGainInfo::create(
            _fbb,
            &clz_Torappu_CampaignData_DropGainInfoArgs {
                dropLadders,
                gainLadders,
                displayRewards,
                displayDetailRewards,
            },
        )
    }
}
pub enum dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo<'a>
{
    type Inner = dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo<'bldr>,
    > {
        let mut builder = dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(
        &self,
    ) -> dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfoT {
        let key = self.key();
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_CampaignStageType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<enum__Torappu_CampaignStageType>(dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo::VT_KEY, Some(enum__Torappu_CampaignStageType::NONE)).unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_CampaignStageType,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_CampaignData_DropGainInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_CampaignData_DropGainInfo>>(dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable
    for dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_CampaignStageType>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CampaignData_DropGainInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfoArgs<'a> {
    pub key: enum__Torappu_CampaignStageType,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_CampaignData_DropGainInfo<'a>>>,
}
impl<'a> Default
    for dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfoArgs<'a>
{
    #[inline]
    fn default() -> Self {
        dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfoArgs {
            key: enum__Torappu_CampaignStageType::NONE,
            value: None,
        }
    }
}

impl Serialize
    for dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo<'_>
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: enum__Torappu_CampaignStageType) {
        self.fbb_.push_slot::<enum__Torappu_CampaignStageType>(
            dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo::VT_KEY,
            key,
            enum__Torappu_CampaignStageType::NONE,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_CampaignData_DropGainInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CampaignData_DropGainInfo>>(
            dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfoBuilder<
        'a,
        'b,
        A,
    > {
        let start = _fbb.start_table();
        dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct(
            "dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo",
        );
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfoT {
    pub key: enum__Torappu_CampaignStageType,
    pub value: Option<Box<clz_Torappu_CampaignData_DropGainInfoT>>,
}
impl Default for dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfoT {
    fn default() -> Self {
        Self {
            key: enum__Torappu_CampaignStageType::NONE,
            value: None,
        }
    }
}
impl dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo<'b>,
    > {
        let key = self.key;
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo::create(
            _fbb,
            &dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfoArgs {
                key,
                value,
            },
        )
    }
}
pub enum clz_Torappu_CampaignDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CampaignData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CampaignData<'a> {
    type Inner = clz_Torappu_CampaignData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CampaignData<'a> {
    pub const VT_STAGEID: flatbuffers::VOffsetT = 4;
    pub const VT_ISSMALLSCALE: flatbuffers::VOffsetT = 6;
    pub const VT_BREAKLADDERS: flatbuffers::VOffsetT = 8;
    pub const VT_ISCUSTOMIZED: flatbuffers::VOffsetT = 10;
    pub const VT_DROPGAINS: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CampaignData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CampaignDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignData<'bldr>> {
        let mut builder = clz_Torappu_CampaignDataBuilder::new(_fbb);
        if let Some(x) = args.dropGains {
            builder.add_dropGains(x);
        }
        if let Some(x) = args.breakLadders {
            builder.add_breakLadders(x);
        }
        builder.add_isSmallScale(args.isSmallScale);
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        builder.add_isCustomized(args.isCustomized);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CampaignDataT {
        let stageId = self.stageId().map(|x| x.to_string());
        let isSmallScale = self.isSmallScale();
        let breakLadders = self
            .breakLadders()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let isCustomized = self.isCustomized();
        let dropGains = self
            .dropGains()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_CampaignDataT {
            stageId,
            isSmallScale,
            breakLadders,
            isCustomized,
            dropGains,
        }
    }

    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CampaignData::VT_STAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn isSmallScale(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CampaignData::VT_ISSMALLSCALE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn breakLadders(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_CampaignData_BreakRewardLadder<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CampaignData_BreakRewardLadder>,
                >,
            >>(clz_Torappu_CampaignData::VT_BREAKLADDERS, None)
        }
    }
    #[inline]
    pub fn isCustomized(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_CampaignData::VT_ISCUSTOMIZED, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn dropGains(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo>>>>(clz_Torappu_CampaignData::VT_DROPGAINS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CampaignData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
     .visit_field::<i32>("isSmallScale", Self::VT_ISSMALLSCALE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_CampaignData_BreakRewardLadder>>>>("breakLadders", Self::VT_BREAKLADDERS, false)?
     .visit_field::<bool>("isCustomized", Self::VT_ISCUSTOMIZED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo>>>>("dropGains", Self::VT_DROPGAINS, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CampaignDataArgs<'a> {
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isSmallScale: i32,
    pub breakLadders: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_CampaignData_BreakRewardLadder<'a>>,
            >,
        >,
    >,
    pub isCustomized: bool,
    pub dropGains: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo<
                        'a,
                    >,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_CampaignDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CampaignDataArgs {
            stageId: None,
            isSmallScale: 0,
            breakLadders: None,
            isCustomized: false,
            dropGains: None,
        }
    }
}

impl Serialize for clz_Torappu_CampaignData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CampaignData", 5)?;
        if let Some(f) = self.stageId() {
            s.serialize_field("stageId", &f)?;
        } else {
            s.skip_field("stageId")?;
        }
        s.serialize_field("isSmallScale", &self.isSmallScale())?;
        if let Some(f) = self.breakLadders() {
            s.serialize_field("breakLadders", &f)?;
        } else {
            s.skip_field("breakLadders")?;
        }
        s.serialize_field("isCustomized", &self.isCustomized())?;
        if let Some(f) = self.dropGains() {
            s.serialize_field("dropGains", &f)?;
        } else {
            s.skip_field("dropGains")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CampaignDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_CampaignDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignData::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn add_isSmallScale(&mut self, isSmallScale: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_CampaignData::VT_ISSMALLSCALE, isSmallScale, 0);
    }
    #[inline]
    pub fn add_breakLadders(
        &mut self,
        breakLadders: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CampaignData_BreakRewardLadder<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignData::VT_BREAKLADDERS,
            breakLadders,
        );
    }
    #[inline]
    pub fn add_isCustomized(&mut self, isCustomized: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_CampaignData::VT_ISCUSTOMIZED,
            isCustomized,
            false,
        );
    }
    #[inline]
    pub fn add_dropGains(
        &mut self,
        dropGains: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfo<
                        'b,
                    >,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignData::VT_DROPGAINS,
            dropGains,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CampaignDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CampaignDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CampaignData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CampaignData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CampaignData");
        ds.field("stageId", &self.stageId());
        ds.field("isSmallScale", &self.isSmallScale());
        ds.field("breakLadders", &self.breakLadders());
        ds.field("isCustomized", &self.isCustomized());
        ds.field("dropGains", &self.dropGains());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CampaignDataT {
    pub stageId: Option<String>,
    pub isSmallScale: i32,
    pub breakLadders: Option<Vec<clz_Torappu_CampaignData_BreakRewardLadderT>>,
    pub isCustomized: bool,
    pub dropGains:
        Option<Vec<dict__enum__Torappu_CampaignStageType__clz_Torappu_CampaignData_DropGainInfoT>>,
}
impl Default for clz_Torappu_CampaignDataT {
    fn default() -> Self {
        Self {
            stageId: None,
            isSmallScale: 0,
            breakLadders: None,
            isCustomized: false,
            dropGains: None,
        }
    }
}
impl clz_Torappu_CampaignDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignData<'b>> {
        let stageId = self.stageId.as_ref().map(|x| _fbb.create_string(x));
        let isSmallScale = self.isSmallScale;
        let breakLadders = self.breakLadders.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let isCustomized = self.isCustomized;
        let dropGains = self.dropGains.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_CampaignData::create(
            _fbb,
            &clz_Torappu_CampaignDataArgs {
                stageId,
                isSmallScale,
                breakLadders,
                isCustomized,
                dropGains,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_CampaignDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_CampaignData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_CampaignData<'a> {
    type Inner = dict__string__clz_Torappu_CampaignData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_CampaignData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_CampaignData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_CampaignDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CampaignData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_CampaignDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_CampaignDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_CampaignDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_CampaignData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_CampaignData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_CampaignData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CampaignData>>(
                    dict__string__clz_Torappu_CampaignData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_CampaignData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CampaignData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_CampaignDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_CampaignData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_CampaignDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_CampaignDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_CampaignData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_CampaignData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_CampaignDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_CampaignDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_CampaignData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_CampaignData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CampaignData>>(
                dict__string__clz_Torappu_CampaignData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_CampaignDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_CampaignDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CampaignData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_CampaignData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_CampaignData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_CampaignData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_CampaignDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_CampaignDataT>>,
}
impl Default for dict__string__clz_Torappu_CampaignDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_CampaignDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CampaignData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_CampaignData::create(
            _fbb,
            &dict__string__clz_Torappu_CampaignDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_CampaignGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CampaignGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CampaignGroupData<'a> {
    type Inner = clz_Torappu_CampaignGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CampaignGroupData<'a> {
    pub const VT_GROUPID: flatbuffers::VOffsetT = 4;
    pub const VT_ACTIVECAMPS: flatbuffers::VOffsetT = 6;
    pub const VT_STARTTS: flatbuffers::VOffsetT = 8;
    pub const VT_ENDTS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CampaignGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CampaignGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignGroupData<'bldr>> {
        let mut builder = clz_Torappu_CampaignGroupDataBuilder::new(_fbb);
        builder.add_endTs(args.endTs);
        builder.add_startTs(args.startTs);
        if let Some(x) = args.activeCamps {
            builder.add_activeCamps(x);
        }
        if let Some(x) = args.groupId {
            builder.add_groupId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CampaignGroupDataT {
        let groupId = self.groupId().map(|x| x.to_string());
        let activeCamps = self
            .activeCamps()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let startTs = self.startTs();
        let endTs = self.endTs();
        clz_Torappu_CampaignGroupDataT {
            groupId,
            activeCamps,
            startTs,
            endTs,
        }
    }

    #[inline]
    pub fn groupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CampaignGroupData::VT_GROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn activeCamps(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_CampaignGroupData::VT_ACTIVECAMPS, None)
        }
    }
    #[inline]
    pub fn startTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_CampaignGroupData::VT_STARTTS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_CampaignGroupData::VT_ENDTS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CampaignGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("groupId", Self::VT_GROUPID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("activeCamps", Self::VT_ACTIVECAMPS, false)?
            .visit_field::<i64>("startTs", Self::VT_STARTTS, false)?
            .visit_field::<i64>("endTs", Self::VT_ENDTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CampaignGroupDataArgs<'a> {
    pub groupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub activeCamps: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub startTs: i64,
    pub endTs: i64,
}
impl<'a> Default for clz_Torappu_CampaignGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CampaignGroupDataArgs {
            groupId: None,
            activeCamps: None,
            startTs: 0,
            endTs: 0,
        }
    }
}

impl Serialize for clz_Torappu_CampaignGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CampaignGroupData", 4)?;
        if let Some(f) = self.groupId() {
            s.serialize_field("groupId", &f)?;
        } else {
            s.skip_field("groupId")?;
        }
        if let Some(f) = self.activeCamps() {
            s.serialize_field("activeCamps", &f)?;
        } else {
            s.skip_field("activeCamps")?;
        }
        s.serialize_field("startTs", &self.startTs())?;
        s.serialize_field("endTs", &self.endTs())?;
        s.end()
    }
}

pub struct clz_Torappu_CampaignGroupDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_CampaignGroupDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_groupId(&mut self, groupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignGroupData::VT_GROUPID,
            groupId,
        );
    }
    #[inline]
    pub fn add_activeCamps(
        &mut self,
        activeCamps: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignGroupData::VT_ACTIVECAMPS,
            activeCamps,
        );
    }
    #[inline]
    pub fn add_startTs(&mut self, startTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_CampaignGroupData::VT_STARTTS, startTs, 0);
    }
    #[inline]
    pub fn add_endTs(&mut self, endTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_CampaignGroupData::VT_ENDTS, endTs, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CampaignGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CampaignGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CampaignGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CampaignGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CampaignGroupData");
        ds.field("groupId", &self.groupId());
        ds.field("activeCamps", &self.activeCamps());
        ds.field("startTs", &self.startTs());
        ds.field("endTs", &self.endTs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CampaignGroupDataT {
    pub groupId: Option<String>,
    pub activeCamps: Option<Vec<String>>,
    pub startTs: i64,
    pub endTs: i64,
}
impl Default for clz_Torappu_CampaignGroupDataT {
    fn default() -> Self {
        Self {
            groupId: None,
            activeCamps: None,
            startTs: 0,
            endTs: 0,
        }
    }
}
impl clz_Torappu_CampaignGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignGroupData<'b>> {
        let groupId = self.groupId.as_ref().map(|x| _fbb.create_string(x));
        let activeCamps = self.activeCamps.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let startTs = self.startTs;
        let endTs = self.endTs;
        clz_Torappu_CampaignGroupData::create(
            _fbb,
            &clz_Torappu_CampaignGroupDataArgs {
                groupId,
                activeCamps,
                startTs,
                endTs,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_CampaignGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_CampaignGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_CampaignGroupData<'a> {
    type Inner = dict__string__clz_Torappu_CampaignGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_CampaignGroupData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_CampaignGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_CampaignGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CampaignGroupData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_CampaignGroupDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_CampaignGroupDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_CampaignGroupDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_CampaignGroupData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_CampaignGroupData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_CampaignGroupData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CampaignGroupData>>(
                    dict__string__clz_Torappu_CampaignGroupData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_CampaignGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CampaignGroupData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_CampaignGroupDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_CampaignGroupData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_CampaignGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_CampaignGroupDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_CampaignGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_CampaignGroupData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_CampaignGroupDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_CampaignGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_CampaignGroupData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_CampaignGroupData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CampaignGroupData>>(
                dict__string__clz_Torappu_CampaignGroupData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_CampaignGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_CampaignGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CampaignGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_CampaignGroupData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_CampaignGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_CampaignGroupData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_CampaignGroupDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_CampaignGroupDataT>>,
}
impl Default for dict__string__clz_Torappu_CampaignGroupDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_CampaignGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CampaignGroupData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_CampaignGroupData::create(
            _fbb,
            &dict__string__clz_Torappu_CampaignGroupDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_CampaignRegionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CampaignRegionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CampaignRegionData<'a> {
    type Inner = clz_Torappu_CampaignRegionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CampaignRegionData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_ISUNKNWON: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CampaignRegionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CampaignRegionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignRegionData<'bldr>> {
        let mut builder = clz_Torappu_CampaignRegionDataBuilder::new(_fbb);
        builder.add_isUnknwon(args.isUnknwon);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CampaignRegionDataT {
        let id = self.id().map(|x| x.to_string());
        let isUnknwon = self.isUnknwon();
        clz_Torappu_CampaignRegionDataT { id, isUnknwon }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CampaignRegionData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn isUnknwon(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CampaignRegionData::VT_ISUNKNWON, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CampaignRegionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("isUnknwon", Self::VT_ISUNKNWON, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CampaignRegionDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isUnknwon: i32,
}
impl<'a> Default for clz_Torappu_CampaignRegionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CampaignRegionDataArgs {
            id: None,
            isUnknwon: 0,
        }
    }
}

impl Serialize for clz_Torappu_CampaignRegionData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CampaignRegionData", 2)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("isUnknwon", &self.isUnknwon())?;
        s.end()
    }
}

pub struct clz_Torappu_CampaignRegionDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_CampaignRegionDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignRegionData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_isUnknwon(&mut self, isUnknwon: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_CampaignRegionData::VT_ISUNKNWON, isUnknwon, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CampaignRegionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CampaignRegionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CampaignRegionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CampaignRegionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CampaignRegionData");
        ds.field("id", &self.id());
        ds.field("isUnknwon", &self.isUnknwon());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CampaignRegionDataT {
    pub id: Option<String>,
    pub isUnknwon: i32,
}
impl Default for clz_Torappu_CampaignRegionDataT {
    fn default() -> Self {
        Self {
            id: None,
            isUnknwon: 0,
        }
    }
}
impl clz_Torappu_CampaignRegionDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignRegionData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let isUnknwon = self.isUnknwon;
        clz_Torappu_CampaignRegionData::create(
            _fbb,
            &clz_Torappu_CampaignRegionDataArgs { id, isUnknwon },
        )
    }
}
pub enum dict__string__clz_Torappu_CampaignRegionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_CampaignRegionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_CampaignRegionData<'a> {
    type Inner = dict__string__clz_Torappu_CampaignRegionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_CampaignRegionData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_CampaignRegionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_CampaignRegionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CampaignRegionData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_CampaignRegionDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_CampaignRegionDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_CampaignRegionDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_CampaignRegionData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_CampaignRegionData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_CampaignRegionData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CampaignRegionData>>(
                    dict__string__clz_Torappu_CampaignRegionData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_CampaignRegionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CampaignRegionData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_CampaignRegionDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_CampaignRegionData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_CampaignRegionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_CampaignRegionDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_CampaignRegionData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_CampaignRegionData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_CampaignRegionDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_CampaignRegionDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_CampaignRegionData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_CampaignRegionData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CampaignRegionData>>(
                dict__string__clz_Torappu_CampaignRegionData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_CampaignRegionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_CampaignRegionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CampaignRegionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_CampaignRegionData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_CampaignRegionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_CampaignRegionData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_CampaignRegionDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_CampaignRegionDataT>>,
}
impl Default for dict__string__clz_Torappu_CampaignRegionDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_CampaignRegionDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CampaignRegionData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_CampaignRegionData::create(
            _fbb,
            &dict__string__clz_Torappu_CampaignRegionDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_CampaignZoneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CampaignZoneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CampaignZoneData<'a> {
    type Inner = clz_Torappu_CampaignZoneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CampaignZoneData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_REGIONID: flatbuffers::VOffsetT = 8;
    pub const VT_TEMPLATEID: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CampaignZoneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CampaignZoneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignZoneData<'bldr>> {
        let mut builder = clz_Torappu_CampaignZoneDataBuilder::new(_fbb);
        if let Some(x) = args.templateId {
            builder.add_templateId(x);
        }
        if let Some(x) = args.regionId {
            builder.add_regionId(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CampaignZoneDataT {
        let id = self.id().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let regionId = self.regionId().map(|x| x.to_string());
        let templateId = self.templateId().map(|x| x.to_string());
        clz_Torappu_CampaignZoneDataT {
            id,
            name,
            regionId,
            templateId,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CampaignZoneData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CampaignZoneData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn regionId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CampaignZoneData::VT_REGIONID,
                None,
            )
        }
    }
    #[inline]
    pub fn templateId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CampaignZoneData::VT_TEMPLATEID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CampaignZoneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "regionId",
                Self::VT_REGIONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "templateId",
                Self::VT_TEMPLATEID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CampaignZoneDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub regionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub templateId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_CampaignZoneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CampaignZoneDataArgs {
            id: None,
            name: None,
            regionId: None,
            templateId: None,
        }
    }
}

impl Serialize for clz_Torappu_CampaignZoneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CampaignZoneData", 4)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.regionId() {
            s.serialize_field("regionId", &f)?;
        } else {
            s.skip_field("regionId")?;
        }
        if let Some(f) = self.templateId() {
            s.serialize_field("templateId", &f)?;
        } else {
            s.skip_field("templateId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CampaignZoneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_CampaignZoneDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_CampaignZoneData::VT_ID, id);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignZoneData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_regionId(&mut self, regionId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignZoneData::VT_REGIONID,
            regionId,
        );
    }
    #[inline]
    pub fn add_templateId(&mut self, templateId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignZoneData::VT_TEMPLATEID,
            templateId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CampaignZoneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CampaignZoneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CampaignZoneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CampaignZoneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CampaignZoneData");
        ds.field("id", &self.id());
        ds.field("name", &self.name());
        ds.field("regionId", &self.regionId());
        ds.field("templateId", &self.templateId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CampaignZoneDataT {
    pub id: Option<String>,
    pub name: Option<String>,
    pub regionId: Option<String>,
    pub templateId: Option<String>,
}
impl Default for clz_Torappu_CampaignZoneDataT {
    fn default() -> Self {
        Self {
            id: None,
            name: None,
            regionId: None,
            templateId: None,
        }
    }
}
impl clz_Torappu_CampaignZoneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignZoneData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let regionId = self.regionId.as_ref().map(|x| _fbb.create_string(x));
        let templateId = self.templateId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_CampaignZoneData::create(
            _fbb,
            &clz_Torappu_CampaignZoneDataArgs {
                id,
                name,
                regionId,
                templateId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_CampaignZoneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_CampaignZoneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_CampaignZoneData<'a> {
    type Inner = dict__string__clz_Torappu_CampaignZoneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_CampaignZoneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_CampaignZoneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_CampaignZoneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CampaignZoneData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_CampaignZoneDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_CampaignZoneDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_CampaignZoneDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_CampaignZoneData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_CampaignZoneData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_CampaignZoneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CampaignZoneData>>(
                    dict__string__clz_Torappu_CampaignZoneData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_CampaignZoneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CampaignZoneData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_CampaignZoneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_CampaignZoneData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_CampaignZoneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_CampaignZoneDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_CampaignZoneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_CampaignZoneData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_CampaignZoneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_CampaignZoneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_CampaignZoneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_CampaignZoneData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CampaignZoneData>>(
                dict__string__clz_Torappu_CampaignZoneData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_CampaignZoneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_CampaignZoneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CampaignZoneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_CampaignZoneData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_CampaignZoneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_CampaignZoneData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_CampaignZoneDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_CampaignZoneDataT>>,
}
impl Default for dict__string__clz_Torappu_CampaignZoneDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_CampaignZoneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CampaignZoneData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_CampaignZoneData::create(
            _fbb,
            &dict__string__clz_Torappu_CampaignZoneDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_CampaignMissionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CampaignMissionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CampaignMissionData<'a> {
    type Inner = clz_Torappu_CampaignMissionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CampaignMissionData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_PARAM: flatbuffers::VOffsetT = 8;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
    pub const VT_BREAKFEEADD: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CampaignMissionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CampaignMissionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignMissionData<'bldr>> {
        let mut builder = clz_Torappu_CampaignMissionDataBuilder::new(_fbb);
        builder.add_breakFeeAdd(args.breakFeeAdd);
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.param {
            builder.add_param(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CampaignMissionDataT {
        let id = self.id().map(|x| x.to_string());
        let sortId = self.sortId();
        let param = self
            .param()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let description = self.description().map(|x| x.to_string());
        let breakFeeAdd = self.breakFeeAdd();
        clz_Torappu_CampaignMissionDataT {
            id,
            sortId,
            param,
            description,
            breakFeeAdd,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CampaignMissionData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CampaignMissionData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn param(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_CampaignMissionData::VT_PARAM, None)
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CampaignMissionData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn breakFeeAdd(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CampaignMissionData::VT_BREAKFEEADD, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CampaignMissionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("param", Self::VT_PARAM, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<i32>("breakFeeAdd", Self::VT_BREAKFEEADD, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CampaignMissionDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub param: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub breakFeeAdd: i32,
}
impl<'a> Default for clz_Torappu_CampaignMissionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CampaignMissionDataArgs {
            id: None,
            sortId: 0,
            param: None,
            description: None,
            breakFeeAdd: 0,
        }
    }
}

impl Serialize for clz_Torappu_CampaignMissionData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CampaignMissionData", 5)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.param() {
            s.serialize_field("param", &f)?;
        } else {
            s.skip_field("param")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        s.serialize_field("breakFeeAdd", &self.breakFeeAdd())?;
        s.end()
    }
}

pub struct clz_Torappu_CampaignMissionDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_CampaignMissionDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignMissionData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_CampaignMissionData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_param(
        &mut self,
        param: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignMissionData::VT_PARAM,
            param,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignMissionData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_breakFeeAdd(&mut self, breakFeeAdd: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_CampaignMissionData::VT_BREAKFEEADD,
            breakFeeAdd,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CampaignMissionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CampaignMissionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CampaignMissionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CampaignMissionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CampaignMissionData");
        ds.field("id", &self.id());
        ds.field("sortId", &self.sortId());
        ds.field("param", &self.param());
        ds.field("description", &self.description());
        ds.field("breakFeeAdd", &self.breakFeeAdd());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CampaignMissionDataT {
    pub id: Option<String>,
    pub sortId: i32,
    pub param: Option<Vec<String>>,
    pub description: Option<String>,
    pub breakFeeAdd: i32,
}
impl Default for clz_Torappu_CampaignMissionDataT {
    fn default() -> Self {
        Self {
            id: None,
            sortId: 0,
            param: None,
            description: None,
            breakFeeAdd: 0,
        }
    }
}
impl clz_Torappu_CampaignMissionDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignMissionData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let param = self.param.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let breakFeeAdd = self.breakFeeAdd;
        clz_Torappu_CampaignMissionData::create(
            _fbb,
            &clz_Torappu_CampaignMissionDataArgs {
                id,
                sortId,
                param,
                description,
                breakFeeAdd,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_CampaignMissionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_CampaignMissionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_CampaignMissionData<'a> {
    type Inner = dict__string__clz_Torappu_CampaignMissionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_CampaignMissionData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_CampaignMissionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_CampaignMissionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CampaignMissionData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_CampaignMissionDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_CampaignMissionDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_CampaignMissionDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_CampaignMissionData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_CampaignMissionData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_CampaignMissionData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CampaignMissionData>>(
                    dict__string__clz_Torappu_CampaignMissionData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_CampaignMissionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CampaignMissionData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_CampaignMissionDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_CampaignMissionData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_CampaignMissionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_CampaignMissionDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_CampaignMissionData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_CampaignMissionData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_CampaignMissionDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_CampaignMissionDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_CampaignMissionData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_CampaignMissionData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CampaignMissionData>>(
                dict__string__clz_Torappu_CampaignMissionData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_CampaignMissionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_CampaignMissionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CampaignMissionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_CampaignMissionData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_CampaignMissionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_CampaignMissionData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_CampaignMissionDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_CampaignMissionDataT>>,
}
impl Default for dict__string__clz_Torappu_CampaignMissionDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_CampaignMissionDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CampaignMissionData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_CampaignMissionData::create(
            _fbb,
            &dict__string__clz_Torappu_CampaignMissionDataArgs { key, value },
        )
    }
}
pub enum dict__string__intOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__int<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__int<'a> {
    type Inner = dict__string__int<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__int<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__int { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__intArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__int<'bldr>> {
        let mut builder = dict__string__intBuilder::new(_fbb);
        builder.add_value(args.value);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__intT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value();
        dict__string__intT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__int::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__int) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(dict__string__int::VT_VALUE, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for dict__string__int<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<i32>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__intArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: i32,
}
impl<'a> Default for dict__string__intArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__intArgs {
            key: None, // required field
            value: 0,
        }
    }
}

impl Serialize for dict__string__int<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__int", 2)?;
        s.serialize_field("key", &self.key())?;
        s.serialize_field("value", &self.value())?;
        s.end()
    }
}

pub struct dict__string__intBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__intBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__int::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(&mut self, value: i32) {
        self.fbb_
            .push_slot::<i32>(dict__string__int::VT_VALUE, value, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__intBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__intBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__int<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, dict__string__int::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__int<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__int");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__intT {
    pub key: String,
    pub value: i32,
}
impl Default for dict__string__intT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: 0,
        }
    }
}
impl dict__string__intT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__int<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value;
        dict__string__int::create(_fbb, &dict__string__intArgs { key, value })
    }
}
pub enum clz_Torappu_CampaignConstTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CampaignConstTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CampaignConstTable<'a> {
    type Inner = clz_Torappu_CampaignConstTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CampaignConstTable<'a> {
    pub const VT_SYSTEMPREPOSEDSTAGE: flatbuffers::VOffsetT = 4;
    pub const VT_ROTATESTARTTIME: flatbuffers::VOffsetT = 6;
    pub const VT_ROTATEPREPOSEDSTAGE: flatbuffers::VOffsetT = 8;
    pub const VT_ZONEUNLOCKSTAGE: flatbuffers::VOffsetT = 10;
    pub const VT_FIRSTROTATEREGION: flatbuffers::VOffsetT = 12;
    pub const VT_SWEEPSTARTTIME: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CampaignConstTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CampaignConstTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignConstTable<'bldr>> {
        let mut builder = clz_Torappu_CampaignConstTableBuilder::new(_fbb);
        builder.add_sweepStartTime(args.sweepStartTime);
        builder.add_rotateStartTime(args.rotateStartTime);
        if let Some(x) = args.firstRotateRegion {
            builder.add_firstRotateRegion(x);
        }
        if let Some(x) = args.zoneUnlockStage {
            builder.add_zoneUnlockStage(x);
        }
        if let Some(x) = args.rotatePreposedStage {
            builder.add_rotatePreposedStage(x);
        }
        if let Some(x) = args.systemPreposedStage {
            builder.add_systemPreposedStage(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CampaignConstTableT {
        let systemPreposedStage = self.systemPreposedStage().map(|x| x.to_string());
        let rotateStartTime = self.rotateStartTime();
        let rotatePreposedStage = self.rotatePreposedStage().map(|x| x.to_string());
        let zoneUnlockStage = self.zoneUnlockStage().map(|x| x.to_string());
        let firstRotateRegion = self.firstRotateRegion().map(|x| x.to_string());
        let sweepStartTime = self.sweepStartTime();
        clz_Torappu_CampaignConstTableT {
            systemPreposedStage,
            rotateStartTime,
            rotatePreposedStage,
            zoneUnlockStage,
            firstRotateRegion,
            sweepStartTime,
        }
    }

    #[inline]
    pub fn systemPreposedStage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CampaignConstTable::VT_SYSTEMPREPOSEDSTAGE,
                None,
            )
        }
    }
    #[inline]
    pub fn rotateStartTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_CampaignConstTable::VT_ROTATESTARTTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn rotatePreposedStage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CampaignConstTable::VT_ROTATEPREPOSEDSTAGE,
                None,
            )
        }
    }
    #[inline]
    pub fn zoneUnlockStage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CampaignConstTable::VT_ZONEUNLOCKSTAGE,
                None,
            )
        }
    }
    #[inline]
    pub fn firstRotateRegion(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CampaignConstTable::VT_FIRSTROTATEREGION,
                None,
            )
        }
    }
    #[inline]
    pub fn sweepStartTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_CampaignConstTable::VT_SWEEPSTARTTIME, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CampaignConstTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "systemPreposedStage",
                Self::VT_SYSTEMPREPOSEDSTAGE,
                false,
            )?
            .visit_field::<i64>("rotateStartTime", Self::VT_ROTATESTARTTIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rotatePreposedStage",
                Self::VT_ROTATEPREPOSEDSTAGE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "zoneUnlockStage",
                Self::VT_ZONEUNLOCKSTAGE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "firstRotateRegion",
                Self::VT_FIRSTROTATEREGION,
                false,
            )?
            .visit_field::<i64>("sweepStartTime", Self::VT_SWEEPSTARTTIME, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CampaignConstTableArgs<'a> {
    pub systemPreposedStage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rotateStartTime: i64,
    pub rotatePreposedStage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneUnlockStage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub firstRotateRegion: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sweepStartTime: i64,
}
impl<'a> Default for clz_Torappu_CampaignConstTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CampaignConstTableArgs {
            systemPreposedStage: None,
            rotateStartTime: 0,
            rotatePreposedStage: None,
            zoneUnlockStage: None,
            firstRotateRegion: None,
            sweepStartTime: 0,
        }
    }
}

impl Serialize for clz_Torappu_CampaignConstTable<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CampaignConstTable", 6)?;
        if let Some(f) = self.systemPreposedStage() {
            s.serialize_field("systemPreposedStage", &f)?;
        } else {
            s.skip_field("systemPreposedStage")?;
        }
        s.serialize_field("rotateStartTime", &self.rotateStartTime())?;
        if let Some(f) = self.rotatePreposedStage() {
            s.serialize_field("rotatePreposedStage", &f)?;
        } else {
            s.skip_field("rotatePreposedStage")?;
        }
        if let Some(f) = self.zoneUnlockStage() {
            s.serialize_field("zoneUnlockStage", &f)?;
        } else {
            s.skip_field("zoneUnlockStage")?;
        }
        if let Some(f) = self.firstRotateRegion() {
            s.serialize_field("firstRotateRegion", &f)?;
        } else {
            s.skip_field("firstRotateRegion")?;
        }
        s.serialize_field("sweepStartTime", &self.sweepStartTime())?;
        s.end()
    }
}

pub struct clz_Torappu_CampaignConstTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_CampaignConstTableBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_systemPreposedStage(
        &mut self,
        systemPreposedStage: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignConstTable::VT_SYSTEMPREPOSEDSTAGE,
            systemPreposedStage,
        );
    }
    #[inline]
    pub fn add_rotateStartTime(&mut self, rotateStartTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_CampaignConstTable::VT_ROTATESTARTTIME,
            rotateStartTime,
            0,
        );
    }
    #[inline]
    pub fn add_rotatePreposedStage(
        &mut self,
        rotatePreposedStage: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignConstTable::VT_ROTATEPREPOSEDSTAGE,
            rotatePreposedStage,
        );
    }
    #[inline]
    pub fn add_zoneUnlockStage(&mut self, zoneUnlockStage: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignConstTable::VT_ZONEUNLOCKSTAGE,
            zoneUnlockStage,
        );
    }
    #[inline]
    pub fn add_firstRotateRegion(&mut self, firstRotateRegion: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignConstTable::VT_FIRSTROTATEREGION,
            firstRotateRegion,
        );
    }
    #[inline]
    pub fn add_sweepStartTime(&mut self, sweepStartTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_CampaignConstTable::VT_SWEEPSTARTTIME,
            sweepStartTime,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CampaignConstTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CampaignConstTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CampaignConstTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CampaignConstTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CampaignConstTable");
        ds.field("systemPreposedStage", &self.systemPreposedStage());
        ds.field("rotateStartTime", &self.rotateStartTime());
        ds.field("rotatePreposedStage", &self.rotatePreposedStage());
        ds.field("zoneUnlockStage", &self.zoneUnlockStage());
        ds.field("firstRotateRegion", &self.firstRotateRegion());
        ds.field("sweepStartTime", &self.sweepStartTime());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CampaignConstTableT {
    pub systemPreposedStage: Option<String>,
    pub rotateStartTime: i64,
    pub rotatePreposedStage: Option<String>,
    pub zoneUnlockStage: Option<String>,
    pub firstRotateRegion: Option<String>,
    pub sweepStartTime: i64,
}
impl Default for clz_Torappu_CampaignConstTableT {
    fn default() -> Self {
        Self {
            systemPreposedStage: None,
            rotateStartTime: 0,
            rotatePreposedStage: None,
            zoneUnlockStage: None,
            firstRotateRegion: None,
            sweepStartTime: 0,
        }
    }
}
impl clz_Torappu_CampaignConstTableT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignConstTable<'b>> {
        let systemPreposedStage = self
            .systemPreposedStage
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let rotateStartTime = self.rotateStartTime;
        let rotatePreposedStage = self
            .rotatePreposedStage
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let zoneUnlockStage = self.zoneUnlockStage.as_ref().map(|x| _fbb.create_string(x));
        let firstRotateRegion = self
            .firstRotateRegion
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let sweepStartTime = self.sweepStartTime;
        clz_Torappu_CampaignConstTable::create(
            _fbb,
            &clz_Torappu_CampaignConstTableArgs {
                systemPreposedStage,
                rotateStartTime,
                rotatePreposedStage,
                zoneUnlockStage,
                firstRotateRegion,
                sweepStartTime,
            },
        )
    }
}
pub enum clz_Torappu_CampaignRotateOpenTimeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CampaignRotateOpenTimeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CampaignRotateOpenTimeData<'a> {
    type Inner = clz_Torappu_CampaignRotateOpenTimeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CampaignRotateOpenTimeData<'a> {
    pub const VT_GROUPID: flatbuffers::VOffsetT = 4;
    pub const VT_STAGEID: flatbuffers::VOffsetT = 6;
    pub const VT_MAPID: flatbuffers::VOffsetT = 8;
    pub const VT_UNKNOWNREGIONS: flatbuffers::VOffsetT = 10;
    pub const VT_DURATION: flatbuffers::VOffsetT = 12;
    pub const VT_STARTTS: flatbuffers::VOffsetT = 14;
    pub const VT_ENDTS: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CampaignRotateOpenTimeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CampaignRotateOpenTimeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignRotateOpenTimeData<'bldr>> {
        let mut builder = clz_Torappu_CampaignRotateOpenTimeDataBuilder::new(_fbb);
        builder.add_endTs(args.endTs);
        builder.add_startTs(args.startTs);
        builder.add_duration(args.duration);
        if let Some(x) = args.unknownRegions {
            builder.add_unknownRegions(x);
        }
        if let Some(x) = args.mapId {
            builder.add_mapId(x);
        }
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        if let Some(x) = args.groupId {
            builder.add_groupId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CampaignRotateOpenTimeDataT {
        let groupId = self.groupId().map(|x| x.to_string());
        let stageId = self.stageId().map(|x| x.to_string());
        let mapId = self.mapId().map(|x| x.to_string());
        let unknownRegions = self
            .unknownRegions()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let duration = self.duration();
        let startTs = self.startTs();
        let endTs = self.endTs();
        clz_Torappu_CampaignRotateOpenTimeDataT {
            groupId,
            stageId,
            mapId,
            unknownRegions,
            duration,
            startTs,
            endTs,
        }
    }

    #[inline]
    pub fn groupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CampaignRotateOpenTimeData::VT_GROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CampaignRotateOpenTimeData::VT_STAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn mapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CampaignRotateOpenTimeData::VT_MAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn unknownRegions(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_CampaignRotateOpenTimeData::VT_UNKNOWNREGIONS,
                None,
            )
        }
    }
    #[inline]
    pub fn duration(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CampaignRotateOpenTimeData::VT_DURATION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn startTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_CampaignRotateOpenTimeData::VT_STARTTS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_CampaignRotateOpenTimeData::VT_ENDTS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CampaignRotateOpenTimeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("groupId", Self::VT_GROUPID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mapId", Self::VT_MAPID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("unknownRegions", Self::VT_UNKNOWNREGIONS, false)?
            .visit_field::<i32>("duration", Self::VT_DURATION, false)?
            .visit_field::<i64>("startTs", Self::VT_STARTTS, false)?
            .visit_field::<i64>("endTs", Self::VT_ENDTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CampaignRotateOpenTimeDataArgs<'a> {
    pub groupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unknownRegions: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub duration: i32,
    pub startTs: i64,
    pub endTs: i64,
}
impl<'a> Default for clz_Torappu_CampaignRotateOpenTimeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CampaignRotateOpenTimeDataArgs {
            groupId: None,
            stageId: None,
            mapId: None,
            unknownRegions: None,
            duration: 0,
            startTs: 0,
            endTs: 0,
        }
    }
}

impl Serialize for clz_Torappu_CampaignRotateOpenTimeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CampaignRotateOpenTimeData", 7)?;
        if let Some(f) = self.groupId() {
            s.serialize_field("groupId", &f)?;
        } else {
            s.skip_field("groupId")?;
        }
        if let Some(f) = self.stageId() {
            s.serialize_field("stageId", &f)?;
        } else {
            s.skip_field("stageId")?;
        }
        if let Some(f) = self.mapId() {
            s.serialize_field("mapId", &f)?;
        } else {
            s.skip_field("mapId")?;
        }
        if let Some(f) = self.unknownRegions() {
            s.serialize_field("unknownRegions", &f)?;
        } else {
            s.skip_field("unknownRegions")?;
        }
        s.serialize_field("duration", &self.duration())?;
        s.serialize_field("startTs", &self.startTs())?;
        s.serialize_field("endTs", &self.endTs())?;
        s.end()
    }
}

pub struct clz_Torappu_CampaignRotateOpenTimeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CampaignRotateOpenTimeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_groupId(&mut self, groupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignRotateOpenTimeData::VT_GROUPID,
            groupId,
        );
    }
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignRotateOpenTimeData::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn add_mapId(&mut self, mapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignRotateOpenTimeData::VT_MAPID,
            mapId,
        );
    }
    #[inline]
    pub fn add_unknownRegions(
        &mut self,
        unknownRegions: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignRotateOpenTimeData::VT_UNKNOWNREGIONS,
            unknownRegions,
        );
    }
    #[inline]
    pub fn add_duration(&mut self, duration: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_CampaignRotateOpenTimeData::VT_DURATION,
            duration,
            0,
        );
    }
    #[inline]
    pub fn add_startTs(&mut self, startTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_CampaignRotateOpenTimeData::VT_STARTTS,
            startTs,
            0,
        );
    }
    #[inline]
    pub fn add_endTs(&mut self, endTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_CampaignRotateOpenTimeData::VT_ENDTS, endTs, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CampaignRotateOpenTimeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CampaignRotateOpenTimeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CampaignRotateOpenTimeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CampaignRotateOpenTimeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CampaignRotateOpenTimeData");
        ds.field("groupId", &self.groupId());
        ds.field("stageId", &self.stageId());
        ds.field("mapId", &self.mapId());
        ds.field("unknownRegions", &self.unknownRegions());
        ds.field("duration", &self.duration());
        ds.field("startTs", &self.startTs());
        ds.field("endTs", &self.endTs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CampaignRotateOpenTimeDataT {
    pub groupId: Option<String>,
    pub stageId: Option<String>,
    pub mapId: Option<String>,
    pub unknownRegions: Option<Vec<String>>,
    pub duration: i32,
    pub startTs: i64,
    pub endTs: i64,
}
impl Default for clz_Torappu_CampaignRotateOpenTimeDataT {
    fn default() -> Self {
        Self {
            groupId: None,
            stageId: None,
            mapId: None,
            unknownRegions: None,
            duration: 0,
            startTs: 0,
            endTs: 0,
        }
    }
}
impl clz_Torappu_CampaignRotateOpenTimeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignRotateOpenTimeData<'b>> {
        let groupId = self.groupId.as_ref().map(|x| _fbb.create_string(x));
        let stageId = self.stageId.as_ref().map(|x| _fbb.create_string(x));
        let mapId = self.mapId.as_ref().map(|x| _fbb.create_string(x));
        let unknownRegions = self.unknownRegions.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let duration = self.duration;
        let startTs = self.startTs;
        let endTs = self.endTs;
        clz_Torappu_CampaignRotateOpenTimeData::create(
            _fbb,
            &clz_Torappu_CampaignRotateOpenTimeDataArgs {
                groupId,
                stageId,
                mapId,
                unknownRegions,
                duration,
                startTs,
                endTs,
            },
        )
    }
}
pub enum clz_Torappu_CampaignTrainingOpenTimeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CampaignTrainingOpenTimeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CampaignTrainingOpenTimeData<'a> {
    type Inner = clz_Torappu_CampaignTrainingOpenTimeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CampaignTrainingOpenTimeData<'a> {
    pub const VT_GROUPID: flatbuffers::VOffsetT = 4;
    pub const VT_STAGES: flatbuffers::VOffsetT = 6;
    pub const VT_STARTTS: flatbuffers::VOffsetT = 8;
    pub const VT_ENDTS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CampaignTrainingOpenTimeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CampaignTrainingOpenTimeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignTrainingOpenTimeData<'bldr>> {
        let mut builder = clz_Torappu_CampaignTrainingOpenTimeDataBuilder::new(_fbb);
        builder.add_endTs(args.endTs);
        builder.add_startTs(args.startTs);
        if let Some(x) = args.stages {
            builder.add_stages(x);
        }
        if let Some(x) = args.groupId {
            builder.add_groupId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CampaignTrainingOpenTimeDataT {
        let groupId = self.groupId().map(|x| x.to_string());
        let stages = self
            .stages()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let startTs = self.startTs();
        let endTs = self.endTs();
        clz_Torappu_CampaignTrainingOpenTimeDataT {
            groupId,
            stages,
            startTs,
            endTs,
        }
    }

    #[inline]
    pub fn groupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CampaignTrainingOpenTimeData::VT_GROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn stages(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_CampaignTrainingOpenTimeData::VT_STAGES, None)
        }
    }
    #[inline]
    pub fn startTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_CampaignTrainingOpenTimeData::VT_STARTTS,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn endTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_CampaignTrainingOpenTimeData::VT_ENDTS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CampaignTrainingOpenTimeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("groupId", Self::VT_GROUPID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("stages", Self::VT_STAGES, false)?
            .visit_field::<i64>("startTs", Self::VT_STARTTS, false)?
            .visit_field::<i64>("endTs", Self::VT_ENDTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CampaignTrainingOpenTimeDataArgs<'a> {
    pub groupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stages: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub startTs: i64,
    pub endTs: i64,
}
impl<'a> Default for clz_Torappu_CampaignTrainingOpenTimeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CampaignTrainingOpenTimeDataArgs {
            groupId: None,
            stages: None,
            startTs: 0,
            endTs: 0,
        }
    }
}

impl Serialize for clz_Torappu_CampaignTrainingOpenTimeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CampaignTrainingOpenTimeData", 4)?;
        if let Some(f) = self.groupId() {
            s.serialize_field("groupId", &f)?;
        } else {
            s.skip_field("groupId")?;
        }
        if let Some(f) = self.stages() {
            s.serialize_field("stages", &f)?;
        } else {
            s.skip_field("stages")?;
        }
        s.serialize_field("startTs", &self.startTs())?;
        s.serialize_field("endTs", &self.endTs())?;
        s.end()
    }
}

pub struct clz_Torappu_CampaignTrainingOpenTimeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CampaignTrainingOpenTimeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_groupId(&mut self, groupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignTrainingOpenTimeData::VT_GROUPID,
            groupId,
        );
    }
    #[inline]
    pub fn add_stages(
        &mut self,
        stages: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignTrainingOpenTimeData::VT_STAGES,
            stages,
        );
    }
    #[inline]
    pub fn add_startTs(&mut self, startTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_CampaignTrainingOpenTimeData::VT_STARTTS,
            startTs,
            0,
        );
    }
    #[inline]
    pub fn add_endTs(&mut self, endTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_CampaignTrainingOpenTimeData::VT_ENDTS, endTs, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CampaignTrainingOpenTimeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CampaignTrainingOpenTimeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CampaignTrainingOpenTimeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CampaignTrainingOpenTimeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CampaignTrainingOpenTimeData");
        ds.field("groupId", &self.groupId());
        ds.field("stages", &self.stages());
        ds.field("startTs", &self.startTs());
        ds.field("endTs", &self.endTs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CampaignTrainingOpenTimeDataT {
    pub groupId: Option<String>,
    pub stages: Option<Vec<String>>,
    pub startTs: i64,
    pub endTs: i64,
}
impl Default for clz_Torappu_CampaignTrainingOpenTimeDataT {
    fn default() -> Self {
        Self {
            groupId: None,
            stages: None,
            startTs: 0,
            endTs: 0,
        }
    }
}
impl clz_Torappu_CampaignTrainingOpenTimeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignTrainingOpenTimeData<'b>> {
        let groupId = self.groupId.as_ref().map(|x| _fbb.create_string(x));
        let stages = self.stages.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let startTs = self.startTs;
        let endTs = self.endTs;
        clz_Torappu_CampaignTrainingOpenTimeData::create(
            _fbb,
            &clz_Torappu_CampaignTrainingOpenTimeDataArgs {
                groupId,
                stages,
                startTs,
                endTs,
            },
        )
    }
}
pub enum clz_Torappu_CampaignTrainingAllOpenTimeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CampaignTrainingAllOpenTimeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CampaignTrainingAllOpenTimeData<'a> {
    type Inner = clz_Torappu_CampaignTrainingAllOpenTimeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CampaignTrainingAllOpenTimeData<'a> {
    pub const VT_GROUPID: flatbuffers::VOffsetT = 4;
    pub const VT_STARTTS: flatbuffers::VOffsetT = 6;
    pub const VT_ENDTS: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CampaignTrainingAllOpenTimeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CampaignTrainingAllOpenTimeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignTrainingAllOpenTimeData<'bldr>> {
        let mut builder = clz_Torappu_CampaignTrainingAllOpenTimeDataBuilder::new(_fbb);
        builder.add_endTs(args.endTs);
        builder.add_startTs(args.startTs);
        if let Some(x) = args.groupId {
            builder.add_groupId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CampaignTrainingAllOpenTimeDataT {
        let groupId = self.groupId().map(|x| x.to_string());
        let startTs = self.startTs();
        let endTs = self.endTs();
        clz_Torappu_CampaignTrainingAllOpenTimeDataT {
            groupId,
            startTs,
            endTs,
        }
    }

    #[inline]
    pub fn groupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CampaignTrainingAllOpenTimeData::VT_GROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn startTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_CampaignTrainingAllOpenTimeData::VT_STARTTS,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn endTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_CampaignTrainingAllOpenTimeData::VT_ENDTS,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CampaignTrainingAllOpenTimeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("groupId", Self::VT_GROUPID, false)?
            .visit_field::<i64>("startTs", Self::VT_STARTTS, false)?
            .visit_field::<i64>("endTs", Self::VT_ENDTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CampaignTrainingAllOpenTimeDataArgs<'a> {
    pub groupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub startTs: i64,
    pub endTs: i64,
}
impl<'a> Default for clz_Torappu_CampaignTrainingAllOpenTimeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CampaignTrainingAllOpenTimeDataArgs {
            groupId: None,
            startTs: 0,
            endTs: 0,
        }
    }
}

impl Serialize for clz_Torappu_CampaignTrainingAllOpenTimeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_CampaignTrainingAllOpenTimeData", 3)?;
        if let Some(f) = self.groupId() {
            s.serialize_field("groupId", &f)?;
        } else {
            s.skip_field("groupId")?;
        }
        s.serialize_field("startTs", &self.startTs())?;
        s.serialize_field("endTs", &self.endTs())?;
        s.end()
    }
}

pub struct clz_Torappu_CampaignTrainingAllOpenTimeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CampaignTrainingAllOpenTimeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_groupId(&mut self, groupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignTrainingAllOpenTimeData::VT_GROUPID,
            groupId,
        );
    }
    #[inline]
    pub fn add_startTs(&mut self, startTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_CampaignTrainingAllOpenTimeData::VT_STARTTS,
            startTs,
            0,
        );
    }
    #[inline]
    pub fn add_endTs(&mut self, endTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_CampaignTrainingAllOpenTimeData::VT_ENDTS,
            endTs,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CampaignTrainingAllOpenTimeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CampaignTrainingAllOpenTimeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CampaignTrainingAllOpenTimeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CampaignTrainingAllOpenTimeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CampaignTrainingAllOpenTimeData");
        ds.field("groupId", &self.groupId());
        ds.field("startTs", &self.startTs());
        ds.field("endTs", &self.endTs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CampaignTrainingAllOpenTimeDataT {
    pub groupId: Option<String>,
    pub startTs: i64,
    pub endTs: i64,
}
impl Default for clz_Torappu_CampaignTrainingAllOpenTimeDataT {
    fn default() -> Self {
        Self {
            groupId: None,
            startTs: 0,
            endTs: 0,
        }
    }
}
impl clz_Torappu_CampaignTrainingAllOpenTimeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignTrainingAllOpenTimeData<'b>> {
        let groupId = self.groupId.as_ref().map(|x| _fbb.create_string(x));
        let startTs = self.startTs;
        let endTs = self.endTs;
        clz_Torappu_CampaignTrainingAllOpenTimeData::create(
            _fbb,
            &clz_Torappu_CampaignTrainingAllOpenTimeDataArgs {
                groupId,
                startTs,
                endTs,
            },
        )
    }
}
pub enum clz_Torappu_CampaignTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CampaignTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CampaignTable<'a> {
    type Inner = clz_Torappu_CampaignTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CampaignTable<'a> {
    pub const VT_CAMPAIGNS: flatbuffers::VOffsetT = 4;
    pub const VT_CAMPAIGNGROUPS: flatbuffers::VOffsetT = 6;
    pub const VT_CAMPAIGNREGIONS: flatbuffers::VOffsetT = 8;
    pub const VT_CAMPAIGNZONES: flatbuffers::VOffsetT = 10;
    pub const VT_CAMPAIGNMISSIONS: flatbuffers::VOffsetT = 12;
    pub const VT_STAGEINDEXINZONEMAP: flatbuffers::VOffsetT = 14;
    pub const VT_CAMPAIGNCONSTTABLE: flatbuffers::VOffsetT = 16;
    pub const VT_CAMPAIGNROTATESTAGEOPENTIMES: flatbuffers::VOffsetT = 18;
    pub const VT_CAMPAIGNTRAININGSTAGEOPENTIMES: flatbuffers::VOffsetT = 20;
    pub const VT_CAMPAIGNTRAININGALLOPENTIMES: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CampaignTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CampaignTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignTable<'bldr>> {
        let mut builder = clz_Torappu_CampaignTableBuilder::new(_fbb);
        if let Some(x) = args.campaignTrainingAllOpenTimes {
            builder.add_campaignTrainingAllOpenTimes(x);
        }
        if let Some(x) = args.campaignTrainingStageOpenTimes {
            builder.add_campaignTrainingStageOpenTimes(x);
        }
        if let Some(x) = args.campaignRotateStageOpenTimes {
            builder.add_campaignRotateStageOpenTimes(x);
        }
        if let Some(x) = args.campaignConstTable {
            builder.add_campaignConstTable(x);
        }
        if let Some(x) = args.stageIndexInZoneMap {
            builder.add_stageIndexInZoneMap(x);
        }
        if let Some(x) = args.campaignMissions {
            builder.add_campaignMissions(x);
        }
        if let Some(x) = args.campaignZones {
            builder.add_campaignZones(x);
        }
        if let Some(x) = args.campaignRegions {
            builder.add_campaignRegions(x);
        }
        if let Some(x) = args.campaignGroups {
            builder.add_campaignGroups(x);
        }
        if let Some(x) = args.campaigns {
            builder.add_campaigns(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CampaignTableT {
        let campaigns = self
            .campaigns()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let campaignGroups = self
            .campaignGroups()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let campaignRegions = self
            .campaignRegions()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let campaignZones = self
            .campaignZones()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let campaignMissions = self
            .campaignMissions()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let stageIndexInZoneMap = self
            .stageIndexInZoneMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let campaignConstTable = self.campaignConstTable().map(|x| Box::new(x.unpack()));
        let campaignRotateStageOpenTimes = self
            .campaignRotateStageOpenTimes()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let campaignTrainingStageOpenTimes = self
            .campaignTrainingStageOpenTimes()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let campaignTrainingAllOpenTimes = self
            .campaignTrainingAllOpenTimes()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_CampaignTableT {
            campaigns,
            campaignGroups,
            campaignRegions,
            campaignZones,
            campaignMissions,
            stageIndexInZoneMap,
            campaignConstTable,
            campaignRotateStageOpenTimes,
            campaignTrainingStageOpenTimes,
            campaignTrainingAllOpenTimes,
        }
    }

    #[inline]
    pub fn campaigns(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignData>,
                >,
            >>(clz_Torappu_CampaignTable::VT_CAMPAIGNS, None)
        }
    }
    #[inline]
    pub fn campaignGroups(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignGroupData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignGroupData>,
                >,
            >>(clz_Torappu_CampaignTable::VT_CAMPAIGNGROUPS, None)
        }
    }
    #[inline]
    pub fn campaignRegions(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignRegionData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignRegionData>,
                >,
            >>(clz_Torappu_CampaignTable::VT_CAMPAIGNREGIONS, None)
        }
    }
    #[inline]
    pub fn campaignZones(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignZoneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignZoneData>,
                >,
            >>(clz_Torappu_CampaignTable::VT_CAMPAIGNZONES, None)
        }
    }
    #[inline]
    pub fn campaignMissions(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignMissionData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignMissionData>,
                >,
            >>(clz_Torappu_CampaignTable::VT_CAMPAIGNMISSIONS, None)
        }
    }
    #[inline]
    pub fn stageIndexInZoneMap(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>(clz_Torappu_CampaignTable::VT_STAGEINDEXINZONEMAP, None)
        }
    }
    #[inline]
    pub fn campaignConstTable(&self) -> Option<clz_Torappu_CampaignConstTable<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CampaignConstTable>>(
                    clz_Torappu_CampaignTable::VT_CAMPAIGNCONSTTABLE,
                    None,
                )
        }
    }
    #[inline]
    pub fn campaignRotateStageOpenTimes(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_CampaignRotateOpenTimeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CampaignRotateOpenTimeData>,
                >,
            >>(
                clz_Torappu_CampaignTable::VT_CAMPAIGNROTATESTAGEOPENTIMES,
                None,
            )
        }
    }
    #[inline]
    pub fn campaignTrainingStageOpenTimes(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_CampaignTrainingOpenTimeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CampaignTrainingOpenTimeData>,
                >,
            >>(
                clz_Torappu_CampaignTable::VT_CAMPAIGNTRAININGSTAGEOPENTIMES,
                None,
            )
        }
    }
    #[inline]
    pub fn campaignTrainingAllOpenTimes(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_CampaignTrainingAllOpenTimeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CampaignTrainingAllOpenTimeData>,
                >,
            >>(
                clz_Torappu_CampaignTable::VT_CAMPAIGNTRAININGALLOPENTIMES,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CampaignTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignData>,
                >,
            >>("campaigns", Self::VT_CAMPAIGNS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignGroupData>,
                >,
            >>("campaignGroups", Self::VT_CAMPAIGNGROUPS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignRegionData>,
                >,
            >>("campaignRegions", Self::VT_CAMPAIGNREGIONS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignZoneData>,
                >,
            >>("campaignZones", Self::VT_CAMPAIGNZONES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignMissionData>,
                >,
            >>("campaignMissions", Self::VT_CAMPAIGNMISSIONS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>("stageIndexInZoneMap", Self::VT_STAGEINDEXINZONEMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CampaignConstTable>>(
                "campaignConstTable",
                Self::VT_CAMPAIGNCONSTTABLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CampaignRotateOpenTimeData>,
                >,
            >>(
                "campaignRotateStageOpenTimes",
                Self::VT_CAMPAIGNROTATESTAGEOPENTIMES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CampaignTrainingOpenTimeData>,
                >,
            >>(
                "campaignTrainingStageOpenTimes",
                Self::VT_CAMPAIGNTRAININGSTAGEOPENTIMES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CampaignTrainingAllOpenTimeData>,
                >,
            >>(
                "campaignTrainingAllOpenTimes",
                Self::VT_CAMPAIGNTRAININGALLOPENTIMES,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CampaignTableArgs<'a> {
    pub campaigns: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignData<'a>>,
            >,
        >,
    >,
    pub campaignGroups: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignGroupData<'a>>,
            >,
        >,
    >,
    pub campaignRegions: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignRegionData<'a>>,
            >,
        >,
    >,
    pub campaignZones: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignZoneData<'a>>,
            >,
        >,
    >,
    pub campaignMissions: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignMissionData<'a>>,
            >,
        >,
    >,
    pub stageIndexInZoneMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>,
        >,
    >,
    pub campaignConstTable: Option<flatbuffers::WIPOffset<clz_Torappu_CampaignConstTable<'a>>>,
    pub campaignRotateStageOpenTimes: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_CampaignRotateOpenTimeData<'a>>,
            >,
        >,
    >,
    pub campaignTrainingStageOpenTimes: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_CampaignTrainingOpenTimeData<'a>>,
            >,
        >,
    >,
    pub campaignTrainingAllOpenTimes: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_CampaignTrainingAllOpenTimeData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_CampaignTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CampaignTableArgs {
            campaigns: None,
            campaignGroups: None,
            campaignRegions: None,
            campaignZones: None,
            campaignMissions: None,
            stageIndexInZoneMap: None,
            campaignConstTable: None,
            campaignRotateStageOpenTimes: None,
            campaignTrainingStageOpenTimes: None,
            campaignTrainingAllOpenTimes: None,
        }
    }
}

impl Serialize for clz_Torappu_CampaignTable<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CampaignTable", 10)?;
        if let Some(f) = self.campaigns() {
            s.serialize_field("campaigns", &f)?;
        } else {
            s.skip_field("campaigns")?;
        }
        if let Some(f) = self.campaignGroups() {
            s.serialize_field("campaignGroups", &f)?;
        } else {
            s.skip_field("campaignGroups")?;
        }
        if let Some(f) = self.campaignRegions() {
            s.serialize_field("campaignRegions", &f)?;
        } else {
            s.skip_field("campaignRegions")?;
        }
        if let Some(f) = self.campaignZones() {
            s.serialize_field("campaignZones", &f)?;
        } else {
            s.skip_field("campaignZones")?;
        }
        if let Some(f) = self.campaignMissions() {
            s.serialize_field("campaignMissions", &f)?;
        } else {
            s.skip_field("campaignMissions")?;
        }
        if let Some(f) = self.stageIndexInZoneMap() {
            s.serialize_field("stageIndexInZoneMap", &f)?;
        } else {
            s.skip_field("stageIndexInZoneMap")?;
        }
        if let Some(f) = self.campaignConstTable() {
            s.serialize_field("campaignConstTable", &f)?;
        } else {
            s.skip_field("campaignConstTable")?;
        }
        if let Some(f) = self.campaignRotateStageOpenTimes() {
            s.serialize_field("campaignRotateStageOpenTimes", &f)?;
        } else {
            s.skip_field("campaignRotateStageOpenTimes")?;
        }
        if let Some(f) = self.campaignTrainingStageOpenTimes() {
            s.serialize_field("campaignTrainingStageOpenTimes", &f)?;
        } else {
            s.skip_field("campaignTrainingStageOpenTimes")?;
        }
        if let Some(f) = self.campaignTrainingAllOpenTimes() {
            s.serialize_field("campaignTrainingAllOpenTimes", &f)?;
        } else {
            s.skip_field("campaignTrainingAllOpenTimes")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CampaignTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_CampaignTableBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_campaigns(
        &mut self,
        campaigns: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignTable::VT_CAMPAIGNS,
            campaigns,
        );
    }
    #[inline]
    pub fn add_campaignGroups(
        &mut self,
        campaignGroups: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignGroupData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignTable::VT_CAMPAIGNGROUPS,
            campaignGroups,
        );
    }
    #[inline]
    pub fn add_campaignRegions(
        &mut self,
        campaignRegions: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignRegionData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignTable::VT_CAMPAIGNREGIONS,
            campaignRegions,
        );
    }
    #[inline]
    pub fn add_campaignZones(
        &mut self,
        campaignZones: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignZoneData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignTable::VT_CAMPAIGNZONES,
            campaignZones,
        );
    }
    #[inline]
    pub fn add_campaignMissions(
        &mut self,
        campaignMissions: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CampaignMissionData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignTable::VT_CAMPAIGNMISSIONS,
            campaignMissions,
        );
    }
    #[inline]
    pub fn add_stageIndexInZoneMap(
        &mut self,
        stageIndexInZoneMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__int<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignTable::VT_STAGEINDEXINZONEMAP,
            stageIndexInZoneMap,
        );
    }
    #[inline]
    pub fn add_campaignConstTable(
        &mut self,
        campaignConstTable: flatbuffers::WIPOffset<clz_Torappu_CampaignConstTable<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CampaignConstTable>>(
                clz_Torappu_CampaignTable::VT_CAMPAIGNCONSTTABLE,
                campaignConstTable,
            );
    }
    #[inline]
    pub fn add_campaignRotateStageOpenTimes(
        &mut self,
        campaignRotateStageOpenTimes: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CampaignRotateOpenTimeData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignTable::VT_CAMPAIGNROTATESTAGEOPENTIMES,
            campaignRotateStageOpenTimes,
        );
    }
    #[inline]
    pub fn add_campaignTrainingStageOpenTimes(
        &mut self,
        campaignTrainingStageOpenTimes: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CampaignTrainingOpenTimeData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignTable::VT_CAMPAIGNTRAININGSTAGEOPENTIMES,
            campaignTrainingStageOpenTimes,
        );
    }
    #[inline]
    pub fn add_campaignTrainingAllOpenTimes(
        &mut self,
        campaignTrainingAllOpenTimes: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CampaignTrainingAllOpenTimeData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CampaignTable::VT_CAMPAIGNTRAININGALLOPENTIMES,
            campaignTrainingAllOpenTimes,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CampaignTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CampaignTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CampaignTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CampaignTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CampaignTable");
        ds.field("campaigns", &self.campaigns());
        ds.field("campaignGroups", &self.campaignGroups());
        ds.field("campaignRegions", &self.campaignRegions());
        ds.field("campaignZones", &self.campaignZones());
        ds.field("campaignMissions", &self.campaignMissions());
        ds.field("stageIndexInZoneMap", &self.stageIndexInZoneMap());
        ds.field("campaignConstTable", &self.campaignConstTable());
        ds.field(
            "campaignRotateStageOpenTimes",
            &self.campaignRotateStageOpenTimes(),
        );
        ds.field(
            "campaignTrainingStageOpenTimes",
            &self.campaignTrainingStageOpenTimes(),
        );
        ds.field(
            "campaignTrainingAllOpenTimes",
            &self.campaignTrainingAllOpenTimes(),
        );
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CampaignTableT {
    pub campaigns: Option<Vec<dict__string__clz_Torappu_CampaignDataT>>,
    pub campaignGroups: Option<Vec<dict__string__clz_Torappu_CampaignGroupDataT>>,
    pub campaignRegions: Option<Vec<dict__string__clz_Torappu_CampaignRegionDataT>>,
    pub campaignZones: Option<Vec<dict__string__clz_Torappu_CampaignZoneDataT>>,
    pub campaignMissions: Option<Vec<dict__string__clz_Torappu_CampaignMissionDataT>>,
    pub stageIndexInZoneMap: Option<Vec<dict__string__intT>>,
    pub campaignConstTable: Option<Box<clz_Torappu_CampaignConstTableT>>,
    pub campaignRotateStageOpenTimes: Option<Vec<clz_Torappu_CampaignRotateOpenTimeDataT>>,
    pub campaignTrainingStageOpenTimes: Option<Vec<clz_Torappu_CampaignTrainingOpenTimeDataT>>,
    pub campaignTrainingAllOpenTimes: Option<Vec<clz_Torappu_CampaignTrainingAllOpenTimeDataT>>,
}
impl Default for clz_Torappu_CampaignTableT {
    fn default() -> Self {
        Self {
            campaigns: None,
            campaignGroups: None,
            campaignRegions: None,
            campaignZones: None,
            campaignMissions: None,
            stageIndexInZoneMap: None,
            campaignConstTable: None,
            campaignRotateStageOpenTimes: None,
            campaignTrainingStageOpenTimes: None,
            campaignTrainingAllOpenTimes: None,
        }
    }
}
impl clz_Torappu_CampaignTableT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CampaignTable<'b>> {
        let campaigns = self.campaigns.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let campaignGroups = self.campaignGroups.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let campaignRegions = self.campaignRegions.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let campaignZones = self.campaignZones.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let campaignMissions = self.campaignMissions.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let stageIndexInZoneMap = self.stageIndexInZoneMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let campaignConstTable = self.campaignConstTable.as_ref().map(|x| x.pack(_fbb));
        let campaignRotateStageOpenTimes = self.campaignRotateStageOpenTimes.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let campaignTrainingStageOpenTimes =
            self.campaignTrainingStageOpenTimes.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
        let campaignTrainingAllOpenTimes = self.campaignTrainingAllOpenTimes.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_CampaignTable::create(
            _fbb,
            &clz_Torappu_CampaignTableArgs {
                campaigns,
                campaignGroups,
                campaignRegions,
                campaignZones,
                campaignMissions,
                stageIndexInZoneMap,
                campaignConstTable,
                campaignRotateStageOpenTimes,
                campaignTrainingStageOpenTimes,
                campaignTrainingAllOpenTimes,
            },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_CampaignTable`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_campaign_table_unchecked`.
pub fn root_as_clz_torappu_campaign_table(
    buf: &[u8],
) -> Result<clz_Torappu_CampaignTable<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_CampaignTable>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_CampaignTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_campaign_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_campaign_table(
    buf: &[u8],
) -> Result<clz_Torappu_CampaignTable<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_CampaignTable>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_CampaignTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_campaign_table_unchecked`.
pub fn root_as_clz_torappu_campaign_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_CampaignTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_CampaignTable<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_CampaignTable` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_campaign_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_campaign_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_CampaignTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_CampaignTable<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_CampaignTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_CampaignTable`.
pub unsafe fn root_as_clz_torappu_campaign_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_CampaignTable<'_> {
    unsafe { flatbuffers::root_unchecked::<clz_Torappu_CampaignTable>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_CampaignTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_CampaignTable`.
pub unsafe fn size_prefixed_root_as_clz_torappu_campaign_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_CampaignTable<'_> {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_CampaignTable>(buf) }
}
#[inline]
pub fn finish_clz_torappu_campaign_table_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_CampaignTable<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_campaign_table_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_CampaignTable<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
