// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BATTLE_COOPERATE_END_TILE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BATTLE_COOPERATE_END_TILE_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BATTLE_COOPERATE_END_TILE_TYPE:
    [enum__Torappu_Battle_Cooperate_EndTileType; 4] = [
    enum__Torappu_Battle_Cooperate_EndTileType::NONE,
    enum__Torappu_Battle_Cooperate_EndTileType::MY_SIDE,
    enum__Torappu_Battle_Cooperate_EndTileType::MATE_SIDE,
    enum__Torappu_Battle_Cooperate_EndTileType::SHARED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_Battle_Cooperate_EndTileType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_Battle_Cooperate_EndTileType {
    pub const NONE: Self = Self(0);
    pub const MY_SIDE: Self = Self(1);
    pub const MATE_SIDE: Self = Self(2);
    pub const SHARED: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::MY_SIDE, Self::MATE_SIDE, Self::SHARED];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MY_SIDE => Some("MY_SIDE"),
            Self::MATE_SIDE => Some("MATE_SIDE"),
            Self::SHARED => Some("SHARED"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_Battle_Cooperate_EndTileType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_Battle_Cooperate_EndTileType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_Battle_Cooperate_EndTileType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_Battle_Cooperate_EndTileType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_Battle_Cooperate_EndTileType {
    type Output = enum__Torappu_Battle_Cooperate_EndTileType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_Battle_Cooperate_EndTileType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_Battle_Cooperate_EndTileType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_Battle_Cooperate_EndTileType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BATTLE_COOPERATE_LASTROUNDRESULT: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BATTLE_COOPERATE_LASTROUNDRESULT: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BATTLE_COOPERATE_LASTROUNDRESULT:
    [enum__Torappu_Battle_Cooperate_LASTROUNDRESULT; 2] = [
    enum__Torappu_Battle_Cooperate_LASTROUNDRESULT::GOAL,
    enum__Torappu_Battle_Cooperate_LASTROUNDRESULT::LOST,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_Battle_Cooperate_LASTROUNDRESULT(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_Battle_Cooperate_LASTROUNDRESULT {
    pub const GOAL: Self = Self(0);
    pub const LOST: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::GOAL, Self::LOST];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::GOAL => Some("GOAL"),
            Self::LOST => Some("LOST"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_Battle_Cooperate_LASTROUNDRESULT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_Battle_Cooperate_LASTROUNDRESULT {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_Battle_Cooperate_LASTROUNDRESULT",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_Battle_Cooperate_LASTROUNDRESULT {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_Battle_Cooperate_LASTROUNDRESULT {
    type Output = enum__Torappu_Battle_Cooperate_LASTROUNDRESULT;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_Battle_Cooperate_LASTROUNDRESULT {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_Battle_Cooperate_LASTROUNDRESULT {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_Battle_Cooperate_LASTROUNDRESULT {}
pub enum clz_Torappu_Battle_Cooperate_CooperateEndTileInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'a> {
    type Inner = clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Battle_Cooperate_CooperateEndTileInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Battle_Cooperate_CooperateEndTileInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'bldr>> {
        let mut builder = clz_Torappu_Battle_Cooperate_CooperateEndTileInfoBuilder::new(_fbb);
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Battle_Cooperate_CooperateEndTileInfoT {
        let name = self.name().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        clz_Torappu_Battle_Cooperate_CooperateEndTileInfoT { name, description }
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Battle_Cooperate_CooperateEndTileInfo::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Battle_Cooperate_CooperateEndTileInfo::VT_DESCRIPTION,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Battle_Cooperate_CooperateEndTileInfoArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Battle_Cooperate_CooperateEndTileInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Battle_Cooperate_CooperateEndTileInfoArgs {
            name: None,
            description: None,
        }
    }
}

impl Serialize for clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_Battle_Cooperate_CooperateEndTileInfo", 2)?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Battle_Cooperate_CooperateEndTileInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Battle_Cooperate_CooperateEndTileInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Battle_Cooperate_CooperateEndTileInfo::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Battle_Cooperate_CooperateEndTileInfo::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Battle_Cooperate_CooperateEndTileInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Battle_Cooperate_CooperateEndTileInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Battle_Cooperate_CooperateEndTileInfo");
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Battle_Cooperate_CooperateEndTileInfoT {
    pub name: Option<String>,
    pub description: Option<String>,
}
impl Default for clz_Torappu_Battle_Cooperate_CooperateEndTileInfoT {
    fn default() -> Self {
        Self {
            name: None,
            description: None,
        }
    }
}
impl clz_Torappu_Battle_Cooperate_CooperateEndTileInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'b>> {
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Battle_Cooperate_CooperateEndTileInfo::create(
            _fbb,
            &clz_Torappu_Battle_Cooperate_CooperateEndTileInfoArgs { name, description },
        )
    }
}
pub enum dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfoOffset
{}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<
    'a,
> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'a> {
  type Inner = dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'bldr>> {
    let mut builder = dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfoBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.add_key(args.key);
    builder.finish()
  }

  pub fn unpack(&self) -> dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfoT {
    let key = self.key();
    let value = self.value().map(|x| {
      Box::new(x.unpack())
    });
    dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfoT {
      key,
      value,
    }
  }

  #[inline]
  pub fn key(&self) -> enum__Torappu_Battle_Cooperate_EndTileType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<enum__Torappu_Battle_Cooperate_EndTileType>(dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo::VT_KEY, Some(enum__Torappu_Battle_Cooperate_EndTileType::NONE)).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: enum__Torappu_Battle_Cooperate_EndTileType) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(&val)
  }
  #[inline]
  pub fn value(&self) -> Option<clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Cooperate_CooperateEndTileInfo>>(dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<enum__Torappu_Battle_Cooperate_EndTileType>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Cooperate_CooperateEndTileInfo>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfoArgs<
    'a,
> {
    pub key: enum__Torappu_Battle_Cooperate_EndTileType,
    pub value:
        Option<flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'a>>>,
}
impl<'a> Default for dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfoArgs {
      key: enum__Torappu_Battle_Cooperate_EndTileType::NONE,
      value: None,
    }
  }
}

impl Serialize for dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo", 2)?;
      s.serialize_field("key", &self.key())?;
      if let Some(f) = self.value() {
        s.serialize_field("value", &f)?;
      } else {
        s.skip_field("value")?;
      }
    s.end()
  }
}

pub struct dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: enum__Torappu_Battle_Cooperate_EndTileType) {
    self.fbb_.push_slot::<enum__Torappu_Battle_Cooperate_EndTileType>(dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo::VT_KEY, key, enum__Torappu_Battle_Cooperate_EndTileType::NONE);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateEndTileInfo>>(dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfoT
{
    pub key: enum__Torappu_Battle_Cooperate_EndTileType,
    pub value: Option<Box<clz_Torappu_Battle_Cooperate_CooperateEndTileInfoT>>,
}
impl Default for dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfoT {
  fn default() -> Self {
    Self {
      key: enum__Torappu_Battle_Cooperate_EndTileType::NONE,
      value: None,
    }
  }
}
impl dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfoT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'b>> {
    let key = self.key;
    let value = self.value.as_ref().map(|x|{
      x.pack(_fbb)
    });
    dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo::create(_fbb, &dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfoArgs{
      key,
      value,
    })
  }
}
pub enum clz_Torappu_Battle_Cooperate_CooperateAheadGoalDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Battle_Cooperate_CooperateAheadGoalData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Battle_Cooperate_CooperateAheadGoalData<'a> {
    type Inner = clz_Torappu_Battle_Cooperate_CooperateAheadGoalData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Battle_Cooperate_CooperateAheadGoalData<'a> {
    pub const VT_AHEADCNT: flatbuffers::VOffsetT = 4;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Battle_Cooperate_CooperateAheadGoalData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Battle_Cooperate_CooperateAheadGoalDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateAheadGoalData<'bldr>> {
        let mut builder = clz_Torappu_Battle_Cooperate_CooperateAheadGoalDataBuilder::new(_fbb);
        builder.add_level(args.level);
        builder.add_aheadCnt(args.aheadCnt);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Battle_Cooperate_CooperateAheadGoalDataT {
        let aheadCnt = self.aheadCnt();
        let level = self.level();
        clz_Torappu_Battle_Cooperate_CooperateAheadGoalDataT { aheadCnt, level }
    }

    #[inline]
    pub fn aheadCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_Battle_Cooperate_CooperateAheadGoalData::VT_AHEADCNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_Battle_Cooperate_CooperateAheadGoalData::VT_LEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Battle_Cooperate_CooperateAheadGoalData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("aheadCnt", Self::VT_AHEADCNT, false)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Battle_Cooperate_CooperateAheadGoalDataArgs {
    pub aheadCnt: i32,
    pub level: i32,
}
impl<'a> Default for clz_Torappu_Battle_Cooperate_CooperateAheadGoalDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Battle_Cooperate_CooperateAheadGoalDataArgs {
            aheadCnt: 0,
            level: 0,
        }
    }
}

impl Serialize for clz_Torappu_Battle_Cooperate_CooperateAheadGoalData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("clz_Torappu_Battle_Cooperate_CooperateAheadGoalData", 2)?;
        s.serialize_field("aheadCnt", &self.aheadCnt())?;
        s.serialize_field("level", &self.level())?;
        s.end()
    }
}

pub struct clz_Torappu_Battle_Cooperate_CooperateAheadGoalDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Battle_Cooperate_CooperateAheadGoalDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_aheadCnt(&mut self, aheadCnt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_Battle_Cooperate_CooperateAheadGoalData::VT_AHEADCNT,
            aheadCnt,
            0,
        );
    }
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_Battle_Cooperate_CooperateAheadGoalData::VT_LEVEL,
            level,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Battle_Cooperate_CooperateAheadGoalDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Battle_Cooperate_CooperateAheadGoalDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateAheadGoalData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Battle_Cooperate_CooperateAheadGoalData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Battle_Cooperate_CooperateAheadGoalData");
        ds.field("aheadCnt", &self.aheadCnt());
        ds.field("level", &self.level());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Battle_Cooperate_CooperateAheadGoalDataT {
    pub aheadCnt: i32,
    pub level: i32,
}
impl Default for clz_Torappu_Battle_Cooperate_CooperateAheadGoalDataT {
    fn default() -> Self {
        Self {
            aheadCnt: 0,
            level: 0,
        }
    }
}
impl clz_Torappu_Battle_Cooperate_CooperateAheadGoalDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateAheadGoalData<'b>> {
        let aheadCnt = self.aheadCnt;
        let level = self.level;
        clz_Torappu_Battle_Cooperate_CooperateAheadGoalData::create(
            _fbb,
            &clz_Torappu_Battle_Cooperate_CooperateAheadGoalDataArgs { aheadCnt, level },
        )
    }
}
pub enum dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__intOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int<'a> {
    type Inner = dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__intArgs,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int<'bldr>>
    {
        let mut builder =
            dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__intBuilder::new(_fbb);
        builder.add_value(args.value);
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__intT {
        let key = self.key();
        let value = self.value();
        dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__intT { key, value }
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_Battle_Cooperate_LASTROUNDRESULT {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_Battle_Cooperate_LASTROUNDRESULT>(
                    dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int::VT_KEY,
                    Some(enum__Torappu_Battle_Cooperate_LASTROUNDRESULT::GOAL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_Battle_Cooperate_LASTROUNDRESULT,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int::VT_VALUE,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_Battle_Cooperate_LASTROUNDRESULT>(
                "key",
                Self::VT_KEY,
                false,
            )?
            .visit_field::<i32>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__intArgs {
    pub key: enum__Torappu_Battle_Cooperate_LASTROUNDRESULT,
    pub value: i32,
}
impl<'a> Default for dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__intArgs {
    #[inline]
    fn default() -> Self {
        dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__intArgs {
            key: enum__Torappu_Battle_Cooperate_LASTROUNDRESULT::GOAL,
            value: 0,
        }
    }
}

impl Serialize for dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        s.serialize_field("value", &self.value())?;
        s.end()
    }
}

pub struct dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__intBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__intBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: enum__Torappu_Battle_Cooperate_LASTROUNDRESULT) {
        self.fbb_
            .push_slot::<enum__Torappu_Battle_Cooperate_LASTROUNDRESULT>(
                dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int::VT_KEY,
                key,
                enum__Torappu_Battle_Cooperate_LASTROUNDRESULT::GOAL,
            );
    }
    #[inline]
    pub fn add_value(&mut self, value: i32) {
        self.fbb_.push_slot::<i32>(
            dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int::VT_VALUE,
            value,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__intBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__intBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__intT {
    pub key: enum__Torappu_Battle_Cooperate_LASTROUNDRESULT,
    pub value: i32,
}
impl Default for dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__intT {
    fn default() -> Self {
        Self {
            key: enum__Torappu_Battle_Cooperate_LASTROUNDRESULT::GOAL,
            value: 0,
        }
    }
}
impl dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__intT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int<'b>> {
        let key = self.key;
        let value = self.value;
        dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int::create(
            _fbb,
            &dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__intArgs { key, value },
        )
    }
}
pub enum clz_Torappu_Battle_Cooperate_CooperateWaveWeightOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'a> {
    type Inner = clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'a> {
    pub const VT_WAVE: flatbuffers::VOffsetT = 4;
    pub const VT_WEIGHT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Battle_Cooperate_CooperateWaveWeight { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Battle_Cooperate_CooperateWaveWeightArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'bldr>> {
        let mut builder = clz_Torappu_Battle_Cooperate_CooperateWaveWeightBuilder::new(_fbb);
        builder.add_weight(args.weight);
        builder.add_wave(args.wave);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Battle_Cooperate_CooperateWaveWeightT {
        let wave = self.wave();
        let weight = self.weight();
        clz_Torappu_Battle_Cooperate_CooperateWaveWeightT { wave, weight }
    }

    #[inline]
    pub fn wave(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_Battle_Cooperate_CooperateWaveWeight::VT_WAVE,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn weight(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_Battle_Cooperate_CooperateWaveWeight::VT_WEIGHT,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("wave", Self::VT_WAVE, false)?
            .visit_field::<i32>("weight", Self::VT_WEIGHT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Battle_Cooperate_CooperateWaveWeightArgs {
    pub wave: i32,
    pub weight: i32,
}
impl<'a> Default for clz_Torappu_Battle_Cooperate_CooperateWaveWeightArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Battle_Cooperate_CooperateWaveWeightArgs { wave: 0, weight: 0 }
    }
}

impl Serialize for clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_Battle_Cooperate_CooperateWaveWeight", 2)?;
        s.serialize_field("wave", &self.wave())?;
        s.serialize_field("weight", &self.weight())?;
        s.end()
    }
}

pub struct clz_Torappu_Battle_Cooperate_CooperateWaveWeightBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Battle_Cooperate_CooperateWaveWeightBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_wave(&mut self, wave: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_Battle_Cooperate_CooperateWaveWeight::VT_WAVE,
            wave,
            0,
        );
    }
    #[inline]
    pub fn add_weight(&mut self, weight: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_Battle_Cooperate_CooperateWaveWeight::VT_WEIGHT,
            weight,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Battle_Cooperate_CooperateWaveWeightBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Battle_Cooperate_CooperateWaveWeightBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Battle_Cooperate_CooperateWaveWeight");
        ds.field("wave", &self.wave());
        ds.field("weight", &self.weight());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Battle_Cooperate_CooperateWaveWeightT {
    pub wave: i32,
    pub weight: i32,
}
impl Default for clz_Torappu_Battle_Cooperate_CooperateWaveWeightT {
    fn default() -> Self {
        Self { wave: 0, weight: 0 }
    }
}
impl clz_Torappu_Battle_Cooperate_CooperateWaveWeightT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'b>> {
        let wave = self.wave;
        let weight = self.weight;
        clz_Torappu_Battle_Cooperate_CooperateWaveWeight::create(
            _fbb,
            &clz_Torappu_Battle_Cooperate_CooperateWaveWeightArgs { wave, weight },
        )
    }
}
pub enum dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeightOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'a>
{
    type Inner = dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeightArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'bldr>,
    > {
        let mut builder =
            dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeightBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeightT {
        let key = self.key();
        let value = self.value().map(|x| x.iter().map(|t| t.unpack()).collect());
        dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeightT { key, value }
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight::VT_KEY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Cooperate_CooperateWaveWeight>,
                >,
            >>(
                dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Cooperate_CooperateWaveWeight>,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeightArgs<'a> {
    pub key: i32,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeightArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeightArgs {
            key: 0,
            value: None,
        }
    }
}

impl Serialize for dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeightBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeightBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_.push_slot::<i32>(
            dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight::VT_KEY,
            key,
            0,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeightBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeightBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeightT {
    pub key: i32,
    pub value: Option<Vec<clz_Torappu_Battle_Cooperate_CooperateWaveWeightT>>,
}
impl Default for dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeightT {
    fn default() -> Self {
        Self {
            key: 0,
            value: None,
        }
    }
}
impl dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeightT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'b>>
    {
        let key = self.key;
        let value = self.value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight::create(
            _fbb,
            &dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeightArgs { key, value },
        )
    }
}
pub enum clz_Torappu_Battle_Cooperate_CooperateTeamWeightOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Battle_Cooperate_CooperateTeamWeight<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Battle_Cooperate_CooperateTeamWeight<'a> {
    type Inner = clz_Torappu_Battle_Cooperate_CooperateTeamWeight<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Battle_Cooperate_CooperateTeamWeight<'a> {
    pub const VT_TEAMNAME: flatbuffers::VOffsetT = 4;
    pub const VT_WEIGHT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Battle_Cooperate_CooperateTeamWeight { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Battle_Cooperate_CooperateTeamWeightArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateTeamWeight<'bldr>> {
        let mut builder = clz_Torappu_Battle_Cooperate_CooperateTeamWeightBuilder::new(_fbb);
        builder.add_weight(args.weight);
        if let Some(x) = args.teamName {
            builder.add_teamName(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Battle_Cooperate_CooperateTeamWeightT {
        let teamName = self.teamName().map(|x| x.to_string());
        let weight = self.weight();
        clz_Torappu_Battle_Cooperate_CooperateTeamWeightT { teamName, weight }
    }

    #[inline]
    pub fn teamName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Battle_Cooperate_CooperateTeamWeight::VT_TEAMNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn weight(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_Battle_Cooperate_CooperateTeamWeight::VT_WEIGHT,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Battle_Cooperate_CooperateTeamWeight<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "teamName",
                Self::VT_TEAMNAME,
                false,
            )?
            .visit_field::<i32>("weight", Self::VT_WEIGHT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Battle_Cooperate_CooperateTeamWeightArgs<'a> {
    pub teamName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weight: i32,
}
impl<'a> Default for clz_Torappu_Battle_Cooperate_CooperateTeamWeightArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Battle_Cooperate_CooperateTeamWeightArgs {
            teamName: None,
            weight: 0,
        }
    }
}

impl Serialize for clz_Torappu_Battle_Cooperate_CooperateTeamWeight<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_Battle_Cooperate_CooperateTeamWeight", 2)?;
        if let Some(f) = self.teamName() {
            s.serialize_field("teamName", &f)?;
        } else {
            s.skip_field("teamName")?;
        }
        s.serialize_field("weight", &self.weight())?;
        s.end()
    }
}

pub struct clz_Torappu_Battle_Cooperate_CooperateTeamWeightBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Battle_Cooperate_CooperateTeamWeightBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_teamName(&mut self, teamName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Battle_Cooperate_CooperateTeamWeight::VT_TEAMNAME,
            teamName,
        );
    }
    #[inline]
    pub fn add_weight(&mut self, weight: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_Battle_Cooperate_CooperateTeamWeight::VT_WEIGHT,
            weight,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Battle_Cooperate_CooperateTeamWeightBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Battle_Cooperate_CooperateTeamWeightBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateTeamWeight<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Battle_Cooperate_CooperateTeamWeight<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Battle_Cooperate_CooperateTeamWeight");
        ds.field("teamName", &self.teamName());
        ds.field("weight", &self.weight());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Battle_Cooperate_CooperateTeamWeightT {
    pub teamName: Option<String>,
    pub weight: i32,
}
impl Default for clz_Torappu_Battle_Cooperate_CooperateTeamWeightT {
    fn default() -> Self {
        Self {
            teamName: None,
            weight: 0,
        }
    }
}
impl clz_Torappu_Battle_Cooperate_CooperateTeamWeightT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateTeamWeight<'b>> {
        let teamName = self.teamName.as_ref().map(|x| _fbb.create_string(x));
        let weight = self.weight;
        clz_Torappu_Battle_Cooperate_CooperateTeamWeight::create(
            _fbb,
            &clz_Torappu_Battle_Cooperate_CooperateTeamWeightArgs { teamName, weight },
        )
    }
}
pub enum clz_Torappu_Battle_Cooperate_CooperateTeamPlayerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'a> {
    type Inner = clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'a> {
    pub const VT_FORWARD: flatbuffers::VOffsetT = 4;
    pub const VT_GOALKEEPER: flatbuffers::VOffsetT = 6;
    pub const VT_MUSCLEMAN: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Battle_Cooperate_CooperateTeamPlayer { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Battle_Cooperate_CooperateTeamPlayerArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'bldr>> {
        let mut builder = clz_Torappu_Battle_Cooperate_CooperateTeamPlayerBuilder::new(_fbb);
        if let Some(x) = args.muscleman {
            builder.add_muscleman(x);
        }
        if let Some(x) = args.goalkeeper {
            builder.add_goalkeeper(x);
        }
        if let Some(x) = args.forward {
            builder.add_forward(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Battle_Cooperate_CooperateTeamPlayerT {
        let forward = self.forward().map(|x| x.to_string());
        let goalkeeper = self.goalkeeper().map(|x| x.to_string());
        let muscleman = self.muscleman().map(|x| x.to_string());
        clz_Torappu_Battle_Cooperate_CooperateTeamPlayerT {
            forward,
            goalkeeper,
            muscleman,
        }
    }

    #[inline]
    pub fn forward(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Battle_Cooperate_CooperateTeamPlayer::VT_FORWARD,
                None,
            )
        }
    }
    #[inline]
    pub fn goalkeeper(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Battle_Cooperate_CooperateTeamPlayer::VT_GOALKEEPER,
                None,
            )
        }
    }
    #[inline]
    pub fn muscleman(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Battle_Cooperate_CooperateTeamPlayer::VT_MUSCLEMAN,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("forward", Self::VT_FORWARD, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "goalkeeper",
                Self::VT_GOALKEEPER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "muscleman",
                Self::VT_MUSCLEMAN,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Battle_Cooperate_CooperateTeamPlayerArgs<'a> {
    pub forward: Option<flatbuffers::WIPOffset<&'a str>>,
    pub goalkeeper: Option<flatbuffers::WIPOffset<&'a str>>,
    pub muscleman: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Battle_Cooperate_CooperateTeamPlayerArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Battle_Cooperate_CooperateTeamPlayerArgs {
            forward: None,
            goalkeeper: None,
            muscleman: None,
        }
    }
}

impl Serialize for clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_Battle_Cooperate_CooperateTeamPlayer", 3)?;
        if let Some(f) = self.forward() {
            s.serialize_field("forward", &f)?;
        } else {
            s.skip_field("forward")?;
        }
        if let Some(f) = self.goalkeeper() {
            s.serialize_field("goalkeeper", &f)?;
        } else {
            s.skip_field("goalkeeper")?;
        }
        if let Some(f) = self.muscleman() {
            s.serialize_field("muscleman", &f)?;
        } else {
            s.skip_field("muscleman")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Battle_Cooperate_CooperateTeamPlayerBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Battle_Cooperate_CooperateTeamPlayerBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_forward(&mut self, forward: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Battle_Cooperate_CooperateTeamPlayer::VT_FORWARD,
            forward,
        );
    }
    #[inline]
    pub fn add_goalkeeper(&mut self, goalkeeper: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Battle_Cooperate_CooperateTeamPlayer::VT_GOALKEEPER,
            goalkeeper,
        );
    }
    #[inline]
    pub fn add_muscleman(&mut self, muscleman: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Battle_Cooperate_CooperateTeamPlayer::VT_MUSCLEMAN,
            muscleman,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Battle_Cooperate_CooperateTeamPlayerBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Battle_Cooperate_CooperateTeamPlayerBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Battle_Cooperate_CooperateTeamPlayer");
        ds.field("forward", &self.forward());
        ds.field("goalkeeper", &self.goalkeeper());
        ds.field("muscleman", &self.muscleman());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Battle_Cooperate_CooperateTeamPlayerT {
    pub forward: Option<String>,
    pub goalkeeper: Option<String>,
    pub muscleman: Option<String>,
}
impl Default for clz_Torappu_Battle_Cooperate_CooperateTeamPlayerT {
    fn default() -> Self {
        Self {
            forward: None,
            goalkeeper: None,
            muscleman: None,
        }
    }
}
impl clz_Torappu_Battle_Cooperate_CooperateTeamPlayerT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'b>> {
        let forward = self.forward.as_ref().map(|x| _fbb.create_string(x));
        let goalkeeper = self.goalkeeper.as_ref().map(|x| _fbb.create_string(x));
        let muscleman = self.muscleman.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Battle_Cooperate_CooperateTeamPlayer::create(
            _fbb,
            &clz_Torappu_Battle_Cooperate_CooperateTeamPlayerArgs {
                forward,
                goalkeeper,
                muscleman,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'a>
{
    type Inner = dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayerArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayerBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayerT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayerT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Cooperate_CooperateTeamPlayer>>(dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Cooperate_CooperateTeamPlayer>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayerArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayerArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayerArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayerBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayerBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateTeamPlayer>>(dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayerBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayerBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayerT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_Battle_Cooperate_CooperateTeamPlayerT>>,
}
impl Default for dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayerT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayerT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'b>>
    {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer::create(
            _fbb,
            &dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayerArgs { key, value },
        )
    }
}
pub enum dict__string__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__string<'a> {
    type Inner = dict__string__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__string<'bldr>> {
        let mut builder = dict__string__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__stringT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| x.to_string());
        dict__string__stringT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__string::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__string::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__stringArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for dict__string__stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__stringArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__string<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__string", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__stringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__stringBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__string::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__string::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, dict__string__string::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__stringT {
    pub key: String,
    pub value: Option<String>,
}
impl Default for dict__string__stringT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__string<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| _fbb.create_string(x));
        dict__string__string::create(_fbb, &dict__string__stringArgs { key, value })
    }
}
pub enum clz_Torappu_Battle_Cooperate_CooperateModeBattleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Battle_Cooperate_CooperateModeBattleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Battle_Cooperate_CooperateModeBattleData<'a> {
    type Inner = clz_Torappu_Battle_Cooperate_CooperateModeBattleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Battle_Cooperate_CooperateModeBattleData<'a> {
    pub const VT_COSTTRANSFERRED: flatbuffers::VOffsetT = 4;
    pub const VT_GETMAXMSGCNTINONEUPDATE: flatbuffers::VOffsetT = 6;
    pub const VT_ENDTILEINFO: flatbuffers::VOffsetT = 8;
    pub const VT_FOOTBALLAHEADGOALCNTFACTOR: flatbuffers::VOffsetT = 10;
    pub const VT_FOOTBALLHARDTYPEFACTOR: flatbuffers::VOffsetT = 12;
    pub const VT_FOOTBALLLASTROUNDRESULTFACTOR: flatbuffers::VOffsetT = 14;
    pub const VT_FOOTBALLLEVELOFWAVEFACTOR: flatbuffers::VOffsetT = 16;
    pub const VT_FOOTBALLTEAMWEIGHTS: flatbuffers::VOffsetT = 18;
    pub const VT_FOOTBALLTEAMPLAYERS: flatbuffers::VOffsetT = 20;
    pub const VT_FOOTBALLPLAYERSNAME: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Battle_Cooperate_CooperateModeBattleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Battle_Cooperate_CooperateModeBattleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateModeBattleData<'bldr>> {
        let mut builder = clz_Torappu_Battle_Cooperate_CooperateModeBattleDataBuilder::new(_fbb);
        if let Some(x) = args.footballPlayersName {
            builder.add_footballPlayersName(x);
        }
        if let Some(x) = args.footballTeamPlayers {
            builder.add_footballTeamPlayers(x);
        }
        if let Some(x) = args.footballTeamWeights {
            builder.add_footballTeamWeights(x);
        }
        if let Some(x) = args.footballLevelOfWaveFactor {
            builder.add_footballLevelOfWaveFactor(x);
        }
        if let Some(x) = args.footballLastRoundResultFactor {
            builder.add_footballLastRoundResultFactor(x);
        }
        builder.add_footballHardTypeFactor(args.footballHardTypeFactor);
        if let Some(x) = args.footballAheadGoalCntFactor {
            builder.add_footballAheadGoalCntFactor(x);
        }
        if let Some(x) = args.endTileInfo {
            builder.add_endTileInfo(x);
        }
        builder.add_getMaxMsgCntInOneUpdate(args.getMaxMsgCntInOneUpdate);
        builder.add_costTransferred(args.costTransferred);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Battle_Cooperate_CooperateModeBattleDataT {
        let costTransferred = self.costTransferred();
        let getMaxMsgCntInOneUpdate = self.getMaxMsgCntInOneUpdate();
        let endTileInfo = self
            .endTileInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let footballAheadGoalCntFactor = self
            .footballAheadGoalCntFactor()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let footballHardTypeFactor = self.footballHardTypeFactor();
        let footballLastRoundResultFactor = self
            .footballLastRoundResultFactor()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let footballLevelOfWaveFactor = self
            .footballLevelOfWaveFactor()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let footballTeamWeights = self
            .footballTeamWeights()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let footballTeamPlayers = self
            .footballTeamPlayers()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let footballPlayersName = self
            .footballPlayersName()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_Battle_Cooperate_CooperateModeBattleDataT {
            costTransferred,
            getMaxMsgCntInOneUpdate,
            endTileInfo,
            footballAheadGoalCntFactor,
            footballHardTypeFactor,
            footballLastRoundResultFactor,
            footballLevelOfWaveFactor,
            footballTeamWeights,
            footballTeamPlayers,
            footballPlayersName,
        }
    }

    #[inline]
    pub fn costTransferred(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_Battle_Cooperate_CooperateModeBattleData::VT_COSTTRANSFERRED,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn getMaxMsgCntInOneUpdate(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<i32>(clz_Torappu_Battle_Cooperate_CooperateModeBattleData::VT_GETMAXMSGCNTINONEUPDATE, Some(0)).unwrap()
        }
    }
    #[inline]
    pub fn endTileInfo(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'a>>>>{
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo>>>>(clz_Torappu_Battle_Cooperate_CooperateModeBattleData::VT_ENDTILEINFO, None)
        }
    }
    #[inline]
    pub fn footballAheadGoalCntFactor(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Cooperate_CooperateAheadGoalData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_Battle_Cooperate_CooperateAheadGoalData,
                    >,
                >,
            >>(
                clz_Torappu_Battle_Cooperate_CooperateModeBattleData::VT_FOOTBALLAHEADGOALCNTFACTOR,
                None,
            )
        }
    }
    #[inline]
    pub fn footballHardTypeFactor(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_Battle_Cooperate_CooperateModeBattleData::VT_FOOTBALLHARDTYPEFACTOR,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn footballLastRoundResultFactor(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int>>>>(clz_Torappu_Battle_Cooperate_CooperateModeBattleData::VT_FOOTBALLLASTROUNDRESULTFACTOR, None)
        }
    }
    #[inline]
    pub fn footballLevelOfWaveFactor(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight,
                    >,
                >,
            >>(
                clz_Torappu_Battle_Cooperate_CooperateModeBattleData::VT_FOOTBALLLEVELOFWAVEFACTOR,
                None,
            )
        }
    }
    #[inline]
    pub fn footballTeamWeights(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Cooperate_CooperateTeamWeight<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Cooperate_CooperateTeamWeight>,
                >,
            >>(
                clz_Torappu_Battle_Cooperate_CooperateModeBattleData::VT_FOOTBALLTEAMWEIGHTS,
                None,
            )
        }
    }
    #[inline]
    pub fn footballTeamPlayers(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer,
                    >,
                >,
            >>(
                clz_Torappu_Battle_Cooperate_CooperateModeBattleData::VT_FOOTBALLTEAMPLAYERS,
                None,
            )
        }
    }
    #[inline]
    pub fn footballPlayersName(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(
                clz_Torappu_Battle_Cooperate_CooperateModeBattleData::VT_FOOTBALLPLAYERSNAME,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Battle_Cooperate_CooperateModeBattleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<i32>("costTransferred", Self::VT_COSTTRANSFERRED, false)?
     .visit_field::<i32>("getMaxMsgCntInOneUpdate", Self::VT_GETMAXMSGCNTINONEUPDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo>>>>("endTileInfo", Self::VT_ENDTILEINFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Cooperate_CooperateAheadGoalData>>>>("footballAheadGoalCntFactor", Self::VT_FOOTBALLAHEADGOALCNTFACTOR, false)?
     .visit_field::<i32>("footballHardTypeFactor", Self::VT_FOOTBALLHARDTYPEFACTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int>>>>("footballLastRoundResultFactor", Self::VT_FOOTBALLLASTROUNDRESULTFACTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight>>>>("footballLevelOfWaveFactor", Self::VT_FOOTBALLLEVELOFWAVEFACTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Cooperate_CooperateTeamWeight>>>>("footballTeamWeights", Self::VT_FOOTBALLTEAMWEIGHTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer>>>>("footballTeamPlayers", Self::VT_FOOTBALLTEAMPLAYERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>>>("footballPlayersName", Self::VT_FOOTBALLPLAYERSNAME, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Battle_Cooperate_CooperateModeBattleDataArgs<'a> {
    pub costTransferred: i32,
    pub getMaxMsgCntInOneUpdate: i32,
    pub endTileInfo: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'a>>>>>,
    pub footballAheadGoalCntFactor: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Cooperate_CooperateAheadGoalData<'a>>>>>,
    pub footballHardTypeFactor: i32,
    pub footballLastRoundResultFactor: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int<'a>>>>>,
    pub footballLevelOfWaveFactor: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'a>>>>>,
    pub footballTeamWeights: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Cooperate_CooperateTeamWeight<'a>>>>>,
    pub footballTeamPlayers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'a>>>>>,
    pub footballPlayersName: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>>,
}
impl<'a> Default for clz_Torappu_Battle_Cooperate_CooperateModeBattleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Battle_Cooperate_CooperateModeBattleDataArgs {
            costTransferred: 0,
            getMaxMsgCntInOneUpdate: 0,
            endTileInfo: None,
            footballAheadGoalCntFactor: None,
            footballHardTypeFactor: 0,
            footballLastRoundResultFactor: None,
            footballLevelOfWaveFactor: None,
            footballTeamWeights: None,
            footballTeamPlayers: None,
            footballPlayersName: None,
        }
    }
}

impl Serialize for clz_Torappu_Battle_Cooperate_CooperateModeBattleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("clz_Torappu_Battle_Cooperate_CooperateModeBattleData", 10)?;
        s.serialize_field("costTransferred", &self.costTransferred())?;
        s.serialize_field("getMaxMsgCntInOneUpdate", &self.getMaxMsgCntInOneUpdate())?;
        if let Some(f) = self.endTileInfo() {
            s.serialize_field("endTileInfo", &f)?;
        } else {
            s.skip_field("endTileInfo")?;
        }
        if let Some(f) = self.footballAheadGoalCntFactor() {
            s.serialize_field("footballAheadGoalCntFactor", &f)?;
        } else {
            s.skip_field("footballAheadGoalCntFactor")?;
        }
        s.serialize_field("footballHardTypeFactor", &self.footballHardTypeFactor())?;
        if let Some(f) = self.footballLastRoundResultFactor() {
            s.serialize_field("footballLastRoundResultFactor", &f)?;
        } else {
            s.skip_field("footballLastRoundResultFactor")?;
        }
        if let Some(f) = self.footballLevelOfWaveFactor() {
            s.serialize_field("footballLevelOfWaveFactor", &f)?;
        } else {
            s.skip_field("footballLevelOfWaveFactor")?;
        }
        if let Some(f) = self.footballTeamWeights() {
            s.serialize_field("footballTeamWeights", &f)?;
        } else {
            s.skip_field("footballTeamWeights")?;
        }
        if let Some(f) = self.footballTeamPlayers() {
            s.serialize_field("footballTeamPlayers", &f)?;
        } else {
            s.skip_field("footballTeamPlayers")?;
        }
        if let Some(f) = self.footballPlayersName() {
            s.serialize_field("footballPlayersName", &f)?;
        } else {
            s.skip_field("footballPlayersName")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Battle_Cooperate_CooperateModeBattleDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Battle_Cooperate_CooperateModeBattleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_costTransferred(&mut self, costTransferred: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_Battle_Cooperate_CooperateModeBattleData::VT_COSTTRANSFERRED,
            costTransferred,
            0,
        );
    }
    #[inline]
    pub fn add_getMaxMsgCntInOneUpdate(&mut self, getMaxMsgCntInOneUpdate: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_Battle_Cooperate_CooperateModeBattleData::VT_GETMAXMSGCNTINONEUPDATE,
            getMaxMsgCntInOneUpdate,
            0,
        );
    }
    #[inline]
    pub fn add_endTileInfo(
        &mut self,
        endTileInfo: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfo<'b >>>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Battle_Cooperate_CooperateModeBattleData::VT_ENDTILEINFO,
            endTileInfo,
        );
    }
    #[inline]
    pub fn add_footballAheadGoalCntFactor(
        &mut self,
        footballAheadGoalCntFactor: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_Battle_Cooperate_CooperateAheadGoalData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Battle_Cooperate_CooperateModeBattleData::VT_FOOTBALLAHEADGOALCNTFACTOR,
            footballAheadGoalCntFactor,
        );
    }
    #[inline]
    pub fn add_footballHardTypeFactor(&mut self, footballHardTypeFactor: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_Battle_Cooperate_CooperateModeBattleData::VT_FOOTBALLHARDTYPEFACTOR,
            footballHardTypeFactor,
            0,
        );
    }
    #[inline]
    pub fn add_footballLastRoundResultFactor(
        &mut self,
        footballLastRoundResultFactor: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__int<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Battle_Cooperate_CooperateModeBattleData::VT_FOOTBALLLASTROUNDRESULTFACTOR,
            footballLastRoundResultFactor,
        );
    }
    #[inline]
    pub fn add_footballLevelOfWaveFactor(
        &mut self,
        footballLevelOfWaveFactor: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeight<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Battle_Cooperate_CooperateModeBattleData::VT_FOOTBALLLEVELOFWAVEFACTOR,
            footballLevelOfWaveFactor,
        );
    }
    #[inline]
    pub fn add_footballTeamWeights(
        &mut self,
        footballTeamWeights: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Battle_Cooperate_CooperateTeamWeight<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Battle_Cooperate_CooperateModeBattleData::VT_FOOTBALLTEAMWEIGHTS,
            footballTeamWeights,
        );
    }
    #[inline]
    pub fn add_footballTeamPlayers(
        &mut self,
        footballTeamPlayers: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayer<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Battle_Cooperate_CooperateModeBattleData::VT_FOOTBALLTEAMPLAYERS,
            footballTeamPlayers,
        );
    }
    #[inline]
    pub fn add_footballPlayersName(
        &mut self,
        footballPlayersName: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Battle_Cooperate_CooperateModeBattleData::VT_FOOTBALLPLAYERSNAME,
            footballPlayersName,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Battle_Cooperate_CooperateModeBattleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Battle_Cooperate_CooperateModeBattleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateModeBattleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Battle_Cooperate_CooperateModeBattleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Battle_Cooperate_CooperateModeBattleData");
        ds.field("costTransferred", &self.costTransferred());
        ds.field("getMaxMsgCntInOneUpdate", &self.getMaxMsgCntInOneUpdate());
        ds.field("endTileInfo", &self.endTileInfo());
        ds.field(
            "footballAheadGoalCntFactor",
            &self.footballAheadGoalCntFactor(),
        );
        ds.field("footballHardTypeFactor", &self.footballHardTypeFactor());
        ds.field(
            "footballLastRoundResultFactor",
            &self.footballLastRoundResultFactor(),
        );
        ds.field(
            "footballLevelOfWaveFactor",
            &self.footballLevelOfWaveFactor(),
        );
        ds.field("footballTeamWeights", &self.footballTeamWeights());
        ds.field("footballTeamPlayers", &self.footballTeamPlayers());
        ds.field("footballPlayersName", &self.footballPlayersName());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Battle_Cooperate_CooperateModeBattleDataT {
  pub costTransferred: i32,
  pub getMaxMsgCntInOneUpdate: i32,
  pub endTileInfo: Option<Vec<dict__enum__Torappu_Battle_Cooperate_EndTileType__clz_Torappu_Battle_Cooperate_CooperateEndTileInfoT>>,
  pub footballAheadGoalCntFactor: Option<Vec<clz_Torappu_Battle_Cooperate_CooperateAheadGoalDataT>>,
  pub footballHardTypeFactor: i32,
  pub footballLastRoundResultFactor: Option<Vec<dict__enum__Torappu_Battle_Cooperate_LASTROUNDRESULT__intT>>,
  pub footballLevelOfWaveFactor: Option<Vec<dict__int__list_clz_Torappu_Battle_Cooperate_CooperateWaveWeightT>>,
  pub footballTeamWeights: Option<Vec<clz_Torappu_Battle_Cooperate_CooperateTeamWeightT>>,
  pub footballTeamPlayers: Option<Vec<dict__string__clz_Torappu_Battle_Cooperate_CooperateTeamPlayerT>>,
  pub footballPlayersName: Option<Vec<dict__string__stringT>>,
}
impl Default for clz_Torappu_Battle_Cooperate_CooperateModeBattleDataT {
    fn default() -> Self {
        Self {
            costTransferred: 0,
            getMaxMsgCntInOneUpdate: 0,
            endTileInfo: None,
            footballAheadGoalCntFactor: None,
            footballHardTypeFactor: 0,
            footballLastRoundResultFactor: None,
            footballLevelOfWaveFactor: None,
            footballTeamWeights: None,
            footballTeamPlayers: None,
            footballPlayersName: None,
        }
    }
}
impl clz_Torappu_Battle_Cooperate_CooperateModeBattleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateModeBattleData<'b>> {
        let costTransferred = self.costTransferred;
        let getMaxMsgCntInOneUpdate = self.getMaxMsgCntInOneUpdate;
        let endTileInfo = self.endTileInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let footballAheadGoalCntFactor = self.footballAheadGoalCntFactor.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let footballHardTypeFactor = self.footballHardTypeFactor;
        let footballLastRoundResultFactor = self.footballLastRoundResultFactor.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let footballLevelOfWaveFactor = self.footballLevelOfWaveFactor.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let footballTeamWeights = self.footballTeamWeights.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let footballTeamPlayers = self.footballTeamPlayers.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let footballPlayersName = self.footballPlayersName.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_Battle_Cooperate_CooperateModeBattleData::create(
            _fbb,
            &clz_Torappu_Battle_Cooperate_CooperateModeBattleDataArgs {
                costTransferred,
                getMaxMsgCntInOneUpdate,
                endTileInfo,
                footballAheadGoalCntFactor,
                footballHardTypeFactor,
                footballLastRoundResultFactor,
                footballLevelOfWaveFactor,
                footballTeamWeights,
                footballTeamPlayers,
                footballPlayersName,
            },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_Battle_Cooperate_CooperateModeBattleData`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_battle_cooperate_cooperate_mode_battle_data_unchecked`.
pub fn root_as_clz_torappu_battle_cooperate_cooperate_mode_battle_data(
    buf: &[u8],
) -> Result<clz_Torappu_Battle_Cooperate_CooperateModeBattleData, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_Battle_Cooperate_CooperateModeBattleData>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_Battle_Cooperate_CooperateModeBattleData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_battle_cooperate_cooperate_mode_battle_data_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_battle_cooperate_cooperate_mode_battle_data(
    buf: &[u8],
) -> Result<clz_Torappu_Battle_Cooperate_CooperateModeBattleData, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_Battle_Cooperate_CooperateModeBattleData>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_Battle_Cooperate_CooperateModeBattleData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_battle_cooperate_cooperate_mode_battle_data_unchecked`.
pub fn root_as_clz_torappu_battle_cooperate_cooperate_mode_battle_data_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_Battle_Cooperate_CooperateModeBattleData<'b>, flatbuffers::InvalidFlatbuffer>
{
    flatbuffers::root_with_opts::<clz_Torappu_Battle_Cooperate_CooperateModeBattleData<'b>>(
        opts, buf,
    )
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_Battle_Cooperate_CooperateModeBattleData` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_battle_cooperate_cooperate_mode_battle_data_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_battle_cooperate_cooperate_mode_battle_data_with_opts<
    'b,
    'o,
>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_Battle_Cooperate_CooperateModeBattleData<'b>, flatbuffers::InvalidFlatbuffer>
{
    flatbuffers::size_prefixed_root_with_opts::<
        clz_Torappu_Battle_Cooperate_CooperateModeBattleData<'b>,
    >(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_Battle_Cooperate_CooperateModeBattleData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_Battle_Cooperate_CooperateModeBattleData`.
pub unsafe fn root_as_clz_torappu_battle_cooperate_cooperate_mode_battle_data_unchecked(
    buf: &[u8],
) -> clz_Torappu_Battle_Cooperate_CooperateModeBattleData {
    unsafe {
        flatbuffers::root_unchecked::<clz_Torappu_Battle_Cooperate_CooperateModeBattleData>(buf)
    }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_Battle_Cooperate_CooperateModeBattleData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_Battle_Cooperate_CooperateModeBattleData`.
pub unsafe fn size_prefixed_root_as_clz_torappu_battle_cooperate_cooperate_mode_battle_data_unchecked(
    buf: &[u8],
) -> clz_Torappu_Battle_Cooperate_CooperateModeBattleData {
    unsafe {
        flatbuffers::size_prefixed_root_unchecked::<
            clz_Torappu_Battle_Cooperate_CooperateModeBattleData,
        >(buf)
    }
}
#[inline]
pub fn finish_clz_torappu_battle_cooperate_cooperate_mode_battle_data_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateModeBattleData<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_battle_cooperate_cooperate_mode_battle_data_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_Battle_Cooperate_CooperateModeBattleData<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
