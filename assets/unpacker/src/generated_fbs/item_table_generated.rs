// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ITEM_RARITY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ITEM_RARITY: i32 = 6;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ITEM_RARITY: [enum__Torappu_ItemRarity; 7] = [
    enum__Torappu_ItemRarity::TIER_1,
    enum__Torappu_ItemRarity::TIER_2,
    enum__Torappu_ItemRarity::TIER_3,
    enum__Torappu_ItemRarity::TIER_4,
    enum__Torappu_ItemRarity::TIER_5,
    enum__Torappu_ItemRarity::TIER_6,
    enum__Torappu_ItemRarity::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ItemRarity(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ItemRarity {
    pub const TIER_1: Self = Self(0);
    pub const TIER_2: Self = Self(1);
    pub const TIER_3: Self = Self(2);
    pub const TIER_4: Self = Self(3);
    pub const TIER_5: Self = Self(4);
    pub const TIER_6: Self = Self(5);
    pub const E_NUM: Self = Self(6);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 6;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::TIER_1,
        Self::TIER_2,
        Self::TIER_3,
        Self::TIER_4,
        Self::TIER_5,
        Self::TIER_6,
        Self::E_NUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::TIER_1 => Some("TIER_1"),
            Self::TIER_2 => Some("TIER_2"),
            Self::TIER_3 => Some("TIER_3"),
            Self::TIER_4 => Some("TIER_4"),
            Self::TIER_5 => Some("TIER_5"),
            Self::TIER_6 => Some("TIER_6"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ItemRarity {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ItemRarity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ItemRarity",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ItemRarity {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ItemRarity {
    type Output = enum__Torappu_ItemRarity;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ItemRarity {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ItemRarity {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ItemRarity {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ITEM_CLASSIFY_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ITEM_CLASSIFY_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ITEM_CLASSIFY_TYPE: [enum__Torappu_ItemClassifyType; 4] = [
    enum__Torappu_ItemClassifyType::NONE,
    enum__Torappu_ItemClassifyType::CONSUME,
    enum__Torappu_ItemClassifyType::NORMAL,
    enum__Torappu_ItemClassifyType::MATERIAL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ItemClassifyType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ItemClassifyType {
    pub const NONE: Self = Self(0);
    pub const CONSUME: Self = Self(1);
    pub const NORMAL: Self = Self(2);
    pub const MATERIAL: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::CONSUME, Self::NORMAL, Self::MATERIAL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::CONSUME => Some("CONSUME"),
            Self::NORMAL => Some("NORMAL"),
            Self::MATERIAL => Some("MATERIAL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ItemClassifyType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ItemClassifyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ItemClassifyType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ItemClassifyType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ItemClassifyType {
    type Output = enum__Torappu_ItemClassifyType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ItemClassifyType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ItemClassifyType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ItemClassifyType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ITEM_TYPE: i32 = 90;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ITEM_TYPE: [enum__Torappu_ItemType; 91] = [
    enum__Torappu_ItemType::NONE,
    enum__Torappu_ItemType::CHAR,
    enum__Torappu_ItemType::CARD_EXP,
    enum__Torappu_ItemType::MATERIAL,
    enum__Torappu_ItemType::GOLD,
    enum__Torappu_ItemType::EXP_PLAYER,
    enum__Torappu_ItemType::TKT_TRY,
    enum__Torappu_ItemType::TKT_RECRUIT,
    enum__Torappu_ItemType::TKT_INST_FIN,
    enum__Torappu_ItemType::TKT_GACHA,
    enum__Torappu_ItemType::ACTIVITY_COIN,
    enum__Torappu_ItemType::DIAMOND,
    enum__Torappu_ItemType::DIAMOND_SHD,
    enum__Torappu_ItemType::HGG_SHD,
    enum__Torappu_ItemType::LGG_SHD,
    enum__Torappu_ItemType::FURN,
    enum__Torappu_ItemType::AP_GAMEPLAY,
    enum__Torappu_ItemType::AP_BASE,
    enum__Torappu_ItemType::SOCIAL_PT,
    enum__Torappu_ItemType::CHAR_SKIN,
    enum__Torappu_ItemType::TKT_GACHA_10,
    enum__Torappu_ItemType::TKT_GACHA_PRSV,
    enum__Torappu_ItemType::AP_ITEM,
    enum__Torappu_ItemType::AP_SUPPLY,
    enum__Torappu_ItemType::RENAMING_CARD,
    enum__Torappu_ItemType::RENAMING_CARD_2,
    enum__Torappu_ItemType::ET_STAGE,
    enum__Torappu_ItemType::ACTIVITY_ITEM,
    enum__Torappu_ItemType::VOUCHER_PICK,
    enum__Torappu_ItemType::VOUCHER_CGACHA,
    enum__Torappu_ItemType::VOUCHER_MGACHA,
    enum__Torappu_ItemType::CRS_SHOP_COIN,
    enum__Torappu_ItemType::CRS_RUNE_COIN,
    enum__Torappu_ItemType::LMTGS_COIN,
    enum__Torappu_ItemType::EPGS_COIN,
    enum__Torappu_ItemType::LIMITED_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_FREE_GACHA,
    enum__Torappu_ItemType::REP_COIN,
    enum__Torappu_ItemType::ROGUELIKE,
    enum__Torappu_ItemType::LINKAGE_TKT_GACHA_10,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_4,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_5,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_6,
    enum__Torappu_ItemType::VOUCHER_SKIN,
    enum__Torappu_ItemType::RETRO_COIN,
    enum__Torappu_ItemType::PLAYER_AVATAR,
    enum__Torappu_ItemType::UNI_COLLECTION,
    enum__Torappu_ItemType::VOUCHER_FULL_POTENTIAL,
    enum__Torappu_ItemType::RL_COIN,
    enum__Torappu_ItemType::RETURN_CREDIT,
    enum__Torappu_ItemType::MEDAL,
    enum__Torappu_ItemType::CHARM,
    enum__Torappu_ItemType::HOME_BACKGROUND,
    enum__Torappu_ItemType::EXTERMINATION_AGENT,
    enum__Torappu_ItemType::OPTIONAL_VOUCHER_PICK,
    enum__Torappu_ItemType::ACT_CART_COMPONENT,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_4,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_4,
    enum__Torappu_ItemType::ACTIVITY_POTENTIAL,
    enum__Torappu_ItemType::ITEM_PACK,
    enum__Torappu_ItemType::SANDBOX,
    enum__Torappu_ItemType::FAVOR_ADD_ITEM,
    enum__Torappu_ItemType::CLASSIC_SHD,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_BUFF,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_5,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_6,
    enum__Torappu_ItemType::RETURN_PROGRESS,
    enum__Torappu_ItemType::NEW_PROGRESS,
    enum__Torappu_ItemType::MCARD_VOUCHER,
    enum__Torappu_ItemType::MATERIAL_ISSUE_VOUCHER,
    enum__Torappu_ItemType::CRS_SHOP_COIN_V2,
    enum__Torappu_ItemType::HOME_THEME,
    enum__Torappu_ItemType::SANDBOX_PERM,
    enum__Torappu_ItemType::SANDBOX_TOKEN,
    enum__Torappu_ItemType::TEMPLATE_TRAP,
    enum__Torappu_ItemType::NAME_CARD_SKIN,
    enum__Torappu_ItemType::EMOTICON_SET,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA_10,
    enum__Torappu_ItemType::SO_CHAR_EXP,
    enum__Torappu_ItemType::GIFTPACKAGE_TKT,
    enum__Torappu_ItemType::VOUCHER_SKIN_V2,
    enum__Torappu_ItemType::RANDOM_VOUCHER_SKIN,
    enum__Torappu_ItemType::ACT1VHALFIDLE_ITEM,
    enum__Torappu_ItemType::PLOT_ITEM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ItemType {
    pub const NONE: Self = Self(0);
    pub const CHAR: Self = Self(1);
    pub const CARD_EXP: Self = Self(2);
    pub const MATERIAL: Self = Self(3);
    pub const GOLD: Self = Self(4);
    pub const EXP_PLAYER: Self = Self(5);
    pub const TKT_TRY: Self = Self(6);
    pub const TKT_RECRUIT: Self = Self(7);
    pub const TKT_INST_FIN: Self = Self(8);
    pub const TKT_GACHA: Self = Self(9);
    pub const ACTIVITY_COIN: Self = Self(10);
    pub const DIAMOND: Self = Self(11);
    pub const DIAMOND_SHD: Self = Self(12);
    pub const HGG_SHD: Self = Self(13);
    pub const LGG_SHD: Self = Self(14);
    pub const FURN: Self = Self(15);
    pub const AP_GAMEPLAY: Self = Self(16);
    pub const AP_BASE: Self = Self(17);
    pub const SOCIAL_PT: Self = Self(18);
    pub const CHAR_SKIN: Self = Self(19);
    pub const TKT_GACHA_10: Self = Self(20);
    pub const TKT_GACHA_PRSV: Self = Self(21);
    pub const AP_ITEM: Self = Self(22);
    pub const AP_SUPPLY: Self = Self(23);
    pub const RENAMING_CARD: Self = Self(24);
    pub const RENAMING_CARD_2: Self = Self(25);
    pub const ET_STAGE: Self = Self(26);
    pub const ACTIVITY_ITEM: Self = Self(27);
    pub const VOUCHER_PICK: Self = Self(28);
    pub const VOUCHER_CGACHA: Self = Self(29);
    pub const VOUCHER_MGACHA: Self = Self(30);
    pub const CRS_SHOP_COIN: Self = Self(31);
    pub const CRS_RUNE_COIN: Self = Self(32);
    pub const LMTGS_COIN: Self = Self(33);
    pub const EPGS_COIN: Self = Self(34);
    pub const LIMITED_TKT_GACHA_10: Self = Self(35);
    pub const LIMITED_FREE_GACHA: Self = Self(36);
    pub const REP_COIN: Self = Self(37);
    pub const ROGUELIKE: Self = Self(38);
    pub const LINKAGE_TKT_GACHA_10: Self = Self(39);
    pub const VOUCHER_ELITE_II_4: Self = Self(40);
    pub const VOUCHER_ELITE_II_5: Self = Self(41);
    pub const VOUCHER_ELITE_II_6: Self = Self(42);
    pub const VOUCHER_SKIN: Self = Self(43);
    pub const RETRO_COIN: Self = Self(44);
    pub const PLAYER_AVATAR: Self = Self(45);
    pub const UNI_COLLECTION: Self = Self(46);
    pub const VOUCHER_FULL_POTENTIAL: Self = Self(47);
    pub const RL_COIN: Self = Self(48);
    pub const RETURN_CREDIT: Self = Self(49);
    pub const MEDAL: Self = Self(50);
    pub const CHARM: Self = Self(51);
    pub const HOME_BACKGROUND: Self = Self(52);
    pub const EXTERMINATION_AGENT: Self = Self(53);
    pub const OPTIONAL_VOUCHER_PICK: Self = Self(54);
    pub const ACT_CART_COMPONENT: Self = Self(55);
    pub const VOUCHER_LEVELMAX_6: Self = Self(56);
    pub const VOUCHER_LEVELMAX_5: Self = Self(57);
    pub const VOUCHER_LEVELMAX_4: Self = Self(58);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_6: Self = Self(59);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_5: Self = Self(60);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_4: Self = Self(61);
    pub const ACTIVITY_POTENTIAL: Self = Self(62);
    pub const ITEM_PACK: Self = Self(63);
    pub const SANDBOX: Self = Self(64);
    pub const FAVOR_ADD_ITEM: Self = Self(65);
    pub const CLASSIC_SHD: Self = Self(66);
    pub const CLASSIC_TKT_GACHA: Self = Self(67);
    pub const CLASSIC_TKT_GACHA_10: Self = Self(68);
    pub const LIMITED_BUFF: Self = Self(69);
    pub const CLASSIC_FES_PICK_TIER_5: Self = Self(70);
    pub const CLASSIC_FES_PICK_TIER_6: Self = Self(71);
    pub const RETURN_PROGRESS: Self = Self(72);
    pub const NEW_PROGRESS: Self = Self(73);
    pub const MCARD_VOUCHER: Self = Self(74);
    pub const MATERIAL_ISSUE_VOUCHER: Self = Self(75);
    pub const CRS_SHOP_COIN_V2: Self = Self(76);
    pub const HOME_THEME: Self = Self(77);
    pub const SANDBOX_PERM: Self = Self(78);
    pub const SANDBOX_TOKEN: Self = Self(79);
    pub const TEMPLATE_TRAP: Self = Self(80);
    pub const NAME_CARD_SKIN: Self = Self(81);
    pub const EMOTICON_SET: Self = Self(82);
    pub const EXCLUSIVE_TKT_GACHA: Self = Self(83);
    pub const EXCLUSIVE_TKT_GACHA_10: Self = Self(84);
    pub const SO_CHAR_EXP: Self = Self(85);
    pub const GIFTPACKAGE_TKT: Self = Self(86);
    pub const VOUCHER_SKIN_V2: Self = Self(87);
    pub const RANDOM_VOUCHER_SKIN: Self = Self(88);
    pub const ACT1VHALFIDLE_ITEM: Self = Self(89);
    pub const PLOT_ITEM: Self = Self(90);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 90;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::CHAR,
        Self::CARD_EXP,
        Self::MATERIAL,
        Self::GOLD,
        Self::EXP_PLAYER,
        Self::TKT_TRY,
        Self::TKT_RECRUIT,
        Self::TKT_INST_FIN,
        Self::TKT_GACHA,
        Self::ACTIVITY_COIN,
        Self::DIAMOND,
        Self::DIAMOND_SHD,
        Self::HGG_SHD,
        Self::LGG_SHD,
        Self::FURN,
        Self::AP_GAMEPLAY,
        Self::AP_BASE,
        Self::SOCIAL_PT,
        Self::CHAR_SKIN,
        Self::TKT_GACHA_10,
        Self::TKT_GACHA_PRSV,
        Self::AP_ITEM,
        Self::AP_SUPPLY,
        Self::RENAMING_CARD,
        Self::RENAMING_CARD_2,
        Self::ET_STAGE,
        Self::ACTIVITY_ITEM,
        Self::VOUCHER_PICK,
        Self::VOUCHER_CGACHA,
        Self::VOUCHER_MGACHA,
        Self::CRS_SHOP_COIN,
        Self::CRS_RUNE_COIN,
        Self::LMTGS_COIN,
        Self::EPGS_COIN,
        Self::LIMITED_TKT_GACHA_10,
        Self::LIMITED_FREE_GACHA,
        Self::REP_COIN,
        Self::ROGUELIKE,
        Self::LINKAGE_TKT_GACHA_10,
        Self::VOUCHER_ELITE_II_4,
        Self::VOUCHER_ELITE_II_5,
        Self::VOUCHER_ELITE_II_6,
        Self::VOUCHER_SKIN,
        Self::RETRO_COIN,
        Self::PLAYER_AVATAR,
        Self::UNI_COLLECTION,
        Self::VOUCHER_FULL_POTENTIAL,
        Self::RL_COIN,
        Self::RETURN_CREDIT,
        Self::MEDAL,
        Self::CHARM,
        Self::HOME_BACKGROUND,
        Self::EXTERMINATION_AGENT,
        Self::OPTIONAL_VOUCHER_PICK,
        Self::ACT_CART_COMPONENT,
        Self::VOUCHER_LEVELMAX_6,
        Self::VOUCHER_LEVELMAX_5,
        Self::VOUCHER_LEVELMAX_4,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_6,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_5,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_4,
        Self::ACTIVITY_POTENTIAL,
        Self::ITEM_PACK,
        Self::SANDBOX,
        Self::FAVOR_ADD_ITEM,
        Self::CLASSIC_SHD,
        Self::CLASSIC_TKT_GACHA,
        Self::CLASSIC_TKT_GACHA_10,
        Self::LIMITED_BUFF,
        Self::CLASSIC_FES_PICK_TIER_5,
        Self::CLASSIC_FES_PICK_TIER_6,
        Self::RETURN_PROGRESS,
        Self::NEW_PROGRESS,
        Self::MCARD_VOUCHER,
        Self::MATERIAL_ISSUE_VOUCHER,
        Self::CRS_SHOP_COIN_V2,
        Self::HOME_THEME,
        Self::SANDBOX_PERM,
        Self::SANDBOX_TOKEN,
        Self::TEMPLATE_TRAP,
        Self::NAME_CARD_SKIN,
        Self::EMOTICON_SET,
        Self::EXCLUSIVE_TKT_GACHA,
        Self::EXCLUSIVE_TKT_GACHA_10,
        Self::SO_CHAR_EXP,
        Self::GIFTPACKAGE_TKT,
        Self::VOUCHER_SKIN_V2,
        Self::RANDOM_VOUCHER_SKIN,
        Self::ACT1VHALFIDLE_ITEM,
        Self::PLOT_ITEM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::CHAR => Some("CHAR"),
            Self::CARD_EXP => Some("CARD_EXP"),
            Self::MATERIAL => Some("MATERIAL"),
            Self::GOLD => Some("GOLD"),
            Self::EXP_PLAYER => Some("EXP_PLAYER"),
            Self::TKT_TRY => Some("TKT_TRY"),
            Self::TKT_RECRUIT => Some("TKT_RECRUIT"),
            Self::TKT_INST_FIN => Some("TKT_INST_FIN"),
            Self::TKT_GACHA => Some("TKT_GACHA"),
            Self::ACTIVITY_COIN => Some("ACTIVITY_COIN"),
            Self::DIAMOND => Some("DIAMOND"),
            Self::DIAMOND_SHD => Some("DIAMOND_SHD"),
            Self::HGG_SHD => Some("HGG_SHD"),
            Self::LGG_SHD => Some("LGG_SHD"),
            Self::FURN => Some("FURN"),
            Self::AP_GAMEPLAY => Some("AP_GAMEPLAY"),
            Self::AP_BASE => Some("AP_BASE"),
            Self::SOCIAL_PT => Some("SOCIAL_PT"),
            Self::CHAR_SKIN => Some("CHAR_SKIN"),
            Self::TKT_GACHA_10 => Some("TKT_GACHA_10"),
            Self::TKT_GACHA_PRSV => Some("TKT_GACHA_PRSV"),
            Self::AP_ITEM => Some("AP_ITEM"),
            Self::AP_SUPPLY => Some("AP_SUPPLY"),
            Self::RENAMING_CARD => Some("RENAMING_CARD"),
            Self::RENAMING_CARD_2 => Some("RENAMING_CARD_2"),
            Self::ET_STAGE => Some("ET_STAGE"),
            Self::ACTIVITY_ITEM => Some("ACTIVITY_ITEM"),
            Self::VOUCHER_PICK => Some("VOUCHER_PICK"),
            Self::VOUCHER_CGACHA => Some("VOUCHER_CGACHA"),
            Self::VOUCHER_MGACHA => Some("VOUCHER_MGACHA"),
            Self::CRS_SHOP_COIN => Some("CRS_SHOP_COIN"),
            Self::CRS_RUNE_COIN => Some("CRS_RUNE_COIN"),
            Self::LMTGS_COIN => Some("LMTGS_COIN"),
            Self::EPGS_COIN => Some("EPGS_COIN"),
            Self::LIMITED_TKT_GACHA_10 => Some("LIMITED_TKT_GACHA_10"),
            Self::LIMITED_FREE_GACHA => Some("LIMITED_FREE_GACHA"),
            Self::REP_COIN => Some("REP_COIN"),
            Self::ROGUELIKE => Some("ROGUELIKE"),
            Self::LINKAGE_TKT_GACHA_10 => Some("LINKAGE_TKT_GACHA_10"),
            Self::VOUCHER_ELITE_II_4 => Some("VOUCHER_ELITE_II_4"),
            Self::VOUCHER_ELITE_II_5 => Some("VOUCHER_ELITE_II_5"),
            Self::VOUCHER_ELITE_II_6 => Some("VOUCHER_ELITE_II_6"),
            Self::VOUCHER_SKIN => Some("VOUCHER_SKIN"),
            Self::RETRO_COIN => Some("RETRO_COIN"),
            Self::PLAYER_AVATAR => Some("PLAYER_AVATAR"),
            Self::UNI_COLLECTION => Some("UNI_COLLECTION"),
            Self::VOUCHER_FULL_POTENTIAL => Some("VOUCHER_FULL_POTENTIAL"),
            Self::RL_COIN => Some("RL_COIN"),
            Self::RETURN_CREDIT => Some("RETURN_CREDIT"),
            Self::MEDAL => Some("MEDAL"),
            Self::CHARM => Some("CHARM"),
            Self::HOME_BACKGROUND => Some("HOME_BACKGROUND"),
            Self::EXTERMINATION_AGENT => Some("EXTERMINATION_AGENT"),
            Self::OPTIONAL_VOUCHER_PICK => Some("OPTIONAL_VOUCHER_PICK"),
            Self::ACT_CART_COMPONENT => Some("ACT_CART_COMPONENT"),
            Self::VOUCHER_LEVELMAX_6 => Some("VOUCHER_LEVELMAX_6"),
            Self::VOUCHER_LEVELMAX_5 => Some("VOUCHER_LEVELMAX_5"),
            Self::VOUCHER_LEVELMAX_4 => Some("VOUCHER_LEVELMAX_4"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_6 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_6"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_5 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_5"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_4 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_4"),
            Self::ACTIVITY_POTENTIAL => Some("ACTIVITY_POTENTIAL"),
            Self::ITEM_PACK => Some("ITEM_PACK"),
            Self::SANDBOX => Some("SANDBOX"),
            Self::FAVOR_ADD_ITEM => Some("FAVOR_ADD_ITEM"),
            Self::CLASSIC_SHD => Some("CLASSIC_SHD"),
            Self::CLASSIC_TKT_GACHA => Some("CLASSIC_TKT_GACHA"),
            Self::CLASSIC_TKT_GACHA_10 => Some("CLASSIC_TKT_GACHA_10"),
            Self::LIMITED_BUFF => Some("LIMITED_BUFF"),
            Self::CLASSIC_FES_PICK_TIER_5 => Some("CLASSIC_FES_PICK_TIER_5"),
            Self::CLASSIC_FES_PICK_TIER_6 => Some("CLASSIC_FES_PICK_TIER_6"),
            Self::RETURN_PROGRESS => Some("RETURN_PROGRESS"),
            Self::NEW_PROGRESS => Some("NEW_PROGRESS"),
            Self::MCARD_VOUCHER => Some("MCARD_VOUCHER"),
            Self::MATERIAL_ISSUE_VOUCHER => Some("MATERIAL_ISSUE_VOUCHER"),
            Self::CRS_SHOP_COIN_V2 => Some("CRS_SHOP_COIN_V2"),
            Self::HOME_THEME => Some("HOME_THEME"),
            Self::SANDBOX_PERM => Some("SANDBOX_PERM"),
            Self::SANDBOX_TOKEN => Some("SANDBOX_TOKEN"),
            Self::TEMPLATE_TRAP => Some("TEMPLATE_TRAP"),
            Self::NAME_CARD_SKIN => Some("NAME_CARD_SKIN"),
            Self::EMOTICON_SET => Some("EMOTICON_SET"),
            Self::EXCLUSIVE_TKT_GACHA => Some("EXCLUSIVE_TKT_GACHA"),
            Self::EXCLUSIVE_TKT_GACHA_10 => Some("EXCLUSIVE_TKT_GACHA_10"),
            Self::SO_CHAR_EXP => Some("SO_CHAR_EXP"),
            Self::GIFTPACKAGE_TKT => Some("GIFTPACKAGE_TKT"),
            Self::VOUCHER_SKIN_V2 => Some("VOUCHER_SKIN_V2"),
            Self::RANDOM_VOUCHER_SKIN => Some("RANDOM_VOUCHER_SKIN"),
            Self::ACT1VHALFIDLE_ITEM => Some("ACT1VHALFIDLE_ITEM"),
            Self::PLOT_ITEM => Some("PLOT_ITEM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ItemType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ItemType {
    type Output = enum__Torappu_ItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_OCC_PER: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_OCC_PER: i32 = 6;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_OCC_PER: [enum__Torappu_OccPer; 7] = [
    enum__Torappu_OccPer::ALWAYS,
    enum__Torappu_OccPer::ALMOST,
    enum__Torappu_OccPer::USUAL,
    enum__Torappu_OccPer::OFTEN,
    enum__Torappu_OccPer::SOMETIMES,
    enum__Torappu_OccPer::NEVER,
    enum__Torappu_OccPer::DEFINITELY_BUFF,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_OccPer(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_OccPer {
    pub const ALWAYS: Self = Self(0);
    pub const ALMOST: Self = Self(1);
    pub const USUAL: Self = Self(2);
    pub const OFTEN: Self = Self(3);
    pub const SOMETIMES: Self = Self(4);
    pub const NEVER: Self = Self(5);
    pub const DEFINITELY_BUFF: Self = Self(6);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 6;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::ALWAYS,
        Self::ALMOST,
        Self::USUAL,
        Self::OFTEN,
        Self::SOMETIMES,
        Self::NEVER,
        Self::DEFINITELY_BUFF,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ALWAYS => Some("ALWAYS"),
            Self::ALMOST => Some("ALMOST"),
            Self::USUAL => Some("USUAL"),
            Self::OFTEN => Some("OFTEN"),
            Self::SOMETIMES => Some("SOMETIMES"),
            Self::NEVER => Some("NEVER"),
            Self::DEFINITELY_BUFF => Some("DEFINITELY_BUFF"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_OccPer {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_OccPer {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_OccPer",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_OccPer {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_OccPer {
    type Output = enum__Torappu_OccPer;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_OccPer {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_OccPer {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_OccPer {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUILDING_DATA_ROOM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUILDING_DATA_ROOM_TYPE: i32 = 8191;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUILDING_DATA_ROOM_TYPE: [enum__Torappu_BuildingData_RoomType;
    16] = [
    enum__Torappu_BuildingData_RoomType::NONE,
    enum__Torappu_BuildingData_RoomType::CONTROL,
    enum__Torappu_BuildingData_RoomType::POWER,
    enum__Torappu_BuildingData_RoomType::MANUFACTURE,
    enum__Torappu_BuildingData_RoomType::SHOP,
    enum__Torappu_BuildingData_RoomType::DORMITORY,
    enum__Torappu_BuildingData_RoomType::MEETING,
    enum__Torappu_BuildingData_RoomType::HIRE,
    enum__Torappu_BuildingData_RoomType::ELEVATOR,
    enum__Torappu_BuildingData_RoomType::CORRIDOR,
    enum__Torappu_BuildingData_RoomType::TRADING,
    enum__Torappu_BuildingData_RoomType::WORKSHOP,
    enum__Torappu_BuildingData_RoomType::TRAINING,
    enum__Torappu_BuildingData_RoomType::FUNCTIONAL,
    enum__Torappu_BuildingData_RoomType::PRIVATE,
    enum__Torappu_BuildingData_RoomType::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuildingData_RoomType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuildingData_RoomType {
    pub const NONE: Self = Self(0);
    pub const CONTROL: Self = Self(1);
    pub const POWER: Self = Self(2);
    pub const MANUFACTURE: Self = Self(4);
    pub const SHOP: Self = Self(8);
    pub const DORMITORY: Self = Self(16);
    pub const MEETING: Self = Self(32);
    pub const HIRE: Self = Self(64);
    pub const ELEVATOR: Self = Self(128);
    pub const CORRIDOR: Self = Self(256);
    pub const TRADING: Self = Self(512);
    pub const WORKSHOP: Self = Self(1024);
    pub const TRAINING: Self = Self(2048);
    pub const FUNCTIONAL: Self = Self(3710);
    pub const PRIVATE: Self = Self(4096);
    pub const ALL: Self = Self(8191);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 8191;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::CONTROL,
        Self::POWER,
        Self::MANUFACTURE,
        Self::SHOP,
        Self::DORMITORY,
        Self::MEETING,
        Self::HIRE,
        Self::ELEVATOR,
        Self::CORRIDOR,
        Self::TRADING,
        Self::WORKSHOP,
        Self::TRAINING,
        Self::FUNCTIONAL,
        Self::PRIVATE,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::CONTROL => Some("CONTROL"),
            Self::POWER => Some("POWER"),
            Self::MANUFACTURE => Some("MANUFACTURE"),
            Self::SHOP => Some("SHOP"),
            Self::DORMITORY => Some("DORMITORY"),
            Self::MEETING => Some("MEETING"),
            Self::HIRE => Some("HIRE"),
            Self::ELEVATOR => Some("ELEVATOR"),
            Self::CORRIDOR => Some("CORRIDOR"),
            Self::TRADING => Some("TRADING"),
            Self::WORKSHOP => Some("WORKSHOP"),
            Self::TRAINING => Some("TRAINING"),
            Self::FUNCTIONAL => Some("FUNCTIONAL"),
            Self::PRIVATE => Some("PRIVATE"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuildingData_RoomType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_BuildingData_RoomType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_BuildingData_RoomType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuildingData_RoomType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuildingData_RoomType {
    type Output = enum__Torappu_BuildingData_RoomType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuildingData_RoomType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuildingData_RoomType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuildingData_RoomType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ITEM_DROP_SHOP_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ITEM_DROP_SHOP_TYPE: i32 = 5;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ITEM_DROP_SHOP_TYPE: [enum__Torappu_ItemDropShopType; 6] = [
    enum__Torappu_ItemDropShopType::HGGSHD_SHOP,
    enum__Torappu_ItemDropShopType::LGGSHD_SHOP,
    enum__Torappu_ItemDropShopType::XSHD_SHOP,
    enum__Torappu_ItemDropShopType::EPGS_SHOP,
    enum__Torappu_ItemDropShopType::REP_SHOP,
    enum__Torappu_ItemDropShopType::CLASSIC_SHOP,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ItemDropShopType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ItemDropShopType {
    pub const HGGSHD_SHOP: Self = Self(0);
    pub const LGGSHD_SHOP: Self = Self(1);
    pub const XSHD_SHOP: Self = Self(2);
    pub const EPGS_SHOP: Self = Self(3);
    pub const REP_SHOP: Self = Self(4);
    pub const CLASSIC_SHOP: Self = Self(5);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 5;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::HGGSHD_SHOP,
        Self::LGGSHD_SHOP,
        Self::XSHD_SHOP,
        Self::EPGS_SHOP,
        Self::REP_SHOP,
        Self::CLASSIC_SHOP,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::HGGSHD_SHOP => Some("HGGSHD_SHOP"),
            Self::LGGSHD_SHOP => Some("LGGSHD_SHOP"),
            Self::XSHD_SHOP => Some("XSHD_SHOP"),
            Self::EPGS_SHOP => Some("EPGS_SHOP"),
            Self::REP_SHOP => Some("REP_SHOP"),
            Self::CLASSIC_SHOP => Some("CLASSIC_SHOP"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ItemDropShopType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ItemDropShopType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ItemDropShopType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ItemDropShopType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ItemDropShopType {
    type Output = enum__Torappu_ItemDropShopType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ItemDropShopType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ItemDropShopType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ItemDropShopType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_VOUCHER_DISPLAY_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_VOUCHER_DISPLAY_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_VOUCHER_DISPLAY_TYPE: [enum__Torappu_VoucherDisplayType; 2] = [
    enum__Torappu_VoucherDisplayType::NONE,
    enum__Torappu_VoucherDisplayType::DIVIDE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_VoucherDisplayType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_VoucherDisplayType {
    pub const NONE: Self = Self(0);
    pub const DIVIDE: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::DIVIDE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::DIVIDE => Some("DIVIDE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_VoucherDisplayType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_VoucherDisplayType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_VoucherDisplayType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_VoucherDisplayType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_VoucherDisplayType {
    type Output = enum__Torappu_VoucherDisplayType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_VoucherDisplayType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_VoucherDisplayType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_VoucherDisplayType {}
pub enum clz_Torappu_ItemData_StageDropInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ItemData_StageDropInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ItemData_StageDropInfo<'a> {
    type Inner = clz_Torappu_ItemData_StageDropInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ItemData_StageDropInfo<'a> {
    pub const VT_STAGEID: flatbuffers::VOffsetT = 4;
    pub const VT_OCCPER: flatbuffers::VOffsetT = 6;
    pub const VT_SORTID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ItemData_StageDropInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ItemData_StageDropInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemData_StageDropInfo<'bldr>> {
        let mut builder = clz_Torappu_ItemData_StageDropInfoBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        builder.add_occPer(args.occPer);
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ItemData_StageDropInfoT {
        let stageId = self.stageId().map(|x| x.to_string());
        let occPer = self.occPer();
        let sortId = self.sortId();
        clz_Torappu_ItemData_StageDropInfoT {
            stageId,
            occPer,
            sortId,
        }
    }

    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ItemData_StageDropInfo::VT_STAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn occPer(&self) -> enum__Torappu_OccPer {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_OccPer>(
                    clz_Torappu_ItemData_StageDropInfo::VT_OCCPER,
                    Some(enum__Torappu_OccPer::ALWAYS),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ItemData_StageDropInfo::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ItemData_StageDropInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .visit_field::<enum__Torappu_OccPer>("occPer", Self::VT_OCCPER, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ItemData_StageDropInfoArgs<'a> {
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub occPer: enum__Torappu_OccPer,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_ItemData_StageDropInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ItemData_StageDropInfoArgs {
            stageId: None,
            occPer: enum__Torappu_OccPer::ALWAYS,
            sortId: 0,
        }
    }
}

impl Serialize for clz_Torappu_ItemData_StageDropInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ItemData_StageDropInfo", 3)?;
        if let Some(f) = self.stageId() {
            s.serialize_field("stageId", &f)?;
        } else {
            s.skip_field("stageId")?;
        }
        s.serialize_field("occPer", &self.occPer())?;
        s.serialize_field("sortId", &self.sortId())?;
        s.end()
    }
}

pub struct clz_Torappu_ItemData_StageDropInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ItemData_StageDropInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ItemData_StageDropInfo::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn add_occPer(&mut self, occPer: enum__Torappu_OccPer) {
        self.fbb_.push_slot::<enum__Torappu_OccPer>(
            clz_Torappu_ItemData_StageDropInfo::VT_OCCPER,
            occPer,
            enum__Torappu_OccPer::ALWAYS,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ItemData_StageDropInfo::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ItemData_StageDropInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ItemData_StageDropInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ItemData_StageDropInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ItemData_StageDropInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ItemData_StageDropInfo");
        ds.field("stageId", &self.stageId());
        ds.field("occPer", &self.occPer());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ItemData_StageDropInfoT {
    pub stageId: Option<String>,
    pub occPer: enum__Torappu_OccPer,
    pub sortId: i32,
}
impl Default for clz_Torappu_ItemData_StageDropInfoT {
    fn default() -> Self {
        Self {
            stageId: None,
            occPer: enum__Torappu_OccPer::ALWAYS,
            sortId: 0,
        }
    }
}
impl clz_Torappu_ItemData_StageDropInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemData_StageDropInfo<'b>> {
        let stageId = self.stageId.as_ref().map(|x| _fbb.create_string(x));
        let occPer = self.occPer;
        let sortId = self.sortId;
        clz_Torappu_ItemData_StageDropInfo::create(
            _fbb,
            &clz_Torappu_ItemData_StageDropInfoArgs {
                stageId,
                occPer,
                sortId,
            },
        )
    }
}
pub enum clz_Torappu_ItemData_BuildingProductInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ItemData_BuildingProductInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ItemData_BuildingProductInfo<'a> {
    type Inner = clz_Torappu_ItemData_BuildingProductInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ItemData_BuildingProductInfo<'a> {
    pub const VT_ROOMTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_FORMULAID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ItemData_BuildingProductInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ItemData_BuildingProductInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemData_BuildingProductInfo<'bldr>> {
        let mut builder = clz_Torappu_ItemData_BuildingProductInfoBuilder::new(_fbb);
        if let Some(x) = args.formulaId {
            builder.add_formulaId(x);
        }
        builder.add_roomType(args.roomType);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ItemData_BuildingProductInfoT {
        let roomType = self.roomType();
        let formulaId = self.formulaId().map(|x| x.to_string());
        clz_Torappu_ItemData_BuildingProductInfoT {
            roomType,
            formulaId,
        }
    }

    #[inline]
    pub fn roomType(&self) -> enum__Torappu_BuildingData_RoomType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_RoomType>(
                    clz_Torappu_ItemData_BuildingProductInfo::VT_ROOMTYPE,
                    Some(enum__Torappu_BuildingData_RoomType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn formulaId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ItemData_BuildingProductInfo::VT_FORMULAID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ItemData_BuildingProductInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_BuildingData_RoomType>(
                "roomType",
                Self::VT_ROOMTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "formulaId",
                Self::VT_FORMULAID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ItemData_BuildingProductInfoArgs<'a> {
    pub roomType: enum__Torappu_BuildingData_RoomType,
    pub formulaId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ItemData_BuildingProductInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ItemData_BuildingProductInfoArgs {
            roomType: enum__Torappu_BuildingData_RoomType::NONE,
            formulaId: None,
        }
    }
}

impl Serialize for clz_Torappu_ItemData_BuildingProductInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ItemData_BuildingProductInfo", 2)?;
        s.serialize_field("roomType", &self.roomType())?;
        if let Some(f) = self.formulaId() {
            s.serialize_field("formulaId", &f)?;
        } else {
            s.skip_field("formulaId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ItemData_BuildingProductInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ItemData_BuildingProductInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_roomType(&mut self, roomType: enum__Torappu_BuildingData_RoomType) {
        self.fbb_.push_slot::<enum__Torappu_BuildingData_RoomType>(
            clz_Torappu_ItemData_BuildingProductInfo::VT_ROOMTYPE,
            roomType,
            enum__Torappu_BuildingData_RoomType::NONE,
        );
    }
    #[inline]
    pub fn add_formulaId(&mut self, formulaId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ItemData_BuildingProductInfo::VT_FORMULAID,
            formulaId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ItemData_BuildingProductInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ItemData_BuildingProductInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ItemData_BuildingProductInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ItemData_BuildingProductInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ItemData_BuildingProductInfo");
        ds.field("roomType", &self.roomType());
        ds.field("formulaId", &self.formulaId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ItemData_BuildingProductInfoT {
    pub roomType: enum__Torappu_BuildingData_RoomType,
    pub formulaId: Option<String>,
}
impl Default for clz_Torappu_ItemData_BuildingProductInfoT {
    fn default() -> Self {
        Self {
            roomType: enum__Torappu_BuildingData_RoomType::NONE,
            formulaId: None,
        }
    }
}
impl clz_Torappu_ItemData_BuildingProductInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemData_BuildingProductInfo<'b>> {
        let roomType = self.roomType;
        let formulaId = self.formulaId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_ItemData_BuildingProductInfo::create(
            _fbb,
            &clz_Torappu_ItemData_BuildingProductInfoArgs {
                roomType,
                formulaId,
            },
        )
    }
}
pub enum clz_Torappu_ItemData_VoucherRelateInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ItemData_VoucherRelateInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ItemData_VoucherRelateInfo<'a> {
    type Inner = clz_Torappu_ItemData_VoucherRelateInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ItemData_VoucherRelateInfo<'a> {
    pub const VT_VOUCHERID: flatbuffers::VOffsetT = 4;
    pub const VT_VOUCHERITEMTYPE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ItemData_VoucherRelateInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ItemData_VoucherRelateInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemData_VoucherRelateInfo<'bldr>> {
        let mut builder = clz_Torappu_ItemData_VoucherRelateInfoBuilder::new(_fbb);
        builder.add_voucherItemType(args.voucherItemType);
        if let Some(x) = args.voucherId {
            builder.add_voucherId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ItemData_VoucherRelateInfoT {
        let voucherId = self.voucherId().map(|x| x.to_string());
        let voucherItemType = self.voucherItemType();
        clz_Torappu_ItemData_VoucherRelateInfoT {
            voucherId,
            voucherItemType,
        }
    }

    #[inline]
    pub fn voucherId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ItemData_VoucherRelateInfo::VT_VOUCHERID,
                None,
            )
        }
    }
    #[inline]
    pub fn voucherItemType(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_ItemData_VoucherRelateInfo::VT_VOUCHERITEMTYPE,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ItemData_VoucherRelateInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "voucherId",
                Self::VT_VOUCHERID,
                false,
            )?
            .visit_field::<enum__Torappu_ItemType>(
                "voucherItemType",
                Self::VT_VOUCHERITEMTYPE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ItemData_VoucherRelateInfoArgs<'a> {
    pub voucherId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub voucherItemType: enum__Torappu_ItemType,
}
impl<'a> Default for clz_Torappu_ItemData_VoucherRelateInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ItemData_VoucherRelateInfoArgs {
            voucherId: None,
            voucherItemType: enum__Torappu_ItemType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_ItemData_VoucherRelateInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ItemData_VoucherRelateInfo", 2)?;
        if let Some(f) = self.voucherId() {
            s.serialize_field("voucherId", &f)?;
        } else {
            s.skip_field("voucherId")?;
        }
        s.serialize_field("voucherItemType", &self.voucherItemType())?;
        s.end()
    }
}

pub struct clz_Torappu_ItemData_VoucherRelateInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ItemData_VoucherRelateInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_voucherId(&mut self, voucherId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ItemData_VoucherRelateInfo::VT_VOUCHERID,
            voucherId,
        );
    }
    #[inline]
    pub fn add_voucherItemType(&mut self, voucherItemType: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_ItemData_VoucherRelateInfo::VT_VOUCHERITEMTYPE,
            voucherItemType,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ItemData_VoucherRelateInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ItemData_VoucherRelateInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ItemData_VoucherRelateInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ItemData_VoucherRelateInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ItemData_VoucherRelateInfo");
        ds.field("voucherId", &self.voucherId());
        ds.field("voucherItemType", &self.voucherItemType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ItemData_VoucherRelateInfoT {
    pub voucherId: Option<String>,
    pub voucherItemType: enum__Torappu_ItemType,
}
impl Default for clz_Torappu_ItemData_VoucherRelateInfoT {
    fn default() -> Self {
        Self {
            voucherId: None,
            voucherItemType: enum__Torappu_ItemType::NONE,
        }
    }
}
impl clz_Torappu_ItemData_VoucherRelateInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemData_VoucherRelateInfo<'b>> {
        let voucherId = self.voucherId.as_ref().map(|x| _fbb.create_string(x));
        let voucherItemType = self.voucherItemType;
        clz_Torappu_ItemData_VoucherRelateInfo::create(
            _fbb,
            &clz_Torappu_ItemData_VoucherRelateInfoArgs {
                voucherId,
                voucherItemType,
            },
        )
    }
}
pub enum clz_Torappu_ItemData_ShopRelateInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ItemData_ShopRelateInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ItemData_ShopRelateInfo<'a> {
    type Inner = clz_Torappu_ItemData_ShopRelateInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ItemData_ShopRelateInfo<'a> {
    pub const VT_SHOPTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_SHOPGROUP: flatbuffers::VOffsetT = 6;
    pub const VT_STARTTS: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ItemData_ShopRelateInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ItemData_ShopRelateInfoArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemData_ShopRelateInfo<'bldr>> {
        let mut builder = clz_Torappu_ItemData_ShopRelateInfoBuilder::new(_fbb);
        builder.add_startTs(args.startTs);
        builder.add_shopGroup(args.shopGroup);
        builder.add_shopType(args.shopType);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ItemData_ShopRelateInfoT {
        let shopType = self.shopType();
        let shopGroup = self.shopGroup();
        let startTs = self.startTs();
        clz_Torappu_ItemData_ShopRelateInfoT {
            shopType,
            shopGroup,
            startTs,
        }
    }

    #[inline]
    pub fn shopType(&self) -> enum__Torappu_ItemDropShopType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemDropShopType>(
                    clz_Torappu_ItemData_ShopRelateInfo::VT_SHOPTYPE,
                    Some(enum__Torappu_ItemDropShopType::HGGSHD_SHOP),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn shopGroup(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ItemData_ShopRelateInfo::VT_SHOPGROUP, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn startTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_ItemData_ShopRelateInfo::VT_STARTTS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ItemData_ShopRelateInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_ItemDropShopType>("shopType", Self::VT_SHOPTYPE, false)?
            .visit_field::<i32>("shopGroup", Self::VT_SHOPGROUP, false)?
            .visit_field::<i64>("startTs", Self::VT_STARTTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ItemData_ShopRelateInfoArgs {
    pub shopType: enum__Torappu_ItemDropShopType,
    pub shopGroup: i32,
    pub startTs: i64,
}
impl<'a> Default for clz_Torappu_ItemData_ShopRelateInfoArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ItemData_ShopRelateInfoArgs {
            shopType: enum__Torappu_ItemDropShopType::HGGSHD_SHOP,
            shopGroup: 0,
            startTs: 0,
        }
    }
}

impl Serialize for clz_Torappu_ItemData_ShopRelateInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ItemData_ShopRelateInfo", 3)?;
        s.serialize_field("shopType", &self.shopType())?;
        s.serialize_field("shopGroup", &self.shopGroup())?;
        s.serialize_field("startTs", &self.startTs())?;
        s.end()
    }
}

pub struct clz_Torappu_ItemData_ShopRelateInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ItemData_ShopRelateInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_shopType(&mut self, shopType: enum__Torappu_ItemDropShopType) {
        self.fbb_.push_slot::<enum__Torappu_ItemDropShopType>(
            clz_Torappu_ItemData_ShopRelateInfo::VT_SHOPTYPE,
            shopType,
            enum__Torappu_ItemDropShopType::HGGSHD_SHOP,
        );
    }
    #[inline]
    pub fn add_shopGroup(&mut self, shopGroup: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ItemData_ShopRelateInfo::VT_SHOPGROUP,
            shopGroup,
            0,
        );
    }
    #[inline]
    pub fn add_startTs(&mut self, startTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_ItemData_ShopRelateInfo::VT_STARTTS, startTs, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ItemData_ShopRelateInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ItemData_ShopRelateInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ItemData_ShopRelateInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ItemData_ShopRelateInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ItemData_ShopRelateInfo");
        ds.field("shopType", &self.shopType());
        ds.field("shopGroup", &self.shopGroup());
        ds.field("startTs", &self.startTs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ItemData_ShopRelateInfoT {
    pub shopType: enum__Torappu_ItemDropShopType,
    pub shopGroup: i32,
    pub startTs: i64,
}
impl Default for clz_Torappu_ItemData_ShopRelateInfoT {
    fn default() -> Self {
        Self {
            shopType: enum__Torappu_ItemDropShopType::HGGSHD_SHOP,
            shopGroup: 0,
            startTs: 0,
        }
    }
}
impl clz_Torappu_ItemData_ShopRelateInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemData_ShopRelateInfo<'b>> {
        let shopType = self.shopType;
        let shopGroup = self.shopGroup;
        let startTs = self.startTs;
        clz_Torappu_ItemData_ShopRelateInfo::create(
            _fbb,
            &clz_Torappu_ItemData_ShopRelateInfoArgs {
                shopType,
                shopGroup,
                startTs,
            },
        )
    }
}
pub enum clz_Torappu_ItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ItemData<'a> {
    type Inner = clz_Torappu_ItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ItemData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 8;
    pub const VT_RARITY: flatbuffers::VOffsetT = 10;
    pub const VT_ICONID: flatbuffers::VOffsetT = 12;
    pub const VT_OVERRIDEBKG: flatbuffers::VOffsetT = 14;
    pub const VT_STACKICONID: flatbuffers::VOffsetT = 16;
    pub const VT_SORTID: flatbuffers::VOffsetT = 18;
    pub const VT_USAGE: flatbuffers::VOffsetT = 20;
    pub const VT_OBTAINAPPROACH: flatbuffers::VOffsetT = 22;
    pub const VT_HIDEINITEMGET: flatbuffers::VOffsetT = 24;
    pub const VT_CLASSIFYTYPE: flatbuffers::VOffsetT = 26;
    pub const VT_ITEMTYPE: flatbuffers::VOffsetT = 28;
    pub const VT_STAGEDROPLIST: flatbuffers::VOffsetT = 30;
    pub const VT_BUILDINGPRODUCTLIST: flatbuffers::VOffsetT = 32;
    pub const VT_VOUCHERRELATELIST: flatbuffers::VOffsetT = 34;
    pub const VT_SHOPRELATEINFOLIST: flatbuffers::VOffsetT = 36;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemData<'bldr>> {
        let mut builder = clz_Torappu_ItemDataBuilder::new(_fbb);
        if let Some(x) = args.shopRelateInfoList {
            builder.add_shopRelateInfoList(x);
        }
        if let Some(x) = args.voucherRelateList {
            builder.add_voucherRelateList(x);
        }
        if let Some(x) = args.buildingProductList {
            builder.add_buildingProductList(x);
        }
        if let Some(x) = args.stageDropList {
            builder.add_stageDropList(x);
        }
        builder.add_itemType(args.itemType);
        builder.add_classifyType(args.classifyType);
        if let Some(x) = args.obtainApproach {
            builder.add_obtainApproach(x);
        }
        if let Some(x) = args.usage {
            builder.add_usage(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.stackIconId {
            builder.add_stackIconId(x);
        }
        if let Some(x) = args.overrideBkg {
            builder.add_overrideBkg(x);
        }
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        builder.add_rarity(args.rarity);
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.add_hideInItemGet(args.hideInItemGet);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ItemDataT {
        let itemId = self.itemId().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let rarity = self.rarity();
        let iconId = self.iconId().map(|x| x.to_string());
        let overrideBkg = self.overrideBkg().map(|x| x.to_string());
        let stackIconId = self.stackIconId().map(|x| x.to_string());
        let sortId = self.sortId();
        let usage = self.usage().map(|x| x.to_string());
        let obtainApproach = self.obtainApproach().map(|x| x.to_string());
        let hideInItemGet = self.hideInItemGet();
        let classifyType = self.classifyType();
        let itemType = self.itemType();
        let stageDropList = self
            .stageDropList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let buildingProductList = self
            .buildingProductList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let voucherRelateList = self
            .voucherRelateList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let shopRelateInfoList = self
            .shopRelateInfoList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ItemDataT {
            itemId,
            name,
            description,
            rarity,
            iconId,
            overrideBkg,
            stackIconId,
            sortId,
            usage,
            obtainApproach,
            hideInItemGet,
            classifyType,
            itemType,
            stageDropList,
            buildingProductList,
            voucherRelateList,
            shopRelateInfoList,
        }
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_ItemData::VT_ITEMID, None)
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_ItemData::VT_NAME, None)
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ItemData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn rarity(&self) -> enum__Torappu_ItemRarity {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemRarity>(
                    clz_Torappu_ItemData::VT_RARITY,
                    Some(enum__Torappu_ItemRarity::TIER_1),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_ItemData::VT_ICONID, None)
        }
    }
    #[inline]
    pub fn overrideBkg(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ItemData::VT_OVERRIDEBKG,
                None,
            )
        }
    }
    #[inline]
    pub fn stackIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ItemData::VT_STACKICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ItemData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn usage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_ItemData::VT_USAGE, None)
        }
    }
    #[inline]
    pub fn obtainApproach(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ItemData::VT_OBTAINAPPROACH,
                None,
            )
        }
    }
    #[inline]
    pub fn hideInItemGet(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_ItemData::VT_HIDEINITEMGET, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn classifyType(&self) -> enum__Torappu_ItemClassifyType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemClassifyType>(
                    clz_Torappu_ItemData::VT_CLASSIFYTYPE,
                    Some(enum__Torappu_ItemClassifyType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn itemType(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_ItemData::VT_ITEMTYPE,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn stageDropList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_ItemData_StageDropInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ItemData_StageDropInfo>,
                >,
            >>(clz_Torappu_ItemData::VT_STAGEDROPLIST, None)
        }
    }
    #[inline]
    pub fn buildingProductList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_ItemData_BuildingProductInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ItemData_BuildingProductInfo>,
                >,
            >>(clz_Torappu_ItemData::VT_BUILDINGPRODUCTLIST, None)
        }
    }
    #[inline]
    pub fn voucherRelateList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_ItemData_VoucherRelateInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ItemData_VoucherRelateInfo>,
                >,
            >>(clz_Torappu_ItemData::VT_VOUCHERRELATELIST, None)
        }
    }
    #[inline]
    pub fn shopRelateInfoList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_ItemData_ShopRelateInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ItemData_ShopRelateInfo>,
                >,
            >>(clz_Torappu_ItemData::VT_SHOPRELATEINFOLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<enum__Torappu_ItemRarity>("rarity", Self::VT_RARITY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "overrideBkg",
                Self::VT_OVERRIDEBKG,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "stackIconId",
                Self::VT_STACKICONID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("usage", Self::VT_USAGE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "obtainApproach",
                Self::VT_OBTAINAPPROACH,
                false,
            )?
            .visit_field::<bool>("hideInItemGet", Self::VT_HIDEINITEMGET, false)?
            .visit_field::<enum__Torappu_ItemClassifyType>(
                "classifyType",
                Self::VT_CLASSIFYTYPE,
                false,
            )?
            .visit_field::<enum__Torappu_ItemType>("itemType", Self::VT_ITEMTYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ItemData_StageDropInfo>,
                >,
            >>("stageDropList", Self::VT_STAGEDROPLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ItemData_BuildingProductInfo>,
                >,
            >>("buildingProductList", Self::VT_BUILDINGPRODUCTLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ItemData_VoucherRelateInfo>,
                >,
            >>("voucherRelateList", Self::VT_VOUCHERRELATELIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ItemData_ShopRelateInfo>,
                >,
            >>("shopRelateInfoList", Self::VT_SHOPRELATEINFOLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ItemDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rarity: enum__Torappu_ItemRarity,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub overrideBkg: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stackIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub usage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub obtainApproach: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hideInItemGet: bool,
    pub classifyType: enum__Torappu_ItemClassifyType,
    pub itemType: enum__Torappu_ItemType,
    pub stageDropList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_ItemData_StageDropInfo<'a>>,
            >,
        >,
    >,
    pub buildingProductList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_ItemData_BuildingProductInfo<'a>>,
            >,
        >,
    >,
    pub voucherRelateList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_ItemData_VoucherRelateInfo<'a>>,
            >,
        >,
    >,
    pub shopRelateInfoList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_ItemData_ShopRelateInfo<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ItemDataArgs {
            itemId: None,
            name: None,
            description: None,
            rarity: enum__Torappu_ItemRarity::TIER_1,
            iconId: None,
            overrideBkg: None,
            stackIconId: None,
            sortId: 0,
            usage: None,
            obtainApproach: None,
            hideInItemGet: false,
            classifyType: enum__Torappu_ItemClassifyType::NONE,
            itemType: enum__Torappu_ItemType::NONE,
            stageDropList: None,
            buildingProductList: None,
            voucherRelateList: None,
            shopRelateInfoList: None,
        }
    }
}

impl Serialize for clz_Torappu_ItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ItemData", 17)?;
        if let Some(f) = self.itemId() {
            s.serialize_field("itemId", &f)?;
        } else {
            s.skip_field("itemId")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        s.serialize_field("rarity", &self.rarity())?;
        if let Some(f) = self.iconId() {
            s.serialize_field("iconId", &f)?;
        } else {
            s.skip_field("iconId")?;
        }
        if let Some(f) = self.overrideBkg() {
            s.serialize_field("overrideBkg", &f)?;
        } else {
            s.skip_field("overrideBkg")?;
        }
        if let Some(f) = self.stackIconId() {
            s.serialize_field("stackIconId", &f)?;
        } else {
            s.skip_field("stackIconId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.usage() {
            s.serialize_field("usage", &f)?;
        } else {
            s.skip_field("usage")?;
        }
        if let Some(f) = self.obtainApproach() {
            s.serialize_field("obtainApproach", &f)?;
        } else {
            s.skip_field("obtainApproach")?;
        }
        s.serialize_field("hideInItemGet", &self.hideInItemGet())?;
        s.serialize_field("classifyType", &self.classifyType())?;
        s.serialize_field("itemType", &self.itemType())?;
        if let Some(f) = self.stageDropList() {
            s.serialize_field("stageDropList", &f)?;
        } else {
            s.skip_field("stageDropList")?;
        }
        if let Some(f) = self.buildingProductList() {
            s.serialize_field("buildingProductList", &f)?;
        } else {
            s.skip_field("buildingProductList")?;
        }
        if let Some(f) = self.voucherRelateList() {
            s.serialize_field("voucherRelateList", &f)?;
        } else {
            s.skip_field("voucherRelateList")?;
        }
        if let Some(f) = self.shopRelateInfoList() {
            s.serialize_field("shopRelateInfoList", &f)?;
        } else {
            s.skip_field("shopRelateInfoList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ItemDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ItemData::VT_ITEMID, itemId);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ItemData::VT_NAME, name);
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ItemData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_rarity(&mut self, rarity: enum__Torappu_ItemRarity) {
        self.fbb_.push_slot::<enum__Torappu_ItemRarity>(
            clz_Torappu_ItemData::VT_RARITY,
            rarity,
            enum__Torappu_ItemRarity::TIER_1,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ItemData::VT_ICONID, iconId);
    }
    #[inline]
    pub fn add_overrideBkg(&mut self, overrideBkg: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ItemData::VT_OVERRIDEBKG,
            overrideBkg,
        );
    }
    #[inline]
    pub fn add_stackIconId(&mut self, stackIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ItemData::VT_STACKICONID,
            stackIconId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ItemData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_usage(&mut self, usage: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ItemData::VT_USAGE, usage);
    }
    #[inline]
    pub fn add_obtainApproach(&mut self, obtainApproach: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ItemData::VT_OBTAINAPPROACH,
            obtainApproach,
        );
    }
    #[inline]
    pub fn add_hideInItemGet(&mut self, hideInItemGet: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_ItemData::VT_HIDEINITEMGET, hideInItemGet, false);
    }
    #[inline]
    pub fn add_classifyType(&mut self, classifyType: enum__Torappu_ItemClassifyType) {
        self.fbb_.push_slot::<enum__Torappu_ItemClassifyType>(
            clz_Torappu_ItemData::VT_CLASSIFYTYPE,
            classifyType,
            enum__Torappu_ItemClassifyType::NONE,
        );
    }
    #[inline]
    pub fn add_itemType(&mut self, itemType: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_ItemData::VT_ITEMTYPE,
            itemType,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn add_stageDropList(
        &mut self,
        stageDropList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_ItemData_StageDropInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ItemData::VT_STAGEDROPLIST,
            stageDropList,
        );
    }
    #[inline]
    pub fn add_buildingProductList(
        &mut self,
        buildingProductList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_ItemData_BuildingProductInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ItemData::VT_BUILDINGPRODUCTLIST,
            buildingProductList,
        );
    }
    #[inline]
    pub fn add_voucherRelateList(
        &mut self,
        voucherRelateList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_ItemData_VoucherRelateInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ItemData::VT_VOUCHERRELATELIST,
            voucherRelateList,
        );
    }
    #[inline]
    pub fn add_shopRelateInfoList(
        &mut self,
        shopRelateInfoList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_ItemData_ShopRelateInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ItemData::VT_SHOPRELATEINFOLIST,
            shopRelateInfoList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ItemData");
        ds.field("itemId", &self.itemId());
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.field("rarity", &self.rarity());
        ds.field("iconId", &self.iconId());
        ds.field("overrideBkg", &self.overrideBkg());
        ds.field("stackIconId", &self.stackIconId());
        ds.field("sortId", &self.sortId());
        ds.field("usage", &self.usage());
        ds.field("obtainApproach", &self.obtainApproach());
        ds.field("hideInItemGet", &self.hideInItemGet());
        ds.field("classifyType", &self.classifyType());
        ds.field("itemType", &self.itemType());
        ds.field("stageDropList", &self.stageDropList());
        ds.field("buildingProductList", &self.buildingProductList());
        ds.field("voucherRelateList", &self.voucherRelateList());
        ds.field("shopRelateInfoList", &self.shopRelateInfoList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ItemDataT {
    pub itemId: Option<String>,
    pub name: Option<String>,
    pub description: Option<String>,
    pub rarity: enum__Torappu_ItemRarity,
    pub iconId: Option<String>,
    pub overrideBkg: Option<String>,
    pub stackIconId: Option<String>,
    pub sortId: i32,
    pub usage: Option<String>,
    pub obtainApproach: Option<String>,
    pub hideInItemGet: bool,
    pub classifyType: enum__Torappu_ItemClassifyType,
    pub itemType: enum__Torappu_ItemType,
    pub stageDropList: Option<Vec<clz_Torappu_ItemData_StageDropInfoT>>,
    pub buildingProductList: Option<Vec<clz_Torappu_ItemData_BuildingProductInfoT>>,
    pub voucherRelateList: Option<Vec<clz_Torappu_ItemData_VoucherRelateInfoT>>,
    pub shopRelateInfoList: Option<Vec<clz_Torappu_ItemData_ShopRelateInfoT>>,
}
impl Default for clz_Torappu_ItemDataT {
    fn default() -> Self {
        Self {
            itemId: None,
            name: None,
            description: None,
            rarity: enum__Torappu_ItemRarity::TIER_1,
            iconId: None,
            overrideBkg: None,
            stackIconId: None,
            sortId: 0,
            usage: None,
            obtainApproach: None,
            hideInItemGet: false,
            classifyType: enum__Torappu_ItemClassifyType::NONE,
            itemType: enum__Torappu_ItemType::NONE,
            stageDropList: None,
            buildingProductList: None,
            voucherRelateList: None,
            shopRelateInfoList: None,
        }
    }
}
impl clz_Torappu_ItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemData<'b>> {
        let itemId = self.itemId.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let rarity = self.rarity;
        let iconId = self.iconId.as_ref().map(|x| _fbb.create_string(x));
        let overrideBkg = self.overrideBkg.as_ref().map(|x| _fbb.create_string(x));
        let stackIconId = self.stackIconId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let usage = self.usage.as_ref().map(|x| _fbb.create_string(x));
        let obtainApproach = self.obtainApproach.as_ref().map(|x| _fbb.create_string(x));
        let hideInItemGet = self.hideInItemGet;
        let classifyType = self.classifyType;
        let itemType = self.itemType;
        let stageDropList = self.stageDropList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let buildingProductList = self.buildingProductList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let voucherRelateList = self.voucherRelateList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let shopRelateInfoList = self.shopRelateInfoList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ItemData::create(
            _fbb,
            &clz_Torappu_ItemDataArgs {
                itemId,
                name,
                description,
                rarity,
                iconId,
                overrideBkg,
                stackIconId,
                sortId,
                usage,
                obtainApproach,
                hideInItemGet,
                classifyType,
                itemType,
                stageDropList,
                buildingProductList,
                voucherRelateList,
                shopRelateInfoList,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ItemData<'a> {
    type Inner = dict__string__clz_Torappu_ItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ItemDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ItemDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_ItemData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ItemData>>(
                    dict__string__clz_Torappu_ItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_ItemData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_ItemData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ItemData>>(
                dict__string__clz_Torappu_ItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_ItemData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ItemDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ItemDataT>>,
}
impl Default for dict__string__clz_Torappu_ItemDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ItemData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ItemData::create(
            _fbb,
            &dict__string__clz_Torappu_ItemDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ExpItemFeatureOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ExpItemFeature<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ExpItemFeature<'a> {
    type Inner = clz_Torappu_ExpItemFeature<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ExpItemFeature<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_GAINEXP: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ExpItemFeature { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ExpItemFeatureArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ExpItemFeature<'bldr>> {
        let mut builder = clz_Torappu_ExpItemFeatureBuilder::new(_fbb);
        builder.add_gainExp(args.gainExp);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ExpItemFeatureT {
        let id = self.id().map(|x| x.to_string());
        let gainExp = self.gainExp();
        clz_Torappu_ExpItemFeatureT { id, gainExp }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_ExpItemFeature::VT_ID, None)
        }
    }
    #[inline]
    pub fn gainExp(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ExpItemFeature::VT_GAINEXP, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ExpItemFeature<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("gainExp", Self::VT_GAINEXP, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ExpItemFeatureArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gainExp: i32,
}
impl<'a> Default for clz_Torappu_ExpItemFeatureArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ExpItemFeatureArgs {
            id: None,
            gainExp: 0,
        }
    }
}

impl Serialize for clz_Torappu_ExpItemFeature<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ExpItemFeature", 2)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("gainExp", &self.gainExp())?;
        s.end()
    }
}

pub struct clz_Torappu_ExpItemFeatureBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ExpItemFeatureBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ExpItemFeature::VT_ID, id);
    }
    #[inline]
    pub fn add_gainExp(&mut self, gainExp: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ExpItemFeature::VT_GAINEXP, gainExp, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ExpItemFeatureBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ExpItemFeatureBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ExpItemFeature<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ExpItemFeature<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ExpItemFeature");
        ds.field("id", &self.id());
        ds.field("gainExp", &self.gainExp());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ExpItemFeatureT {
    pub id: Option<String>,
    pub gainExp: i32,
}
impl Default for clz_Torappu_ExpItemFeatureT {
    fn default() -> Self {
        Self {
            id: None,
            gainExp: 0,
        }
    }
}
impl clz_Torappu_ExpItemFeatureT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ExpItemFeature<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let gainExp = self.gainExp;
        clz_Torappu_ExpItemFeature::create(_fbb, &clz_Torappu_ExpItemFeatureArgs { id, gainExp })
    }
}
pub enum dict__string__clz_Torappu_ExpItemFeatureOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ExpItemFeature<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ExpItemFeature<'a> {
    type Inner = dict__string__clz_Torappu_ExpItemFeature<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ExpItemFeature<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ExpItemFeature { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ExpItemFeatureArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ExpItemFeature<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ExpItemFeatureBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ExpItemFeatureT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ExpItemFeatureT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ExpItemFeature::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_ExpItemFeature) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ExpItemFeature<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ExpItemFeature>>(
                    dict__string__clz_Torappu_ExpItemFeature::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ExpItemFeature<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ExpItemFeature>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ExpItemFeatureArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ExpItemFeature<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ExpItemFeatureArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ExpItemFeatureArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ExpItemFeature<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_ExpItemFeature", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ExpItemFeatureBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ExpItemFeatureBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ExpItemFeature::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_ExpItemFeature<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ExpItemFeature>>(
                dict__string__clz_Torappu_ExpItemFeature::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ExpItemFeatureBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ExpItemFeatureBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ExpItemFeature<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_ExpItemFeature::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ExpItemFeature<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ExpItemFeature");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ExpItemFeatureT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ExpItemFeatureT>>,
}
impl Default for dict__string__clz_Torappu_ExpItemFeatureT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ExpItemFeatureT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ExpItemFeature<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ExpItemFeature::create(
            _fbb,
            &dict__string__clz_Torappu_ExpItemFeatureArgs { key, value },
        )
    }
}
pub enum dict__string__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__string<'a> {
    type Inner = dict__string__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__string<'bldr>> {
        let mut builder = dict__string__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__stringT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| x.to_string());
        dict__string__stringT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__string::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__string::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__stringArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for dict__string__stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__stringArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__string<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__string", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__stringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__stringBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__string::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__string::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, dict__string__string::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__stringT {
    pub key: String,
    pub value: Option<String>,
}
impl Default for dict__string__stringT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__string<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| _fbb.create_string(x));
        dict__string__string::create(_fbb, &dict__string__stringArgs { key, value })
    }
}
pub enum dict__int__list_dict__string__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__list_dict__string__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__int__list_dict__string__string<'a> {
    type Inner = dict__int__list_dict__string__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__int__list_dict__string__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__list_dict__string__string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__list_dict__string__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__int__list_dict__string__string<'bldr>> {
        let mut builder = dict__int__list_dict__string__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__int__list_dict__string__stringT {
        let key = self.key();
        let value = self.value().map(|x| x.iter().map(|t| t.unpack()).collect());
        dict__int__list_dict__string__stringT { key, value }
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(dict__int__list_dict__string__string::VT_KEY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__int__list_dict__string__string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(dict__int__list_dict__string__string::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__int__list_dict__string__string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__int__list_dict__string__stringArgs<'a> {
    pub key: i32,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>,
        >,
    >,
}
impl<'a> Default for dict__int__list_dict__string__stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__int__list_dict__string__stringArgs {
            key: 0,
            value: None,
        }
    }
}

impl Serialize for dict__int__list_dict__string__string<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__int__list_dict__string__string", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__int__list_dict__string__stringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__int__list_dict__string__stringBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_
            .push_slot::<i32>(dict__int__list_dict__string__string::VT_KEY, key, 0);
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__int__list_dict__string__string::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__list_dict__string__stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__int__list_dict__string__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__int__list_dict__string__string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__int__list_dict__string__string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__int__list_dict__string__string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__int__list_dict__string__stringT {
    pub key: i32,
    pub value: Option<Vec<dict__string__stringT>>,
}
impl Default for dict__int__list_dict__string__stringT {
    fn default() -> Self {
        Self {
            key: 0,
            value: None,
        }
    }
}
impl dict__int__list_dict__string__stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__int__list_dict__string__string<'b>> {
        let key = self.key;
        let value = self.value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        dict__int__list_dict__string__string::create(
            _fbb,
            &dict__int__list_dict__string__stringArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ApSupplyFeatureOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ApSupplyFeature<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ApSupplyFeature<'a> {
    type Inner = clz_Torappu_ApSupplyFeature<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ApSupplyFeature<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_AP: flatbuffers::VOffsetT = 6;
    pub const VT_HASTS: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ApSupplyFeature { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ApSupplyFeatureArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ApSupplyFeature<'bldr>> {
        let mut builder = clz_Torappu_ApSupplyFeatureBuilder::new(_fbb);
        builder.add_ap(args.ap);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_hasTs(args.hasTs);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ApSupplyFeatureT {
        let id = self.id().map(|x| x.to_string());
        let ap = self.ap();
        let hasTs = self.hasTs();
        clz_Torappu_ApSupplyFeatureT { id, ap, hasTs }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_ApSupplyFeature::VT_ID, None)
        }
    }
    #[inline]
    pub fn ap(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ApSupplyFeature::VT_AP, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn hasTs(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_ApSupplyFeature::VT_HASTS, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ApSupplyFeature<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("ap", Self::VT_AP, false)?
            .visit_field::<bool>("hasTs", Self::VT_HASTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ApSupplyFeatureArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ap: i32,
    pub hasTs: bool,
}
impl<'a> Default for clz_Torappu_ApSupplyFeatureArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ApSupplyFeatureArgs {
            id: None,
            ap: 0,
            hasTs: false,
        }
    }
}

impl Serialize for clz_Torappu_ApSupplyFeature<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ApSupplyFeature", 3)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("ap", &self.ap())?;
        s.serialize_field("hasTs", &self.hasTs())?;
        s.end()
    }
}

pub struct clz_Torappu_ApSupplyFeatureBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ApSupplyFeatureBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ApSupplyFeature::VT_ID, id);
    }
    #[inline]
    pub fn add_ap(&mut self, ap: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ApSupplyFeature::VT_AP, ap, 0);
    }
    #[inline]
    pub fn add_hasTs(&mut self, hasTs: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_ApSupplyFeature::VT_HASTS, hasTs, false);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ApSupplyFeatureBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ApSupplyFeatureBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ApSupplyFeature<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ApSupplyFeature<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ApSupplyFeature");
        ds.field("id", &self.id());
        ds.field("ap", &self.ap());
        ds.field("hasTs", &self.hasTs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ApSupplyFeatureT {
    pub id: Option<String>,
    pub ap: i32,
    pub hasTs: bool,
}
impl Default for clz_Torappu_ApSupplyFeatureT {
    fn default() -> Self {
        Self {
            id: None,
            ap: 0,
            hasTs: false,
        }
    }
}
impl clz_Torappu_ApSupplyFeatureT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ApSupplyFeature<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let ap = self.ap;
        let hasTs = self.hasTs;
        clz_Torappu_ApSupplyFeature::create(
            _fbb,
            &clz_Torappu_ApSupplyFeatureArgs { id, ap, hasTs },
        )
    }
}
pub enum dict__string__clz_Torappu_ApSupplyFeatureOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ApSupplyFeature<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ApSupplyFeature<'a> {
    type Inner = dict__string__clz_Torappu_ApSupplyFeature<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ApSupplyFeature<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ApSupplyFeature { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ApSupplyFeatureArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ApSupplyFeature<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ApSupplyFeatureBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ApSupplyFeatureT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ApSupplyFeatureT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ApSupplyFeature::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_ApSupplyFeature) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ApSupplyFeature<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ApSupplyFeature>>(
                    dict__string__clz_Torappu_ApSupplyFeature::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ApSupplyFeature<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ApSupplyFeature>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ApSupplyFeatureArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ApSupplyFeature<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ApSupplyFeatureArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ApSupplyFeatureArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ApSupplyFeature<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_ApSupplyFeature", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ApSupplyFeatureBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ApSupplyFeatureBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ApSupplyFeature::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_ApSupplyFeature<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ApSupplyFeature>>(
                dict__string__clz_Torappu_ApSupplyFeature::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ApSupplyFeatureBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ApSupplyFeatureBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ApSupplyFeature<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_ApSupplyFeature::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ApSupplyFeature<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ApSupplyFeature");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ApSupplyFeatureT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ApSupplyFeatureT>>,
}
impl Default for dict__string__clz_Torappu_ApSupplyFeatureT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ApSupplyFeatureT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ApSupplyFeature<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ApSupplyFeature::create(
            _fbb,
            &dict__string__clz_Torappu_ApSupplyFeatureArgs { key, value },
        )
    }
}
pub enum clz_Torappu_CharVoucherItemFeatureOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharVoucherItemFeature<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharVoucherItemFeature<'a> {
    type Inner = clz_Torappu_CharVoucherItemFeature<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharVoucherItemFeature<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DISPLAYTYPE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharVoucherItemFeature { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharVoucherItemFeatureArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharVoucherItemFeature<'bldr>> {
        let mut builder = clz_Torappu_CharVoucherItemFeatureBuilder::new(_fbb);
        builder.add_displayType(args.displayType);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharVoucherItemFeatureT {
        let id = self.id().map(|x| x.to_string());
        let displayType = self.displayType();
        clz_Torappu_CharVoucherItemFeatureT { id, displayType }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharVoucherItemFeature::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn displayType(&self) -> enum__Torappu_VoucherDisplayType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_VoucherDisplayType>(
                    clz_Torappu_CharVoucherItemFeature::VT_DISPLAYTYPE,
                    Some(enum__Torappu_VoucherDisplayType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharVoucherItemFeature<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_VoucherDisplayType>(
                "displayType",
                Self::VT_DISPLAYTYPE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharVoucherItemFeatureArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub displayType: enum__Torappu_VoucherDisplayType,
}
impl<'a> Default for clz_Torappu_CharVoucherItemFeatureArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharVoucherItemFeatureArgs {
            id: None,
            displayType: enum__Torappu_VoucherDisplayType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_CharVoucherItemFeature<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharVoucherItemFeature", 2)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("displayType", &self.displayType())?;
        s.end()
    }
}

pub struct clz_Torappu_CharVoucherItemFeatureBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharVoucherItemFeatureBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharVoucherItemFeature::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_displayType(&mut self, displayType: enum__Torappu_VoucherDisplayType) {
        self.fbb_.push_slot::<enum__Torappu_VoucherDisplayType>(
            clz_Torappu_CharVoucherItemFeature::VT_DISPLAYTYPE,
            displayType,
            enum__Torappu_VoucherDisplayType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharVoucherItemFeatureBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharVoucherItemFeatureBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharVoucherItemFeature<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharVoucherItemFeature<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharVoucherItemFeature");
        ds.field("id", &self.id());
        ds.field("displayType", &self.displayType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharVoucherItemFeatureT {
    pub id: Option<String>,
    pub displayType: enum__Torappu_VoucherDisplayType,
}
impl Default for clz_Torappu_CharVoucherItemFeatureT {
    fn default() -> Self {
        Self {
            id: None,
            displayType: enum__Torappu_VoucherDisplayType::NONE,
        }
    }
}
impl clz_Torappu_CharVoucherItemFeatureT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharVoucherItemFeature<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let displayType = self.displayType;
        clz_Torappu_CharVoucherItemFeature::create(
            _fbb,
            &clz_Torappu_CharVoucherItemFeatureArgs { id, displayType },
        )
    }
}
pub enum dict__string__clz_Torappu_CharVoucherItemFeatureOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_CharVoucherItemFeature<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_CharVoucherItemFeature<'a> {
    type Inner = dict__string__clz_Torappu_CharVoucherItemFeature<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_CharVoucherItemFeature<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_CharVoucherItemFeature { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_CharVoucherItemFeatureArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharVoucherItemFeature<'bldr>> {
        let mut builder = dict__string__clz_Torappu_CharVoucherItemFeatureBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_CharVoucherItemFeatureT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_CharVoucherItemFeatureT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_CharVoucherItemFeature::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_CharVoucherItemFeature,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_CharVoucherItemFeature<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharVoucherItemFeature>>(
                    dict__string__clz_Torappu_CharVoucherItemFeature::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_CharVoucherItemFeature<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharVoucherItemFeature>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_CharVoucherItemFeatureArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_CharVoucherItemFeature<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_CharVoucherItemFeatureArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_CharVoucherItemFeatureArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_CharVoucherItemFeature<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_CharVoucherItemFeature", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_CharVoucherItemFeatureBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_CharVoucherItemFeatureBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_CharVoucherItemFeature::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_CharVoucherItemFeature<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharVoucherItemFeature>>(
                dict__string__clz_Torappu_CharVoucherItemFeature::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_CharVoucherItemFeatureBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_CharVoucherItemFeatureBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharVoucherItemFeature<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_CharVoucherItemFeature::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_CharVoucherItemFeature<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_CharVoucherItemFeature");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_CharVoucherItemFeatureT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_CharVoucherItemFeatureT>>,
}
impl Default for dict__string__clz_Torappu_CharVoucherItemFeatureT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_CharVoucherItemFeatureT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_CharVoucherItemFeature<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_CharVoucherItemFeature::create(
            _fbb,
            &dict__string__clz_Torappu_CharVoucherItemFeatureArgs { key, value },
        )
    }
}
pub enum dict__string__intOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__int<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__int<'a> {
    type Inner = dict__string__int<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__int<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__int { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__intArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__int<'bldr>> {
        let mut builder = dict__string__intBuilder::new(_fbb);
        builder.add_value(args.value);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__intT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value();
        dict__string__intT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__int::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__int) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(dict__string__int::VT_VALUE, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for dict__string__int<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<i32>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__intArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: i32,
}
impl<'a> Default for dict__string__intArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__intArgs {
            key: None, // required field
            value: 0,
        }
    }
}

impl Serialize for dict__string__int<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__int", 2)?;
        s.serialize_field("key", &self.key())?;
        s.serialize_field("value", &self.value())?;
        s.end()
    }
}

pub struct dict__string__intBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__intBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__int::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(&mut self, value: i32) {
        self.fbb_
            .push_slot::<i32>(dict__string__int::VT_VALUE, value, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__intBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__intBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__int<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, dict__string__int::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__int<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__int");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__intT {
    pub key: String,
    pub value: i32,
}
impl Default for dict__string__intT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: 0,
        }
    }
}
impl dict__string__intT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__int<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value;
        dict__string__int::create(_fbb, &dict__string__intArgs { key, value })
    }
}
pub enum clz_Torappu_ItemBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ItemBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ItemBundle<'a> {
    type Inner = clz_Torappu_ItemBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ItemBundle<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_COUNT: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ItemBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ItemBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'bldr>> {
        let mut builder = clz_Torappu_ItemBundleBuilder::new(_fbb);
        builder.add_type_(args.type_);
        builder.add_count(args.count);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ItemBundleT {
        let id = self.id().map(|x| x.to_string());
        let count = self.count();
        let type_ = self.type_();
        clz_Torappu_ItemBundleT { id, count, type_ }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_ItemBundle::VT_ID, None)
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ItemBundle::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_ItemBundle::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ItemBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ItemBundleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl<'a> Default for clz_Torappu_ItemBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ItemBundleArgs {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_ItemBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ItemBundle", 3)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("count", &self.count())?;
        s.serialize_field("type_", &self.type_())?;
        s.end()
    }
}

pub struct clz_Torappu_ItemBundleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ItemBundle::VT_ID, id);
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ItemBundle::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_ItemBundle::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ItemBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ItemBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ItemBundle");
        ds.field("id", &self.id());
        ds.field("count", &self.count());
        ds.field("type_", &self.type_());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ItemBundleT {
    pub id: Option<String>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl Default for clz_Torappu_ItemBundleT {
    fn default() -> Self {
        Self {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}
impl clz_Torappu_ItemBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let count = self.count;
        let type_ = self.type_;
        clz_Torappu_ItemBundle::create(_fbb, &clz_Torappu_ItemBundleArgs { id, count, type_ })
    }
}
pub enum clz_Torappu_UniCollectionInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_UniCollectionInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_UniCollectionInfo<'a> {
    type Inner = clz_Torappu_UniCollectionInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_UniCollectionInfo<'a> {
    pub const VT_UNICOLLECTIONITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_UNIQUEITEM: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_UniCollectionInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_UniCollectionInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_UniCollectionInfo<'bldr>> {
        let mut builder = clz_Torappu_UniCollectionInfoBuilder::new(_fbb);
        if let Some(x) = args.uniqueItem {
            builder.add_uniqueItem(x);
        }
        if let Some(x) = args.uniCollectionItemId {
            builder.add_uniCollectionItemId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_UniCollectionInfoT {
        let uniCollectionItemId = self.uniCollectionItemId().map(|x| x.to_string());
        let uniqueItem = self
            .uniqueItem()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_UniCollectionInfoT {
            uniCollectionItemId,
            uniqueItem,
        }
    }

    #[inline]
    pub fn uniCollectionItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_UniCollectionInfo::VT_UNICOLLECTIONITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn uniqueItem(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(clz_Torappu_UniCollectionInfo::VT_UNIQUEITEM, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_UniCollectionInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "uniCollectionItemId",
                Self::VT_UNICOLLECTIONITEMID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("uniqueItem", Self::VT_UNIQUEITEM, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_UniCollectionInfoArgs<'a> {
    pub uniCollectionItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub uniqueItem: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_UniCollectionInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_UniCollectionInfoArgs {
            uniCollectionItemId: None,
            uniqueItem: None,
        }
    }
}

impl Serialize for clz_Torappu_UniCollectionInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_UniCollectionInfo", 2)?;
        if let Some(f) = self.uniCollectionItemId() {
            s.serialize_field("uniCollectionItemId", &f)?;
        } else {
            s.skip_field("uniCollectionItemId")?;
        }
        if let Some(f) = self.uniqueItem() {
            s.serialize_field("uniqueItem", &f)?;
        } else {
            s.skip_field("uniqueItem")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_UniCollectionInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_UniCollectionInfoBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_uniCollectionItemId(
        &mut self,
        uniCollectionItemId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_UniCollectionInfo::VT_UNICOLLECTIONITEMID,
            uniCollectionItemId,
        );
    }
    #[inline]
    pub fn add_uniqueItem(
        &mut self,
        uniqueItem: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_UniCollectionInfo::VT_UNIQUEITEM,
            uniqueItem,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_UniCollectionInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_UniCollectionInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_UniCollectionInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_UniCollectionInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_UniCollectionInfo");
        ds.field("uniCollectionItemId", &self.uniCollectionItemId());
        ds.field("uniqueItem", &self.uniqueItem());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_UniCollectionInfoT {
    pub uniCollectionItemId: Option<String>,
    pub uniqueItem: Option<Vec<clz_Torappu_ItemBundleT>>,
}
impl Default for clz_Torappu_UniCollectionInfoT {
    fn default() -> Self {
        Self {
            uniCollectionItemId: None,
            uniqueItem: None,
        }
    }
}
impl clz_Torappu_UniCollectionInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_UniCollectionInfo<'b>> {
        let uniCollectionItemId = self
            .uniCollectionItemId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let uniqueItem = self.uniqueItem.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_UniCollectionInfo::create(
            _fbb,
            &clz_Torappu_UniCollectionInfoArgs {
                uniCollectionItemId,
                uniqueItem,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_UniCollectionInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_UniCollectionInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_UniCollectionInfo<'a> {
    type Inner = dict__string__clz_Torappu_UniCollectionInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_UniCollectionInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_UniCollectionInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_UniCollectionInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_UniCollectionInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_UniCollectionInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_UniCollectionInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_UniCollectionInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_UniCollectionInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_UniCollectionInfo) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_UniCollectionInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_UniCollectionInfo>>(
                    dict__string__clz_Torappu_UniCollectionInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_UniCollectionInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_UniCollectionInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_UniCollectionInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_UniCollectionInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_UniCollectionInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_UniCollectionInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_UniCollectionInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_UniCollectionInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_UniCollectionInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_UniCollectionInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_UniCollectionInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_UniCollectionInfo<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_UniCollectionInfo>>(
                dict__string__clz_Torappu_UniCollectionInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_UniCollectionInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_UniCollectionInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_UniCollectionInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_UniCollectionInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_UniCollectionInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_UniCollectionInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_UniCollectionInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_UniCollectionInfoT>>,
}
impl Default for dict__string__clz_Torappu_UniCollectionInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_UniCollectionInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_UniCollectionInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_UniCollectionInfo::create(
            _fbb,
            &dict__string__clz_Torappu_UniCollectionInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ItemPackInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ItemPackInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ItemPackInfo<'a> {
    type Inner = clz_Torappu_ItemPackInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ItemPackInfo<'a> {
    pub const VT_PACKID: flatbuffers::VOffsetT = 4;
    pub const VT_CONTENT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ItemPackInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ItemPackInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemPackInfo<'bldr>> {
        let mut builder = clz_Torappu_ItemPackInfoBuilder::new(_fbb);
        if let Some(x) = args.content {
            builder.add_content(x);
        }
        if let Some(x) = args.packId {
            builder.add_packId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ItemPackInfoT {
        let packId = self.packId().map(|x| x.to_string());
        let content = self
            .content()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ItemPackInfoT { packId, content }
    }

    #[inline]
    pub fn packId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ItemPackInfo::VT_PACKID,
                None,
            )
        }
    }
    #[inline]
    pub fn content(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(clz_Torappu_ItemPackInfo::VT_CONTENT, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ItemPackInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("packId", Self::VT_PACKID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("content", Self::VT_CONTENT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ItemPackInfoArgs<'a> {
    pub packId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub content: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ItemPackInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ItemPackInfoArgs {
            packId: None,
            content: None,
        }
    }
}

impl Serialize for clz_Torappu_ItemPackInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ItemPackInfo", 2)?;
        if let Some(f) = self.packId() {
            s.serialize_field("packId", &f)?;
        } else {
            s.skip_field("packId")?;
        }
        if let Some(f) = self.content() {
            s.serialize_field("content", &f)?;
        } else {
            s.skip_field("content")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ItemPackInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ItemPackInfoBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_packId(&mut self, packId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ItemPackInfo::VT_PACKID,
            packId,
        );
    }
    #[inline]
    pub fn add_content(
        &mut self,
        content: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ItemPackInfo::VT_CONTENT,
            content,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ItemPackInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ItemPackInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ItemPackInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ItemPackInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ItemPackInfo");
        ds.field("packId", &self.packId());
        ds.field("content", &self.content());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ItemPackInfoT {
    pub packId: Option<String>,
    pub content: Option<Vec<clz_Torappu_ItemBundleT>>,
}
impl Default for clz_Torappu_ItemPackInfoT {
    fn default() -> Self {
        Self {
            packId: None,
            content: None,
        }
    }
}
impl clz_Torappu_ItemPackInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemPackInfo<'b>> {
        let packId = self.packId.as_ref().map(|x| _fbb.create_string(x));
        let content = self.content.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ItemPackInfo::create(_fbb, &clz_Torappu_ItemPackInfoArgs { packId, content })
    }
}
pub enum dict__string__clz_Torappu_ItemPackInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ItemPackInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ItemPackInfo<'a> {
    type Inner = dict__string__clz_Torappu_ItemPackInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ItemPackInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ItemPackInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ItemPackInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ItemPackInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ItemPackInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ItemPackInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ItemPackInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ItemPackInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_ItemPackInfo) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ItemPackInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ItemPackInfo>>(
                    dict__string__clz_Torappu_ItemPackInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ItemPackInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ItemPackInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ItemPackInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ItemPackInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ItemPackInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ItemPackInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ItemPackInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_ItemPackInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ItemPackInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ItemPackInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ItemPackInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_ItemPackInfo<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ItemPackInfo>>(
                dict__string__clz_Torappu_ItemPackInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ItemPackInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ItemPackInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ItemPackInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_ItemPackInfo::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ItemPackInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ItemPackInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ItemPackInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ItemPackInfoT>>,
}
impl Default for dict__string__clz_Torappu_ItemPackInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ItemPackInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ItemPackInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ItemPackInfo::create(
            _fbb,
            &dict__string__clz_Torappu_ItemPackInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_FullPotentialCharacterInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_FullPotentialCharacterInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_FullPotentialCharacterInfo<'a> {
    type Inner = clz_Torappu_FullPotentialCharacterInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_FullPotentialCharacterInfo<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_TS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_FullPotentialCharacterInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_FullPotentialCharacterInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_FullPotentialCharacterInfo<'bldr>> {
        let mut builder = clz_Torappu_FullPotentialCharacterInfoBuilder::new(_fbb);
        builder.add_ts(args.ts);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_FullPotentialCharacterInfoT {
        let itemId = self.itemId().map(|x| x.to_string());
        let ts = self.ts();
        clz_Torappu_FullPotentialCharacterInfoT { itemId, ts }
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_FullPotentialCharacterInfo::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn ts(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_FullPotentialCharacterInfo::VT_TS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_FullPotentialCharacterInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<i64>("ts", Self::VT_TS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_FullPotentialCharacterInfoArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ts: i64,
}
impl<'a> Default for clz_Torappu_FullPotentialCharacterInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_FullPotentialCharacterInfoArgs {
            itemId: None,
            ts: 0,
        }
    }
}

impl Serialize for clz_Torappu_FullPotentialCharacterInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_FullPotentialCharacterInfo", 2)?;
        if let Some(f) = self.itemId() {
            s.serialize_field("itemId", &f)?;
        } else {
            s.skip_field("itemId")?;
        }
        s.serialize_field("ts", &self.ts())?;
        s.end()
    }
}

pub struct clz_Torappu_FullPotentialCharacterInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_FullPotentialCharacterInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_FullPotentialCharacterInfo::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_ts(&mut self, ts: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_FullPotentialCharacterInfo::VT_TS, ts, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_FullPotentialCharacterInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_FullPotentialCharacterInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_FullPotentialCharacterInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_FullPotentialCharacterInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_FullPotentialCharacterInfo");
        ds.field("itemId", &self.itemId());
        ds.field("ts", &self.ts());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_FullPotentialCharacterInfoT {
    pub itemId: Option<String>,
    pub ts: i64,
}
impl Default for clz_Torappu_FullPotentialCharacterInfoT {
    fn default() -> Self {
        Self {
            itemId: None,
            ts: 0,
        }
    }
}
impl clz_Torappu_FullPotentialCharacterInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_FullPotentialCharacterInfo<'b>> {
        let itemId = self.itemId.as_ref().map(|x| _fbb.create_string(x));
        let ts = self.ts;
        clz_Torappu_FullPotentialCharacterInfo::create(
            _fbb,
            &clz_Torappu_FullPotentialCharacterInfoArgs { itemId, ts },
        )
    }
}
pub enum dict__string__clz_Torappu_FullPotentialCharacterInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_FullPotentialCharacterInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_FullPotentialCharacterInfo<'a> {
    type Inner = dict__string__clz_Torappu_FullPotentialCharacterInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_FullPotentialCharacterInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_FullPotentialCharacterInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_FullPotentialCharacterInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_FullPotentialCharacterInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_FullPotentialCharacterInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_FullPotentialCharacterInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_FullPotentialCharacterInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_FullPotentialCharacterInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_FullPotentialCharacterInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_FullPotentialCharacterInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_FullPotentialCharacterInfo>>(
                    dict__string__clz_Torappu_FullPotentialCharacterInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_FullPotentialCharacterInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_FullPotentialCharacterInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_FullPotentialCharacterInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_FullPotentialCharacterInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_FullPotentialCharacterInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_FullPotentialCharacterInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_FullPotentialCharacterInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_FullPotentialCharacterInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_FullPotentialCharacterInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_FullPotentialCharacterInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_FullPotentialCharacterInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_FullPotentialCharacterInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_FullPotentialCharacterInfo>>(
                dict__string__clz_Torappu_FullPotentialCharacterInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_FullPotentialCharacterInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_FullPotentialCharacterInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_FullPotentialCharacterInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_FullPotentialCharacterInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_FullPotentialCharacterInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_FullPotentialCharacterInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_FullPotentialCharacterInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_FullPotentialCharacterInfoT>>,
}
impl Default for dict__string__clz_Torappu_FullPotentialCharacterInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_FullPotentialCharacterInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_FullPotentialCharacterInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_FullPotentialCharacterInfo::create(
            _fbb,
            &dict__string__clz_Torappu_FullPotentialCharacterInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ActivityPotentialCharacterInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActivityPotentialCharacterInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActivityPotentialCharacterInfo<'a> {
    type Inner = clz_Torappu_ActivityPotentialCharacterInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActivityPotentialCharacterInfo<'a> {
    pub const VT_CHARID: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActivityPotentialCharacterInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActivityPotentialCharacterInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActivityPotentialCharacterInfo<'bldr>> {
        let mut builder = clz_Torappu_ActivityPotentialCharacterInfoBuilder::new(_fbb);
        if let Some(x) = args.charId {
            builder.add_charId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActivityPotentialCharacterInfoT {
        let charId = self.charId().map(|x| x.to_string());
        clz_Torappu_ActivityPotentialCharacterInfoT { charId }
    }

    #[inline]
    pub fn charId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActivityPotentialCharacterInfo::VT_CHARID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActivityPotentialCharacterInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("charId", Self::VT_CHARID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActivityPotentialCharacterInfoArgs<'a> {
    pub charId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ActivityPotentialCharacterInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActivityPotentialCharacterInfoArgs { charId: None }
    }
}

impl Serialize for clz_Torappu_ActivityPotentialCharacterInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActivityPotentialCharacterInfo", 1)?;
        if let Some(f) = self.charId() {
            s.serialize_field("charId", &f)?;
        } else {
            s.skip_field("charId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActivityPotentialCharacterInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActivityPotentialCharacterInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_charId(&mut self, charId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActivityPotentialCharacterInfo::VT_CHARID,
            charId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActivityPotentialCharacterInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActivityPotentialCharacterInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActivityPotentialCharacterInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActivityPotentialCharacterInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActivityPotentialCharacterInfo");
        ds.field("charId", &self.charId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActivityPotentialCharacterInfoT {
    pub charId: Option<String>,
}
impl Default for clz_Torappu_ActivityPotentialCharacterInfoT {
    fn default() -> Self {
        Self { charId: None }
    }
}
impl clz_Torappu_ActivityPotentialCharacterInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActivityPotentialCharacterInfo<'b>> {
        let charId = self.charId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_ActivityPotentialCharacterInfo::create(
            _fbb,
            &clz_Torappu_ActivityPotentialCharacterInfoArgs { charId },
        )
    }
}
pub enum dict__string__clz_Torappu_ActivityPotentialCharacterInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActivityPotentialCharacterInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActivityPotentialCharacterInfo<'a> {
    type Inner = dict__string__clz_Torappu_ActivityPotentialCharacterInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActivityPotentialCharacterInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActivityPotentialCharacterInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActivityPotentialCharacterInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActivityPotentialCharacterInfo<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_ActivityPotentialCharacterInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ActivityPotentialCharacterInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ActivityPotentialCharacterInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActivityPotentialCharacterInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActivityPotentialCharacterInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActivityPotentialCharacterInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActivityPotentialCharacterInfo>>(
                    dict__string__clz_Torappu_ActivityPotentialCharacterInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActivityPotentialCharacterInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActivityPotentialCharacterInfo>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActivityPotentialCharacterInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActivityPotentialCharacterInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActivityPotentialCharacterInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActivityPotentialCharacterInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ActivityPotentialCharacterInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_ActivityPotentialCharacterInfo",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ActivityPotentialCharacterInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActivityPotentialCharacterInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActivityPotentialCharacterInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActivityPotentialCharacterInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActivityPotentialCharacterInfo>>(
                dict__string__clz_Torappu_ActivityPotentialCharacterInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActivityPotentialCharacterInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActivityPotentialCharacterInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActivityPotentialCharacterInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActivityPotentialCharacterInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActivityPotentialCharacterInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActivityPotentialCharacterInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ActivityPotentialCharacterInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ActivityPotentialCharacterInfoT>>,
}
impl Default for dict__string__clz_Torappu_ActivityPotentialCharacterInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ActivityPotentialCharacterInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActivityPotentialCharacterInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ActivityPotentialCharacterInfo::create(
            _fbb,
            &dict__string__clz_Torappu_ActivityPotentialCharacterInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_FavorCharacterInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_FavorCharacterInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_FavorCharacterInfo<'a> {
    type Inner = clz_Torappu_FavorCharacterInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_FavorCharacterInfo<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_CHARID: flatbuffers::VOffsetT = 6;
    pub const VT_FAVORADDAMT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_FavorCharacterInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_FavorCharacterInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_FavorCharacterInfo<'bldr>> {
        let mut builder = clz_Torappu_FavorCharacterInfoBuilder::new(_fbb);
        builder.add_favorAddAmt(args.favorAddAmt);
        if let Some(x) = args.charId {
            builder.add_charId(x);
        }
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_FavorCharacterInfoT {
        let itemId = self.itemId().map(|x| x.to_string());
        let charId = self.charId().map(|x| x.to_string());
        let favorAddAmt = self.favorAddAmt();
        clz_Torappu_FavorCharacterInfoT {
            itemId,
            charId,
            favorAddAmt,
        }
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_FavorCharacterInfo::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn charId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_FavorCharacterInfo::VT_CHARID,
                None,
            )
        }
    }
    #[inline]
    pub fn favorAddAmt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_FavorCharacterInfo::VT_FAVORADDAMT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_FavorCharacterInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("charId", Self::VT_CHARID, false)?
            .visit_field::<i32>("favorAddAmt", Self::VT_FAVORADDAMT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_FavorCharacterInfoArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub charId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub favorAddAmt: i32,
}
impl<'a> Default for clz_Torappu_FavorCharacterInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_FavorCharacterInfoArgs {
            itemId: None,
            charId: None,
            favorAddAmt: 0,
        }
    }
}

impl Serialize for clz_Torappu_FavorCharacterInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_FavorCharacterInfo", 3)?;
        if let Some(f) = self.itemId() {
            s.serialize_field("itemId", &f)?;
        } else {
            s.skip_field("itemId")?;
        }
        if let Some(f) = self.charId() {
            s.serialize_field("charId", &f)?;
        } else {
            s.skip_field("charId")?;
        }
        s.serialize_field("favorAddAmt", &self.favorAddAmt())?;
        s.end()
    }
}

pub struct clz_Torappu_FavorCharacterInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_FavorCharacterInfoBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_FavorCharacterInfo::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_charId(&mut self, charId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_FavorCharacterInfo::VT_CHARID,
            charId,
        );
    }
    #[inline]
    pub fn add_favorAddAmt(&mut self, favorAddAmt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_FavorCharacterInfo::VT_FAVORADDAMT,
            favorAddAmt,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_FavorCharacterInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_FavorCharacterInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_FavorCharacterInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_FavorCharacterInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_FavorCharacterInfo");
        ds.field("itemId", &self.itemId());
        ds.field("charId", &self.charId());
        ds.field("favorAddAmt", &self.favorAddAmt());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_FavorCharacterInfoT {
    pub itemId: Option<String>,
    pub charId: Option<String>,
    pub favorAddAmt: i32,
}
impl Default for clz_Torappu_FavorCharacterInfoT {
    fn default() -> Self {
        Self {
            itemId: None,
            charId: None,
            favorAddAmt: 0,
        }
    }
}
impl clz_Torappu_FavorCharacterInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_FavorCharacterInfo<'b>> {
        let itemId = self.itemId.as_ref().map(|x| _fbb.create_string(x));
        let charId = self.charId.as_ref().map(|x| _fbb.create_string(x));
        let favorAddAmt = self.favorAddAmt;
        clz_Torappu_FavorCharacterInfo::create(
            _fbb,
            &clz_Torappu_FavorCharacterInfoArgs {
                itemId,
                charId,
                favorAddAmt,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_FavorCharacterInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_FavorCharacterInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_FavorCharacterInfo<'a> {
    type Inner = dict__string__clz_Torappu_FavorCharacterInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_FavorCharacterInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_FavorCharacterInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_FavorCharacterInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_FavorCharacterInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_FavorCharacterInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_FavorCharacterInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_FavorCharacterInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_FavorCharacterInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_FavorCharacterInfo) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_FavorCharacterInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_FavorCharacterInfo>>(
                    dict__string__clz_Torappu_FavorCharacterInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_FavorCharacterInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_FavorCharacterInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_FavorCharacterInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_FavorCharacterInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_FavorCharacterInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_FavorCharacterInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_FavorCharacterInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_FavorCharacterInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_FavorCharacterInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_FavorCharacterInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_FavorCharacterInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_FavorCharacterInfo<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_FavorCharacterInfo>>(
                dict__string__clz_Torappu_FavorCharacterInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_FavorCharacterInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_FavorCharacterInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_FavorCharacterInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_FavorCharacterInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_FavorCharacterInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_FavorCharacterInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_FavorCharacterInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_FavorCharacterInfoT>>,
}
impl Default for dict__string__clz_Torappu_FavorCharacterInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_FavorCharacterInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_FavorCharacterInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_FavorCharacterInfo::create(
            _fbb,
            &dict__string__clz_Torappu_FavorCharacterInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_InventoryDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_InventoryData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_InventoryData<'a> {
    type Inner = clz_Torappu_InventoryData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_InventoryData<'a> {
    pub const VT_ITEMS: flatbuffers::VOffsetT = 4;
    pub const VT_EXPITEMS: flatbuffers::VOffsetT = 6;
    pub const VT_POTENTIALITEMS: flatbuffers::VOffsetT = 8;
    pub const VT_APSUPPLIES: flatbuffers::VOffsetT = 10;
    pub const VT_CHARVOUCHERITEMS: flatbuffers::VOffsetT = 12;
    pub const VT_UNIQUEINFO: flatbuffers::VOffsetT = 14;
    pub const VT_ITEMTIMELIMIT: flatbuffers::VOffsetT = 16;
    pub const VT_UNICOLLECTIONINFO: flatbuffers::VOffsetT = 18;
    pub const VT_ITEMPACKINFOS: flatbuffers::VOffsetT = 20;
    pub const VT_FULLPOTENTIALCHARACTERS: flatbuffers::VOffsetT = 22;
    pub const VT_ACTIVITYPOTENTIALCHARACTERS: flatbuffers::VOffsetT = 24;
    pub const VT_FAVORCHARACTERS: flatbuffers::VOffsetT = 26;
    pub const VT_ITEMSHOPNAMEDICT: flatbuffers::VOffsetT = 28;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_InventoryData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_InventoryDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_InventoryData<'bldr>> {
        let mut builder = clz_Torappu_InventoryDataBuilder::new(_fbb);
        if let Some(x) = args.itemShopNameDict {
            builder.add_itemShopNameDict(x);
        }
        if let Some(x) = args.favorCharacters {
            builder.add_favorCharacters(x);
        }
        if let Some(x) = args.activityPotentialCharacters {
            builder.add_activityPotentialCharacters(x);
        }
        if let Some(x) = args.fullPotentialCharacters {
            builder.add_fullPotentialCharacters(x);
        }
        if let Some(x) = args.itemPackInfos {
            builder.add_itemPackInfos(x);
        }
        if let Some(x) = args.uniCollectionInfo {
            builder.add_uniCollectionInfo(x);
        }
        if let Some(x) = args.itemTimeLimit {
            builder.add_itemTimeLimit(x);
        }
        if let Some(x) = args.uniqueInfo {
            builder.add_uniqueInfo(x);
        }
        if let Some(x) = args.charVoucherItems {
            builder.add_charVoucherItems(x);
        }
        if let Some(x) = args.apSupplies {
            builder.add_apSupplies(x);
        }
        if let Some(x) = args.potentialItems {
            builder.add_potentialItems(x);
        }
        if let Some(x) = args.expItems {
            builder.add_expItems(x);
        }
        if let Some(x) = args.items {
            builder.add_items(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_InventoryDataT {
        let items = self.items().map(|x| x.iter().map(|t| t.unpack()).collect());
        let expItems = self
            .expItems()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let potentialItems = self
            .potentialItems()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let apSupplies = self
            .apSupplies()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let charVoucherItems = self
            .charVoucherItems()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let uniqueInfo = self
            .uniqueInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let itemTimeLimit = self
            .itemTimeLimit()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let uniCollectionInfo = self
            .uniCollectionInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let itemPackInfos = self
            .itemPackInfos()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let fullPotentialCharacters = self
            .fullPotentialCharacters()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let activityPotentialCharacters = self
            .activityPotentialCharacters()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let favorCharacters = self
            .favorCharacters()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let itemShopNameDict = self
            .itemShopNameDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_InventoryDataT {
            items,
            expItems,
            potentialItems,
            apSupplies,
            charVoucherItems,
            uniqueInfo,
            itemTimeLimit,
            uniCollectionInfo,
            itemPackInfos,
            fullPotentialCharacters,
            activityPotentialCharacters,
            favorCharacters,
            itemShopNameDict,
        }
    }

    #[inline]
    pub fn items(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ItemData>,
                >,
            >>(clz_Torappu_InventoryData::VT_ITEMS, None)
        }
    }
    #[inline]
    pub fn expItems(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ExpItemFeature<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ExpItemFeature>,
                >,
            >>(clz_Torappu_InventoryData::VT_EXPITEMS, None)
        }
    }
    #[inline]
    pub fn potentialItems(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__int__list_dict__string__string<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__int__list_dict__string__string>,
                >,
            >>(clz_Torappu_InventoryData::VT_POTENTIALITEMS, None)
        }
    }
    #[inline]
    pub fn apSupplies(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ApSupplyFeature<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ApSupplyFeature>,
                >,
            >>(clz_Torappu_InventoryData::VT_APSUPPLIES, None)
        }
    }
    #[inline]
    pub fn charVoucherItems(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharVoucherItemFeature<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharVoucherItemFeature>,
                >,
            >>(clz_Torappu_InventoryData::VT_CHARVOUCHERITEMS, None)
        }
    }
    #[inline]
    pub fn uniqueInfo(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>(clz_Torappu_InventoryData::VT_UNIQUEINFO, None)
        }
    }
    #[inline]
    pub fn itemTimeLimit(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>(clz_Torappu_InventoryData::VT_ITEMTIMELIMIT, None)
        }
    }
    #[inline]
    pub fn uniCollectionInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_UniCollectionInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_UniCollectionInfo>,
                >,
            >>(clz_Torappu_InventoryData::VT_UNICOLLECTIONINFO, None)
        }
    }
    #[inline]
    pub fn itemPackInfos(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ItemPackInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ItemPackInfo>,
                >,
            >>(clz_Torappu_InventoryData::VT_ITEMPACKINFOS, None)
        }
    }
    #[inline]
    pub fn fullPotentialCharacters(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_FullPotentialCharacterInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_FullPotentialCharacterInfo,
                    >,
                >,
            >>(clz_Torappu_InventoryData::VT_FULLPOTENTIALCHARACTERS, None)
        }
    }
    #[inline]
    pub fn activityPotentialCharacters(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_ActivityPotentialCharacterInfo<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActivityPotentialCharacterInfo,
                    >,
                >,
            >>(
                clz_Torappu_InventoryData::VT_ACTIVITYPOTENTIALCHARACTERS,
                None,
            )
        }
    }
    #[inline]
    pub fn favorCharacters(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_FavorCharacterInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_FavorCharacterInfo>,
                >,
            >>(clz_Torappu_InventoryData::VT_FAVORCHARACTERS, None)
        }
    }
    #[inline]
    pub fn itemShopNameDict(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(clz_Torappu_InventoryData::VT_ITEMSHOPNAMEDICT, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_InventoryData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ItemData>,
                >,
            >>("items", Self::VT_ITEMS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ExpItemFeature>,
                >,
            >>("expItems", Self::VT_EXPITEMS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__int__list_dict__string__string>,
                >,
            >>("potentialItems", Self::VT_POTENTIALITEMS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ApSupplyFeature>,
                >,
            >>("apSupplies", Self::VT_APSUPPLIES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharVoucherItemFeature>,
                >,
            >>("charVoucherItems", Self::VT_CHARVOUCHERITEMS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>("uniqueInfo", Self::VT_UNIQUEINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>("itemTimeLimit", Self::VT_ITEMTIMELIMIT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_UniCollectionInfo>,
                >,
            >>("uniCollectionInfo", Self::VT_UNICOLLECTIONINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ItemPackInfo>,
                >,
            >>("itemPackInfos", Self::VT_ITEMPACKINFOS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_FullPotentialCharacterInfo,
                    >,
                >,
            >>(
                "fullPotentialCharacters",
                Self::VT_FULLPOTENTIALCHARACTERS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActivityPotentialCharacterInfo,
                    >,
                >,
            >>(
                "activityPotentialCharacters",
                Self::VT_ACTIVITYPOTENTIALCHARACTERS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_FavorCharacterInfo>,
                >,
            >>("favorCharacters", Self::VT_FAVORCHARACTERS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>("itemShopNameDict", Self::VT_ITEMSHOPNAMEDICT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_InventoryDataArgs<'a> {
    pub items: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ItemData<'a>>,
            >,
        >,
    >,
    pub expItems: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ExpItemFeature<'a>>,
            >,
        >,
    >,
    pub potentialItems: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__int__list_dict__string__string<'a>>,
            >,
        >,
    >,
    pub apSupplies: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ApSupplyFeature<'a>>,
            >,
        >,
    >,
    pub charVoucherItems: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharVoucherItemFeature<'a>>,
            >,
        >,
    >,
    pub uniqueInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>,
        >,
    >,
    pub itemTimeLimit: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>,
        >,
    >,
    pub uniCollectionInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_UniCollectionInfo<'a>>,
            >,
        >,
    >,
    pub itemPackInfos: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ItemPackInfo<'a>>,
            >,
        >,
    >,
    pub fullPotentialCharacters: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_FullPotentialCharacterInfo<'a>,
                >,
            >,
        >,
    >,
    pub activityPotentialCharacters: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActivityPotentialCharacterInfo<'a>,
                >,
            >,
        >,
    >,
    pub favorCharacters: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_FavorCharacterInfo<'a>>,
            >,
        >,
    >,
    pub itemShopNameDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_InventoryDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_InventoryDataArgs {
            items: None,
            expItems: None,
            potentialItems: None,
            apSupplies: None,
            charVoucherItems: None,
            uniqueInfo: None,
            itemTimeLimit: None,
            uniCollectionInfo: None,
            itemPackInfos: None,
            fullPotentialCharacters: None,
            activityPotentialCharacters: None,
            favorCharacters: None,
            itemShopNameDict: None,
        }
    }
}

impl Serialize for clz_Torappu_InventoryData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_InventoryData", 13)?;
        if let Some(f) = self.items() {
            s.serialize_field("items", &f)?;
        } else {
            s.skip_field("items")?;
        }
        if let Some(f) = self.expItems() {
            s.serialize_field("expItems", &f)?;
        } else {
            s.skip_field("expItems")?;
        }
        if let Some(f) = self.potentialItems() {
            s.serialize_field("potentialItems", &f)?;
        } else {
            s.skip_field("potentialItems")?;
        }
        if let Some(f) = self.apSupplies() {
            s.serialize_field("apSupplies", &f)?;
        } else {
            s.skip_field("apSupplies")?;
        }
        if let Some(f) = self.charVoucherItems() {
            s.serialize_field("charVoucherItems", &f)?;
        } else {
            s.skip_field("charVoucherItems")?;
        }
        if let Some(f) = self.uniqueInfo() {
            s.serialize_field("uniqueInfo", &f)?;
        } else {
            s.skip_field("uniqueInfo")?;
        }
        if let Some(f) = self.itemTimeLimit() {
            s.serialize_field("itemTimeLimit", &f)?;
        } else {
            s.skip_field("itemTimeLimit")?;
        }
        if let Some(f) = self.uniCollectionInfo() {
            s.serialize_field("uniCollectionInfo", &f)?;
        } else {
            s.skip_field("uniCollectionInfo")?;
        }
        if let Some(f) = self.itemPackInfos() {
            s.serialize_field("itemPackInfos", &f)?;
        } else {
            s.skip_field("itemPackInfos")?;
        }
        if let Some(f) = self.fullPotentialCharacters() {
            s.serialize_field("fullPotentialCharacters", &f)?;
        } else {
            s.skip_field("fullPotentialCharacters")?;
        }
        if let Some(f) = self.activityPotentialCharacters() {
            s.serialize_field("activityPotentialCharacters", &f)?;
        } else {
            s.skip_field("activityPotentialCharacters")?;
        }
        if let Some(f) = self.favorCharacters() {
            s.serialize_field("favorCharacters", &f)?;
        } else {
            s.skip_field("favorCharacters")?;
        }
        if let Some(f) = self.itemShopNameDict() {
            s.serialize_field("itemShopNameDict", &f)?;
        } else {
            s.skip_field("itemShopNameDict")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_InventoryDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_InventoryDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_items(
        &mut self,
        items: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_InventoryData::VT_ITEMS,
            items,
        );
    }
    #[inline]
    pub fn add_expItems(
        &mut self,
        expItems: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ExpItemFeature<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_InventoryData::VT_EXPITEMS,
            expItems,
        );
    }
    #[inline]
    pub fn add_potentialItems(
        &mut self,
        potentialItems: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__int__list_dict__string__string<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_InventoryData::VT_POTENTIALITEMS,
            potentialItems,
        );
    }
    #[inline]
    pub fn add_apSupplies(
        &mut self,
        apSupplies: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ApSupplyFeature<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_InventoryData::VT_APSUPPLIES,
            apSupplies,
        );
    }
    #[inline]
    pub fn add_charVoucherItems(
        &mut self,
        charVoucherItems: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_CharVoucherItemFeature<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_InventoryData::VT_CHARVOUCHERITEMS,
            charVoucherItems,
        );
    }
    #[inline]
    pub fn add_uniqueInfo(
        &mut self,
        uniqueInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__int<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_InventoryData::VT_UNIQUEINFO,
            uniqueInfo,
        );
    }
    #[inline]
    pub fn add_itemTimeLimit(
        &mut self,
        itemTimeLimit: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__int<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_InventoryData::VT_ITEMTIMELIMIT,
            itemTimeLimit,
        );
    }
    #[inline]
    pub fn add_uniCollectionInfo(
        &mut self,
        uniCollectionInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_UniCollectionInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_InventoryData::VT_UNICOLLECTIONINFO,
            uniCollectionInfo,
        );
    }
    #[inline]
    pub fn add_itemPackInfos(
        &mut self,
        itemPackInfos: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ItemPackInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_InventoryData::VT_ITEMPACKINFOS,
            itemPackInfos,
        );
    }
    #[inline]
    pub fn add_fullPotentialCharacters(
        &mut self,
        fullPotentialCharacters: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_FullPotentialCharacterInfo<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_InventoryData::VT_FULLPOTENTIALCHARACTERS,
            fullPotentialCharacters,
        );
    }
    #[inline]
    pub fn add_activityPotentialCharacters(
        &mut self,
        activityPotentialCharacters: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActivityPotentialCharacterInfo<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_InventoryData::VT_ACTIVITYPOTENTIALCHARACTERS,
            activityPotentialCharacters,
        );
    }
    #[inline]
    pub fn add_favorCharacters(
        &mut self,
        favorCharacters: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_FavorCharacterInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_InventoryData::VT_FAVORCHARACTERS,
            favorCharacters,
        );
    }
    #[inline]
    pub fn add_itemShopNameDict(
        &mut self,
        itemShopNameDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_InventoryData::VT_ITEMSHOPNAMEDICT,
            itemShopNameDict,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_InventoryDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_InventoryDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_InventoryData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_InventoryData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_InventoryData");
        ds.field("items", &self.items());
        ds.field("expItems", &self.expItems());
        ds.field("potentialItems", &self.potentialItems());
        ds.field("apSupplies", &self.apSupplies());
        ds.field("charVoucherItems", &self.charVoucherItems());
        ds.field("uniqueInfo", &self.uniqueInfo());
        ds.field("itemTimeLimit", &self.itemTimeLimit());
        ds.field("uniCollectionInfo", &self.uniCollectionInfo());
        ds.field("itemPackInfos", &self.itemPackInfos());
        ds.field("fullPotentialCharacters", &self.fullPotentialCharacters());
        ds.field(
            "activityPotentialCharacters",
            &self.activityPotentialCharacters(),
        );
        ds.field("favorCharacters", &self.favorCharacters());
        ds.field("itemShopNameDict", &self.itemShopNameDict());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_InventoryDataT {
    pub items: Option<Vec<dict__string__clz_Torappu_ItemDataT>>,
    pub expItems: Option<Vec<dict__string__clz_Torappu_ExpItemFeatureT>>,
    pub potentialItems: Option<Vec<dict__int__list_dict__string__stringT>>,
    pub apSupplies: Option<Vec<dict__string__clz_Torappu_ApSupplyFeatureT>>,
    pub charVoucherItems: Option<Vec<dict__string__clz_Torappu_CharVoucherItemFeatureT>>,
    pub uniqueInfo: Option<Vec<dict__string__intT>>,
    pub itemTimeLimit: Option<Vec<dict__string__intT>>,
    pub uniCollectionInfo: Option<Vec<dict__string__clz_Torappu_UniCollectionInfoT>>,
    pub itemPackInfos: Option<Vec<dict__string__clz_Torappu_ItemPackInfoT>>,
    pub fullPotentialCharacters: Option<Vec<dict__string__clz_Torappu_FullPotentialCharacterInfoT>>,
    pub activityPotentialCharacters:
        Option<Vec<dict__string__clz_Torappu_ActivityPotentialCharacterInfoT>>,
    pub favorCharacters: Option<Vec<dict__string__clz_Torappu_FavorCharacterInfoT>>,
    pub itemShopNameDict: Option<Vec<dict__string__stringT>>,
}
impl Default for clz_Torappu_InventoryDataT {
    fn default() -> Self {
        Self {
            items: None,
            expItems: None,
            potentialItems: None,
            apSupplies: None,
            charVoucherItems: None,
            uniqueInfo: None,
            itemTimeLimit: None,
            uniCollectionInfo: None,
            itemPackInfos: None,
            fullPotentialCharacters: None,
            activityPotentialCharacters: None,
            favorCharacters: None,
            itemShopNameDict: None,
        }
    }
}
impl clz_Torappu_InventoryDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_InventoryData<'b>> {
        let items = self.items.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let expItems = self.expItems.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let potentialItems = self.potentialItems.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let apSupplies = self.apSupplies.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let charVoucherItems = self.charVoucherItems.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let uniqueInfo = self.uniqueInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let itemTimeLimit = self.itemTimeLimit.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let uniCollectionInfo = self.uniCollectionInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let itemPackInfos = self.itemPackInfos.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let fullPotentialCharacters = self.fullPotentialCharacters.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let activityPotentialCharacters = self.activityPotentialCharacters.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let favorCharacters = self.favorCharacters.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let itemShopNameDict = self.itemShopNameDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_InventoryData::create(
            _fbb,
            &clz_Torappu_InventoryDataArgs {
                items,
                expItems,
                potentialItems,
                apSupplies,
                charVoucherItems,
                uniqueInfo,
                itemTimeLimit,
                uniCollectionInfo,
                itemPackInfos,
                fullPotentialCharacters,
                activityPotentialCharacters,
                favorCharacters,
                itemShopNameDict,
            },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_InventoryData`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_inventory_data_unchecked`.
pub fn root_as_clz_torappu_inventory_data(
    buf: &[u8],
) -> Result<clz_Torappu_InventoryData, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_InventoryData>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_InventoryData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_inventory_data_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_inventory_data(
    buf: &[u8],
) -> Result<clz_Torappu_InventoryData, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_InventoryData>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_InventoryData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_inventory_data_unchecked`.
pub fn root_as_clz_torappu_inventory_data_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_InventoryData<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_InventoryData<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_InventoryData` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_inventory_data_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_inventory_data_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_InventoryData<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_InventoryData<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_InventoryData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_InventoryData`.
pub unsafe fn root_as_clz_torappu_inventory_data_unchecked(
    buf: &[u8],
) -> clz_Torappu_InventoryData {
    unsafe { flatbuffers::root_unchecked::<clz_Torappu_InventoryData>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_InventoryData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_InventoryData`.
pub unsafe fn size_prefixed_root_as_clz_torappu_inventory_data_unchecked(
    buf: &[u8],
) -> clz_Torappu_InventoryData {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_InventoryData>(buf) }
}
#[inline]
pub fn finish_clz_torappu_inventory_data_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_InventoryData<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_inventory_data_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_InventoryData<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
