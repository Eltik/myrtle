// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_RECOMMEND_ITEM_TAG_TIPS: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_RECOMMEND_ITEM_TAG_TIPS: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_RECOMMEND_ITEM_TAG_TIPS: [enum__Torappu_RecommendItemTagTips;
    3] = [
    enum__Torappu_RecommendItemTagTips::ONSALE,
    enum__Torappu_RecommendItemTagTips::DEADLINE,
    enum__Torappu_RecommendItemTagTips::NONE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RecommendItemTagTips(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RecommendItemTagTips {
    pub const ONSALE: Self = Self(0);
    pub const DEADLINE: Self = Self(1);
    pub const NONE: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::ONSALE, Self::DEADLINE, Self::NONE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ONSALE => Some("ONSALE"),
            Self::DEADLINE => Some("DEADLINE"),
            Self::NONE => Some("NONE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RecommendItemTagTips {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RecommendItemTagTips {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RecommendItemTagTips",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RecommendItemTagTips {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RecommendItemTagTips {
    type Output = enum__Torappu_RecommendItemTagTips;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RecommendItemTagTips {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RecommendItemTagTips {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RecommendItemTagTips {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SHOP_ROUTE_TARGET: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SHOP_ROUTE_TARGET: i32 = 13;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SHOP_ROUTE_TARGET: [enum__Torappu_ShopRouteTarget; 14] = [
    enum__Torappu_ShopRouteTarget::RECOMMENDSHOP,
    enum__Torappu_ShopRouteTarget::CASHSHOP,
    enum__Torappu_ShopRouteTarget::GIFTPACKAGE,
    enum__Torappu_ShopRouteTarget::SKINSHOP,
    enum__Torappu_ShopRouteTarget::HQCSHOP,
    enum__Torappu_ShopRouteTarget::LQCSHOP,
    enum__Torappu_ShopRouteTarget::EXQCSHOP,
    enum__Torappu_ShopRouteTarget::SOCAILSHOP,
    enum__Torappu_ShopRouteTarget::FURNSHOP,
    enum__Torappu_ShopRouteTarget::REPSHOP,
    enum__Torappu_ShopRouteTarget::LMGTSSHOP,
    enum__Torappu_ShopRouteTarget::EPGSSHOP,
    enum__Torappu_ShopRouteTarget::CLASSICSHOP,
    enum__Torappu_ShopRouteTarget::NONE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ShopRouteTarget(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ShopRouteTarget {
    pub const RECOMMENDSHOP: Self = Self(0);
    pub const CASHSHOP: Self = Self(1);
    pub const GIFTPACKAGE: Self = Self(2);
    pub const SKINSHOP: Self = Self(3);
    pub const HQCSHOP: Self = Self(4);
    pub const LQCSHOP: Self = Self(5);
    pub const EXQCSHOP: Self = Self(6);
    pub const SOCAILSHOP: Self = Self(7);
    pub const FURNSHOP: Self = Self(8);
    pub const REPSHOP: Self = Self(9);
    pub const LMGTSSHOP: Self = Self(10);
    pub const EPGSSHOP: Self = Self(11);
    pub const CLASSICSHOP: Self = Self(12);
    pub const NONE: Self = Self(13);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 13;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::RECOMMENDSHOP,
        Self::CASHSHOP,
        Self::GIFTPACKAGE,
        Self::SKINSHOP,
        Self::HQCSHOP,
        Self::LQCSHOP,
        Self::EXQCSHOP,
        Self::SOCAILSHOP,
        Self::FURNSHOP,
        Self::REPSHOP,
        Self::LMGTSSHOP,
        Self::EPGSSHOP,
        Self::CLASSICSHOP,
        Self::NONE,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::RECOMMENDSHOP => Some("RECOMMENDSHOP"),
            Self::CASHSHOP => Some("CASHSHOP"),
            Self::GIFTPACKAGE => Some("GIFTPACKAGE"),
            Self::SKINSHOP => Some("SKINSHOP"),
            Self::HQCSHOP => Some("HQCSHOP"),
            Self::LQCSHOP => Some("LQCSHOP"),
            Self::EXQCSHOP => Some("EXQCSHOP"),
            Self::SOCAILSHOP => Some("SOCAILSHOP"),
            Self::FURNSHOP => Some("FURNSHOP"),
            Self::REPSHOP => Some("REPSHOP"),
            Self::LMGTSSHOP => Some("LMGTSSHOP"),
            Self::EPGSSHOP => Some("EPGSSHOP"),
            Self::CLASSICSHOP => Some("CLASSICSHOP"),
            Self::NONE => Some("NONE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ShopRouteTarget {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ShopRouteTarget {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ShopRouteTarget",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ShopRouteTarget {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ShopRouteTarget {
    type Output = enum__Torappu_ShopRouteTarget;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ShopRouteTarget {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ShopRouteTarget {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ShopRouteTarget {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SHOP_RECOMMEND_TEMPLATE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SHOP_RECOMMEND_TEMPLATE_TYPE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SHOP_RECOMMEND_TEMPLATE_TYPE:
    [enum__Torappu_ShopRecommendTemplateType; 5] = [
    enum__Torappu_ShopRecommendTemplateType::DEFAULT,
    enum__Torappu_ShopRecommendTemplateType::NORSKIN,
    enum__Torappu_ShopRecommendTemplateType::RETURNSKIN,
    enum__Torappu_ShopRecommendTemplateType::NORFURN,
    enum__Torappu_ShopRecommendTemplateType::NORGIFT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ShopRecommendTemplateType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ShopRecommendTemplateType {
    pub const DEFAULT: Self = Self(0);
    pub const NORSKIN: Self = Self(1);
    pub const RETURNSKIN: Self = Self(2);
    pub const NORFURN: Self = Self(3);
    pub const NORGIFT: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::DEFAULT,
        Self::NORSKIN,
        Self::RETURNSKIN,
        Self::NORFURN,
        Self::NORGIFT,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::DEFAULT => Some("DEFAULT"),
            Self::NORSKIN => Some("NORSKIN"),
            Self::RETURNSKIN => Some("RETURNSKIN"),
            Self::NORFURN => Some("NORFURN"),
            Self::NORGIFT => Some("NORGIFT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ShopRecommendTemplateType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ShopRecommendTemplateType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ShopRecommendTemplateType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ShopRecommendTemplateType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ShopRecommendTemplateType {
    type Output = enum__Torappu_ShopRecommendTemplateType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ShopRecommendTemplateType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ShopRecommendTemplateType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ShopRecommendTemplateType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SHOP_UNLOCK_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SHOP_UNLOCK_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SHOP_UNLOCK_TYPE: [enum__Torappu_ShopUnlockType; 4] = [
    enum__Torappu_ShopUnlockType::ALWAYS_UNLOCK,
    enum__Torappu_ShopUnlockType::SKIN_UNLOCK,
    enum__Torappu_ShopUnlockType::FURN_UNLOCK,
    enum__Torappu_ShopUnlockType::BOTH_SKIN_FURN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ShopUnlockType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ShopUnlockType {
    pub const ALWAYS_UNLOCK: Self = Self(0);
    pub const SKIN_UNLOCK: Self = Self(1);
    pub const FURN_UNLOCK: Self = Self(2);
    pub const BOTH_SKIN_FURN: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::ALWAYS_UNLOCK,
        Self::SKIN_UNLOCK,
        Self::FURN_UNLOCK,
        Self::BOTH_SKIN_FURN,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ALWAYS_UNLOCK => Some("ALWAYS_UNLOCK"),
            Self::SKIN_UNLOCK => Some("SKIN_UNLOCK"),
            Self::FURN_UNLOCK => Some("FURN_UNLOCK"),
            Self::BOTH_SKIN_FURN => Some("BOTH_SKIN_FURN"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ShopUnlockType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ShopUnlockType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ShopUnlockType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ShopUnlockType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ShopUnlockType {
    type Output = enum__Torappu_ShopUnlockType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ShopUnlockType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ShopUnlockType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ShopUnlockType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SHOP_COND_TRIG_PACKAGE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SHOP_COND_TRIG_PACKAGE_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SHOP_COND_TRIG_PACKAGE_TYPE:
    [enum__Torappu_ShopCondTrigPackageType; 4] = [
    enum__Torappu_ShopCondTrigPackageType::NONE,
    enum__Torappu_ShopCondTrigPackageType::RETURN_PROGRESS,
    enum__Torappu_ShopCondTrigPackageType::RETURN_ONCE,
    enum__Torappu_ShopCondTrigPackageType::NEW_PROGRESS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ShopCondTrigPackageType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ShopCondTrigPackageType {
    pub const NONE: Self = Self(0);
    pub const RETURN_PROGRESS: Self = Self(1);
    pub const RETURN_ONCE: Self = Self(2);
    pub const NEW_PROGRESS: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::RETURN_PROGRESS,
        Self::RETURN_ONCE,
        Self::NEW_PROGRESS,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::RETURN_PROGRESS => Some("RETURN_PROGRESS"),
            Self::RETURN_ONCE => Some("RETURN_ONCE"),
            Self::NEW_PROGRESS => Some("NEW_PROGRESS"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ShopCondTrigPackageType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ShopCondTrigPackageType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ShopCondTrigPackageType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ShopCondTrigPackageType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ShopCondTrigPackageType {
    type Output = enum__Torappu_ShopCondTrigPackageType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ShopCondTrigPackageType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ShopCondTrigPackageType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ShopCondTrigPackageType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SHOP_GPTAB_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SHOP_GPTAB_TYPE: i32 = 6;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SHOP_GPTAB_TYPE: [enum__Torappu_ShopGPTabType; 7] = [
    enum__Torappu_ShopGPTabType::DEFAULT_ALL,
    enum__Torappu_ShopGPTabType::MONTH_CARD,
    enum__Torappu_ShopGPTabType::PERM,
    enum__Torappu_ShopGPTabType::NEWBIE,
    enum__Torappu_ShopGPTabType::RETURN,
    enum__Torappu_ShopGPTabType::RECOMMOND,
    enum__Torappu_ShopGPTabType::TIMELY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ShopGPTabType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ShopGPTabType {
    pub const DEFAULT_ALL: Self = Self(0);
    pub const MONTH_CARD: Self = Self(1);
    pub const PERM: Self = Self(2);
    pub const NEWBIE: Self = Self(3);
    pub const RETURN: Self = Self(4);
    pub const RECOMMOND: Self = Self(5);
    pub const TIMELY: Self = Self(6);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 6;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::DEFAULT_ALL,
        Self::MONTH_CARD,
        Self::PERM,
        Self::NEWBIE,
        Self::RETURN,
        Self::RECOMMOND,
        Self::TIMELY,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::DEFAULT_ALL => Some("DEFAULT_ALL"),
            Self::MONTH_CARD => Some("MONTH_CARD"),
            Self::PERM => Some("PERM"),
            Self::NEWBIE => Some("NEWBIE"),
            Self::RETURN => Some("RETURN"),
            Self::RECOMMOND => Some("RECOMMOND"),
            Self::TIMELY => Some("TIMELY"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ShopGPTabType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ShopGPTabType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ShopGPTabType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ShopGPTabType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ShopGPTabType {
    type Output = enum__Torappu_ShopGPTabType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ShopGPTabType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ShopGPTabType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ShopGPTabType {}
pub enum clz_Torappu_ShopRecommendDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ShopRecommendData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ShopRecommendData<'a> {
    type Inner = clz_Torappu_ShopRecommendData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ShopRecommendData<'a> {
    pub const VT_IMGID: flatbuffers::VOffsetT = 4;
    pub const VT_SLOTINDEX: flatbuffers::VOffsetT = 6;
    pub const VT_CMD: flatbuffers::VOffsetT = 8;
    pub const VT_PARAM1: flatbuffers::VOffsetT = 10;
    pub const VT_PARAM2: flatbuffers::VOffsetT = 12;
    pub const VT_SKINID: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ShopRecommendData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ShopRecommendDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendData<'bldr>> {
        let mut builder = clz_Torappu_ShopRecommendDataBuilder::new(_fbb);
        if let Some(x) = args.skinId {
            builder.add_skinId(x);
        }
        if let Some(x) = args.param2 {
            builder.add_param2(x);
        }
        if let Some(x) = args.param1 {
            builder.add_param1(x);
        }
        builder.add_cmd(args.cmd);
        builder.add_slotIndex(args.slotIndex);
        if let Some(x) = args.imgId {
            builder.add_imgId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ShopRecommendDataT {
        let imgId = self.imgId().map(|x| x.to_string());
        let slotIndex = self.slotIndex();
        let cmd = self.cmd();
        let param1 = self.param1().map(|x| x.to_string());
        let param2 = self.param2().map(|x| x.to_string());
        let skinId = self.skinId().map(|x| x.to_string());
        clz_Torappu_ShopRecommendDataT {
            imgId,
            slotIndex,
            cmd,
            param1,
            param2,
            skinId,
        }
    }

    #[inline]
    pub fn imgId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopRecommendData::VT_IMGID,
                None,
            )
        }
    }
    #[inline]
    pub fn slotIndex(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ShopRecommendData::VT_SLOTINDEX, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn cmd(&self) -> enum__Torappu_ShopRouteTarget {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ShopRouteTarget>(
                    clz_Torappu_ShopRecommendData::VT_CMD,
                    Some(enum__Torappu_ShopRouteTarget::RECOMMENDSHOP),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn param1(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopRecommendData::VT_PARAM1,
                None,
            )
        }
    }
    #[inline]
    pub fn param2(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopRecommendData::VT_PARAM2,
                None,
            )
        }
    }
    #[inline]
    pub fn skinId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopRecommendData::VT_SKINID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ShopRecommendData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("imgId", Self::VT_IMGID, false)?
            .visit_field::<i32>("slotIndex", Self::VT_SLOTINDEX, false)?
            .visit_field::<enum__Torappu_ShopRouteTarget>("cmd", Self::VT_CMD, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("param1", Self::VT_PARAM1, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("param2", Self::VT_PARAM2, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("skinId", Self::VT_SKINID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ShopRecommendDataArgs<'a> {
    pub imgId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub slotIndex: i32,
    pub cmd: enum__Torappu_ShopRouteTarget,
    pub param1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub param2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub skinId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ShopRecommendDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ShopRecommendDataArgs {
            imgId: None,
            slotIndex: 0,
            cmd: enum__Torappu_ShopRouteTarget::RECOMMENDSHOP,
            param1: None,
            param2: None,
            skinId: None,
        }
    }
}

impl Serialize for clz_Torappu_ShopRecommendData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ShopRecommendData", 6)?;
        if let Some(f) = self.imgId() {
            s.serialize_field("imgId", &f)?;
        } else {
            s.skip_field("imgId")?;
        }
        s.serialize_field("slotIndex", &self.slotIndex())?;
        s.serialize_field("cmd", &self.cmd())?;
        if let Some(f) = self.param1() {
            s.serialize_field("param1", &f)?;
        } else {
            s.skip_field("param1")?;
        }
        if let Some(f) = self.param2() {
            s.serialize_field("param2", &f)?;
        } else {
            s.skip_field("param2")?;
        }
        if let Some(f) = self.skinId() {
            s.serialize_field("skinId", &f)?;
        } else {
            s.skip_field("skinId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ShopRecommendDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ShopRecommendDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_imgId(&mut self, imgId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendData::VT_IMGID,
            imgId,
        );
    }
    #[inline]
    pub fn add_slotIndex(&mut self, slotIndex: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ShopRecommendData::VT_SLOTINDEX, slotIndex, 0);
    }
    #[inline]
    pub fn add_cmd(&mut self, cmd: enum__Torappu_ShopRouteTarget) {
        self.fbb_.push_slot::<enum__Torappu_ShopRouteTarget>(
            clz_Torappu_ShopRecommendData::VT_CMD,
            cmd,
            enum__Torappu_ShopRouteTarget::RECOMMENDSHOP,
        );
    }
    #[inline]
    pub fn add_param1(&mut self, param1: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendData::VT_PARAM1,
            param1,
        );
    }
    #[inline]
    pub fn add_param2(&mut self, param2: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendData::VT_PARAM2,
            param2,
        );
    }
    #[inline]
    pub fn add_skinId(&mut self, skinId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendData::VT_SKINID,
            skinId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ShopRecommendDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ShopRecommendDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ShopRecommendData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ShopRecommendData");
        ds.field("imgId", &self.imgId());
        ds.field("slotIndex", &self.slotIndex());
        ds.field("cmd", &self.cmd());
        ds.field("param1", &self.param1());
        ds.field("param2", &self.param2());
        ds.field("skinId", &self.skinId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ShopRecommendDataT {
    pub imgId: Option<String>,
    pub slotIndex: i32,
    pub cmd: enum__Torappu_ShopRouteTarget,
    pub param1: Option<String>,
    pub param2: Option<String>,
    pub skinId: Option<String>,
}
impl Default for clz_Torappu_ShopRecommendDataT {
    fn default() -> Self {
        Self {
            imgId: None,
            slotIndex: 0,
            cmd: enum__Torappu_ShopRouteTarget::RECOMMENDSHOP,
            param1: None,
            param2: None,
            skinId: None,
        }
    }
}
impl clz_Torappu_ShopRecommendDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendData<'b>> {
        let imgId = self.imgId.as_ref().map(|x| _fbb.create_string(x));
        let slotIndex = self.slotIndex;
        let cmd = self.cmd;
        let param1 = self.param1.as_ref().map(|x| _fbb.create_string(x));
        let param2 = self.param2.as_ref().map(|x| _fbb.create_string(x));
        let skinId = self.skinId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_ShopRecommendData::create(
            _fbb,
            &clz_Torappu_ShopRecommendDataArgs {
                imgId,
                slotIndex,
                cmd,
                param1,
                param2,
                skinId,
            },
        )
    }
}
pub enum clz_Torappu_ShopRecommendGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ShopRecommendGroup<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ShopRecommendGroup<'a> {
    type Inner = clz_Torappu_ShopRecommendGroup<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ShopRecommendGroup<'a> {
    pub const VT_RECOMMENDGROUP: flatbuffers::VOffsetT = 4;
    pub const VT_DATALIST: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ShopRecommendGroup { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ShopRecommendGroupArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendGroup<'bldr>> {
        let mut builder = clz_Torappu_ShopRecommendGroupBuilder::new(_fbb);
        if let Some(x) = args.dataList {
            builder.add_dataList(x);
        }
        if let Some(x) = args.recommendGroup {
            builder.add_recommendGroup(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ShopRecommendGroupT {
        let recommendGroup = self.recommendGroup().map(|x| x.into_iter().collect());
        let dataList = self
            .dataList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ShopRecommendGroupT {
            recommendGroup,
            dataList,
        }
    }

    #[inline]
    pub fn recommendGroup(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    clz_Torappu_ShopRecommendGroup::VT_RECOMMENDGROUP,
                    None,
                )
        }
    }
    #[inline]
    pub fn dataList(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendData<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendData>,
                >,
            >>(clz_Torappu_ShopRecommendGroup::VT_DATALIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ShopRecommendGroup<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "recommendGroup",
                Self::VT_RECOMMENDGROUP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendData>,
                >,
            >>("dataList", Self::VT_DATALIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ShopRecommendGroupArgs<'a> {
    pub recommendGroup: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub dataList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ShopRecommendGroupArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ShopRecommendGroupArgs {
            recommendGroup: None,
            dataList: None,
        }
    }
}

impl Serialize for clz_Torappu_ShopRecommendGroup<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ShopRecommendGroup", 2)?;
        if let Some(f) = self.recommendGroup() {
            s.serialize_field("recommendGroup", &f)?;
        } else {
            s.skip_field("recommendGroup")?;
        }
        if let Some(f) = self.dataList() {
            s.serialize_field("dataList", &f)?;
        } else {
            s.skip_field("dataList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ShopRecommendGroupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ShopRecommendGroupBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_recommendGroup(
        &mut self,
        recommendGroup: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendGroup::VT_RECOMMENDGROUP,
            recommendGroup,
        );
    }
    #[inline]
    pub fn add_dataList(
        &mut self,
        dataList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendGroup::VT_DATALIST,
            dataList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ShopRecommendGroupBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ShopRecommendGroupBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendGroup<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ShopRecommendGroup<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ShopRecommendGroup");
        ds.field("recommendGroup", &self.recommendGroup());
        ds.field("dataList", &self.dataList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ShopRecommendGroupT {
    pub recommendGroup: Option<Vec<i32>>,
    pub dataList: Option<Vec<clz_Torappu_ShopRecommendDataT>>,
}
impl Default for clz_Torappu_ShopRecommendGroupT {
    fn default() -> Self {
        Self {
            recommendGroup: None,
            dataList: None,
        }
    }
}
impl clz_Torappu_ShopRecommendGroupT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendGroup<'b>> {
        let recommendGroup = self.recommendGroup.as_ref().map(|x| _fbb.create_vector(x));
        let dataList = self.dataList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ShopRecommendGroup::create(
            _fbb,
            &clz_Torappu_ShopRecommendGroupArgs {
                recommendGroup,
                dataList,
            },
        )
    }
}
pub enum clz_Torappu_ShopKeeperWordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ShopKeeperWord<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ShopKeeperWord<'a> {
    type Inner = clz_Torappu_ShopKeeperWord<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ShopKeeperWord<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TEXT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ShopKeeperWord { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ShopKeeperWordArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopKeeperWord<'bldr>> {
        let mut builder = clz_Torappu_ShopKeeperWordBuilder::new(_fbb);
        if let Some(x) = args.text {
            builder.add_text(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ShopKeeperWordT {
        let id = self.id().map(|x| x.to_string());
        let text = self.text().map(|x| x.to_string());
        clz_Torappu_ShopKeeperWordT { id, text }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_ShopKeeperWord::VT_ID, None)
        }
    }
    #[inline]
    pub fn text(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopKeeperWord::VT_TEXT,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ShopKeeperWord<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ShopKeeperWordArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ShopKeeperWordArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ShopKeeperWordArgs {
            id: None,
            text: None,
        }
    }
}

impl Serialize for clz_Torappu_ShopKeeperWord<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ShopKeeperWord", 2)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.text() {
            s.serialize_field("text", &f)?;
        } else {
            s.skip_field("text")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ShopKeeperWordBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ShopKeeperWordBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ShopKeeperWord::VT_ID, id);
    }
    #[inline]
    pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopKeeperWord::VT_TEXT,
            text,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ShopKeeperWordBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ShopKeeperWordBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ShopKeeperWord<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ShopKeeperWord<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ShopKeeperWord");
        ds.field("id", &self.id());
        ds.field("text", &self.text());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ShopKeeperWordT {
    pub id: Option<String>,
    pub text: Option<String>,
}
impl Default for clz_Torappu_ShopKeeperWordT {
    fn default() -> Self {
        Self {
            id: None,
            text: None,
        }
    }
}
impl clz_Torappu_ShopKeeperWordT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopKeeperWord<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let text = self.text.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_ShopKeeperWord::create(_fbb, &clz_Torappu_ShopKeeperWordArgs { id, text })
    }
}
pub enum clz_Torappu_ShopRecommendTemplateNormalGiftParamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ShopRecommendTemplateNormalGiftParam<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ShopRecommendTemplateNormalGiftParam<'a> {
    type Inner = clz_Torappu_ShopRecommendTemplateNormalGiftParam<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ShopRecommendTemplateNormalGiftParam<'a> {
    pub const VT_SHOWSTARTTS: flatbuffers::VOffsetT = 4;
    pub const VT_SHOWENDTS: flatbuffers::VOffsetT = 6;
    pub const VT_GOODID: flatbuffers::VOffsetT = 8;
    pub const VT_GIFTPACKAGENAME: flatbuffers::VOffsetT = 10;
    pub const VT_PRICE: flatbuffers::VOffsetT = 12;
    pub const VT_LOGOID: flatbuffers::VOffsetT = 14;
    pub const VT_COLOR: flatbuffers::VOffsetT = 16;
    pub const VT_HAVEMARK: flatbuffers::VOffsetT = 18;
    pub const VT_AVAILCOUNT: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ShopRecommendTemplateNormalGiftParam { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ShopRecommendTemplateNormalGiftParamArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateNormalGiftParam<'bldr>> {
        let mut builder = clz_Torappu_ShopRecommendTemplateNormalGiftParamBuilder::new(_fbb);
        builder.add_showEndTs(args.showEndTs);
        builder.add_showStartTs(args.showStartTs);
        builder.add_availCount(args.availCount);
        if let Some(x) = args.color {
            builder.add_color(x);
        }
        if let Some(x) = args.logoId {
            builder.add_logoId(x);
        }
        builder.add_price(args.price);
        if let Some(x) = args.giftPackageName {
            builder.add_giftPackageName(x);
        }
        if let Some(x) = args.goodId {
            builder.add_goodId(x);
        }
        builder.add_haveMark(args.haveMark);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ShopRecommendTemplateNormalGiftParamT {
        let showStartTs = self.showStartTs();
        let showEndTs = self.showEndTs();
        let goodId = self.goodId().map(|x| x.to_string());
        let giftPackageName = self.giftPackageName().map(|x| x.to_string());
        let price = self.price();
        let logoId = self.logoId().map(|x| x.to_string());
        let color = self.color().map(|x| x.to_string());
        let haveMark = self.haveMark();
        let availCount = self.availCount();
        clz_Torappu_ShopRecommendTemplateNormalGiftParamT {
            showStartTs,
            showEndTs,
            goodId,
            giftPackageName,
            price,
            logoId,
            color,
            haveMark,
            availCount,
        }
    }

    #[inline]
    pub fn showStartTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_ShopRecommendTemplateNormalGiftParam::VT_SHOWSTARTTS,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn showEndTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_ShopRecommendTemplateNormalGiftParam::VT_SHOWENDTS,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn goodId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopRecommendTemplateNormalGiftParam::VT_GOODID,
                None,
            )
        }
    }
    #[inline]
    pub fn giftPackageName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopRecommendTemplateNormalGiftParam::VT_GIFTPACKAGENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn price(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ShopRecommendTemplateNormalGiftParam::VT_PRICE,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn logoId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopRecommendTemplateNormalGiftParam::VT_LOGOID,
                None,
            )
        }
    }
    #[inline]
    pub fn color(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopRecommendTemplateNormalGiftParam::VT_COLOR,
                None,
            )
        }
    }
    #[inline]
    pub fn haveMark(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_ShopRecommendTemplateNormalGiftParam::VT_HAVEMARK,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn availCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ShopRecommendTemplateNormalGiftParam::VT_AVAILCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ShopRecommendTemplateNormalGiftParam<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("showStartTs", Self::VT_SHOWSTARTTS, false)?
            .visit_field::<i64>("showEndTs", Self::VT_SHOWENDTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("goodId", Self::VT_GOODID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "giftPackageName",
                Self::VT_GIFTPACKAGENAME,
                false,
            )?
            .visit_field::<i32>("price", Self::VT_PRICE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("logoId", Self::VT_LOGOID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("color", Self::VT_COLOR, false)?
            .visit_field::<bool>("haveMark", Self::VT_HAVEMARK, false)?
            .visit_field::<i32>("availCount", Self::VT_AVAILCOUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ShopRecommendTemplateNormalGiftParamArgs<'a> {
    pub showStartTs: i64,
    pub showEndTs: i64,
    pub goodId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub giftPackageName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub price: i32,
    pub logoId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub color: Option<flatbuffers::WIPOffset<&'a str>>,
    pub haveMark: bool,
    pub availCount: i32,
}
impl<'a> Default for clz_Torappu_ShopRecommendTemplateNormalGiftParamArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ShopRecommendTemplateNormalGiftParamArgs {
            showStartTs: 0,
            showEndTs: 0,
            goodId: None,
            giftPackageName: None,
            price: 0,
            logoId: None,
            color: None,
            haveMark: false,
            availCount: 0,
        }
    }
}

impl Serialize for clz_Torappu_ShopRecommendTemplateNormalGiftParam<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_ShopRecommendTemplateNormalGiftParam", 9)?;
        s.serialize_field("showStartTs", &self.showStartTs())?;
        s.serialize_field("showEndTs", &self.showEndTs())?;
        if let Some(f) = self.goodId() {
            s.serialize_field("goodId", &f)?;
        } else {
            s.skip_field("goodId")?;
        }
        if let Some(f) = self.giftPackageName() {
            s.serialize_field("giftPackageName", &f)?;
        } else {
            s.skip_field("giftPackageName")?;
        }
        s.serialize_field("price", &self.price())?;
        if let Some(f) = self.logoId() {
            s.serialize_field("logoId", &f)?;
        } else {
            s.skip_field("logoId")?;
        }
        if let Some(f) = self.color() {
            s.serialize_field("color", &f)?;
        } else {
            s.skip_field("color")?;
        }
        s.serialize_field("haveMark", &self.haveMark())?;
        s.serialize_field("availCount", &self.availCount())?;
        s.end()
    }
}

pub struct clz_Torappu_ShopRecommendTemplateNormalGiftParamBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ShopRecommendTemplateNormalGiftParamBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_showStartTs(&mut self, showStartTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_ShopRecommendTemplateNormalGiftParam::VT_SHOWSTARTTS,
            showStartTs,
            0,
        );
    }
    #[inline]
    pub fn add_showEndTs(&mut self, showEndTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_ShopRecommendTemplateNormalGiftParam::VT_SHOWENDTS,
            showEndTs,
            0,
        );
    }
    #[inline]
    pub fn add_goodId(&mut self, goodId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendTemplateNormalGiftParam::VT_GOODID,
            goodId,
        );
    }
    #[inline]
    pub fn add_giftPackageName(&mut self, giftPackageName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendTemplateNormalGiftParam::VT_GIFTPACKAGENAME,
            giftPackageName,
        );
    }
    #[inline]
    pub fn add_price(&mut self, price: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ShopRecommendTemplateNormalGiftParam::VT_PRICE,
            price,
            0,
        );
    }
    #[inline]
    pub fn add_logoId(&mut self, logoId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendTemplateNormalGiftParam::VT_LOGOID,
            logoId,
        );
    }
    #[inline]
    pub fn add_color(&mut self, color: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendTemplateNormalGiftParam::VT_COLOR,
            color,
        );
    }
    #[inline]
    pub fn add_haveMark(&mut self, haveMark: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_ShopRecommendTemplateNormalGiftParam::VT_HAVEMARK,
            haveMark,
            false,
        );
    }
    #[inline]
    pub fn add_availCount(&mut self, availCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ShopRecommendTemplateNormalGiftParam::VT_AVAILCOUNT,
            availCount,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ShopRecommendTemplateNormalGiftParamBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ShopRecommendTemplateNormalGiftParamBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateNormalGiftParam<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ShopRecommendTemplateNormalGiftParam<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ShopRecommendTemplateNormalGiftParam");
        ds.field("showStartTs", &self.showStartTs());
        ds.field("showEndTs", &self.showEndTs());
        ds.field("goodId", &self.goodId());
        ds.field("giftPackageName", &self.giftPackageName());
        ds.field("price", &self.price());
        ds.field("logoId", &self.logoId());
        ds.field("color", &self.color());
        ds.field("haveMark", &self.haveMark());
        ds.field("availCount", &self.availCount());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ShopRecommendTemplateNormalGiftParamT {
    pub showStartTs: i64,
    pub showEndTs: i64,
    pub goodId: Option<String>,
    pub giftPackageName: Option<String>,
    pub price: i32,
    pub logoId: Option<String>,
    pub color: Option<String>,
    pub haveMark: bool,
    pub availCount: i32,
}
impl Default for clz_Torappu_ShopRecommendTemplateNormalGiftParamT {
    fn default() -> Self {
        Self {
            showStartTs: 0,
            showEndTs: 0,
            goodId: None,
            giftPackageName: None,
            price: 0,
            logoId: None,
            color: None,
            haveMark: false,
            availCount: 0,
        }
    }
}
impl clz_Torappu_ShopRecommendTemplateNormalGiftParamT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateNormalGiftParam<'b>> {
        let showStartTs = self.showStartTs;
        let showEndTs = self.showEndTs;
        let goodId = self.goodId.as_ref().map(|x| _fbb.create_string(x));
        let giftPackageName = self.giftPackageName.as_ref().map(|x| _fbb.create_string(x));
        let price = self.price;
        let logoId = self.logoId.as_ref().map(|x| _fbb.create_string(x));
        let color = self.color.as_ref().map(|x| _fbb.create_string(x));
        let haveMark = self.haveMark;
        let availCount = self.availCount;
        clz_Torappu_ShopRecommendTemplateNormalGiftParam::create(
            _fbb,
            &clz_Torappu_ShopRecommendTemplateNormalGiftParamArgs {
                showStartTs,
                showEndTs,
                goodId,
                giftPackageName,
                price,
                logoId,
                color,
                haveMark,
                availCount,
            },
        )
    }
}
pub enum clz_Torappu_ShopRecommendTemplateNormalSkinParamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ShopRecommendTemplateNormalSkinParam<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ShopRecommendTemplateNormalSkinParam<'a> {
    type Inner = clz_Torappu_ShopRecommendTemplateNormalSkinParam<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ShopRecommendTemplateNormalSkinParam<'a> {
    pub const VT_SHOWSTARTTS: flatbuffers::VOffsetT = 4;
    pub const VT_SHOWENDTS: flatbuffers::VOffsetT = 6;
    pub const VT_SKINIDS: flatbuffers::VOffsetT = 8;
    pub const VT_SKINGROUPNAME: flatbuffers::VOffsetT = 10;
    pub const VT_BRANDICONID: flatbuffers::VOffsetT = 12;
    pub const VT_COLORBACK: flatbuffers::VOffsetT = 14;
    pub const VT_COLORTEXT: flatbuffers::VOffsetT = 16;
    pub const VT_TEXT: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ShopRecommendTemplateNormalSkinParam { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ShopRecommendTemplateNormalSkinParamArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateNormalSkinParam<'bldr>> {
        let mut builder = clz_Torappu_ShopRecommendTemplateNormalSkinParamBuilder::new(_fbb);
        builder.add_showEndTs(args.showEndTs);
        builder.add_showStartTs(args.showStartTs);
        if let Some(x) = args.text {
            builder.add_text(x);
        }
        if let Some(x) = args.colorText {
            builder.add_colorText(x);
        }
        if let Some(x) = args.colorBack {
            builder.add_colorBack(x);
        }
        if let Some(x) = args.brandIconId {
            builder.add_brandIconId(x);
        }
        if let Some(x) = args.skinGroupName {
            builder.add_skinGroupName(x);
        }
        if let Some(x) = args.skinIds {
            builder.add_skinIds(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ShopRecommendTemplateNormalSkinParamT {
        let showStartTs = self.showStartTs();
        let showEndTs = self.showEndTs();
        let skinIds = self
            .skinIds()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let skinGroupName = self.skinGroupName().map(|x| x.to_string());
        let brandIconId = self.brandIconId().map(|x| x.to_string());
        let colorBack = self.colorBack().map(|x| x.to_string());
        let colorText = self.colorText().map(|x| x.to_string());
        let text = self.text().map(|x| x.to_string());
        clz_Torappu_ShopRecommendTemplateNormalSkinParamT {
            showStartTs,
            showEndTs,
            skinIds,
            skinGroupName,
            brandIconId,
            colorBack,
            colorText,
            text,
        }
    }

    #[inline]
    pub fn showStartTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_ShopRecommendTemplateNormalSkinParam::VT_SHOWSTARTTS,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn showEndTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_ShopRecommendTemplateNormalSkinParam::VT_SHOWENDTS,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn skinIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_ShopRecommendTemplateNormalSkinParam::VT_SKINIDS,
                None,
            )
        }
    }
    #[inline]
    pub fn skinGroupName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopRecommendTemplateNormalSkinParam::VT_SKINGROUPNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn brandIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopRecommendTemplateNormalSkinParam::VT_BRANDICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn colorBack(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopRecommendTemplateNormalSkinParam::VT_COLORBACK,
                None,
            )
        }
    }
    #[inline]
    pub fn colorText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopRecommendTemplateNormalSkinParam::VT_COLORTEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn text(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopRecommendTemplateNormalSkinParam::VT_TEXT,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ShopRecommendTemplateNormalSkinParam<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("showStartTs", Self::VT_SHOWSTARTTS, false)?
            .visit_field::<i64>("showEndTs", Self::VT_SHOWENDTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("skinIds", Self::VT_SKINIDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "skinGroupName",
                Self::VT_SKINGROUPNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "brandIconId",
                Self::VT_BRANDICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "colorBack",
                Self::VT_COLORBACK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "colorText",
                Self::VT_COLORTEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ShopRecommendTemplateNormalSkinParamArgs<'a> {
    pub showStartTs: i64,
    pub showEndTs: i64,
    pub skinIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub skinGroupName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub brandIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub colorBack: Option<flatbuffers::WIPOffset<&'a str>>,
    pub colorText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ShopRecommendTemplateNormalSkinParamArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ShopRecommendTemplateNormalSkinParamArgs {
            showStartTs: 0,
            showEndTs: 0,
            skinIds: None,
            skinGroupName: None,
            brandIconId: None,
            colorBack: None,
            colorText: None,
            text: None,
        }
    }
}

impl Serialize for clz_Torappu_ShopRecommendTemplateNormalSkinParam<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_ShopRecommendTemplateNormalSkinParam", 8)?;
        s.serialize_field("showStartTs", &self.showStartTs())?;
        s.serialize_field("showEndTs", &self.showEndTs())?;
        if let Some(f) = self.skinIds() {
            s.serialize_field("skinIds", &f)?;
        } else {
            s.skip_field("skinIds")?;
        }
        if let Some(f) = self.skinGroupName() {
            s.serialize_field("skinGroupName", &f)?;
        } else {
            s.skip_field("skinGroupName")?;
        }
        if let Some(f) = self.brandIconId() {
            s.serialize_field("brandIconId", &f)?;
        } else {
            s.skip_field("brandIconId")?;
        }
        if let Some(f) = self.colorBack() {
            s.serialize_field("colorBack", &f)?;
        } else {
            s.skip_field("colorBack")?;
        }
        if let Some(f) = self.colorText() {
            s.serialize_field("colorText", &f)?;
        } else {
            s.skip_field("colorText")?;
        }
        if let Some(f) = self.text() {
            s.serialize_field("text", &f)?;
        } else {
            s.skip_field("text")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ShopRecommendTemplateNormalSkinParamBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ShopRecommendTemplateNormalSkinParamBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_showStartTs(&mut self, showStartTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_ShopRecommendTemplateNormalSkinParam::VT_SHOWSTARTTS,
            showStartTs,
            0,
        );
    }
    #[inline]
    pub fn add_showEndTs(&mut self, showEndTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_ShopRecommendTemplateNormalSkinParam::VT_SHOWENDTS,
            showEndTs,
            0,
        );
    }
    #[inline]
    pub fn add_skinIds(
        &mut self,
        skinIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendTemplateNormalSkinParam::VT_SKINIDS,
            skinIds,
        );
    }
    #[inline]
    pub fn add_skinGroupName(&mut self, skinGroupName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendTemplateNormalSkinParam::VT_SKINGROUPNAME,
            skinGroupName,
        );
    }
    #[inline]
    pub fn add_brandIconId(&mut self, brandIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendTemplateNormalSkinParam::VT_BRANDICONID,
            brandIconId,
        );
    }
    #[inline]
    pub fn add_colorBack(&mut self, colorBack: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendTemplateNormalSkinParam::VT_COLORBACK,
            colorBack,
        );
    }
    #[inline]
    pub fn add_colorText(&mut self, colorText: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendTemplateNormalSkinParam::VT_COLORTEXT,
            colorText,
        );
    }
    #[inline]
    pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendTemplateNormalSkinParam::VT_TEXT,
            text,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ShopRecommendTemplateNormalSkinParamBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ShopRecommendTemplateNormalSkinParamBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateNormalSkinParam<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ShopRecommendTemplateNormalSkinParam<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ShopRecommendTemplateNormalSkinParam");
        ds.field("showStartTs", &self.showStartTs());
        ds.field("showEndTs", &self.showEndTs());
        ds.field("skinIds", &self.skinIds());
        ds.field("skinGroupName", &self.skinGroupName());
        ds.field("brandIconId", &self.brandIconId());
        ds.field("colorBack", &self.colorBack());
        ds.field("colorText", &self.colorText());
        ds.field("text", &self.text());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ShopRecommendTemplateNormalSkinParamT {
    pub showStartTs: i64,
    pub showEndTs: i64,
    pub skinIds: Option<Vec<String>>,
    pub skinGroupName: Option<String>,
    pub brandIconId: Option<String>,
    pub colorBack: Option<String>,
    pub colorText: Option<String>,
    pub text: Option<String>,
}
impl Default for clz_Torappu_ShopRecommendTemplateNormalSkinParamT {
    fn default() -> Self {
        Self {
            showStartTs: 0,
            showEndTs: 0,
            skinIds: None,
            skinGroupName: None,
            brandIconId: None,
            colorBack: None,
            colorText: None,
            text: None,
        }
    }
}
impl clz_Torappu_ShopRecommendTemplateNormalSkinParamT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateNormalSkinParam<'b>> {
        let showStartTs = self.showStartTs;
        let showEndTs = self.showEndTs;
        let skinIds = self.skinIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let skinGroupName = self.skinGroupName.as_ref().map(|x| _fbb.create_string(x));
        let brandIconId = self.brandIconId.as_ref().map(|x| _fbb.create_string(x));
        let colorBack = self.colorBack.as_ref().map(|x| _fbb.create_string(x));
        let colorText = self.colorText.as_ref().map(|x| _fbb.create_string(x));
        let text = self.text.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_ShopRecommendTemplateNormalSkinParam::create(
            _fbb,
            &clz_Torappu_ShopRecommendTemplateNormalSkinParamArgs {
                showStartTs,
                showEndTs,
                skinIds,
                skinGroupName,
                brandIconId,
                colorBack,
                colorText,
                text,
            },
        )
    }
}
pub enum clz_Torappu_ShopRecommendTemplateNormalFurnParamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ShopRecommendTemplateNormalFurnParam<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ShopRecommendTemplateNormalFurnParam<'a> {
    type Inner = clz_Torappu_ShopRecommendTemplateNormalFurnParam<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ShopRecommendTemplateNormalFurnParam<'a> {
    pub const VT_SHOWSTARTTS: flatbuffers::VOffsetT = 4;
    pub const VT_SHOWENDTS: flatbuffers::VOffsetT = 6;
    pub const VT_FURNPACKID: flatbuffers::VOffsetT = 8;
    pub const VT_ISNEW: flatbuffers::VOffsetT = 10;
    pub const VT_ISPACKSELL: flatbuffers::VOffsetT = 12;
    pub const VT_COUNT: flatbuffers::VOffsetT = 14;
    pub const VT_COLORBACK: flatbuffers::VOffsetT = 16;
    pub const VT_COLORTEXT: flatbuffers::VOffsetT = 18;
    pub const VT_ACTID: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ShopRecommendTemplateNormalFurnParam { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ShopRecommendTemplateNormalFurnParamArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateNormalFurnParam<'bldr>> {
        let mut builder = clz_Torappu_ShopRecommendTemplateNormalFurnParamBuilder::new(_fbb);
        builder.add_showEndTs(args.showEndTs);
        builder.add_showStartTs(args.showStartTs);
        if let Some(x) = args.actId {
            builder.add_actId(x);
        }
        if let Some(x) = args.colorText {
            builder.add_colorText(x);
        }
        if let Some(x) = args.colorBack {
            builder.add_colorBack(x);
        }
        builder.add_count(args.count);
        if let Some(x) = args.furnPackId {
            builder.add_furnPackId(x);
        }
        builder.add_isPackSell(args.isPackSell);
        builder.add_isNew(args.isNew);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ShopRecommendTemplateNormalFurnParamT {
        let showStartTs = self.showStartTs();
        let showEndTs = self.showEndTs();
        let furnPackId = self.furnPackId().map(|x| x.to_string());
        let isNew = self.isNew();
        let isPackSell = self.isPackSell();
        let count = self.count();
        let colorBack = self.colorBack().map(|x| x.to_string());
        let colorText = self.colorText().map(|x| x.to_string());
        let actId = self.actId().map(|x| x.to_string());
        clz_Torappu_ShopRecommendTemplateNormalFurnParamT {
            showStartTs,
            showEndTs,
            furnPackId,
            isNew,
            isPackSell,
            count,
            colorBack,
            colorText,
            actId,
        }
    }

    #[inline]
    pub fn showStartTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_ShopRecommendTemplateNormalFurnParam::VT_SHOWSTARTTS,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn showEndTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_ShopRecommendTemplateNormalFurnParam::VT_SHOWENDTS,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn furnPackId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopRecommendTemplateNormalFurnParam::VT_FURNPACKID,
                None,
            )
        }
    }
    #[inline]
    pub fn isNew(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_ShopRecommendTemplateNormalFurnParam::VT_ISNEW,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn isPackSell(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_ShopRecommendTemplateNormalFurnParam::VT_ISPACKSELL,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ShopRecommendTemplateNormalFurnParam::VT_COUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn colorBack(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopRecommendTemplateNormalFurnParam::VT_COLORBACK,
                None,
            )
        }
    }
    #[inline]
    pub fn colorText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopRecommendTemplateNormalFurnParam::VT_COLORTEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn actId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopRecommendTemplateNormalFurnParam::VT_ACTID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ShopRecommendTemplateNormalFurnParam<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("showStartTs", Self::VT_SHOWSTARTTS, false)?
            .visit_field::<i64>("showEndTs", Self::VT_SHOWENDTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "furnPackId",
                Self::VT_FURNPACKID,
                false,
            )?
            .visit_field::<bool>("isNew", Self::VT_ISNEW, false)?
            .visit_field::<bool>("isPackSell", Self::VT_ISPACKSELL, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "colorBack",
                Self::VT_COLORBACK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "colorText",
                Self::VT_COLORTEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("actId", Self::VT_ACTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ShopRecommendTemplateNormalFurnParamArgs<'a> {
    pub showStartTs: i64,
    pub showEndTs: i64,
    pub furnPackId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isNew: bool,
    pub isPackSell: bool,
    pub count: i32,
    pub colorBack: Option<flatbuffers::WIPOffset<&'a str>>,
    pub colorText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub actId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ShopRecommendTemplateNormalFurnParamArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ShopRecommendTemplateNormalFurnParamArgs {
            showStartTs: 0,
            showEndTs: 0,
            furnPackId: None,
            isNew: false,
            isPackSell: false,
            count: 0,
            colorBack: None,
            colorText: None,
            actId: None,
        }
    }
}

impl Serialize for clz_Torappu_ShopRecommendTemplateNormalFurnParam<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_ShopRecommendTemplateNormalFurnParam", 9)?;
        s.serialize_field("showStartTs", &self.showStartTs())?;
        s.serialize_field("showEndTs", &self.showEndTs())?;
        if let Some(f) = self.furnPackId() {
            s.serialize_field("furnPackId", &f)?;
        } else {
            s.skip_field("furnPackId")?;
        }
        s.serialize_field("isNew", &self.isNew())?;
        s.serialize_field("isPackSell", &self.isPackSell())?;
        s.serialize_field("count", &self.count())?;
        if let Some(f) = self.colorBack() {
            s.serialize_field("colorBack", &f)?;
        } else {
            s.skip_field("colorBack")?;
        }
        if let Some(f) = self.colorText() {
            s.serialize_field("colorText", &f)?;
        } else {
            s.skip_field("colorText")?;
        }
        if let Some(f) = self.actId() {
            s.serialize_field("actId", &f)?;
        } else {
            s.skip_field("actId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ShopRecommendTemplateNormalFurnParamBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ShopRecommendTemplateNormalFurnParamBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_showStartTs(&mut self, showStartTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_ShopRecommendTemplateNormalFurnParam::VT_SHOWSTARTTS,
            showStartTs,
            0,
        );
    }
    #[inline]
    pub fn add_showEndTs(&mut self, showEndTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_ShopRecommendTemplateNormalFurnParam::VT_SHOWENDTS,
            showEndTs,
            0,
        );
    }
    #[inline]
    pub fn add_furnPackId(&mut self, furnPackId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendTemplateNormalFurnParam::VT_FURNPACKID,
            furnPackId,
        );
    }
    #[inline]
    pub fn add_isNew(&mut self, isNew: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_ShopRecommendTemplateNormalFurnParam::VT_ISNEW,
            isNew,
            false,
        );
    }
    #[inline]
    pub fn add_isPackSell(&mut self, isPackSell: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_ShopRecommendTemplateNormalFurnParam::VT_ISPACKSELL,
            isPackSell,
            false,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ShopRecommendTemplateNormalFurnParam::VT_COUNT,
            count,
            0,
        );
    }
    #[inline]
    pub fn add_colorBack(&mut self, colorBack: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendTemplateNormalFurnParam::VT_COLORBACK,
            colorBack,
        );
    }
    #[inline]
    pub fn add_colorText(&mut self, colorText: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendTemplateNormalFurnParam::VT_COLORTEXT,
            colorText,
        );
    }
    #[inline]
    pub fn add_actId(&mut self, actId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendTemplateNormalFurnParam::VT_ACTID,
            actId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ShopRecommendTemplateNormalFurnParamBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ShopRecommendTemplateNormalFurnParamBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateNormalFurnParam<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ShopRecommendTemplateNormalFurnParam<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ShopRecommendTemplateNormalFurnParam");
        ds.field("showStartTs", &self.showStartTs());
        ds.field("showEndTs", &self.showEndTs());
        ds.field("furnPackId", &self.furnPackId());
        ds.field("isNew", &self.isNew());
        ds.field("isPackSell", &self.isPackSell());
        ds.field("count", &self.count());
        ds.field("colorBack", &self.colorBack());
        ds.field("colorText", &self.colorText());
        ds.field("actId", &self.actId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ShopRecommendTemplateNormalFurnParamT {
    pub showStartTs: i64,
    pub showEndTs: i64,
    pub furnPackId: Option<String>,
    pub isNew: bool,
    pub isPackSell: bool,
    pub count: i32,
    pub colorBack: Option<String>,
    pub colorText: Option<String>,
    pub actId: Option<String>,
}
impl Default for clz_Torappu_ShopRecommendTemplateNormalFurnParamT {
    fn default() -> Self {
        Self {
            showStartTs: 0,
            showEndTs: 0,
            furnPackId: None,
            isNew: false,
            isPackSell: false,
            count: 0,
            colorBack: None,
            colorText: None,
            actId: None,
        }
    }
}
impl clz_Torappu_ShopRecommendTemplateNormalFurnParamT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateNormalFurnParam<'b>> {
        let showStartTs = self.showStartTs;
        let showEndTs = self.showEndTs;
        let furnPackId = self.furnPackId.as_ref().map(|x| _fbb.create_string(x));
        let isNew = self.isNew;
        let isPackSell = self.isPackSell;
        let count = self.count;
        let colorBack = self.colorBack.as_ref().map(|x| _fbb.create_string(x));
        let colorText = self.colorText.as_ref().map(|x| _fbb.create_string(x));
        let actId = self.actId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_ShopRecommendTemplateNormalFurnParam::create(
            _fbb,
            &clz_Torappu_ShopRecommendTemplateNormalFurnParamArgs {
                showStartTs,
                showEndTs,
                furnPackId,
                isNew,
                isPackSell,
                count,
                colorBack,
                colorText,
                actId,
            },
        )
    }
}
pub enum clz_Torappu_ShopRecommendTemplateReturnSkinParamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ShopRecommendTemplateReturnSkinParam<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ShopRecommendTemplateReturnSkinParam<'a> {
    type Inner = clz_Torappu_ShopRecommendTemplateReturnSkinParam<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ShopRecommendTemplateReturnSkinParam<'a> {
    pub const VT_SHOWSTARTTS: flatbuffers::VOffsetT = 4;
    pub const VT_SHOWENDTS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ShopRecommendTemplateReturnSkinParam { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ShopRecommendTemplateReturnSkinParamArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateReturnSkinParam<'bldr>> {
        let mut builder = clz_Torappu_ShopRecommendTemplateReturnSkinParamBuilder::new(_fbb);
        builder.add_showEndTs(args.showEndTs);
        builder.add_showStartTs(args.showStartTs);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ShopRecommendTemplateReturnSkinParamT {
        let showStartTs = self.showStartTs();
        let showEndTs = self.showEndTs();
        clz_Torappu_ShopRecommendTemplateReturnSkinParamT {
            showStartTs,
            showEndTs,
        }
    }

    #[inline]
    pub fn showStartTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_ShopRecommendTemplateReturnSkinParam::VT_SHOWSTARTTS,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn showEndTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_ShopRecommendTemplateReturnSkinParam::VT_SHOWENDTS,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ShopRecommendTemplateReturnSkinParam<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("showStartTs", Self::VT_SHOWSTARTTS, false)?
            .visit_field::<i64>("showEndTs", Self::VT_SHOWENDTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ShopRecommendTemplateReturnSkinParamArgs {
    pub showStartTs: i64,
    pub showEndTs: i64,
}
impl<'a> Default for clz_Torappu_ShopRecommendTemplateReturnSkinParamArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ShopRecommendTemplateReturnSkinParamArgs {
            showStartTs: 0,
            showEndTs: 0,
        }
    }
}

impl Serialize for clz_Torappu_ShopRecommendTemplateReturnSkinParam<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_ShopRecommendTemplateReturnSkinParam", 2)?;
        s.serialize_field("showStartTs", &self.showStartTs())?;
        s.serialize_field("showEndTs", &self.showEndTs())?;
        s.end()
    }
}

pub struct clz_Torappu_ShopRecommendTemplateReturnSkinParamBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ShopRecommendTemplateReturnSkinParamBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_showStartTs(&mut self, showStartTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_ShopRecommendTemplateReturnSkinParam::VT_SHOWSTARTTS,
            showStartTs,
            0,
        );
    }
    #[inline]
    pub fn add_showEndTs(&mut self, showEndTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_ShopRecommendTemplateReturnSkinParam::VT_SHOWENDTS,
            showEndTs,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ShopRecommendTemplateReturnSkinParamBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ShopRecommendTemplateReturnSkinParamBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateReturnSkinParam<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ShopRecommendTemplateReturnSkinParam<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ShopRecommendTemplateReturnSkinParam");
        ds.field("showStartTs", &self.showStartTs());
        ds.field("showEndTs", &self.showEndTs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ShopRecommendTemplateReturnSkinParamT {
    pub showStartTs: i64,
    pub showEndTs: i64,
}
impl Default for clz_Torappu_ShopRecommendTemplateReturnSkinParamT {
    fn default() -> Self {
        Self {
            showStartTs: 0,
            showEndTs: 0,
        }
    }
}
impl clz_Torappu_ShopRecommendTemplateReturnSkinParamT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateReturnSkinParam<'b>> {
        let showStartTs = self.showStartTs;
        let showEndTs = self.showEndTs;
        clz_Torappu_ShopRecommendTemplateReturnSkinParam::create(
            _fbb,
            &clz_Torappu_ShopRecommendTemplateReturnSkinParamArgs {
                showStartTs,
                showEndTs,
            },
        )
    }
}
pub enum clz_Torappu_ShopRecommendTemplateParamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ShopRecommendTemplateParam<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ShopRecommendTemplateParam<'a> {
    type Inner = clz_Torappu_ShopRecommendTemplateParam<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ShopRecommendTemplateParam<'a> {
    pub const VT_NORMALGIFTPARAM: flatbuffers::VOffsetT = 4;
    pub const VT_NORMALSKINPARAM: flatbuffers::VOffsetT = 6;
    pub const VT_NORMALFURNPARAM: flatbuffers::VOffsetT = 8;
    pub const VT_RETURNSKINPARAM: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ShopRecommendTemplateParam { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ShopRecommendTemplateParamArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateParam<'bldr>> {
        let mut builder = clz_Torappu_ShopRecommendTemplateParamBuilder::new(_fbb);
        if let Some(x) = args.returnSkinParam {
            builder.add_returnSkinParam(x);
        }
        if let Some(x) = args.normalFurnParam {
            builder.add_normalFurnParam(x);
        }
        if let Some(x) = args.normalSkinParam {
            builder.add_normalSkinParam(x);
        }
        if let Some(x) = args.normalGiftParam {
            builder.add_normalGiftParam(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ShopRecommendTemplateParamT {
        let normalGiftParam = self.normalGiftParam().map(|x| Box::new(x.unpack()));
        let normalSkinParam = self.normalSkinParam().map(|x| Box::new(x.unpack()));
        let normalFurnParam = self.normalFurnParam().map(|x| Box::new(x.unpack()));
        let returnSkinParam = self.returnSkinParam().map(|x| Box::new(x.unpack()));
        clz_Torappu_ShopRecommendTemplateParamT {
            normalGiftParam,
            normalSkinParam,
            normalFurnParam,
            returnSkinParam,
        }
    }

    #[inline]
    pub fn normalGiftParam(&self) -> Option<clz_Torappu_ShopRecommendTemplateNormalGiftParam<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendTemplateNormalGiftParam>>(clz_Torappu_ShopRecommendTemplateParam::VT_NORMALGIFTPARAM, None)
        }
    }
    #[inline]
    pub fn normalSkinParam(&self) -> Option<clz_Torappu_ShopRecommendTemplateNormalSkinParam<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendTemplateNormalSkinParam>>(clz_Torappu_ShopRecommendTemplateParam::VT_NORMALSKINPARAM, None)
        }
    }
    #[inline]
    pub fn normalFurnParam(&self) -> Option<clz_Torappu_ShopRecommendTemplateNormalFurnParam<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendTemplateNormalFurnParam>>(clz_Torappu_ShopRecommendTemplateParam::VT_NORMALFURNPARAM, None)
        }
    }
    #[inline]
    pub fn returnSkinParam(&self) -> Option<clz_Torappu_ShopRecommendTemplateReturnSkinParam<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendTemplateReturnSkinParam>>(clz_Torappu_ShopRecommendTemplateParam::VT_RETURNSKINPARAM, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ShopRecommendTemplateParam<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendTemplateNormalGiftParam>>("normalGiftParam", Self::VT_NORMALGIFTPARAM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendTemplateNormalSkinParam>>("normalSkinParam", Self::VT_NORMALSKINPARAM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendTemplateNormalFurnParam>>("normalFurnParam", Self::VT_NORMALFURNPARAM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendTemplateReturnSkinParam>>("returnSkinParam", Self::VT_RETURNSKINPARAM, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ShopRecommendTemplateParamArgs<'a> {
    pub normalGiftParam:
        Option<flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateNormalGiftParam<'a>>>,
    pub normalSkinParam:
        Option<flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateNormalSkinParam<'a>>>,
    pub normalFurnParam:
        Option<flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateNormalFurnParam<'a>>>,
    pub returnSkinParam:
        Option<flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateReturnSkinParam<'a>>>,
}
impl<'a> Default for clz_Torappu_ShopRecommendTemplateParamArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ShopRecommendTemplateParamArgs {
            normalGiftParam: None,
            normalSkinParam: None,
            normalFurnParam: None,
            returnSkinParam: None,
        }
    }
}

impl Serialize for clz_Torappu_ShopRecommendTemplateParam<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ShopRecommendTemplateParam", 4)?;
        if let Some(f) = self.normalGiftParam() {
            s.serialize_field("normalGiftParam", &f)?;
        } else {
            s.skip_field("normalGiftParam")?;
        }
        if let Some(f) = self.normalSkinParam() {
            s.serialize_field("normalSkinParam", &f)?;
        } else {
            s.skip_field("normalSkinParam")?;
        }
        if let Some(f) = self.normalFurnParam() {
            s.serialize_field("normalFurnParam", &f)?;
        } else {
            s.skip_field("normalFurnParam")?;
        }
        if let Some(f) = self.returnSkinParam() {
            s.serialize_field("returnSkinParam", &f)?;
        } else {
            s.skip_field("returnSkinParam")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ShopRecommendTemplateParamBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ShopRecommendTemplateParamBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_normalGiftParam(
        &mut self,
        normalGiftParam: flatbuffers::WIPOffset<
            clz_Torappu_ShopRecommendTemplateNormalGiftParam<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateNormalGiftParam>>(clz_Torappu_ShopRecommendTemplateParam::VT_NORMALGIFTPARAM, normalGiftParam);
    }
    #[inline]
    pub fn add_normalSkinParam(
        &mut self,
        normalSkinParam: flatbuffers::WIPOffset<
            clz_Torappu_ShopRecommendTemplateNormalSkinParam<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateNormalSkinParam>>(clz_Torappu_ShopRecommendTemplateParam::VT_NORMALSKINPARAM, normalSkinParam);
    }
    #[inline]
    pub fn add_normalFurnParam(
        &mut self,
        normalFurnParam: flatbuffers::WIPOffset<
            clz_Torappu_ShopRecommendTemplateNormalFurnParam<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateNormalFurnParam>>(clz_Torappu_ShopRecommendTemplateParam::VT_NORMALFURNPARAM, normalFurnParam);
    }
    #[inline]
    pub fn add_returnSkinParam(
        &mut self,
        returnSkinParam: flatbuffers::WIPOffset<
            clz_Torappu_ShopRecommendTemplateReturnSkinParam<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateReturnSkinParam>>(clz_Torappu_ShopRecommendTemplateParam::VT_RETURNSKINPARAM, returnSkinParam);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ShopRecommendTemplateParamBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ShopRecommendTemplateParamBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateParam<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ShopRecommendTemplateParam<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ShopRecommendTemplateParam");
        ds.field("normalGiftParam", &self.normalGiftParam());
        ds.field("normalSkinParam", &self.normalSkinParam());
        ds.field("normalFurnParam", &self.normalFurnParam());
        ds.field("returnSkinParam", &self.returnSkinParam());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ShopRecommendTemplateParamT {
    pub normalGiftParam: Option<Box<clz_Torappu_ShopRecommendTemplateNormalGiftParamT>>,
    pub normalSkinParam: Option<Box<clz_Torappu_ShopRecommendTemplateNormalSkinParamT>>,
    pub normalFurnParam: Option<Box<clz_Torappu_ShopRecommendTemplateNormalFurnParamT>>,
    pub returnSkinParam: Option<Box<clz_Torappu_ShopRecommendTemplateReturnSkinParamT>>,
}
impl Default for clz_Torappu_ShopRecommendTemplateParamT {
    fn default() -> Self {
        Self {
            normalGiftParam: None,
            normalSkinParam: None,
            normalFurnParam: None,
            returnSkinParam: None,
        }
    }
}
impl clz_Torappu_ShopRecommendTemplateParamT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateParam<'b>> {
        let normalGiftParam = self.normalGiftParam.as_ref().map(|x| x.pack(_fbb));
        let normalSkinParam = self.normalSkinParam.as_ref().map(|x| x.pack(_fbb));
        let normalFurnParam = self.normalFurnParam.as_ref().map(|x| x.pack(_fbb));
        let returnSkinParam = self.returnSkinParam.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_ShopRecommendTemplateParam::create(
            _fbb,
            &clz_Torappu_ShopRecommendTemplateParamArgs {
                normalGiftParam,
                normalSkinParam,
                normalFurnParam,
                returnSkinParam,
            },
        )
    }
}
pub enum clz_Torappu_ShopRecommendItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ShopRecommendItem<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ShopRecommendItem<'a> {
    type Inner = clz_Torappu_ShopRecommendItem<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ShopRecommendItem<'a> {
    pub const VT_TAGID: flatbuffers::VOffsetT = 4;
    pub const VT_DISPLAYTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_TAGNAME: flatbuffers::VOffsetT = 8;
    pub const VT_ITEMTAG: flatbuffers::VOffsetT = 10;
    pub const VT_ORDERNUM: flatbuffers::VOffsetT = 12;
    pub const VT_STARTDATETIME: flatbuffers::VOffsetT = 14;
    pub const VT_ENDDATETIME: flatbuffers::VOffsetT = 16;
    pub const VT_GROUPLIST: flatbuffers::VOffsetT = 18;
    pub const VT_TAGWORD: flatbuffers::VOffsetT = 20;
    pub const VT_TEMPLATETYPE: flatbuffers::VOffsetT = 22;
    pub const VT_TEMPLATEPARAM: flatbuffers::VOffsetT = 24;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ShopRecommendItem { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ShopRecommendItemArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendItem<'bldr>> {
        let mut builder = clz_Torappu_ShopRecommendItemBuilder::new(_fbb);
        builder.add_endDatetime(args.endDatetime);
        builder.add_startDatetime(args.startDatetime);
        if let Some(x) = args.templateParam {
            builder.add_templateParam(x);
        }
        builder.add_templateType(args.templateType);
        if let Some(x) = args.tagWord {
            builder.add_tagWord(x);
        }
        if let Some(x) = args.groupList {
            builder.add_groupList(x);
        }
        builder.add_orderNum(args.orderNum);
        builder.add_itemTag(args.itemTag);
        if let Some(x) = args.tagName {
            builder.add_tagName(x);
        }
        if let Some(x) = args.displayType {
            builder.add_displayType(x);
        }
        if let Some(x) = args.tagId {
            builder.add_tagId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ShopRecommendItemT {
        let tagId = self.tagId().map(|x| x.to_string());
        let displayType = self.displayType().map(|x| x.to_string());
        let tagName = self.tagName().map(|x| x.to_string());
        let itemTag = self.itemTag();
        let orderNum = self.orderNum();
        let startDatetime = self.startDatetime();
        let endDatetime = self.endDatetime();
        let groupList = self
            .groupList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let tagWord = self.tagWord().map(|x| Box::new(x.unpack()));
        let templateType = self.templateType();
        let templateParam = self.templateParam().map(|x| Box::new(x.unpack()));
        clz_Torappu_ShopRecommendItemT {
            tagId,
            displayType,
            tagName,
            itemTag,
            orderNum,
            startDatetime,
            endDatetime,
            groupList,
            tagWord,
            templateType,
            templateParam,
        }
    }

    #[inline]
    pub fn tagId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopRecommendItem::VT_TAGID,
                None,
            )
        }
    }
    #[inline]
    pub fn displayType(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopRecommendItem::VT_DISPLAYTYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn tagName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopRecommendItem::VT_TAGNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn itemTag(&self) -> enum__Torappu_RecommendItemTagTips {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RecommendItemTagTips>(
                    clz_Torappu_ShopRecommendItem::VT_ITEMTAG,
                    Some(enum__Torappu_RecommendItemTagTips::ONSALE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn orderNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ShopRecommendItem::VT_ORDERNUM, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn startDatetime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_ShopRecommendItem::VT_STARTDATETIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endDatetime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_ShopRecommendItem::VT_ENDDATETIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn groupList(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendGroup<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendGroup>,
                >,
            >>(clz_Torappu_ShopRecommendItem::VT_GROUPLIST, None)
        }
    }
    #[inline]
    pub fn tagWord(&self) -> Option<clz_Torappu_ShopKeeperWord<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ShopKeeperWord>>(
                    clz_Torappu_ShopRecommendItem::VT_TAGWORD,
                    None,
                )
        }
    }
    #[inline]
    pub fn templateType(&self) -> enum__Torappu_ShopRecommendTemplateType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ShopRecommendTemplateType>(
                    clz_Torappu_ShopRecommendItem::VT_TEMPLATETYPE,
                    Some(enum__Torappu_ShopRecommendTemplateType::DEFAULT),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn templateParam(&self) -> Option<clz_Torappu_ShopRecommendTemplateParam<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendTemplateParam>>(
                    clz_Torappu_ShopRecommendItem::VT_TEMPLATEPARAM,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ShopRecommendItem<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tagId", Self::VT_TAGID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "displayType",
                Self::VT_DISPLAYTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tagName", Self::VT_TAGNAME, false)?
            .visit_field::<enum__Torappu_RecommendItemTagTips>("itemTag", Self::VT_ITEMTAG, false)?
            .visit_field::<i32>("orderNum", Self::VT_ORDERNUM, false)?
            .visit_field::<i64>("startDatetime", Self::VT_STARTDATETIME, false)?
            .visit_field::<i64>("endDatetime", Self::VT_ENDDATETIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendGroup>,
                >,
            >>("groupList", Self::VT_GROUPLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ShopKeeperWord>>(
                "tagWord",
                Self::VT_TAGWORD,
                false,
            )?
            .visit_field::<enum__Torappu_ShopRecommendTemplateType>(
                "templateType",
                Self::VT_TEMPLATETYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendTemplateParam>>(
                "templateParam",
                Self::VT_TEMPLATEPARAM,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ShopRecommendItemArgs<'a> {
    pub tagId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub displayType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tagName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemTag: enum__Torappu_RecommendItemTagTips,
    pub orderNum: i32,
    pub startDatetime: i64,
    pub endDatetime: i64,
    pub groupList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendGroup<'a>>,
            >,
        >,
    >,
    pub tagWord: Option<flatbuffers::WIPOffset<clz_Torappu_ShopKeeperWord<'a>>>,
    pub templateType: enum__Torappu_ShopRecommendTemplateType,
    pub templateParam: Option<flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateParam<'a>>>,
}
impl<'a> Default for clz_Torappu_ShopRecommendItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ShopRecommendItemArgs {
            tagId: None,
            displayType: None,
            tagName: None,
            itemTag: enum__Torappu_RecommendItemTagTips::ONSALE,
            orderNum: 0,
            startDatetime: 0,
            endDatetime: 0,
            groupList: None,
            tagWord: None,
            templateType: enum__Torappu_ShopRecommendTemplateType::DEFAULT,
            templateParam: None,
        }
    }
}

impl Serialize for clz_Torappu_ShopRecommendItem<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ShopRecommendItem", 11)?;
        if let Some(f) = self.tagId() {
            s.serialize_field("tagId", &f)?;
        } else {
            s.skip_field("tagId")?;
        }
        if let Some(f) = self.displayType() {
            s.serialize_field("displayType", &f)?;
        } else {
            s.skip_field("displayType")?;
        }
        if let Some(f) = self.tagName() {
            s.serialize_field("tagName", &f)?;
        } else {
            s.skip_field("tagName")?;
        }
        s.serialize_field("itemTag", &self.itemTag())?;
        s.serialize_field("orderNum", &self.orderNum())?;
        s.serialize_field("startDatetime", &self.startDatetime())?;
        s.serialize_field("endDatetime", &self.endDatetime())?;
        if let Some(f) = self.groupList() {
            s.serialize_field("groupList", &f)?;
        } else {
            s.skip_field("groupList")?;
        }
        if let Some(f) = self.tagWord() {
            s.serialize_field("tagWord", &f)?;
        } else {
            s.skip_field("tagWord")?;
        }
        s.serialize_field("templateType", &self.templateType())?;
        if let Some(f) = self.templateParam() {
            s.serialize_field("templateParam", &f)?;
        } else {
            s.skip_field("templateParam")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ShopRecommendItemBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ShopRecommendItemBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_tagId(&mut self, tagId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendItem::VT_TAGID,
            tagId,
        );
    }
    #[inline]
    pub fn add_displayType(&mut self, displayType: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendItem::VT_DISPLAYTYPE,
            displayType,
        );
    }
    #[inline]
    pub fn add_tagName(&mut self, tagName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendItem::VT_TAGNAME,
            tagName,
        );
    }
    #[inline]
    pub fn add_itemTag(&mut self, itemTag: enum__Torappu_RecommendItemTagTips) {
        self.fbb_.push_slot::<enum__Torappu_RecommendItemTagTips>(
            clz_Torappu_ShopRecommendItem::VT_ITEMTAG,
            itemTag,
            enum__Torappu_RecommendItemTagTips::ONSALE,
        );
    }
    #[inline]
    pub fn add_orderNum(&mut self, orderNum: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ShopRecommendItem::VT_ORDERNUM, orderNum, 0);
    }
    #[inline]
    pub fn add_startDatetime(&mut self, startDatetime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_ShopRecommendItem::VT_STARTDATETIME,
            startDatetime,
            0,
        );
    }
    #[inline]
    pub fn add_endDatetime(&mut self, endDatetime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_ShopRecommendItem::VT_ENDDATETIME,
            endDatetime,
            0,
        );
    }
    #[inline]
    pub fn add_groupList(
        &mut self,
        groupList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendGroup<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopRecommendItem::VT_GROUPLIST,
            groupList,
        );
    }
    #[inline]
    pub fn add_tagWord(&mut self, tagWord: flatbuffers::WIPOffset<clz_Torappu_ShopKeeperWord<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ShopKeeperWord>>(
                clz_Torappu_ShopRecommendItem::VT_TAGWORD,
                tagWord,
            );
    }
    #[inline]
    pub fn add_templateType(&mut self, templateType: enum__Torappu_ShopRecommendTemplateType) {
        self.fbb_
            .push_slot::<enum__Torappu_ShopRecommendTemplateType>(
                clz_Torappu_ShopRecommendItem::VT_TEMPLATETYPE,
                templateType,
                enum__Torappu_ShopRecommendTemplateType::DEFAULT,
            );
    }
    #[inline]
    pub fn add_templateParam(
        &mut self,
        templateParam: flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateParam<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ShopRecommendTemplateParam>>(
                clz_Torappu_ShopRecommendItem::VT_TEMPLATEPARAM,
                templateParam,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ShopRecommendItemBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ShopRecommendItemBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendItem<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ShopRecommendItem<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ShopRecommendItem");
        ds.field("tagId", &self.tagId());
        ds.field("displayType", &self.displayType());
        ds.field("tagName", &self.tagName());
        ds.field("itemTag", &self.itemTag());
        ds.field("orderNum", &self.orderNum());
        ds.field("startDatetime", &self.startDatetime());
        ds.field("endDatetime", &self.endDatetime());
        ds.field("groupList", &self.groupList());
        ds.field("tagWord", &self.tagWord());
        ds.field("templateType", &self.templateType());
        ds.field("templateParam", &self.templateParam());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ShopRecommendItemT {
    pub tagId: Option<String>,
    pub displayType: Option<String>,
    pub tagName: Option<String>,
    pub itemTag: enum__Torappu_RecommendItemTagTips,
    pub orderNum: i32,
    pub startDatetime: i64,
    pub endDatetime: i64,
    pub groupList: Option<Vec<clz_Torappu_ShopRecommendGroupT>>,
    pub tagWord: Option<Box<clz_Torappu_ShopKeeperWordT>>,
    pub templateType: enum__Torappu_ShopRecommendTemplateType,
    pub templateParam: Option<Box<clz_Torappu_ShopRecommendTemplateParamT>>,
}
impl Default for clz_Torappu_ShopRecommendItemT {
    fn default() -> Self {
        Self {
            tagId: None,
            displayType: None,
            tagName: None,
            itemTag: enum__Torappu_RecommendItemTagTips::ONSALE,
            orderNum: 0,
            startDatetime: 0,
            endDatetime: 0,
            groupList: None,
            tagWord: None,
            templateType: enum__Torappu_ShopRecommendTemplateType::DEFAULT,
            templateParam: None,
        }
    }
}
impl clz_Torappu_ShopRecommendItemT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopRecommendItem<'b>> {
        let tagId = self.tagId.as_ref().map(|x| _fbb.create_string(x));
        let displayType = self.displayType.as_ref().map(|x| _fbb.create_string(x));
        let tagName = self.tagName.as_ref().map(|x| _fbb.create_string(x));
        let itemTag = self.itemTag;
        let orderNum = self.orderNum;
        let startDatetime = self.startDatetime;
        let endDatetime = self.endDatetime;
        let groupList = self.groupList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let tagWord = self.tagWord.as_ref().map(|x| x.pack(_fbb));
        let templateType = self.templateType;
        let templateParam = self.templateParam.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_ShopRecommendItem::create(
            _fbb,
            &clz_Torappu_ShopRecommendItemArgs {
                tagId,
                displayType,
                tagName,
                itemTag,
                orderNum,
                startDatetime,
                endDatetime,
                groupList,
                tagWord,
                templateType,
                templateParam,
            },
        )
    }
}
pub enum clz_Torappu_ShopCreditUnlockItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ShopCreditUnlockItem<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ShopCreditUnlockItem<'a> {
    type Inner = clz_Torappu_ShopCreditUnlockItem<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ShopCreditUnlockItem<'a> {
    pub const VT_SORTID: flatbuffers::VOffsetT = 4;
    pub const VT_UNLOCKNUM: flatbuffers::VOffsetT = 6;
    pub const VT_CHARID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ShopCreditUnlockItem { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ShopCreditUnlockItemArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopCreditUnlockItem<'bldr>> {
        let mut builder = clz_Torappu_ShopCreditUnlockItemBuilder::new(_fbb);
        if let Some(x) = args.charId {
            builder.add_charId(x);
        }
        builder.add_unlockNum(args.unlockNum);
        builder.add_sortId(args.sortId);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ShopCreditUnlockItemT {
        let sortId = self.sortId();
        let unlockNum = self.unlockNum();
        let charId = self.charId().map(|x| x.to_string());
        clz_Torappu_ShopCreditUnlockItemT {
            sortId,
            unlockNum,
            charId,
        }
    }

    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ShopCreditUnlockItem::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ShopCreditUnlockItem::VT_UNLOCKNUM, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn charId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopCreditUnlockItem::VT_CHARID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ShopCreditUnlockItem<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<i32>("unlockNum", Self::VT_UNLOCKNUM, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("charId", Self::VT_CHARID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ShopCreditUnlockItemArgs<'a> {
    pub sortId: i32,
    pub unlockNum: i32,
    pub charId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ShopCreditUnlockItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ShopCreditUnlockItemArgs {
            sortId: 0,
            unlockNum: 0,
            charId: None,
        }
    }
}

impl Serialize for clz_Torappu_ShopCreditUnlockItem<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ShopCreditUnlockItem", 3)?;
        s.serialize_field("sortId", &self.sortId())?;
        s.serialize_field("unlockNum", &self.unlockNum())?;
        if let Some(f) = self.charId() {
            s.serialize_field("charId", &f)?;
        } else {
            s.skip_field("charId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ShopCreditUnlockItemBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ShopCreditUnlockItemBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ShopCreditUnlockItem::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_unlockNum(&mut self, unlockNum: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ShopCreditUnlockItem::VT_UNLOCKNUM, unlockNum, 0);
    }
    #[inline]
    pub fn add_charId(&mut self, charId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopCreditUnlockItem::VT_CHARID,
            charId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ShopCreditUnlockItemBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ShopCreditUnlockItemBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ShopCreditUnlockItem<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ShopCreditUnlockItem<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ShopCreditUnlockItem");
        ds.field("sortId", &self.sortId());
        ds.field("unlockNum", &self.unlockNum());
        ds.field("charId", &self.charId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ShopCreditUnlockItemT {
    pub sortId: i32,
    pub unlockNum: i32,
    pub charId: Option<String>,
}
impl Default for clz_Torappu_ShopCreditUnlockItemT {
    fn default() -> Self {
        Self {
            sortId: 0,
            unlockNum: 0,
            charId: None,
        }
    }
}
impl clz_Torappu_ShopCreditUnlockItemT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopCreditUnlockItem<'b>> {
        let sortId = self.sortId;
        let unlockNum = self.unlockNum;
        let charId = self.charId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_ShopCreditUnlockItem::create(
            _fbb,
            &clz_Torappu_ShopCreditUnlockItemArgs {
                sortId,
                unlockNum,
                charId,
            },
        )
    }
}
pub enum clz_Torappu_ShopCreditUnlockGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ShopCreditUnlockGroup<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ShopCreditUnlockGroup<'a> {
    type Inner = clz_Torappu_ShopCreditUnlockGroup<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ShopCreditUnlockGroup<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_INDEX: flatbuffers::VOffsetT = 6;
    pub const VT_STARTDATETIME: flatbuffers::VOffsetT = 8;
    pub const VT_CHARDICT: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ShopCreditUnlockGroup { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ShopCreditUnlockGroupArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopCreditUnlockGroup<'bldr>> {
        let mut builder = clz_Torappu_ShopCreditUnlockGroupBuilder::new(_fbb);
        builder.add_startDateTime(args.startDateTime);
        if let Some(x) = args.charDict {
            builder.add_charDict(x);
        }
        if let Some(x) = args.index {
            builder.add_index(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ShopCreditUnlockGroupT {
        let id = self.id().map(|x| x.to_string());
        let index = self.index().map(|x| x.to_string());
        let startDateTime = self.startDateTime();
        let charDict = self
            .charDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ShopCreditUnlockGroupT {
            id,
            index,
            startDateTime,
            charDict,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopCreditUnlockGroup::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn index(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopCreditUnlockGroup::VT_INDEX,
                None,
            )
        }
    }
    #[inline]
    pub fn startDateTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_ShopCreditUnlockGroup::VT_STARTDATETIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn charDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ShopCreditUnlockItem<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ShopCreditUnlockItem>,
                >,
            >>(clz_Torappu_ShopCreditUnlockGroup::VT_CHARDICT, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ShopCreditUnlockGroup<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("index", Self::VT_INDEX, false)?
            .visit_field::<i64>("startDateTime", Self::VT_STARTDATETIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ShopCreditUnlockItem>,
                >,
            >>("charDict", Self::VT_CHARDICT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ShopCreditUnlockGroupArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub index: Option<flatbuffers::WIPOffset<&'a str>>,
    pub startDateTime: i64,
    pub charDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_ShopCreditUnlockItem<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ShopCreditUnlockGroupArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ShopCreditUnlockGroupArgs {
            id: None,
            index: None,
            startDateTime: 0,
            charDict: None,
        }
    }
}

impl Serialize for clz_Torappu_ShopCreditUnlockGroup<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ShopCreditUnlockGroup", 4)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.index() {
            s.serialize_field("index", &f)?;
        } else {
            s.skip_field("index")?;
        }
        s.serialize_field("startDateTime", &self.startDateTime())?;
        if let Some(f) = self.charDict() {
            s.serialize_field("charDict", &f)?;
        } else {
            s.skip_field("charDict")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ShopCreditUnlockGroupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ShopCreditUnlockGroupBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopCreditUnlockGroup::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_index(&mut self, index: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopCreditUnlockGroup::VT_INDEX,
            index,
        );
    }
    #[inline]
    pub fn add_startDateTime(&mut self, startDateTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_ShopCreditUnlockGroup::VT_STARTDATETIME,
            startDateTime,
            0,
        );
    }
    #[inline]
    pub fn add_charDict(
        &mut self,
        charDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_ShopCreditUnlockItem<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopCreditUnlockGroup::VT_CHARDICT,
            charDict,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ShopCreditUnlockGroupBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ShopCreditUnlockGroupBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ShopCreditUnlockGroup<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ShopCreditUnlockGroup<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ShopCreditUnlockGroup");
        ds.field("id", &self.id());
        ds.field("index", &self.index());
        ds.field("startDateTime", &self.startDateTime());
        ds.field("charDict", &self.charDict());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ShopCreditUnlockGroupT {
    pub id: Option<String>,
    pub index: Option<String>,
    pub startDateTime: i64,
    pub charDict: Option<Vec<clz_Torappu_ShopCreditUnlockItemT>>,
}
impl Default for clz_Torappu_ShopCreditUnlockGroupT {
    fn default() -> Self {
        Self {
            id: None,
            index: None,
            startDateTime: 0,
            charDict: None,
        }
    }
}
impl clz_Torappu_ShopCreditUnlockGroupT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopCreditUnlockGroup<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let index = self.index.as_ref().map(|x| _fbb.create_string(x));
        let startDateTime = self.startDateTime;
        let charDict = self.charDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ShopCreditUnlockGroup::create(
            _fbb,
            &clz_Torappu_ShopCreditUnlockGroupArgs {
                id,
                index,
                startDateTime,
                charDict,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ShopCreditUnlockGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ShopCreditUnlockGroup<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ShopCreditUnlockGroup<'a> {
    type Inner = dict__string__clz_Torappu_ShopCreditUnlockGroup<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ShopCreditUnlockGroup<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ShopCreditUnlockGroup { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ShopCreditUnlockGroupArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ShopCreditUnlockGroup<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ShopCreditUnlockGroupBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ShopCreditUnlockGroupT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ShopCreditUnlockGroupT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ShopCreditUnlockGroup::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ShopCreditUnlockGroup,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ShopCreditUnlockGroup<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ShopCreditUnlockGroup>>(
                    dict__string__clz_Torappu_ShopCreditUnlockGroup::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ShopCreditUnlockGroup<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ShopCreditUnlockGroup>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ShopCreditUnlockGroupArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ShopCreditUnlockGroup<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ShopCreditUnlockGroupArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ShopCreditUnlockGroupArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ShopCreditUnlockGroup<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ShopCreditUnlockGroup", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ShopCreditUnlockGroupBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ShopCreditUnlockGroupBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ShopCreditUnlockGroup::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ShopCreditUnlockGroup<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ShopCreditUnlockGroup>>(
                dict__string__clz_Torappu_ShopCreditUnlockGroup::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ShopCreditUnlockGroupBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ShopCreditUnlockGroupBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ShopCreditUnlockGroup<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ShopCreditUnlockGroup::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ShopCreditUnlockGroup<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ShopCreditUnlockGroup");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ShopCreditUnlockGroupT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ShopCreditUnlockGroupT>>,
}
impl Default for dict__string__clz_Torappu_ShopCreditUnlockGroupT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ShopCreditUnlockGroupT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ShopCreditUnlockGroup<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ShopCreditUnlockGroup::create(
            _fbb,
            &dict__string__clz_Torappu_ShopCreditUnlockGroupArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ShopClientData_ShopKeeperDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ShopClientData_ShopKeeperData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ShopClientData_ShopKeeperData<'a> {
    type Inner = clz_Torappu_ShopClientData_ShopKeeperData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ShopClientData_ShopKeeperData<'a> {
    pub const VT_WELCOMEWORDS: flatbuffers::VOffsetT = 4;
    pub const VT_CLICKWORDS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ShopClientData_ShopKeeperData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ShopClientData_ShopKeeperDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopClientData_ShopKeeperData<'bldr>> {
        let mut builder = clz_Torappu_ShopClientData_ShopKeeperDataBuilder::new(_fbb);
        if let Some(x) = args.clickWords {
            builder.add_clickWords(x);
        }
        if let Some(x) = args.welcomeWords {
            builder.add_welcomeWords(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ShopClientData_ShopKeeperDataT {
        let welcomeWords = self
            .welcomeWords()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let clickWords = self
            .clickWords()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ShopClientData_ShopKeeperDataT {
            welcomeWords,
            clickWords,
        }
    }

    #[inline]
    pub fn welcomeWords(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ShopKeeperWord<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ShopKeeperWord>>,
            >>(
                clz_Torappu_ShopClientData_ShopKeeperData::VT_WELCOMEWORDS,
                None,
            )
        }
    }
    #[inline]
    pub fn clickWords(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ShopKeeperWord<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ShopKeeperWord>>,
            >>(
                clz_Torappu_ShopClientData_ShopKeeperData::VT_CLICKWORDS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ShopClientData_ShopKeeperData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ShopKeeperWord>>,
            >>("welcomeWords", Self::VT_WELCOMEWORDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ShopKeeperWord>>,
            >>("clickWords", Self::VT_CLICKWORDS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ShopClientData_ShopKeeperDataArgs<'a> {
    pub welcomeWords: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ShopKeeperWord<'a>>>,
        >,
    >,
    pub clickWords: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ShopKeeperWord<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ShopClientData_ShopKeeperDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ShopClientData_ShopKeeperDataArgs {
            welcomeWords: None,
            clickWords: None,
        }
    }
}

impl Serialize for clz_Torappu_ShopClientData_ShopKeeperData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ShopClientData_ShopKeeperData", 2)?;
        if let Some(f) = self.welcomeWords() {
            s.serialize_field("welcomeWords", &f)?;
        } else {
            s.skip_field("welcomeWords")?;
        }
        if let Some(f) = self.clickWords() {
            s.serialize_field("clickWords", &f)?;
        } else {
            s.skip_field("clickWords")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ShopClientData_ShopKeeperDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ShopClientData_ShopKeeperDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_welcomeWords(
        &mut self,
        welcomeWords: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ShopKeeperWord<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopClientData_ShopKeeperData::VT_WELCOMEWORDS,
            welcomeWords,
        );
    }
    #[inline]
    pub fn add_clickWords(
        &mut self,
        clickWords: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ShopKeeperWord<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopClientData_ShopKeeperData::VT_CLICKWORDS,
            clickWords,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ShopClientData_ShopKeeperDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ShopClientData_ShopKeeperDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ShopClientData_ShopKeeperData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ShopClientData_ShopKeeperData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ShopClientData_ShopKeeperData");
        ds.field("welcomeWords", &self.welcomeWords());
        ds.field("clickWords", &self.clickWords());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ShopClientData_ShopKeeperDataT {
    pub welcomeWords: Option<Vec<clz_Torappu_ShopKeeperWordT>>,
    pub clickWords: Option<Vec<clz_Torappu_ShopKeeperWordT>>,
}
impl Default for clz_Torappu_ShopClientData_ShopKeeperDataT {
    fn default() -> Self {
        Self {
            welcomeWords: None,
            clickWords: None,
        }
    }
}
impl clz_Torappu_ShopClientData_ShopKeeperDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopClientData_ShopKeeperData<'b>> {
        let welcomeWords = self.welcomeWords.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let clickWords = self.clickWords.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ShopClientData_ShopKeeperData::create(
            _fbb,
            &clz_Torappu_ShopClientData_ShopKeeperDataArgs {
                welcomeWords,
                clickWords,
            },
        )
    }
}
pub enum clz_Torappu_ShopCarouselData_ItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ShopCarouselData_Item<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ShopCarouselData_Item<'a> {
    type Inner = clz_Torappu_ShopCarouselData_Item<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ShopCarouselData_Item<'a> {
    pub const VT_SPRITEID: flatbuffers::VOffsetT = 4;
    pub const VT_STARTTIME: flatbuffers::VOffsetT = 6;
    pub const VT_ENDTIME: flatbuffers::VOffsetT = 8;
    pub const VT_CMD: flatbuffers::VOffsetT = 10;
    pub const VT_PARAM1: flatbuffers::VOffsetT = 12;
    pub const VT_SKINID: flatbuffers::VOffsetT = 14;
    pub const VT_FURNIID: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ShopCarouselData_Item { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ShopCarouselData_ItemArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopCarouselData_Item<'bldr>> {
        let mut builder = clz_Torappu_ShopCarouselData_ItemBuilder::new(_fbb);
        builder.add_endTime(args.endTime);
        builder.add_startTime(args.startTime);
        if let Some(x) = args.furniId {
            builder.add_furniId(x);
        }
        if let Some(x) = args.skinId {
            builder.add_skinId(x);
        }
        if let Some(x) = args.param1 {
            builder.add_param1(x);
        }
        builder.add_cmd(args.cmd);
        if let Some(x) = args.spriteId {
            builder.add_spriteId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ShopCarouselData_ItemT {
        let spriteId = self.spriteId().map(|x| x.to_string());
        let startTime = self.startTime();
        let endTime = self.endTime();
        let cmd = self.cmd();
        let param1 = self.param1().map(|x| x.to_string());
        let skinId = self.skinId().map(|x| x.to_string());
        let furniId = self.furniId().map(|x| x.to_string());
        clz_Torappu_ShopCarouselData_ItemT {
            spriteId,
            startTime,
            endTime,
            cmd,
            param1,
            skinId,
            furniId,
        }
    }

    #[inline]
    pub fn spriteId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopCarouselData_Item::VT_SPRITEID,
                None,
            )
        }
    }
    #[inline]
    pub fn startTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_ShopCarouselData_Item::VT_STARTTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_ShopCarouselData_Item::VT_ENDTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn cmd(&self) -> enum__Torappu_ShopRouteTarget {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ShopRouteTarget>(
                    clz_Torappu_ShopCarouselData_Item::VT_CMD,
                    Some(enum__Torappu_ShopRouteTarget::RECOMMENDSHOP),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn param1(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopCarouselData_Item::VT_PARAM1,
                None,
            )
        }
    }
    #[inline]
    pub fn skinId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopCarouselData_Item::VT_SKINID,
                None,
            )
        }
    }
    #[inline]
    pub fn furniId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopCarouselData_Item::VT_FURNIID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ShopCarouselData_Item<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "spriteId",
                Self::VT_SPRITEID,
                false,
            )?
            .visit_field::<i64>("startTime", Self::VT_STARTTIME, false)?
            .visit_field::<i64>("endTime", Self::VT_ENDTIME, false)?
            .visit_field::<enum__Torappu_ShopRouteTarget>("cmd", Self::VT_CMD, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("param1", Self::VT_PARAM1, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("skinId", Self::VT_SKINID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("furniId", Self::VT_FURNIID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ShopCarouselData_ItemArgs<'a> {
    pub spriteId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub startTime: i64,
    pub endTime: i64,
    pub cmd: enum__Torappu_ShopRouteTarget,
    pub param1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub skinId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub furniId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ShopCarouselData_ItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ShopCarouselData_ItemArgs {
            spriteId: None,
            startTime: 0,
            endTime: 0,
            cmd: enum__Torappu_ShopRouteTarget::RECOMMENDSHOP,
            param1: None,
            skinId: None,
            furniId: None,
        }
    }
}

impl Serialize for clz_Torappu_ShopCarouselData_Item<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ShopCarouselData_Item", 7)?;
        if let Some(f) = self.spriteId() {
            s.serialize_field("spriteId", &f)?;
        } else {
            s.skip_field("spriteId")?;
        }
        s.serialize_field("startTime", &self.startTime())?;
        s.serialize_field("endTime", &self.endTime())?;
        s.serialize_field("cmd", &self.cmd())?;
        if let Some(f) = self.param1() {
            s.serialize_field("param1", &f)?;
        } else {
            s.skip_field("param1")?;
        }
        if let Some(f) = self.skinId() {
            s.serialize_field("skinId", &f)?;
        } else {
            s.skip_field("skinId")?;
        }
        if let Some(f) = self.furniId() {
            s.serialize_field("furniId", &f)?;
        } else {
            s.skip_field("furniId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ShopCarouselData_ItemBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ShopCarouselData_ItemBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_spriteId(&mut self, spriteId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopCarouselData_Item::VT_SPRITEID,
            spriteId,
        );
    }
    #[inline]
    pub fn add_startTime(&mut self, startTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_ShopCarouselData_Item::VT_STARTTIME,
            startTime,
            0,
        );
    }
    #[inline]
    pub fn add_endTime(&mut self, endTime: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_ShopCarouselData_Item::VT_ENDTIME, endTime, 0);
    }
    #[inline]
    pub fn add_cmd(&mut self, cmd: enum__Torappu_ShopRouteTarget) {
        self.fbb_.push_slot::<enum__Torappu_ShopRouteTarget>(
            clz_Torappu_ShopCarouselData_Item::VT_CMD,
            cmd,
            enum__Torappu_ShopRouteTarget::RECOMMENDSHOP,
        );
    }
    #[inline]
    pub fn add_param1(&mut self, param1: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopCarouselData_Item::VT_PARAM1,
            param1,
        );
    }
    #[inline]
    pub fn add_skinId(&mut self, skinId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopCarouselData_Item::VT_SKINID,
            skinId,
        );
    }
    #[inline]
    pub fn add_furniId(&mut self, furniId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopCarouselData_Item::VT_FURNIID,
            furniId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ShopCarouselData_ItemBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ShopCarouselData_ItemBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ShopCarouselData_Item<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ShopCarouselData_Item<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ShopCarouselData_Item");
        ds.field("spriteId", &self.spriteId());
        ds.field("startTime", &self.startTime());
        ds.field("endTime", &self.endTime());
        ds.field("cmd", &self.cmd());
        ds.field("param1", &self.param1());
        ds.field("skinId", &self.skinId());
        ds.field("furniId", &self.furniId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ShopCarouselData_ItemT {
    pub spriteId: Option<String>,
    pub startTime: i64,
    pub endTime: i64,
    pub cmd: enum__Torappu_ShopRouteTarget,
    pub param1: Option<String>,
    pub skinId: Option<String>,
    pub furniId: Option<String>,
}
impl Default for clz_Torappu_ShopCarouselData_ItemT {
    fn default() -> Self {
        Self {
            spriteId: None,
            startTime: 0,
            endTime: 0,
            cmd: enum__Torappu_ShopRouteTarget::RECOMMENDSHOP,
            param1: None,
            skinId: None,
            furniId: None,
        }
    }
}
impl clz_Torappu_ShopCarouselData_ItemT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopCarouselData_Item<'b>> {
        let spriteId = self.spriteId.as_ref().map(|x| _fbb.create_string(x));
        let startTime = self.startTime;
        let endTime = self.endTime;
        let cmd = self.cmd;
        let param1 = self.param1.as_ref().map(|x| _fbb.create_string(x));
        let skinId = self.skinId.as_ref().map(|x| _fbb.create_string(x));
        let furniId = self.furniId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_ShopCarouselData_Item::create(
            _fbb,
            &clz_Torappu_ShopCarouselData_ItemArgs {
                spriteId,
                startTime,
                endTime,
                cmd,
                param1,
                skinId,
                furniId,
            },
        )
    }
}
pub enum clz_Torappu_ShopCarouselDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ShopCarouselData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ShopCarouselData<'a> {
    type Inner = clz_Torappu_ShopCarouselData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ShopCarouselData<'a> {
    pub const VT_ITEMS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ShopCarouselData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ShopCarouselDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopCarouselData<'bldr>> {
        let mut builder = clz_Torappu_ShopCarouselDataBuilder::new(_fbb);
        if let Some(x) = args.items {
            builder.add_items(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ShopCarouselDataT {
        let items = self.items().map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ShopCarouselDataT { items }
    }

    #[inline]
    pub fn items(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_ShopCarouselData_Item<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ShopCarouselData_Item>,
                >,
            >>(clz_Torappu_ShopCarouselData::VT_ITEMS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ShopCarouselData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ShopCarouselData_Item>,
                >,
            >>("items", Self::VT_ITEMS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ShopCarouselDataArgs<'a> {
    pub items: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_ShopCarouselData_Item<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ShopCarouselDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ShopCarouselDataArgs { items: None }
    }
}

impl Serialize for clz_Torappu_ShopCarouselData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ShopCarouselData", 1)?;
        if let Some(f) = self.items() {
            s.serialize_field("items", &f)?;
        } else {
            s.skip_field("items")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ShopCarouselDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ShopCarouselDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_items(
        &mut self,
        items: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_ShopCarouselData_Item<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopCarouselData::VT_ITEMS,
            items,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ShopCarouselDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ShopCarouselDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ShopCarouselData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ShopCarouselData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ShopCarouselData");
        ds.field("items", &self.items());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ShopCarouselDataT {
    pub items: Option<Vec<clz_Torappu_ShopCarouselData_ItemT>>,
}
impl Default for clz_Torappu_ShopCarouselDataT {
    fn default() -> Self {
        Self { items: None }
    }
}
impl clz_Torappu_ShopCarouselDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopCarouselData<'b>> {
        let items = self.items.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ShopCarouselData::create(_fbb, &clz_Torappu_ShopCarouselDataArgs { items })
    }
}
pub enum clz_Torappu_ChooseShopRelationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ChooseShopRelation<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ChooseShopRelation<'a> {
    type Inner = clz_Torappu_ChooseShopRelation<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ChooseShopRelation<'a> {
    pub const VT_GOODID: flatbuffers::VOffsetT = 4;
    pub const VT_OPTIONLIST: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ChooseShopRelation { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ChooseShopRelationArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ChooseShopRelation<'bldr>> {
        let mut builder = clz_Torappu_ChooseShopRelationBuilder::new(_fbb);
        if let Some(x) = args.optionList {
            builder.add_optionList(x);
        }
        if let Some(x) = args.goodId {
            builder.add_goodId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ChooseShopRelationT {
        let goodId = self.goodId().map(|x| x.to_string());
        let optionList = self
            .optionList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_ChooseShopRelationT { goodId, optionList }
    }

    #[inline]
    pub fn goodId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ChooseShopRelation::VT_GOODID,
                None,
            )
        }
    }
    #[inline]
    pub fn optionList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ChooseShopRelation::VT_OPTIONLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ChooseShopRelation<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("goodId", Self::VT_GOODID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("optionList", Self::VT_OPTIONLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ChooseShopRelationArgs<'a> {
    pub goodId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub optionList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_ChooseShopRelationArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ChooseShopRelationArgs {
            goodId: None,
            optionList: None,
        }
    }
}

impl Serialize for clz_Torappu_ChooseShopRelation<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ChooseShopRelation", 2)?;
        if let Some(f) = self.goodId() {
            s.serialize_field("goodId", &f)?;
        } else {
            s.skip_field("goodId")?;
        }
        if let Some(f) = self.optionList() {
            s.serialize_field("optionList", &f)?;
        } else {
            s.skip_field("optionList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ChooseShopRelationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ChooseShopRelationBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_goodId(&mut self, goodId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ChooseShopRelation::VT_GOODID,
            goodId,
        );
    }
    #[inline]
    pub fn add_optionList(
        &mut self,
        optionList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ChooseShopRelation::VT_OPTIONLIST,
            optionList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ChooseShopRelationBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ChooseShopRelationBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ChooseShopRelation<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ChooseShopRelation<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ChooseShopRelation");
        ds.field("goodId", &self.goodId());
        ds.field("optionList", &self.optionList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ChooseShopRelationT {
    pub goodId: Option<String>,
    pub optionList: Option<Vec<String>>,
}
impl Default for clz_Torappu_ChooseShopRelationT {
    fn default() -> Self {
        Self {
            goodId: None,
            optionList: None,
        }
    }
}
impl clz_Torappu_ChooseShopRelationT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ChooseShopRelation<'b>> {
        let goodId = self.goodId.as_ref().map(|x| _fbb.create_string(x));
        let optionList = self.optionList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ChooseShopRelation::create(
            _fbb,
            &clz_Torappu_ChooseShopRelationArgs { goodId, optionList },
        )
    }
}
pub enum dict__string__enum__Torappu_ShopUnlockTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__enum__Torappu_ShopUnlockType<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__enum__Torappu_ShopUnlockType<'a> {
    type Inner = dict__string__enum__Torappu_ShopUnlockType<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__enum__Torappu_ShopUnlockType<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__enum__Torappu_ShopUnlockType { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__enum__Torappu_ShopUnlockTypeArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__enum__Torappu_ShopUnlockType<'bldr>> {
        let mut builder = dict__string__enum__Torappu_ShopUnlockTypeBuilder::new(_fbb);
        builder.add_value(args.value);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__enum__Torappu_ShopUnlockTypeT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value();
        dict__string__enum__Torappu_ShopUnlockTypeT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__enum__Torappu_ShopUnlockType::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__enum__Torappu_ShopUnlockType) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> enum__Torappu_ShopUnlockType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ShopUnlockType>(
                    dict__string__enum__Torappu_ShopUnlockType::VT_VALUE,
                    Some(enum__Torappu_ShopUnlockType::ALWAYS_UNLOCK),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for dict__string__enum__Torappu_ShopUnlockType<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<enum__Torappu_ShopUnlockType>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__enum__Torappu_ShopUnlockTypeArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: enum__Torappu_ShopUnlockType,
}
impl<'a> Default for dict__string__enum__Torappu_ShopUnlockTypeArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__enum__Torappu_ShopUnlockTypeArgs {
            key: None, // required field
            value: enum__Torappu_ShopUnlockType::ALWAYS_UNLOCK,
        }
    }
}

impl Serialize for dict__string__enum__Torappu_ShopUnlockType<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__enum__Torappu_ShopUnlockType", 2)?;
        s.serialize_field("key", &self.key())?;
        s.serialize_field("value", &self.value())?;
        s.end()
    }
}

pub struct dict__string__enum__Torappu_ShopUnlockTypeBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__enum__Torappu_ShopUnlockTypeBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__enum__Torappu_ShopUnlockType::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: enum__Torappu_ShopUnlockType) {
        self.fbb_.push_slot::<enum__Torappu_ShopUnlockType>(
            dict__string__enum__Torappu_ShopUnlockType::VT_VALUE,
            value,
            enum__Torappu_ShopUnlockType::ALWAYS_UNLOCK,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__enum__Torappu_ShopUnlockTypeBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__enum__Torappu_ShopUnlockTypeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__enum__Torappu_ShopUnlockType<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__enum__Torappu_ShopUnlockType::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__enum__Torappu_ShopUnlockType<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__enum__Torappu_ShopUnlockType");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__enum__Torappu_ShopUnlockTypeT {
    pub key: String,
    pub value: enum__Torappu_ShopUnlockType,
}
impl Default for dict__string__enum__Torappu_ShopUnlockTypeT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: enum__Torappu_ShopUnlockType::ALWAYS_UNLOCK,
        }
    }
}
impl dict__string__enum__Torappu_ShopUnlockTypeT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__enum__Torappu_ShopUnlockType<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value;
        dict__string__enum__Torappu_ShopUnlockType::create(
            _fbb,
            &dict__string__enum__Torappu_ShopUnlockTypeArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ShopClientGPDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ShopClientGPData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ShopClientGPData<'a> {
    type Inner = clz_Torappu_ShopClientGPData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ShopClientGPData<'a> {
    pub const VT_GOODID: flatbuffers::VOffsetT = 4;
    pub const VT_DISPLAYNAME: flatbuffers::VOffsetT = 6;
    pub const VT_CONDTRIGPACKAGETYPE: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ShopClientGPData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ShopClientGPDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopClientGPData<'bldr>> {
        let mut builder = clz_Torappu_ShopClientGPDataBuilder::new(_fbb);
        builder.add_condTrigPackageType(args.condTrigPackageType);
        if let Some(x) = args.displayName {
            builder.add_displayName(x);
        }
        if let Some(x) = args.goodId {
            builder.add_goodId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ShopClientGPDataT {
        let goodId = self.goodId().map(|x| x.to_string());
        let displayName = self.displayName().map(|x| x.to_string());
        let condTrigPackageType = self.condTrigPackageType();
        clz_Torappu_ShopClientGPDataT {
            goodId,
            displayName,
            condTrigPackageType,
        }
    }

    #[inline]
    pub fn goodId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopClientGPData::VT_GOODID,
                None,
            )
        }
    }
    #[inline]
    pub fn displayName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopClientGPData::VT_DISPLAYNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn condTrigPackageType(&self) -> enum__Torappu_ShopCondTrigPackageType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ShopCondTrigPackageType>(
                    clz_Torappu_ShopClientGPData::VT_CONDTRIGPACKAGETYPE,
                    Some(enum__Torappu_ShopCondTrigPackageType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ShopClientGPData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("goodId", Self::VT_GOODID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "displayName",
                Self::VT_DISPLAYNAME,
                false,
            )?
            .visit_field::<enum__Torappu_ShopCondTrigPackageType>(
                "condTrigPackageType",
                Self::VT_CONDTRIGPACKAGETYPE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ShopClientGPDataArgs<'a> {
    pub goodId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub displayName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub condTrigPackageType: enum__Torappu_ShopCondTrigPackageType,
}
impl<'a> Default for clz_Torappu_ShopClientGPDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ShopClientGPDataArgs {
            goodId: None,
            displayName: None,
            condTrigPackageType: enum__Torappu_ShopCondTrigPackageType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_ShopClientGPData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ShopClientGPData", 3)?;
        if let Some(f) = self.goodId() {
            s.serialize_field("goodId", &f)?;
        } else {
            s.skip_field("goodId")?;
        }
        if let Some(f) = self.displayName() {
            s.serialize_field("displayName", &f)?;
        } else {
            s.skip_field("displayName")?;
        }
        s.serialize_field("condTrigPackageType", &self.condTrigPackageType())?;
        s.end()
    }
}

pub struct clz_Torappu_ShopClientGPDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ShopClientGPDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_goodId(&mut self, goodId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopClientGPData::VT_GOODID,
            goodId,
        );
    }
    #[inline]
    pub fn add_displayName(&mut self, displayName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopClientGPData::VT_DISPLAYNAME,
            displayName,
        );
    }
    #[inline]
    pub fn add_condTrigPackageType(
        &mut self,
        condTrigPackageType: enum__Torappu_ShopCondTrigPackageType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_ShopCondTrigPackageType>(
                clz_Torappu_ShopClientGPData::VT_CONDTRIGPACKAGETYPE,
                condTrigPackageType,
                enum__Torappu_ShopCondTrigPackageType::NONE,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ShopClientGPDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ShopClientGPDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ShopClientGPData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ShopClientGPData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ShopClientGPData");
        ds.field("goodId", &self.goodId());
        ds.field("displayName", &self.displayName());
        ds.field("condTrigPackageType", &self.condTrigPackageType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ShopClientGPDataT {
    pub goodId: Option<String>,
    pub displayName: Option<String>,
    pub condTrigPackageType: enum__Torappu_ShopCondTrigPackageType,
}
impl Default for clz_Torappu_ShopClientGPDataT {
    fn default() -> Self {
        Self {
            goodId: None,
            displayName: None,
            condTrigPackageType: enum__Torappu_ShopCondTrigPackageType::NONE,
        }
    }
}
impl clz_Torappu_ShopClientGPDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopClientGPData<'b>> {
        let goodId = self.goodId.as_ref().map(|x| _fbb.create_string(x));
        let displayName = self.displayName.as_ref().map(|x| _fbb.create_string(x));
        let condTrigPackageType = self.condTrigPackageType;
        clz_Torappu_ShopClientGPData::create(
            _fbb,
            &clz_Torappu_ShopClientGPDataArgs {
                goodId,
                displayName,
                condTrigPackageType,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ShopClientGPDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ShopClientGPData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ShopClientGPData<'a> {
    type Inner = dict__string__clz_Torappu_ShopClientGPData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ShopClientGPData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ShopClientGPData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ShopClientGPDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ShopClientGPData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ShopClientGPDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ShopClientGPDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ShopClientGPDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ShopClientGPData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_ShopClientGPData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ShopClientGPData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ShopClientGPData>>(
                    dict__string__clz_Torappu_ShopClientGPData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ShopClientGPData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ShopClientGPData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ShopClientGPDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ShopClientGPData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ShopClientGPDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ShopClientGPDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ShopClientGPData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_ShopClientGPData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ShopClientGPDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ShopClientGPDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ShopClientGPData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_ShopClientGPData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ShopClientGPData>>(
                dict__string__clz_Torappu_ShopClientGPData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ShopClientGPDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ShopClientGPDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ShopClientGPData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_ShopClientGPData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ShopClientGPData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ShopClientGPData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ShopClientGPDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ShopClientGPDataT>>,
}
impl Default for dict__string__clz_Torappu_ShopClientGPDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ShopClientGPDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ShopClientGPData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ShopClientGPData::create(
            _fbb,
            &dict__string__clz_Torappu_ShopClientGPDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ShopGPTabDisplayDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ShopGPTabDisplayData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ShopGPTabDisplayData<'a> {
    type Inner = clz_Torappu_ShopGPTabDisplayData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ShopGPTabDisplayData<'a> {
    pub const VT_TABID: flatbuffers::VOffsetT = 4;
    pub const VT_TABNAME: flatbuffers::VOffsetT = 6;
    pub const VT_TABTYPE: flatbuffers::VOffsetT = 8;
    pub const VT_RECOMDISPLAYNUM: flatbuffers::VOffsetT = 10;
    pub const VT_TABPICID: flatbuffers::VOffsetT = 12;
    pub const VT_TABPICONCOLOR: flatbuffers::VOffsetT = 14;
    pub const VT_TABPICOFFCOLOR: flatbuffers::VOffsetT = 16;
    pub const VT_SORTID: flatbuffers::VOffsetT = 18;
    pub const VT_TABSTARTTIME: flatbuffers::VOffsetT = 20;
    pub const VT_TABENDTIME: flatbuffers::VOffsetT = 22;
    pub const VT_MARKERPICID: flatbuffers::VOffsetT = 24;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ShopGPTabDisplayData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ShopGPTabDisplayDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopGPTabDisplayData<'bldr>> {
        let mut builder = clz_Torappu_ShopGPTabDisplayDataBuilder::new(_fbb);
        builder.add_tabEndTime(args.tabEndTime);
        builder.add_tabStartTime(args.tabStartTime);
        if let Some(x) = args.markerPicId {
            builder.add_markerPicId(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.tabPicOffColor {
            builder.add_tabPicOffColor(x);
        }
        if let Some(x) = args.tabPicOnColor {
            builder.add_tabPicOnColor(x);
        }
        if let Some(x) = args.tabPicId {
            builder.add_tabPicId(x);
        }
        builder.add_recomDisplayNum(args.recomDisplayNum);
        builder.add_tabType(args.tabType);
        if let Some(x) = args.tabName {
            builder.add_tabName(x);
        }
        if let Some(x) = args.tabId {
            builder.add_tabId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ShopGPTabDisplayDataT {
        let tabId = self.tabId().map(|x| x.to_string());
        let tabName = self.tabName().map(|x| x.to_string());
        let tabType = self.tabType();
        let recomDisplayNum = self.recomDisplayNum();
        let tabPicId = self.tabPicId().map(|x| x.to_string());
        let tabPicOnColor = self.tabPicOnColor().map(|x| x.to_string());
        let tabPicOffColor = self.tabPicOffColor().map(|x| x.to_string());
        let sortId = self.sortId();
        let tabStartTime = self.tabStartTime();
        let tabEndTime = self.tabEndTime();
        let markerPicId = self.markerPicId().map(|x| x.to_string());
        clz_Torappu_ShopGPTabDisplayDataT {
            tabId,
            tabName,
            tabType,
            recomDisplayNum,
            tabPicId,
            tabPicOnColor,
            tabPicOffColor,
            sortId,
            tabStartTime,
            tabEndTime,
            markerPicId,
        }
    }

    #[inline]
    pub fn tabId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopGPTabDisplayData::VT_TABID,
                None,
            )
        }
    }
    #[inline]
    pub fn tabName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopGPTabDisplayData::VT_TABNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn tabType(&self) -> enum__Torappu_ShopGPTabType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ShopGPTabType>(
                    clz_Torappu_ShopGPTabDisplayData::VT_TABTYPE,
                    Some(enum__Torappu_ShopGPTabType::DEFAULT_ALL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn recomDisplayNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ShopGPTabDisplayData::VT_RECOMDISPLAYNUM,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn tabPicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopGPTabDisplayData::VT_TABPICID,
                None,
            )
        }
    }
    #[inline]
    pub fn tabPicOnColor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopGPTabDisplayData::VT_TABPICONCOLOR,
                None,
            )
        }
    }
    #[inline]
    pub fn tabPicOffColor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopGPTabDisplayData::VT_TABPICOFFCOLOR,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ShopGPTabDisplayData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn tabStartTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_ShopGPTabDisplayData::VT_TABSTARTTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn tabEndTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_ShopGPTabDisplayData::VT_TABENDTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn markerPicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopGPTabDisplayData::VT_MARKERPICID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ShopGPTabDisplayData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tabId", Self::VT_TABID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tabName", Self::VT_TABNAME, false)?
            .visit_field::<enum__Torappu_ShopGPTabType>("tabType", Self::VT_TABTYPE, false)?
            .visit_field::<i32>("recomDisplayNum", Self::VT_RECOMDISPLAYNUM, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "tabPicId",
                Self::VT_TABPICID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "tabPicOnColor",
                Self::VT_TABPICONCOLOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "tabPicOffColor",
                Self::VT_TABPICOFFCOLOR,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<i64>("tabStartTime", Self::VT_TABSTARTTIME, false)?
            .visit_field::<i64>("tabEndTime", Self::VT_TABENDTIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "markerPicId",
                Self::VT_MARKERPICID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ShopGPTabDisplayDataArgs<'a> {
    pub tabId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tabName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tabType: enum__Torappu_ShopGPTabType,
    pub recomDisplayNum: i32,
    pub tabPicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tabPicOnColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tabPicOffColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub tabStartTime: i64,
    pub tabEndTime: i64,
    pub markerPicId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ShopGPTabDisplayDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ShopGPTabDisplayDataArgs {
            tabId: None,
            tabName: None,
            tabType: enum__Torappu_ShopGPTabType::DEFAULT_ALL,
            recomDisplayNum: 0,
            tabPicId: None,
            tabPicOnColor: None,
            tabPicOffColor: None,
            sortId: 0,
            tabStartTime: 0,
            tabEndTime: 0,
            markerPicId: None,
        }
    }
}

impl Serialize for clz_Torappu_ShopGPTabDisplayData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ShopGPTabDisplayData", 11)?;
        if let Some(f) = self.tabId() {
            s.serialize_field("tabId", &f)?;
        } else {
            s.skip_field("tabId")?;
        }
        if let Some(f) = self.tabName() {
            s.serialize_field("tabName", &f)?;
        } else {
            s.skip_field("tabName")?;
        }
        s.serialize_field("tabType", &self.tabType())?;
        s.serialize_field("recomDisplayNum", &self.recomDisplayNum())?;
        if let Some(f) = self.tabPicId() {
            s.serialize_field("tabPicId", &f)?;
        } else {
            s.skip_field("tabPicId")?;
        }
        if let Some(f) = self.tabPicOnColor() {
            s.serialize_field("tabPicOnColor", &f)?;
        } else {
            s.skip_field("tabPicOnColor")?;
        }
        if let Some(f) = self.tabPicOffColor() {
            s.serialize_field("tabPicOffColor", &f)?;
        } else {
            s.skip_field("tabPicOffColor")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.serialize_field("tabStartTime", &self.tabStartTime())?;
        s.serialize_field("tabEndTime", &self.tabEndTime())?;
        if let Some(f) = self.markerPicId() {
            s.serialize_field("markerPicId", &f)?;
        } else {
            s.skip_field("markerPicId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ShopGPTabDisplayDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ShopGPTabDisplayDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_tabId(&mut self, tabId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopGPTabDisplayData::VT_TABID,
            tabId,
        );
    }
    #[inline]
    pub fn add_tabName(&mut self, tabName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopGPTabDisplayData::VT_TABNAME,
            tabName,
        );
    }
    #[inline]
    pub fn add_tabType(&mut self, tabType: enum__Torappu_ShopGPTabType) {
        self.fbb_.push_slot::<enum__Torappu_ShopGPTabType>(
            clz_Torappu_ShopGPTabDisplayData::VT_TABTYPE,
            tabType,
            enum__Torappu_ShopGPTabType::DEFAULT_ALL,
        );
    }
    #[inline]
    pub fn add_recomDisplayNum(&mut self, recomDisplayNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ShopGPTabDisplayData::VT_RECOMDISPLAYNUM,
            recomDisplayNum,
            0,
        );
    }
    #[inline]
    pub fn add_tabPicId(&mut self, tabPicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopGPTabDisplayData::VT_TABPICID,
            tabPicId,
        );
    }
    #[inline]
    pub fn add_tabPicOnColor(&mut self, tabPicOnColor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopGPTabDisplayData::VT_TABPICONCOLOR,
            tabPicOnColor,
        );
    }
    #[inline]
    pub fn add_tabPicOffColor(&mut self, tabPicOffColor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopGPTabDisplayData::VT_TABPICOFFCOLOR,
            tabPicOffColor,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ShopGPTabDisplayData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_tabStartTime(&mut self, tabStartTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_ShopGPTabDisplayData::VT_TABSTARTTIME,
            tabStartTime,
            0,
        );
    }
    #[inline]
    pub fn add_tabEndTime(&mut self, tabEndTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_ShopGPTabDisplayData::VT_TABENDTIME,
            tabEndTime,
            0,
        );
    }
    #[inline]
    pub fn add_markerPicId(&mut self, markerPicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopGPTabDisplayData::VT_MARKERPICID,
            markerPicId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ShopGPTabDisplayDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ShopGPTabDisplayDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ShopGPTabDisplayData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ShopGPTabDisplayData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ShopGPTabDisplayData");
        ds.field("tabId", &self.tabId());
        ds.field("tabName", &self.tabName());
        ds.field("tabType", &self.tabType());
        ds.field("recomDisplayNum", &self.recomDisplayNum());
        ds.field("tabPicId", &self.tabPicId());
        ds.field("tabPicOnColor", &self.tabPicOnColor());
        ds.field("tabPicOffColor", &self.tabPicOffColor());
        ds.field("sortId", &self.sortId());
        ds.field("tabStartTime", &self.tabStartTime());
        ds.field("tabEndTime", &self.tabEndTime());
        ds.field("markerPicId", &self.markerPicId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ShopGPTabDisplayDataT {
    pub tabId: Option<String>,
    pub tabName: Option<String>,
    pub tabType: enum__Torappu_ShopGPTabType,
    pub recomDisplayNum: i32,
    pub tabPicId: Option<String>,
    pub tabPicOnColor: Option<String>,
    pub tabPicOffColor: Option<String>,
    pub sortId: i32,
    pub tabStartTime: i64,
    pub tabEndTime: i64,
    pub markerPicId: Option<String>,
}
impl Default for clz_Torappu_ShopGPTabDisplayDataT {
    fn default() -> Self {
        Self {
            tabId: None,
            tabName: None,
            tabType: enum__Torappu_ShopGPTabType::DEFAULT_ALL,
            recomDisplayNum: 0,
            tabPicId: None,
            tabPicOnColor: None,
            tabPicOffColor: None,
            sortId: 0,
            tabStartTime: 0,
            tabEndTime: 0,
            markerPicId: None,
        }
    }
}
impl clz_Torappu_ShopGPTabDisplayDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopGPTabDisplayData<'b>> {
        let tabId = self.tabId.as_ref().map(|x| _fbb.create_string(x));
        let tabName = self.tabName.as_ref().map(|x| _fbb.create_string(x));
        let tabType = self.tabType;
        let recomDisplayNum = self.recomDisplayNum;
        let tabPicId = self.tabPicId.as_ref().map(|x| _fbb.create_string(x));
        let tabPicOnColor = self.tabPicOnColor.as_ref().map(|x| _fbb.create_string(x));
        let tabPicOffColor = self.tabPicOffColor.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let tabStartTime = self.tabStartTime;
        let tabEndTime = self.tabEndTime;
        let markerPicId = self.markerPicId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_ShopGPTabDisplayData::create(
            _fbb,
            &clz_Torappu_ShopGPTabDisplayDataArgs {
                tabId,
                tabName,
                tabType,
                recomDisplayNum,
                tabPicId,
                tabPicOnColor,
                tabPicOffColor,
                sortId,
                tabStartTime,
                tabEndTime,
                markerPicId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ShopGPTabDisplayDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ShopGPTabDisplayData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ShopGPTabDisplayData<'a> {
    type Inner = dict__string__clz_Torappu_ShopGPTabDisplayData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ShopGPTabDisplayData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ShopGPTabDisplayData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ShopGPTabDisplayDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ShopGPTabDisplayData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ShopGPTabDisplayDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ShopGPTabDisplayDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ShopGPTabDisplayDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ShopGPTabDisplayData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ShopGPTabDisplayData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ShopGPTabDisplayData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ShopGPTabDisplayData>>(
                    dict__string__clz_Torappu_ShopGPTabDisplayData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ShopGPTabDisplayData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ShopGPTabDisplayData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ShopGPTabDisplayDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ShopGPTabDisplayData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ShopGPTabDisplayDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ShopGPTabDisplayDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ShopGPTabDisplayData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ShopGPTabDisplayData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ShopGPTabDisplayDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ShopGPTabDisplayDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ShopGPTabDisplayData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ShopGPTabDisplayData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ShopGPTabDisplayData>>(
                dict__string__clz_Torappu_ShopGPTabDisplayData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ShopGPTabDisplayDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ShopGPTabDisplayDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ShopGPTabDisplayData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ShopGPTabDisplayData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ShopGPTabDisplayData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ShopGPTabDisplayData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ShopGPTabDisplayDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ShopGPTabDisplayDataT>>,
}
impl Default for dict__string__clz_Torappu_ShopGPTabDisplayDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ShopGPTabDisplayDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ShopGPTabDisplayData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ShopGPTabDisplayData::create(
            _fbb,
            &dict__string__clz_Torappu_ShopGPTabDisplayDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_LMTGSShopScheduleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LMTGSShopSchedule<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LMTGSShopSchedule<'a> {
    type Inner = clz_Torappu_LMTGSShopSchedule<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_LMTGSShopSchedule<'a> {
    pub const VT_GACHAPOOLID: flatbuffers::VOffsetT = 4;
    pub const VT_LMTGSID: flatbuffers::VOffsetT = 6;
    pub const VT_ICONCOLOR: flatbuffers::VOffsetT = 8;
    pub const VT_ICONBACKCOLOR: flatbuffers::VOffsetT = 10;
    pub const VT_STORETEXTCOLOR: flatbuffers::VOffsetT = 12;
    pub const VT_STARTTIME: flatbuffers::VOffsetT = 14;
    pub const VT_ENDTIME: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LMTGSShopSchedule { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LMTGSShopScheduleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LMTGSShopSchedule<'bldr>> {
        let mut builder = clz_Torappu_LMTGSShopScheduleBuilder::new(_fbb);
        builder.add_endTime(args.endTime);
        builder.add_startTime(args.startTime);
        if let Some(x) = args.storeTextColor {
            builder.add_storeTextColor(x);
        }
        if let Some(x) = args.iconBackColor {
            builder.add_iconBackColor(x);
        }
        if let Some(x) = args.iconColor {
            builder.add_iconColor(x);
        }
        if let Some(x) = args.LMTGSId {
            builder.add_LMTGSId(x);
        }
        if let Some(x) = args.gachaPoolId {
            builder.add_gachaPoolId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_LMTGSShopScheduleT {
        let gachaPoolId = self.gachaPoolId().map(|x| x.to_string());
        let LMTGSId = self.LMTGSId().map(|x| x.to_string());
        let iconColor = self.iconColor().map(|x| x.to_string());
        let iconBackColor = self.iconBackColor().map(|x| x.to_string());
        let storeTextColor = self.storeTextColor().map(|x| x.to_string());
        let startTime = self.startTime();
        let endTime = self.endTime();
        clz_Torappu_LMTGSShopScheduleT {
            gachaPoolId,
            LMTGSId,
            iconColor,
            iconBackColor,
            storeTextColor,
            startTime,
            endTime,
        }
    }

    #[inline]
    pub fn gachaPoolId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LMTGSShopSchedule::VT_GACHAPOOLID,
                None,
            )
        }
    }
    #[inline]
    pub fn LMTGSId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LMTGSShopSchedule::VT_LMTGSID,
                None,
            )
        }
    }
    #[inline]
    pub fn iconColor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LMTGSShopSchedule::VT_ICONCOLOR,
                None,
            )
        }
    }
    #[inline]
    pub fn iconBackColor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LMTGSShopSchedule::VT_ICONBACKCOLOR,
                None,
            )
        }
    }
    #[inline]
    pub fn storeTextColor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LMTGSShopSchedule::VT_STORETEXTCOLOR,
                None,
            )
        }
    }
    #[inline]
    pub fn startTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_LMTGSShopSchedule::VT_STARTTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_LMTGSShopSchedule::VT_ENDTIME, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LMTGSShopSchedule<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "gachaPoolId",
                Self::VT_GACHAPOOLID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LMTGSId", Self::VT_LMTGSID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "iconColor",
                Self::VT_ICONCOLOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "iconBackColor",
                Self::VT_ICONBACKCOLOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "storeTextColor",
                Self::VT_STORETEXTCOLOR,
                false,
            )?
            .visit_field::<i64>("startTime", Self::VT_STARTTIME, false)?
            .visit_field::<i64>("endTime", Self::VT_ENDTIME, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LMTGSShopScheduleArgs<'a> {
    pub gachaPoolId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LMTGSId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconBackColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub storeTextColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub startTime: i64,
    pub endTime: i64,
}
impl<'a> Default for clz_Torappu_LMTGSShopScheduleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LMTGSShopScheduleArgs {
            gachaPoolId: None,
            LMTGSId: None,
            iconColor: None,
            iconBackColor: None,
            storeTextColor: None,
            startTime: 0,
            endTime: 0,
        }
    }
}

impl Serialize for clz_Torappu_LMTGSShopSchedule<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_LMTGSShopSchedule", 7)?;
        if let Some(f) = self.gachaPoolId() {
            s.serialize_field("gachaPoolId", &f)?;
        } else {
            s.skip_field("gachaPoolId")?;
        }
        if let Some(f) = self.LMTGSId() {
            s.serialize_field("LMTGSId", &f)?;
        } else {
            s.skip_field("LMTGSId")?;
        }
        if let Some(f) = self.iconColor() {
            s.serialize_field("iconColor", &f)?;
        } else {
            s.skip_field("iconColor")?;
        }
        if let Some(f) = self.iconBackColor() {
            s.serialize_field("iconBackColor", &f)?;
        } else {
            s.skip_field("iconBackColor")?;
        }
        if let Some(f) = self.storeTextColor() {
            s.serialize_field("storeTextColor", &f)?;
        } else {
            s.skip_field("storeTextColor")?;
        }
        s.serialize_field("startTime", &self.startTime())?;
        s.serialize_field("endTime", &self.endTime())?;
        s.end()
    }
}

pub struct clz_Torappu_LMTGSShopScheduleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_LMTGSShopScheduleBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_gachaPoolId(&mut self, gachaPoolId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LMTGSShopSchedule::VT_GACHAPOOLID,
            gachaPoolId,
        );
    }
    #[inline]
    pub fn add_LMTGSId(&mut self, LMTGSId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LMTGSShopSchedule::VT_LMTGSID,
            LMTGSId,
        );
    }
    #[inline]
    pub fn add_iconColor(&mut self, iconColor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LMTGSShopSchedule::VT_ICONCOLOR,
            iconColor,
        );
    }
    #[inline]
    pub fn add_iconBackColor(&mut self, iconBackColor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LMTGSShopSchedule::VT_ICONBACKCOLOR,
            iconBackColor,
        );
    }
    #[inline]
    pub fn add_storeTextColor(&mut self, storeTextColor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LMTGSShopSchedule::VT_STORETEXTCOLOR,
            storeTextColor,
        );
    }
    #[inline]
    pub fn add_startTime(&mut self, startTime: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_LMTGSShopSchedule::VT_STARTTIME, startTime, 0);
    }
    #[inline]
    pub fn add_endTime(&mut self, endTime: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_LMTGSShopSchedule::VT_ENDTIME, endTime, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LMTGSShopScheduleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LMTGSShopScheduleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_LMTGSShopSchedule<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LMTGSShopSchedule<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LMTGSShopSchedule");
        ds.field("gachaPoolId", &self.gachaPoolId());
        ds.field("LMTGSId", &self.LMTGSId());
        ds.field("iconColor", &self.iconColor());
        ds.field("iconBackColor", &self.iconBackColor());
        ds.field("storeTextColor", &self.storeTextColor());
        ds.field("startTime", &self.startTime());
        ds.field("endTime", &self.endTime());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_LMTGSShopScheduleT {
    pub gachaPoolId: Option<String>,
    pub LMTGSId: Option<String>,
    pub iconColor: Option<String>,
    pub iconBackColor: Option<String>,
    pub storeTextColor: Option<String>,
    pub startTime: i64,
    pub endTime: i64,
}
impl Default for clz_Torappu_LMTGSShopScheduleT {
    fn default() -> Self {
        Self {
            gachaPoolId: None,
            LMTGSId: None,
            iconColor: None,
            iconBackColor: None,
            storeTextColor: None,
            startTime: 0,
            endTime: 0,
        }
    }
}
impl clz_Torappu_LMTGSShopScheduleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LMTGSShopSchedule<'b>> {
        let gachaPoolId = self.gachaPoolId.as_ref().map(|x| _fbb.create_string(x));
        let LMTGSId = self.LMTGSId.as_ref().map(|x| _fbb.create_string(x));
        let iconColor = self.iconColor.as_ref().map(|x| _fbb.create_string(x));
        let iconBackColor = self.iconBackColor.as_ref().map(|x| _fbb.create_string(x));
        let storeTextColor = self.storeTextColor.as_ref().map(|x| _fbb.create_string(x));
        let startTime = self.startTime;
        let endTime = self.endTime;
        clz_Torappu_LMTGSShopSchedule::create(
            _fbb,
            &clz_Torappu_LMTGSShopScheduleArgs {
                gachaPoolId,
                LMTGSId,
                iconColor,
                iconBackColor,
                storeTextColor,
                startTime,
                endTime,
            },
        )
    }
}
pub enum clz_Torappu_LMTGSShopOverlayScheduleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LMTGSShopOverlaySchedule<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LMTGSShopOverlaySchedule<'a> {
    type Inner = clz_Torappu_LMTGSShopOverlaySchedule<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_LMTGSShopOverlaySchedule<'a> {
    pub const VT_GACHAPOOLID1: flatbuffers::VOffsetT = 4;
    pub const VT_GACHAPOOLID2: flatbuffers::VOffsetT = 6;
    pub const VT_PICID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LMTGSShopOverlaySchedule { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LMTGSShopOverlayScheduleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LMTGSShopOverlaySchedule<'bldr>> {
        let mut builder = clz_Torappu_LMTGSShopOverlayScheduleBuilder::new(_fbb);
        if let Some(x) = args.picId {
            builder.add_picId(x);
        }
        if let Some(x) = args.gachaPoolId2 {
            builder.add_gachaPoolId2(x);
        }
        if let Some(x) = args.gachaPoolId1 {
            builder.add_gachaPoolId1(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_LMTGSShopOverlayScheduleT {
        let gachaPoolId1 = self.gachaPoolId1().map(|x| x.to_string());
        let gachaPoolId2 = self.gachaPoolId2().map(|x| x.to_string());
        let picId = self.picId().map(|x| x.to_string());
        clz_Torappu_LMTGSShopOverlayScheduleT {
            gachaPoolId1,
            gachaPoolId2,
            picId,
        }
    }

    #[inline]
    pub fn gachaPoolId1(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LMTGSShopOverlaySchedule::VT_GACHAPOOLID1,
                None,
            )
        }
    }
    #[inline]
    pub fn gachaPoolId2(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LMTGSShopOverlaySchedule::VT_GACHAPOOLID2,
                None,
            )
        }
    }
    #[inline]
    pub fn picId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LMTGSShopOverlaySchedule::VT_PICID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LMTGSShopOverlaySchedule<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "gachaPoolId1",
                Self::VT_GACHAPOOLID1,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "gachaPoolId2",
                Self::VT_GACHAPOOLID2,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("picId", Self::VT_PICID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LMTGSShopOverlayScheduleArgs<'a> {
    pub gachaPoolId1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gachaPoolId2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub picId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_LMTGSShopOverlayScheduleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LMTGSShopOverlayScheduleArgs {
            gachaPoolId1: None,
            gachaPoolId2: None,
            picId: None,
        }
    }
}

impl Serialize for clz_Torappu_LMTGSShopOverlaySchedule<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_LMTGSShopOverlaySchedule", 3)?;
        if let Some(f) = self.gachaPoolId1() {
            s.serialize_field("gachaPoolId1", &f)?;
        } else {
            s.skip_field("gachaPoolId1")?;
        }
        if let Some(f) = self.gachaPoolId2() {
            s.serialize_field("gachaPoolId2", &f)?;
        } else {
            s.skip_field("gachaPoolId2")?;
        }
        if let Some(f) = self.picId() {
            s.serialize_field("picId", &f)?;
        } else {
            s.skip_field("picId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_LMTGSShopOverlayScheduleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_LMTGSShopOverlayScheduleBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_gachaPoolId1(&mut self, gachaPoolId1: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LMTGSShopOverlaySchedule::VT_GACHAPOOLID1,
            gachaPoolId1,
        );
    }
    #[inline]
    pub fn add_gachaPoolId2(&mut self, gachaPoolId2: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LMTGSShopOverlaySchedule::VT_GACHAPOOLID2,
            gachaPoolId2,
        );
    }
    #[inline]
    pub fn add_picId(&mut self, picId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LMTGSShopOverlaySchedule::VT_PICID,
            picId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LMTGSShopOverlayScheduleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LMTGSShopOverlayScheduleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_LMTGSShopOverlaySchedule<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LMTGSShopOverlaySchedule<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LMTGSShopOverlaySchedule");
        ds.field("gachaPoolId1", &self.gachaPoolId1());
        ds.field("gachaPoolId2", &self.gachaPoolId2());
        ds.field("picId", &self.picId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_LMTGSShopOverlayScheduleT {
    pub gachaPoolId1: Option<String>,
    pub gachaPoolId2: Option<String>,
    pub picId: Option<String>,
}
impl Default for clz_Torappu_LMTGSShopOverlayScheduleT {
    fn default() -> Self {
        Self {
            gachaPoolId1: None,
            gachaPoolId2: None,
            picId: None,
        }
    }
}
impl clz_Torappu_LMTGSShopOverlayScheduleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LMTGSShopOverlaySchedule<'b>> {
        let gachaPoolId1 = self.gachaPoolId1.as_ref().map(|x| _fbb.create_string(x));
        let gachaPoolId2 = self.gachaPoolId2.as_ref().map(|x| _fbb.create_string(x));
        let picId = self.picId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_LMTGSShopOverlaySchedule::create(
            _fbb,
            &clz_Torappu_LMTGSShopOverlayScheduleArgs {
                gachaPoolId1,
                gachaPoolId2,
                picId,
            },
        )
    }
}
pub enum clz_Torappu_ShopClientDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ShopClientData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ShopClientData<'a> {
    type Inner = clz_Torappu_ShopClientData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ShopClientData<'a> {
    pub const VT_RECOMMENDLIST: flatbuffers::VOffsetT = 4;
    pub const VT_CREDITUNLOCKGROUP: flatbuffers::VOffsetT = 6;
    pub const VT_SHOPKEEPERDATA: flatbuffers::VOffsetT = 8;
    pub const VT_CAROUSELS: flatbuffers::VOffsetT = 10;
    pub const VT_CHOOSESHOPRELATIONS: flatbuffers::VOffsetT = 12;
    pub const VT_SHOPUNLOCKDICT: flatbuffers::VOffsetT = 14;
    pub const VT_EXTRAQCSHOPRULE: flatbuffers::VOffsetT = 16;
    pub const VT_REPQCSHOPRULE: flatbuffers::VOffsetT = 18;
    pub const VT_SHOPGPDATADICT: flatbuffers::VOffsetT = 20;
    pub const VT_TABDISPLAYDATA: flatbuffers::VOffsetT = 22;
    pub const VT_SHOPMONTHLYSUBGOODID: flatbuffers::VOffsetT = 24;
    pub const VT_LS: flatbuffers::VOffsetT = 26;
    pub const VT_OS: flatbuffers::VOffsetT = 28;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ShopClientData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ShopClientDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopClientData<'bldr>> {
        let mut builder = clz_Torappu_ShopClientDataBuilder::new(_fbb);
        if let Some(x) = args.os {
            builder.add_os(x);
        }
        if let Some(x) = args.ls {
            builder.add_ls(x);
        }
        if let Some(x) = args.shopMonthlySubGoodId {
            builder.add_shopMonthlySubGoodId(x);
        }
        if let Some(x) = args.tabDisplayData {
            builder.add_tabDisplayData(x);
        }
        if let Some(x) = args.shopGPDataDict {
            builder.add_shopGPDataDict(x);
        }
        if let Some(x) = args.repQCShopRule {
            builder.add_repQCShopRule(x);
        }
        if let Some(x) = args.extraQCShopRule {
            builder.add_extraQCShopRule(x);
        }
        if let Some(x) = args.shopUnlockDict {
            builder.add_shopUnlockDict(x);
        }
        if let Some(x) = args.chooseShopRelations {
            builder.add_chooseShopRelations(x);
        }
        if let Some(x) = args.carousels {
            builder.add_carousels(x);
        }
        if let Some(x) = args.shopKeeperData {
            builder.add_shopKeeperData(x);
        }
        if let Some(x) = args.creditUnlockGroup {
            builder.add_creditUnlockGroup(x);
        }
        if let Some(x) = args.recommendList {
            builder.add_recommendList(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ShopClientDataT {
        let recommendList = self
            .recommendList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let creditUnlockGroup = self
            .creditUnlockGroup()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let shopKeeperData = self.shopKeeperData().map(|x| Box::new(x.unpack()));
        let carousels = self
            .carousels()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let chooseShopRelations = self
            .chooseShopRelations()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let shopUnlockDict = self
            .shopUnlockDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let extraQCShopRule = self
            .extraQCShopRule()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let repQCShopRule = self
            .repQCShopRule()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let shopGPDataDict = self
            .shopGPDataDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let tabDisplayData = self
            .tabDisplayData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let shopMonthlySubGoodId = self.shopMonthlySubGoodId().map(|x| x.to_string());
        let ls = self.ls().map(|x| x.iter().map(|t| t.unpack()).collect());
        let os = self.os().map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ShopClientDataT {
            recommendList,
            creditUnlockGroup,
            shopKeeperData,
            carousels,
            chooseShopRelations,
            shopUnlockDict,
            extraQCShopRule,
            repQCShopRule,
            shopGPDataDict,
            tabDisplayData,
            shopMonthlySubGoodId,
            ls,
            os,
        }
    }

    #[inline]
    pub fn recommendList(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendItem<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendItem>,
                >,
            >>(clz_Torappu_ShopClientData::VT_RECOMMENDLIST, None)
        }
    }
    #[inline]
    pub fn creditUnlockGroup(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ShopCreditUnlockGroup<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ShopCreditUnlockGroup>,
                >,
            >>(clz_Torappu_ShopClientData::VT_CREDITUNLOCKGROUP, None)
        }
    }
    #[inline]
    pub fn shopKeeperData(&self) -> Option<clz_Torappu_ShopClientData_ShopKeeperData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ShopClientData_ShopKeeperData>>(
                    clz_Torappu_ShopClientData::VT_SHOPKEEPERDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn carousels(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ShopCarouselData<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ShopCarouselData>>,
            >>(clz_Torappu_ShopClientData::VT_CAROUSELS, None)
        }
    }
    #[inline]
    pub fn chooseShopRelations(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ChooseShopRelation<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ChooseShopRelation>,
                >,
            >>(clz_Torappu_ShopClientData::VT_CHOOSESHOPRELATIONS, None)
        }
    }
    #[inline]
    pub fn shopUnlockDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__enum__Torappu_ShopUnlockType<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__enum__Torappu_ShopUnlockType>,
                >,
            >>(clz_Torappu_ShopClientData::VT_SHOPUNLOCKDICT, None)
        }
    }
    #[inline]
    pub fn extraQCShopRule(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ShopClientData::VT_EXTRAQCSHOPRULE, None)
        }
    }
    #[inline]
    pub fn repQCShopRule(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ShopClientData::VT_REPQCSHOPRULE, None)
        }
    }
    #[inline]
    pub fn shopGPDataDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ShopClientGPData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ShopClientGPData>,
                >,
            >>(clz_Torappu_ShopClientData::VT_SHOPGPDATADICT, None)
        }
    }
    #[inline]
    pub fn tabDisplayData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ShopGPTabDisplayData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ShopGPTabDisplayData>,
                >,
            >>(clz_Torappu_ShopClientData::VT_TABDISPLAYDATA, None)
        }
    }
    #[inline]
    pub fn shopMonthlySubGoodId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ShopClientData::VT_SHOPMONTHLYSUBGOODID,
                None,
            )
        }
    }
    #[inline]
    pub fn ls(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_LMTGSShopSchedule<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LMTGSShopSchedule>,
                >,
            >>(clz_Torappu_ShopClientData::VT_LS, None)
        }
    }
    #[inline]
    pub fn os(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_LMTGSShopOverlaySchedule<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LMTGSShopOverlaySchedule>,
                >,
            >>(clz_Torappu_ShopClientData::VT_OS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ShopClientData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendItem>,
                >,
            >>("recommendList", Self::VT_RECOMMENDLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ShopCreditUnlockGroup>,
                >,
            >>("creditUnlockGroup", Self::VT_CREDITUNLOCKGROUP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ShopClientData_ShopKeeperData>>(
                "shopKeeperData",
                Self::VT_SHOPKEEPERDATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ShopCarouselData>>,
            >>("carousels", Self::VT_CAROUSELS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ChooseShopRelation>,
                >,
            >>("chooseShopRelations", Self::VT_CHOOSESHOPRELATIONS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__enum__Torappu_ShopUnlockType>,
                >,
            >>("shopUnlockDict", Self::VT_SHOPUNLOCKDICT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("extraQCShopRule", Self::VT_EXTRAQCSHOPRULE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("repQCShopRule", Self::VT_REPQCSHOPRULE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ShopClientGPData>,
                >,
            >>("shopGPDataDict", Self::VT_SHOPGPDATADICT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ShopGPTabDisplayData>,
                >,
            >>("tabDisplayData", Self::VT_TABDISPLAYDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "shopMonthlySubGoodId",
                Self::VT_SHOPMONTHLYSUBGOODID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LMTGSShopSchedule>,
                >,
            >>("ls", Self::VT_LS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LMTGSShopOverlaySchedule>,
                >,
            >>("os", Self::VT_OS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ShopClientDataArgs<'a> {
    pub recommendList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendItem<'a>>,
            >,
        >,
    >,
    pub creditUnlockGroup: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ShopCreditUnlockGroup<'a>>,
            >,
        >,
    >,
    pub shopKeeperData:
        Option<flatbuffers::WIPOffset<clz_Torappu_ShopClientData_ShopKeeperData<'a>>>,
    pub carousels: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ShopCarouselData<'a>>>,
        >,
    >,
    pub chooseShopRelations: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_ChooseShopRelation<'a>>,
            >,
        >,
    >,
    pub shopUnlockDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__enum__Torappu_ShopUnlockType<'a>>,
            >,
        >,
    >,
    pub extraQCShopRule: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub repQCShopRule: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub shopGPDataDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ShopClientGPData<'a>>,
            >,
        >,
    >,
    pub tabDisplayData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ShopGPTabDisplayData<'a>>,
            >,
        >,
    >,
    pub shopMonthlySubGoodId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ls: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_LMTGSShopSchedule<'a>>,
            >,
        >,
    >,
    pub os: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_LMTGSShopOverlaySchedule<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ShopClientDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ShopClientDataArgs {
            recommendList: None,
            creditUnlockGroup: None,
            shopKeeperData: None,
            carousels: None,
            chooseShopRelations: None,
            shopUnlockDict: None,
            extraQCShopRule: None,
            repQCShopRule: None,
            shopGPDataDict: None,
            tabDisplayData: None,
            shopMonthlySubGoodId: None,
            ls: None,
            os: None,
        }
    }
}

impl Serialize for clz_Torappu_ShopClientData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ShopClientData", 13)?;
        if let Some(f) = self.recommendList() {
            s.serialize_field("recommendList", &f)?;
        } else {
            s.skip_field("recommendList")?;
        }
        if let Some(f) = self.creditUnlockGroup() {
            s.serialize_field("creditUnlockGroup", &f)?;
        } else {
            s.skip_field("creditUnlockGroup")?;
        }
        if let Some(f) = self.shopKeeperData() {
            s.serialize_field("shopKeeperData", &f)?;
        } else {
            s.skip_field("shopKeeperData")?;
        }
        if let Some(f) = self.carousels() {
            s.serialize_field("carousels", &f)?;
        } else {
            s.skip_field("carousels")?;
        }
        if let Some(f) = self.chooseShopRelations() {
            s.serialize_field("chooseShopRelations", &f)?;
        } else {
            s.skip_field("chooseShopRelations")?;
        }
        if let Some(f) = self.shopUnlockDict() {
            s.serialize_field("shopUnlockDict", &f)?;
        } else {
            s.skip_field("shopUnlockDict")?;
        }
        if let Some(f) = self.extraQCShopRule() {
            s.serialize_field("extraQCShopRule", &f)?;
        } else {
            s.skip_field("extraQCShopRule")?;
        }
        if let Some(f) = self.repQCShopRule() {
            s.serialize_field("repQCShopRule", &f)?;
        } else {
            s.skip_field("repQCShopRule")?;
        }
        if let Some(f) = self.shopGPDataDict() {
            s.serialize_field("shopGPDataDict", &f)?;
        } else {
            s.skip_field("shopGPDataDict")?;
        }
        if let Some(f) = self.tabDisplayData() {
            s.serialize_field("tabDisplayData", &f)?;
        } else {
            s.skip_field("tabDisplayData")?;
        }
        if let Some(f) = self.shopMonthlySubGoodId() {
            s.serialize_field("shopMonthlySubGoodId", &f)?;
        } else {
            s.skip_field("shopMonthlySubGoodId")?;
        }
        if let Some(f) = self.ls() {
            s.serialize_field("ls", &f)?;
        } else {
            s.skip_field("ls")?;
        }
        if let Some(f) = self.os() {
            s.serialize_field("os", &f)?;
        } else {
            s.skip_field("os")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ShopClientDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ShopClientDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_recommendList(
        &mut self,
        recommendList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_ShopRecommendItem<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopClientData::VT_RECOMMENDLIST,
            recommendList,
        );
    }
    #[inline]
    pub fn add_creditUnlockGroup(
        &mut self,
        creditUnlockGroup: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ShopCreditUnlockGroup<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopClientData::VT_CREDITUNLOCKGROUP,
            creditUnlockGroup,
        );
    }
    #[inline]
    pub fn add_shopKeeperData(
        &mut self,
        shopKeeperData: flatbuffers::WIPOffset<clz_Torappu_ShopClientData_ShopKeeperData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ShopClientData_ShopKeeperData>>(
                clz_Torappu_ShopClientData::VT_SHOPKEEPERDATA,
                shopKeeperData,
            );
    }
    #[inline]
    pub fn add_carousels(
        &mut self,
        carousels: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ShopCarouselData<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopClientData::VT_CAROUSELS,
            carousels,
        );
    }
    #[inline]
    pub fn add_chooseShopRelations(
        &mut self,
        chooseShopRelations: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_ChooseShopRelation<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopClientData::VT_CHOOSESHOPRELATIONS,
            chooseShopRelations,
        );
    }
    #[inline]
    pub fn add_shopUnlockDict(
        &mut self,
        shopUnlockDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__enum__Torappu_ShopUnlockType<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopClientData::VT_SHOPUNLOCKDICT,
            shopUnlockDict,
        );
    }
    #[inline]
    pub fn add_extraQCShopRule(
        &mut self,
        extraQCShopRule: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopClientData::VT_EXTRAQCSHOPRULE,
            extraQCShopRule,
        );
    }
    #[inline]
    pub fn add_repQCShopRule(
        &mut self,
        repQCShopRule: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopClientData::VT_REPQCSHOPRULE,
            repQCShopRule,
        );
    }
    #[inline]
    pub fn add_shopGPDataDict(
        &mut self,
        shopGPDataDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ShopClientGPData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopClientData::VT_SHOPGPDATADICT,
            shopGPDataDict,
        );
    }
    #[inline]
    pub fn add_tabDisplayData(
        &mut self,
        tabDisplayData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ShopGPTabDisplayData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopClientData::VT_TABDISPLAYDATA,
            tabDisplayData,
        );
    }
    #[inline]
    pub fn add_shopMonthlySubGoodId(
        &mut self,
        shopMonthlySubGoodId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ShopClientData::VT_SHOPMONTHLYSUBGOODID,
            shopMonthlySubGoodId,
        );
    }
    #[inline]
    pub fn add_ls(
        &mut self,
        ls: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_LMTGSShopSchedule<'b>>,
            >,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ShopClientData::VT_LS, ls);
    }
    #[inline]
    pub fn add_os(
        &mut self,
        os: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_LMTGSShopOverlaySchedule<'b>>,
            >,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ShopClientData::VT_OS, os);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ShopClientDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ShopClientDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ShopClientData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ShopClientData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ShopClientData");
        ds.field("recommendList", &self.recommendList());
        ds.field("creditUnlockGroup", &self.creditUnlockGroup());
        ds.field("shopKeeperData", &self.shopKeeperData());
        ds.field("carousels", &self.carousels());
        ds.field("chooseShopRelations", &self.chooseShopRelations());
        ds.field("shopUnlockDict", &self.shopUnlockDict());
        ds.field("extraQCShopRule", &self.extraQCShopRule());
        ds.field("repQCShopRule", &self.repQCShopRule());
        ds.field("shopGPDataDict", &self.shopGPDataDict());
        ds.field("tabDisplayData", &self.tabDisplayData());
        ds.field("shopMonthlySubGoodId", &self.shopMonthlySubGoodId());
        ds.field("ls", &self.ls());
        ds.field("os", &self.os());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ShopClientDataT {
    pub recommendList: Option<Vec<clz_Torappu_ShopRecommendItemT>>,
    pub creditUnlockGroup: Option<Vec<dict__string__clz_Torappu_ShopCreditUnlockGroupT>>,
    pub shopKeeperData: Option<Box<clz_Torappu_ShopClientData_ShopKeeperDataT>>,
    pub carousels: Option<Vec<clz_Torappu_ShopCarouselDataT>>,
    pub chooseShopRelations: Option<Vec<clz_Torappu_ChooseShopRelationT>>,
    pub shopUnlockDict: Option<Vec<dict__string__enum__Torappu_ShopUnlockTypeT>>,
    pub extraQCShopRule: Option<Vec<String>>,
    pub repQCShopRule: Option<Vec<String>>,
    pub shopGPDataDict: Option<Vec<dict__string__clz_Torappu_ShopClientGPDataT>>,
    pub tabDisplayData: Option<Vec<dict__string__clz_Torappu_ShopGPTabDisplayDataT>>,
    pub shopMonthlySubGoodId: Option<String>,
    pub ls: Option<Vec<clz_Torappu_LMTGSShopScheduleT>>,
    pub os: Option<Vec<clz_Torappu_LMTGSShopOverlayScheduleT>>,
}
impl Default for clz_Torappu_ShopClientDataT {
    fn default() -> Self {
        Self {
            recommendList: None,
            creditUnlockGroup: None,
            shopKeeperData: None,
            carousels: None,
            chooseShopRelations: None,
            shopUnlockDict: None,
            extraQCShopRule: None,
            repQCShopRule: None,
            shopGPDataDict: None,
            tabDisplayData: None,
            shopMonthlySubGoodId: None,
            ls: None,
            os: None,
        }
    }
}
impl clz_Torappu_ShopClientDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ShopClientData<'b>> {
        let recommendList = self.recommendList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let creditUnlockGroup = self.creditUnlockGroup.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let shopKeeperData = self.shopKeeperData.as_ref().map(|x| x.pack(_fbb));
        let carousels = self.carousels.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let chooseShopRelations = self.chooseShopRelations.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let shopUnlockDict = self.shopUnlockDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let extraQCShopRule = self.extraQCShopRule.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let repQCShopRule = self.repQCShopRule.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let shopGPDataDict = self.shopGPDataDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let tabDisplayData = self.tabDisplayData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let shopMonthlySubGoodId = self
            .shopMonthlySubGoodId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let ls = self.ls.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let os = self.os.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ShopClientData::create(
            _fbb,
            &clz_Torappu_ShopClientDataArgs {
                recommendList,
                creditUnlockGroup,
                shopKeeperData,
                carousels,
                chooseShopRelations,
                shopUnlockDict,
                extraQCShopRule,
                repQCShopRule,
                shopGPDataDict,
                tabDisplayData,
                shopMonthlySubGoodId,
                ls,
                os,
            },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_ShopClientData`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_shop_client_data_unchecked`.
pub fn root_as_clz_torappu_shop_client_data(
    buf: &[u8],
) -> Result<clz_Torappu_ShopClientData, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_ShopClientData>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_ShopClientData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_shop_client_data_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_shop_client_data(
    buf: &[u8],
) -> Result<clz_Torappu_ShopClientData, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_ShopClientData>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_ShopClientData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_shop_client_data_unchecked`.
pub fn root_as_clz_torappu_shop_client_data_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_ShopClientData<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_ShopClientData<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_ShopClientData` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_shop_client_data_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_shop_client_data_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_ShopClientData<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_ShopClientData<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_ShopClientData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_ShopClientData`.
pub unsafe fn root_as_clz_torappu_shop_client_data_unchecked(
    buf: &[u8],
) -> clz_Torappu_ShopClientData {
    unsafe { flatbuffers::root_unchecked::<clz_Torappu_ShopClientData>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_ShopClientData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_ShopClientData`.
pub unsafe fn size_prefixed_root_as_clz_torappu_shop_client_data_unchecked(
    buf: &[u8],
) -> clz_Torappu_ShopClientData {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_ShopClientData>(buf) }
}
#[inline]
pub fn finish_clz_torappu_shop_client_data_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_ShopClientData<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_shop_client_data_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_ShopClientData<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
