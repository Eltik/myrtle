// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_CLIMB_TOWER_TOWER_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_CLIMB_TOWER_TOWER_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_CLIMB_TOWER_TOWER_TYPE: [enum__Torappu_ClimbTowerTowerType; 2] = [
    enum__Torappu_ClimbTowerTowerType::TRAINING,
    enum__Torappu_ClimbTowerTowerType::NORMAL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ClimbTowerTowerType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ClimbTowerTowerType {
    pub const TRAINING: Self = Self(0);
    pub const NORMAL: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::TRAINING, Self::NORMAL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::TRAINING => Some("TRAINING"),
            Self::NORMAL => Some("NORMAL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ClimbTowerTowerType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ClimbTowerTowerType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ClimbTowerTowerType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ClimbTowerTowerType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ClimbTowerTowerType {
    type Output = enum__Torappu_ClimbTowerTowerType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ClimbTowerTowerType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ClimbTowerTowerType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ClimbTowerTowerType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ITEM_TYPE: i32 = 90;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ITEM_TYPE: [enum__Torappu_ItemType; 91] = [
    enum__Torappu_ItemType::NONE,
    enum__Torappu_ItemType::CHAR,
    enum__Torappu_ItemType::CARD_EXP,
    enum__Torappu_ItemType::MATERIAL,
    enum__Torappu_ItemType::GOLD,
    enum__Torappu_ItemType::EXP_PLAYER,
    enum__Torappu_ItemType::TKT_TRY,
    enum__Torappu_ItemType::TKT_RECRUIT,
    enum__Torappu_ItemType::TKT_INST_FIN,
    enum__Torappu_ItemType::TKT_GACHA,
    enum__Torappu_ItemType::ACTIVITY_COIN,
    enum__Torappu_ItemType::DIAMOND,
    enum__Torappu_ItemType::DIAMOND_SHD,
    enum__Torappu_ItemType::HGG_SHD,
    enum__Torappu_ItemType::LGG_SHD,
    enum__Torappu_ItemType::FURN,
    enum__Torappu_ItemType::AP_GAMEPLAY,
    enum__Torappu_ItemType::AP_BASE,
    enum__Torappu_ItemType::SOCIAL_PT,
    enum__Torappu_ItemType::CHAR_SKIN,
    enum__Torappu_ItemType::TKT_GACHA_10,
    enum__Torappu_ItemType::TKT_GACHA_PRSV,
    enum__Torappu_ItemType::AP_ITEM,
    enum__Torappu_ItemType::AP_SUPPLY,
    enum__Torappu_ItemType::RENAMING_CARD,
    enum__Torappu_ItemType::RENAMING_CARD_2,
    enum__Torappu_ItemType::ET_STAGE,
    enum__Torappu_ItemType::ACTIVITY_ITEM,
    enum__Torappu_ItemType::VOUCHER_PICK,
    enum__Torappu_ItemType::VOUCHER_CGACHA,
    enum__Torappu_ItemType::VOUCHER_MGACHA,
    enum__Torappu_ItemType::CRS_SHOP_COIN,
    enum__Torappu_ItemType::CRS_RUNE_COIN,
    enum__Torappu_ItemType::LMTGS_COIN,
    enum__Torappu_ItemType::EPGS_COIN,
    enum__Torappu_ItemType::LIMITED_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_FREE_GACHA,
    enum__Torappu_ItemType::REP_COIN,
    enum__Torappu_ItemType::ROGUELIKE,
    enum__Torappu_ItemType::LINKAGE_TKT_GACHA_10,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_4,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_5,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_6,
    enum__Torappu_ItemType::VOUCHER_SKIN,
    enum__Torappu_ItemType::RETRO_COIN,
    enum__Torappu_ItemType::PLAYER_AVATAR,
    enum__Torappu_ItemType::UNI_COLLECTION,
    enum__Torappu_ItemType::VOUCHER_FULL_POTENTIAL,
    enum__Torappu_ItemType::RL_COIN,
    enum__Torappu_ItemType::RETURN_CREDIT,
    enum__Torappu_ItemType::MEDAL,
    enum__Torappu_ItemType::CHARM,
    enum__Torappu_ItemType::HOME_BACKGROUND,
    enum__Torappu_ItemType::EXTERMINATION_AGENT,
    enum__Torappu_ItemType::OPTIONAL_VOUCHER_PICK,
    enum__Torappu_ItemType::ACT_CART_COMPONENT,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_4,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_4,
    enum__Torappu_ItemType::ACTIVITY_POTENTIAL,
    enum__Torappu_ItemType::ITEM_PACK,
    enum__Torappu_ItemType::SANDBOX,
    enum__Torappu_ItemType::FAVOR_ADD_ITEM,
    enum__Torappu_ItemType::CLASSIC_SHD,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_BUFF,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_5,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_6,
    enum__Torappu_ItemType::RETURN_PROGRESS,
    enum__Torappu_ItemType::NEW_PROGRESS,
    enum__Torappu_ItemType::MCARD_VOUCHER,
    enum__Torappu_ItemType::MATERIAL_ISSUE_VOUCHER,
    enum__Torappu_ItemType::CRS_SHOP_COIN_V2,
    enum__Torappu_ItemType::HOME_THEME,
    enum__Torappu_ItemType::SANDBOX_PERM,
    enum__Torappu_ItemType::SANDBOX_TOKEN,
    enum__Torappu_ItemType::TEMPLATE_TRAP,
    enum__Torappu_ItemType::NAME_CARD_SKIN,
    enum__Torappu_ItemType::EMOTICON_SET,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA_10,
    enum__Torappu_ItemType::SO_CHAR_EXP,
    enum__Torappu_ItemType::GIFTPACKAGE_TKT,
    enum__Torappu_ItemType::VOUCHER_SKIN_V2,
    enum__Torappu_ItemType::RANDOM_VOUCHER_SKIN,
    enum__Torappu_ItemType::ACT1VHALFIDLE_ITEM,
    enum__Torappu_ItemType::PLOT_ITEM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ItemType {
    pub const NONE: Self = Self(0);
    pub const CHAR: Self = Self(1);
    pub const CARD_EXP: Self = Self(2);
    pub const MATERIAL: Self = Self(3);
    pub const GOLD: Self = Self(4);
    pub const EXP_PLAYER: Self = Self(5);
    pub const TKT_TRY: Self = Self(6);
    pub const TKT_RECRUIT: Self = Self(7);
    pub const TKT_INST_FIN: Self = Self(8);
    pub const TKT_GACHA: Self = Self(9);
    pub const ACTIVITY_COIN: Self = Self(10);
    pub const DIAMOND: Self = Self(11);
    pub const DIAMOND_SHD: Self = Self(12);
    pub const HGG_SHD: Self = Self(13);
    pub const LGG_SHD: Self = Self(14);
    pub const FURN: Self = Self(15);
    pub const AP_GAMEPLAY: Self = Self(16);
    pub const AP_BASE: Self = Self(17);
    pub const SOCIAL_PT: Self = Self(18);
    pub const CHAR_SKIN: Self = Self(19);
    pub const TKT_GACHA_10: Self = Self(20);
    pub const TKT_GACHA_PRSV: Self = Self(21);
    pub const AP_ITEM: Self = Self(22);
    pub const AP_SUPPLY: Self = Self(23);
    pub const RENAMING_CARD: Self = Self(24);
    pub const RENAMING_CARD_2: Self = Self(25);
    pub const ET_STAGE: Self = Self(26);
    pub const ACTIVITY_ITEM: Self = Self(27);
    pub const VOUCHER_PICK: Self = Self(28);
    pub const VOUCHER_CGACHA: Self = Self(29);
    pub const VOUCHER_MGACHA: Self = Self(30);
    pub const CRS_SHOP_COIN: Self = Self(31);
    pub const CRS_RUNE_COIN: Self = Self(32);
    pub const LMTGS_COIN: Self = Self(33);
    pub const EPGS_COIN: Self = Self(34);
    pub const LIMITED_TKT_GACHA_10: Self = Self(35);
    pub const LIMITED_FREE_GACHA: Self = Self(36);
    pub const REP_COIN: Self = Self(37);
    pub const ROGUELIKE: Self = Self(38);
    pub const LINKAGE_TKT_GACHA_10: Self = Self(39);
    pub const VOUCHER_ELITE_II_4: Self = Self(40);
    pub const VOUCHER_ELITE_II_5: Self = Self(41);
    pub const VOUCHER_ELITE_II_6: Self = Self(42);
    pub const VOUCHER_SKIN: Self = Self(43);
    pub const RETRO_COIN: Self = Self(44);
    pub const PLAYER_AVATAR: Self = Self(45);
    pub const UNI_COLLECTION: Self = Self(46);
    pub const VOUCHER_FULL_POTENTIAL: Self = Self(47);
    pub const RL_COIN: Self = Self(48);
    pub const RETURN_CREDIT: Self = Self(49);
    pub const MEDAL: Self = Self(50);
    pub const CHARM: Self = Self(51);
    pub const HOME_BACKGROUND: Self = Self(52);
    pub const EXTERMINATION_AGENT: Self = Self(53);
    pub const OPTIONAL_VOUCHER_PICK: Self = Self(54);
    pub const ACT_CART_COMPONENT: Self = Self(55);
    pub const VOUCHER_LEVELMAX_6: Self = Self(56);
    pub const VOUCHER_LEVELMAX_5: Self = Self(57);
    pub const VOUCHER_LEVELMAX_4: Self = Self(58);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_6: Self = Self(59);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_5: Self = Self(60);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_4: Self = Self(61);
    pub const ACTIVITY_POTENTIAL: Self = Self(62);
    pub const ITEM_PACK: Self = Self(63);
    pub const SANDBOX: Self = Self(64);
    pub const FAVOR_ADD_ITEM: Self = Self(65);
    pub const CLASSIC_SHD: Self = Self(66);
    pub const CLASSIC_TKT_GACHA: Self = Self(67);
    pub const CLASSIC_TKT_GACHA_10: Self = Self(68);
    pub const LIMITED_BUFF: Self = Self(69);
    pub const CLASSIC_FES_PICK_TIER_5: Self = Self(70);
    pub const CLASSIC_FES_PICK_TIER_6: Self = Self(71);
    pub const RETURN_PROGRESS: Self = Self(72);
    pub const NEW_PROGRESS: Self = Self(73);
    pub const MCARD_VOUCHER: Self = Self(74);
    pub const MATERIAL_ISSUE_VOUCHER: Self = Self(75);
    pub const CRS_SHOP_COIN_V2: Self = Self(76);
    pub const HOME_THEME: Self = Self(77);
    pub const SANDBOX_PERM: Self = Self(78);
    pub const SANDBOX_TOKEN: Self = Self(79);
    pub const TEMPLATE_TRAP: Self = Self(80);
    pub const NAME_CARD_SKIN: Self = Self(81);
    pub const EMOTICON_SET: Self = Self(82);
    pub const EXCLUSIVE_TKT_GACHA: Self = Self(83);
    pub const EXCLUSIVE_TKT_GACHA_10: Self = Self(84);
    pub const SO_CHAR_EXP: Self = Self(85);
    pub const GIFTPACKAGE_TKT: Self = Self(86);
    pub const VOUCHER_SKIN_V2: Self = Self(87);
    pub const RANDOM_VOUCHER_SKIN: Self = Self(88);
    pub const ACT1VHALFIDLE_ITEM: Self = Self(89);
    pub const PLOT_ITEM: Self = Self(90);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 90;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::CHAR,
        Self::CARD_EXP,
        Self::MATERIAL,
        Self::GOLD,
        Self::EXP_PLAYER,
        Self::TKT_TRY,
        Self::TKT_RECRUIT,
        Self::TKT_INST_FIN,
        Self::TKT_GACHA,
        Self::ACTIVITY_COIN,
        Self::DIAMOND,
        Self::DIAMOND_SHD,
        Self::HGG_SHD,
        Self::LGG_SHD,
        Self::FURN,
        Self::AP_GAMEPLAY,
        Self::AP_BASE,
        Self::SOCIAL_PT,
        Self::CHAR_SKIN,
        Self::TKT_GACHA_10,
        Self::TKT_GACHA_PRSV,
        Self::AP_ITEM,
        Self::AP_SUPPLY,
        Self::RENAMING_CARD,
        Self::RENAMING_CARD_2,
        Self::ET_STAGE,
        Self::ACTIVITY_ITEM,
        Self::VOUCHER_PICK,
        Self::VOUCHER_CGACHA,
        Self::VOUCHER_MGACHA,
        Self::CRS_SHOP_COIN,
        Self::CRS_RUNE_COIN,
        Self::LMTGS_COIN,
        Self::EPGS_COIN,
        Self::LIMITED_TKT_GACHA_10,
        Self::LIMITED_FREE_GACHA,
        Self::REP_COIN,
        Self::ROGUELIKE,
        Self::LINKAGE_TKT_GACHA_10,
        Self::VOUCHER_ELITE_II_4,
        Self::VOUCHER_ELITE_II_5,
        Self::VOUCHER_ELITE_II_6,
        Self::VOUCHER_SKIN,
        Self::RETRO_COIN,
        Self::PLAYER_AVATAR,
        Self::UNI_COLLECTION,
        Self::VOUCHER_FULL_POTENTIAL,
        Self::RL_COIN,
        Self::RETURN_CREDIT,
        Self::MEDAL,
        Self::CHARM,
        Self::HOME_BACKGROUND,
        Self::EXTERMINATION_AGENT,
        Self::OPTIONAL_VOUCHER_PICK,
        Self::ACT_CART_COMPONENT,
        Self::VOUCHER_LEVELMAX_6,
        Self::VOUCHER_LEVELMAX_5,
        Self::VOUCHER_LEVELMAX_4,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_6,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_5,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_4,
        Self::ACTIVITY_POTENTIAL,
        Self::ITEM_PACK,
        Self::SANDBOX,
        Self::FAVOR_ADD_ITEM,
        Self::CLASSIC_SHD,
        Self::CLASSIC_TKT_GACHA,
        Self::CLASSIC_TKT_GACHA_10,
        Self::LIMITED_BUFF,
        Self::CLASSIC_FES_PICK_TIER_5,
        Self::CLASSIC_FES_PICK_TIER_6,
        Self::RETURN_PROGRESS,
        Self::NEW_PROGRESS,
        Self::MCARD_VOUCHER,
        Self::MATERIAL_ISSUE_VOUCHER,
        Self::CRS_SHOP_COIN_V2,
        Self::HOME_THEME,
        Self::SANDBOX_PERM,
        Self::SANDBOX_TOKEN,
        Self::TEMPLATE_TRAP,
        Self::NAME_CARD_SKIN,
        Self::EMOTICON_SET,
        Self::EXCLUSIVE_TKT_GACHA,
        Self::EXCLUSIVE_TKT_GACHA_10,
        Self::SO_CHAR_EXP,
        Self::GIFTPACKAGE_TKT,
        Self::VOUCHER_SKIN_V2,
        Self::RANDOM_VOUCHER_SKIN,
        Self::ACT1VHALFIDLE_ITEM,
        Self::PLOT_ITEM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::CHAR => Some("CHAR"),
            Self::CARD_EXP => Some("CARD_EXP"),
            Self::MATERIAL => Some("MATERIAL"),
            Self::GOLD => Some("GOLD"),
            Self::EXP_PLAYER => Some("EXP_PLAYER"),
            Self::TKT_TRY => Some("TKT_TRY"),
            Self::TKT_RECRUIT => Some("TKT_RECRUIT"),
            Self::TKT_INST_FIN => Some("TKT_INST_FIN"),
            Self::TKT_GACHA => Some("TKT_GACHA"),
            Self::ACTIVITY_COIN => Some("ACTIVITY_COIN"),
            Self::DIAMOND => Some("DIAMOND"),
            Self::DIAMOND_SHD => Some("DIAMOND_SHD"),
            Self::HGG_SHD => Some("HGG_SHD"),
            Self::LGG_SHD => Some("LGG_SHD"),
            Self::FURN => Some("FURN"),
            Self::AP_GAMEPLAY => Some("AP_GAMEPLAY"),
            Self::AP_BASE => Some("AP_BASE"),
            Self::SOCIAL_PT => Some("SOCIAL_PT"),
            Self::CHAR_SKIN => Some("CHAR_SKIN"),
            Self::TKT_GACHA_10 => Some("TKT_GACHA_10"),
            Self::TKT_GACHA_PRSV => Some("TKT_GACHA_PRSV"),
            Self::AP_ITEM => Some("AP_ITEM"),
            Self::AP_SUPPLY => Some("AP_SUPPLY"),
            Self::RENAMING_CARD => Some("RENAMING_CARD"),
            Self::RENAMING_CARD_2 => Some("RENAMING_CARD_2"),
            Self::ET_STAGE => Some("ET_STAGE"),
            Self::ACTIVITY_ITEM => Some("ACTIVITY_ITEM"),
            Self::VOUCHER_PICK => Some("VOUCHER_PICK"),
            Self::VOUCHER_CGACHA => Some("VOUCHER_CGACHA"),
            Self::VOUCHER_MGACHA => Some("VOUCHER_MGACHA"),
            Self::CRS_SHOP_COIN => Some("CRS_SHOP_COIN"),
            Self::CRS_RUNE_COIN => Some("CRS_RUNE_COIN"),
            Self::LMTGS_COIN => Some("LMTGS_COIN"),
            Self::EPGS_COIN => Some("EPGS_COIN"),
            Self::LIMITED_TKT_GACHA_10 => Some("LIMITED_TKT_GACHA_10"),
            Self::LIMITED_FREE_GACHA => Some("LIMITED_FREE_GACHA"),
            Self::REP_COIN => Some("REP_COIN"),
            Self::ROGUELIKE => Some("ROGUELIKE"),
            Self::LINKAGE_TKT_GACHA_10 => Some("LINKAGE_TKT_GACHA_10"),
            Self::VOUCHER_ELITE_II_4 => Some("VOUCHER_ELITE_II_4"),
            Self::VOUCHER_ELITE_II_5 => Some("VOUCHER_ELITE_II_5"),
            Self::VOUCHER_ELITE_II_6 => Some("VOUCHER_ELITE_II_6"),
            Self::VOUCHER_SKIN => Some("VOUCHER_SKIN"),
            Self::RETRO_COIN => Some("RETRO_COIN"),
            Self::PLAYER_AVATAR => Some("PLAYER_AVATAR"),
            Self::UNI_COLLECTION => Some("UNI_COLLECTION"),
            Self::VOUCHER_FULL_POTENTIAL => Some("VOUCHER_FULL_POTENTIAL"),
            Self::RL_COIN => Some("RL_COIN"),
            Self::RETURN_CREDIT => Some("RETURN_CREDIT"),
            Self::MEDAL => Some("MEDAL"),
            Self::CHARM => Some("CHARM"),
            Self::HOME_BACKGROUND => Some("HOME_BACKGROUND"),
            Self::EXTERMINATION_AGENT => Some("EXTERMINATION_AGENT"),
            Self::OPTIONAL_VOUCHER_PICK => Some("OPTIONAL_VOUCHER_PICK"),
            Self::ACT_CART_COMPONENT => Some("ACT_CART_COMPONENT"),
            Self::VOUCHER_LEVELMAX_6 => Some("VOUCHER_LEVELMAX_6"),
            Self::VOUCHER_LEVELMAX_5 => Some("VOUCHER_LEVELMAX_5"),
            Self::VOUCHER_LEVELMAX_4 => Some("VOUCHER_LEVELMAX_4"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_6 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_6"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_5 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_5"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_4 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_4"),
            Self::ACTIVITY_POTENTIAL => Some("ACTIVITY_POTENTIAL"),
            Self::ITEM_PACK => Some("ITEM_PACK"),
            Self::SANDBOX => Some("SANDBOX"),
            Self::FAVOR_ADD_ITEM => Some("FAVOR_ADD_ITEM"),
            Self::CLASSIC_SHD => Some("CLASSIC_SHD"),
            Self::CLASSIC_TKT_GACHA => Some("CLASSIC_TKT_GACHA"),
            Self::CLASSIC_TKT_GACHA_10 => Some("CLASSIC_TKT_GACHA_10"),
            Self::LIMITED_BUFF => Some("LIMITED_BUFF"),
            Self::CLASSIC_FES_PICK_TIER_5 => Some("CLASSIC_FES_PICK_TIER_5"),
            Self::CLASSIC_FES_PICK_TIER_6 => Some("CLASSIC_FES_PICK_TIER_6"),
            Self::RETURN_PROGRESS => Some("RETURN_PROGRESS"),
            Self::NEW_PROGRESS => Some("NEW_PROGRESS"),
            Self::MCARD_VOUCHER => Some("MCARD_VOUCHER"),
            Self::MATERIAL_ISSUE_VOUCHER => Some("MATERIAL_ISSUE_VOUCHER"),
            Self::CRS_SHOP_COIN_V2 => Some("CRS_SHOP_COIN_V2"),
            Self::HOME_THEME => Some("HOME_THEME"),
            Self::SANDBOX_PERM => Some("SANDBOX_PERM"),
            Self::SANDBOX_TOKEN => Some("SANDBOX_TOKEN"),
            Self::TEMPLATE_TRAP => Some("TEMPLATE_TRAP"),
            Self::NAME_CARD_SKIN => Some("NAME_CARD_SKIN"),
            Self::EMOTICON_SET => Some("EMOTICON_SET"),
            Self::EXCLUSIVE_TKT_GACHA => Some("EXCLUSIVE_TKT_GACHA"),
            Self::EXCLUSIVE_TKT_GACHA_10 => Some("EXCLUSIVE_TKT_GACHA_10"),
            Self::SO_CHAR_EXP => Some("SO_CHAR_EXP"),
            Self::GIFTPACKAGE_TKT => Some("GIFTPACKAGE_TKT"),
            Self::VOUCHER_SKIN_V2 => Some("VOUCHER_SKIN_V2"),
            Self::RANDOM_VOUCHER_SKIN => Some("RANDOM_VOUCHER_SKIN"),
            Self::ACT1VHALFIDLE_ITEM => Some("ACT1VHALFIDLE_ITEM"),
            Self::PLOT_ITEM => Some("PLOT_ITEM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ItemType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ItemType {
    type Output = enum__Torappu_ItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_CLIMB_TOWER_LEVEL_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_CLIMB_TOWER_LEVEL_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_CLIMB_TOWER_LEVEL_TYPE: [enum__Torappu_ClimbTowerLevelType; 3] = [
    enum__Torappu_ClimbTowerLevelType::NORMAL,
    enum__Torappu_ClimbTowerLevelType::HIGHLEVEL,
    enum__Torappu_ClimbTowerLevelType::BOSS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ClimbTowerLevelType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ClimbTowerLevelType {
    pub const NORMAL: Self = Self(0);
    pub const HIGHLEVEL: Self = Self(1);
    pub const BOSS: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NORMAL, Self::HIGHLEVEL, Self::BOSS];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NORMAL => Some("NORMAL"),
            Self::HIGHLEVEL => Some("HIGHLEVEL"),
            Self::BOSS => Some("BOSS"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ClimbTowerLevelType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ClimbTowerLevelType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ClimbTowerLevelType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ClimbTowerLevelType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ClimbTowerLevelType {
    type Output = enum__Torappu_ClimbTowerLevelType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ClimbTowerLevelType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ClimbTowerLevelType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ClimbTowerLevelType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_STAGE_DROP_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_STAGE_DROP_TYPE: i32 = 12;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_STAGE_DROP_TYPE: [enum__Torappu_StageDropType; 13] = [
    enum__Torappu_StageDropType::NONE,
    enum__Torappu_StageDropType::ONCE,
    enum__Torappu_StageDropType::NORMAL,
    enum__Torappu_StageDropType::SPECIAL,
    enum__Torappu_StageDropType::ADDITIONAL,
    enum__Torappu_StageDropType::APRETURN,
    enum__Torappu_StageDropType::DIAMOND_MATERIAL,
    enum__Torappu_StageDropType::FUNITURE_DROP,
    enum__Torappu_StageDropType::COMPLETE,
    enum__Torappu_StageDropType::CHARM_DROP,
    enum__Torappu_StageDropType::OVERRIDE_DROP,
    enum__Torappu_StageDropType::ITEM_RETURN,
    enum__Torappu_StageDropType::CONDITION_DROP,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_StageDropType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_StageDropType {
    pub const NONE: Self = Self(0);
    pub const ONCE: Self = Self(1);
    pub const NORMAL: Self = Self(2);
    pub const SPECIAL: Self = Self(3);
    pub const ADDITIONAL: Self = Self(4);
    pub const APRETURN: Self = Self(5);
    pub const DIAMOND_MATERIAL: Self = Self(6);
    pub const FUNITURE_DROP: Self = Self(7);
    pub const COMPLETE: Self = Self(8);
    pub const CHARM_DROP: Self = Self(9);
    pub const OVERRIDE_DROP: Self = Self(10);
    pub const ITEM_RETURN: Self = Self(11);
    pub const CONDITION_DROP: Self = Self(12);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 12;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ONCE,
        Self::NORMAL,
        Self::SPECIAL,
        Self::ADDITIONAL,
        Self::APRETURN,
        Self::DIAMOND_MATERIAL,
        Self::FUNITURE_DROP,
        Self::COMPLETE,
        Self::CHARM_DROP,
        Self::OVERRIDE_DROP,
        Self::ITEM_RETURN,
        Self::CONDITION_DROP,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ONCE => Some("ONCE"),
            Self::NORMAL => Some("NORMAL"),
            Self::SPECIAL => Some("SPECIAL"),
            Self::ADDITIONAL => Some("ADDITIONAL"),
            Self::APRETURN => Some("APRETURN"),
            Self::DIAMOND_MATERIAL => Some("DIAMOND_MATERIAL"),
            Self::FUNITURE_DROP => Some("FUNITURE_DROP"),
            Self::COMPLETE => Some("COMPLETE"),
            Self::CHARM_DROP => Some("CHARM_DROP"),
            Self::OVERRIDE_DROP => Some("OVERRIDE_DROP"),
            Self::ITEM_RETURN => Some("ITEM_RETURN"),
            Self::CONDITION_DROP => Some("CONDITION_DROP"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_StageDropType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_StageDropType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_StageDropType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_StageDropType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_StageDropType {
    type Output = enum__Torappu_StageDropType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_StageDropType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_StageDropType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_StageDropType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_OCC_PER: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_OCC_PER: i32 = 6;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_OCC_PER: [enum__Torappu_OccPer; 7] = [
    enum__Torappu_OccPer::ALWAYS,
    enum__Torappu_OccPer::ALMOST,
    enum__Torappu_OccPer::USUAL,
    enum__Torappu_OccPer::OFTEN,
    enum__Torappu_OccPer::SOMETIMES,
    enum__Torappu_OccPer::NEVER,
    enum__Torappu_OccPer::DEFINITELY_BUFF,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_OccPer(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_OccPer {
    pub const ALWAYS: Self = Self(0);
    pub const ALMOST: Self = Self(1);
    pub const USUAL: Self = Self(2);
    pub const OFTEN: Self = Self(3);
    pub const SOMETIMES: Self = Self(4);
    pub const NEVER: Self = Self(5);
    pub const DEFINITELY_BUFF: Self = Self(6);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 6;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::ALWAYS,
        Self::ALMOST,
        Self::USUAL,
        Self::OFTEN,
        Self::SOMETIMES,
        Self::NEVER,
        Self::DEFINITELY_BUFF,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ALWAYS => Some("ALWAYS"),
            Self::ALMOST => Some("ALMOST"),
            Self::USUAL => Some("USUAL"),
            Self::OFTEN => Some("OFTEN"),
            Self::SOMETIMES => Some("SOMETIMES"),
            Self::NEVER => Some("NEVER"),
            Self::DEFINITELY_BUFF => Some("DEFINITELY_BUFF"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_OccPer {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_OccPer {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_OccPer",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_OccPer {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_OccPer {
    type Output = enum__Torappu_OccPer;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_OccPer {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_OccPer {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_OccPer {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_PROFESSION_CATEGORY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_PROFESSION_CATEGORY: i32 = 512;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_PROFESSION_CATEGORY: [enum__Torappu_ProfessionCategory; 11] = [
    enum__Torappu_ProfessionCategory::NONE,
    enum__Torappu_ProfessionCategory::WARRIOR,
    enum__Torappu_ProfessionCategory::SNIPER,
    enum__Torappu_ProfessionCategory::TANK,
    enum__Torappu_ProfessionCategory::MEDIC,
    enum__Torappu_ProfessionCategory::SUPPORT,
    enum__Torappu_ProfessionCategory::CASTER,
    enum__Torappu_ProfessionCategory::SPECIAL,
    enum__Torappu_ProfessionCategory::TOKEN,
    enum__Torappu_ProfessionCategory::TRAP,
    enum__Torappu_ProfessionCategory::PIONEER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ProfessionCategory(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ProfessionCategory {
    pub const NONE: Self = Self(0);
    pub const WARRIOR: Self = Self(1);
    pub const SNIPER: Self = Self(2);
    pub const TANK: Self = Self(4);
    pub const MEDIC: Self = Self(8);
    pub const SUPPORT: Self = Self(16);
    pub const CASTER: Self = Self(32);
    pub const SPECIAL: Self = Self(64);
    pub const TOKEN: Self = Self(128);
    pub const TRAP: Self = Self(256);
    pub const PIONEER: Self = Self(512);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 512;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::WARRIOR,
        Self::SNIPER,
        Self::TANK,
        Self::MEDIC,
        Self::SUPPORT,
        Self::CASTER,
        Self::SPECIAL,
        Self::TOKEN,
        Self::TRAP,
        Self::PIONEER,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::WARRIOR => Some("WARRIOR"),
            Self::SNIPER => Some("SNIPER"),
            Self::TANK => Some("TANK"),
            Self::MEDIC => Some("MEDIC"),
            Self::SUPPORT => Some("SUPPORT"),
            Self::CASTER => Some("CASTER"),
            Self::SPECIAL => Some("SPECIAL"),
            Self::TOKEN => Some("TOKEN"),
            Self::TRAP => Some("TRAP"),
            Self::PIONEER => Some("PIONEER"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ProfessionCategory {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ProfessionCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ProfessionCategory",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ProfessionCategory {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ProfessionCategory {
    type Output = enum__Torappu_ProfessionCategory;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ProfessionCategory {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ProfessionCategory {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ProfessionCategory {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_CLIMB_TOWER_TATICAL_BUFF_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_CLIMB_TOWER_TATICAL_BUFF_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_CLIMB_TOWER_TATICAL_BUFF_TYPE:
    [enum__Torappu_ClimbTowerTaticalBuffType; 2] = [
    enum__Torappu_ClimbTowerTaticalBuffType::A,
    enum__Torappu_ClimbTowerTaticalBuffType::B,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ClimbTowerTaticalBuffType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ClimbTowerTaticalBuffType {
    pub const A: Self = Self(0);
    pub const B: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::A, Self::B];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::A => Some("A"),
            Self::B => Some("B"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ClimbTowerTaticalBuffType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ClimbTowerTaticalBuffType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ClimbTowerTaticalBuffType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ClimbTowerTaticalBuffType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ClimbTowerTaticalBuffType {
    type Output = enum__Torappu_ClimbTowerTaticalBuffType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ClimbTowerTaticalBuffType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ClimbTowerTaticalBuffType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ClimbTowerTaticalBuffType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_CLIMB_TOWER_CARD_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_CLIMB_TOWER_CARD_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_CLIMB_TOWER_CARD_TYPE: [enum__Torappu_ClimbTowerCardType; 2] = [
    enum__Torappu_ClimbTowerCardType::SEASON,
    enum__Torappu_ClimbTowerCardType::TOWER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ClimbTowerCardType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ClimbTowerCardType {
    pub const SEASON: Self = Self(0);
    pub const TOWER: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::SEASON, Self::TOWER];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::SEASON => Some("SEASON"),
            Self::TOWER => Some("TOWER"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ClimbTowerCardType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ClimbTowerCardType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ClimbTowerCardType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ClimbTowerCardType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ClimbTowerCardType {
    type Output = enum__Torappu_ClimbTowerCardType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ClimbTowerCardType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ClimbTowerCardType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ClimbTowerCardType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUILDABLE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUILDABLE_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUILDABLE_TYPE: [enum__Torappu_BuildableType; 4] = [
    enum__Torappu_BuildableType::NONE,
    enum__Torappu_BuildableType::MELEE,
    enum__Torappu_BuildableType::RANGED,
    enum__Torappu_BuildableType::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuildableType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuildableType {
    pub const NONE: Self = Self(0);
    pub const MELEE: Self = Self(1);
    pub const RANGED: Self = Self(2);
    pub const ALL: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::MELEE, Self::RANGED, Self::ALL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MELEE => Some("MELEE"),
            Self::RANGED => Some("RANGED"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuildableType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_BuildableType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_BuildableType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuildableType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuildableType {
    type Output = enum__Torappu_BuildableType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuildableType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuildableType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuildableType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_PLAYER_SIDE_MASK: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_PLAYER_SIDE_MASK: u8 = 255;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_PLAYER_SIDE_MASK: [enum__Torappu_PlayerSideMask; 4] = [
    enum__Torappu_PlayerSideMask::ALL,
    enum__Torappu_PlayerSideMask::SIDE_A,
    enum__Torappu_PlayerSideMask::SIDE_B,
    enum__Torappu_PlayerSideMask::NONE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_PlayerSideMask(pub u8);
#[allow(non_upper_case_globals)]
impl enum__Torappu_PlayerSideMask {
    pub const ALL: Self = Self(0);
    pub const SIDE_A: Self = Self(2);
    pub const SIDE_B: Self = Self(4);
    pub const NONE: Self = Self(255);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 255;
    pub const ENUM_VALUES: &'static [Self] = &[Self::ALL, Self::SIDE_A, Self::SIDE_B, Self::NONE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ALL => Some("ALL"),
            Self::SIDE_A => Some("SIDE_A"),
            Self::SIDE_B => Some("SIDE_B"),
            Self::NONE => Some("NONE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_PlayerSideMask {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_PlayerSideMask {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_PlayerSideMask",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_PlayerSideMask {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_PlayerSideMask {
    type Output = enum__Torappu_PlayerSideMask;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_PlayerSideMask {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_PlayerSideMask {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_PlayerSideMask {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BATTLE_SIDE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BATTLE_SIDE_TYPE: i32 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BATTLE_SIDE_TYPE: [enum__Torappu_Battle_SideType; 6] = [
    enum__Torappu_Battle_SideType::NONE,
    enum__Torappu_Battle_SideType::ALLY,
    enum__Torappu_Battle_SideType::ENEMY,
    enum__Torappu_Battle_SideType::BOTH_ALLY_AND_ENEMY,
    enum__Torappu_Battle_SideType::NEUTRAL,
    enum__Torappu_Battle_SideType::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_Battle_SideType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_Battle_SideType {
    pub const NONE: Self = Self(0);
    pub const ALLY: Self = Self(1);
    pub const ENEMY: Self = Self(2);
    pub const BOTH_ALLY_AND_ENEMY: Self = Self(3);
    pub const NEUTRAL: Self = Self(4);
    pub const ALL: Self = Self(7);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 7;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ALLY,
        Self::ENEMY,
        Self::BOTH_ALLY_AND_ENEMY,
        Self::NEUTRAL,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ALLY => Some("ALLY"),
            Self::ENEMY => Some("ENEMY"),
            Self::BOTH_ALLY_AND_ENEMY => Some("BOTH_ALLY_AND_ENEMY"),
            Self::NEUTRAL => Some("NEUTRAL"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_Battle_SideType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_Battle_SideType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_Battle_SideType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_Battle_SideType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_Battle_SideType {
    type Output = enum__Torappu_Battle_SideType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_Battle_SideType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_Battle_SideType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_Battle_SideType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_TILE_DATA_HEIGHT_TYPE_MASK: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_TILE_DATA_HEIGHT_TYPE_MASK: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_TILE_DATA_HEIGHT_TYPE_MASK:
    [enum__Torappu_TileData_HeightTypeMask; 4] = [
    enum__Torappu_TileData_HeightTypeMask::NONE,
    enum__Torappu_TileData_HeightTypeMask::LOWLAND,
    enum__Torappu_TileData_HeightTypeMask::HIGHLAND,
    enum__Torappu_TileData_HeightTypeMask::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_TileData_HeightTypeMask(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_TileData_HeightTypeMask {
    pub const NONE: Self = Self(0);
    pub const LOWLAND: Self = Self(1);
    pub const HIGHLAND: Self = Self(2);
    pub const ALL: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::LOWLAND, Self::HIGHLAND, Self::ALL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::LOWLAND => Some("LOWLAND"),
            Self::HIGHLAND => Some("HIGHLAND"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_TileData_HeightTypeMask {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_TileData_HeightTypeMask {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_TileData_HeightTypeMask",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_TileData_HeightTypeMask {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_TileData_HeightTypeMask {
    type Output = enum__Torappu_TileData_HeightTypeMask;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_TileData_HeightTypeMask {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_TileData_HeightTypeMask {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_TileData_HeightTypeMask {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_MISSION_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_MISSION_TYPE: i32 = 11;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_MISSION_TYPE: [enum__Torappu_MissionType; 12] = [
    enum__Torappu_MissionType::UNKNOWN,
    enum__Torappu_MissionType::MAIN,
    enum__Torappu_MissionType::DAILY,
    enum__Torappu_MissionType::WEEKLY,
    enum__Torappu_MissionType::GUIDE,
    enum__Torappu_MissionType::SUB,
    enum__Torappu_MissionType::ACTIVITY,
    enum__Torappu_MissionType::OPENSERVER,
    enum__Torappu_MissionType::TOWERSEASON,
    enum__Torappu_MissionType::RETRO,
    enum__Torappu_MissionType::SPECIAL_OPERATOR,
    enum__Torappu_MissionType::SPECIAL_OPERATOR_WEEKLY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_MissionType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_MissionType {
    pub const UNKNOWN: Self = Self(0);
    pub const MAIN: Self = Self(1);
    pub const DAILY: Self = Self(2);
    pub const WEEKLY: Self = Self(3);
    pub const GUIDE: Self = Self(4);
    pub const SUB: Self = Self(5);
    pub const ACTIVITY: Self = Self(6);
    pub const OPENSERVER: Self = Self(7);
    pub const TOWERSEASON: Self = Self(8);
    pub const RETRO: Self = Self(9);
    pub const SPECIAL_OPERATOR: Self = Self(10);
    pub const SPECIAL_OPERATOR_WEEKLY: Self = Self(11);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 11;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::UNKNOWN,
        Self::MAIN,
        Self::DAILY,
        Self::WEEKLY,
        Self::GUIDE,
        Self::SUB,
        Self::ACTIVITY,
        Self::OPENSERVER,
        Self::TOWERSEASON,
        Self::RETRO,
        Self::SPECIAL_OPERATOR,
        Self::SPECIAL_OPERATOR_WEEKLY,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::UNKNOWN => Some("UNKNOWN"),
            Self::MAIN => Some("MAIN"),
            Self::DAILY => Some("DAILY"),
            Self::WEEKLY => Some("WEEKLY"),
            Self::GUIDE => Some("GUIDE"),
            Self::SUB => Some("SUB"),
            Self::ACTIVITY => Some("ACTIVITY"),
            Self::OPENSERVER => Some("OPENSERVER"),
            Self::TOWERSEASON => Some("TOWERSEASON"),
            Self::RETRO => Some("RETRO"),
            Self::SPECIAL_OPERATOR => Some("SPECIAL_OPERATOR"),
            Self::SPECIAL_OPERATOR_WEEKLY => Some("SPECIAL_OPERATOR_WEEKLY"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_MissionType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_MissionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_MissionType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_MissionType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_MissionType {
    type Output = enum__Torappu_MissionType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_MissionType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_MissionType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_MissionType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_MISSION_ITEM_BG_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_MISSION_ITEM_BG_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_MISSION_ITEM_BG_TYPE: [enum__Torappu_MissionItemBgType; 3] = [
    enum__Torappu_MissionItemBgType::COMMON,
    enum__Torappu_MissionItemBgType::Equipment,
    enum__Torappu_MissionItemBgType::Char,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_MissionItemBgType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_MissionItemBgType {
    pub const COMMON: Self = Self(0);
    pub const Equipment: Self = Self(1);
    pub const Char: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::COMMON, Self::Equipment, Self::Char];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::COMMON => Some("COMMON"),
            Self::Equipment => Some("Equipment"),
            Self::Char => Some("Char"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_MissionItemBgType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_MissionItemBgType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_MissionItemBgType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_MissionItemBgType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_MissionItemBgType {
    type Output = enum__Torappu_MissionItemBgType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_MissionItemBgType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_MissionItemBgType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_MissionItemBgType {}
pub enum clz_Torappu_ItemBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ItemBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ItemBundle<'a> {
    type Inner = clz_Torappu_ItemBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ItemBundle<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_COUNT: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ItemBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ItemBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'bldr>> {
        let mut builder = clz_Torappu_ItemBundleBuilder::new(_fbb);
        builder.add_type_(args.type_);
        builder.add_count(args.count);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ItemBundleT {
        let id = self.id().map(|x| x.to_string());
        let count = self.count();
        let type_ = self.type_();
        clz_Torappu_ItemBundleT { id, count, type_ }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_ItemBundle::VT_ID, None)
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ItemBundle::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_ItemBundle::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ItemBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ItemBundleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl<'a> Default for clz_Torappu_ItemBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ItemBundleArgs {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_ItemBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ItemBundle", 3)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("count", &self.count())?;
        s.serialize_field("type_", &self.type_())?;
        s.end()
    }
}

pub struct clz_Torappu_ItemBundleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ItemBundle::VT_ID, id);
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ItemBundle::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_ItemBundle::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ItemBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ItemBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ItemBundle");
        ds.field("id", &self.id());
        ds.field("count", &self.count());
        ds.field("type_", &self.type_());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ItemBundleT {
    pub id: Option<String>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl Default for clz_Torappu_ItemBundleT {
    fn default() -> Self {
        Self {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}
impl clz_Torappu_ItemBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let count = self.count;
        let type_ = self.type_;
        clz_Torappu_ItemBundle::create(_fbb, &clz_Torappu_ItemBundleArgs { id, count, type_ })
    }
}
pub enum clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData<'a>
{
    type Inner = clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData<'a> {
    pub const VT_LEVELNUM: flatbuffers::VOffsetT = 4;
    pub const VT_REWARDS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData<'bldr>>
    {
        let mut builder =
            clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardDataBuilder::new(_fbb);
        if let Some(x) = args.rewards {
            builder.add_rewards(x);
        }
        builder.add_levelNum(args.levelNum);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardDataT {
        let levelNum = self.levelNum();
        let rewards = self
            .rewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardDataT { levelNum, rewards }
    }

    #[inline]
    pub fn levelNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData::VT_LEVELNUM,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rewards(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(
                clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData::VT_REWARDS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("levelNum", Self::VT_LEVELNUM, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("rewards", Self::VT_REWARDS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardDataArgs<'a> {
    pub levelNum: i32,
    pub rewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardDataArgs {
            levelNum: 0,
            rewards: None,
        }
    }
}

impl Serialize for clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData",
            2,
        )?;
        s.serialize_field("levelNum", &self.levelNum())?;
        if let Some(f) = self.rewards() {
            s.serialize_field("rewards", &f)?;
        } else {
            s.skip_field("rewards")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_levelNum(&mut self, levelNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData::VT_LEVELNUM,
            levelNum,
            0,
        );
    }
    #[inline]
    pub fn add_rewards(
        &mut self,
        rewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData::VT_REWARDS,
            rewards,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData");
        ds.field("levelNum", &self.levelNum());
        ds.field("rewards", &self.rewards());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardDataT {
    pub levelNum: i32,
    pub rewards: Option<Vec<clz_Torappu_ItemBundleT>>,
}
impl Default for clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardDataT {
    fn default() -> Self {
        Self {
            levelNum: 0,
            rewards: None,
        }
    }
}
impl clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData<'b>>
    {
        let levelNum = self.levelNum;
        let rewards = self.rewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData::create(
            _fbb,
            &clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardDataArgs {
                levelNum,
                rewards,
            },
        )
    }
}
pub enum clz_Torappu_ClimbTowerSingleTowerDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ClimbTowerSingleTowerData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ClimbTowerSingleTowerData<'a> {
    type Inner = clz_Torappu_ClimbTowerSingleTowerData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ClimbTowerSingleTowerData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_STAGENUM: flatbuffers::VOffsetT = 8;
    pub const VT_NAME: flatbuffers::VOffsetT = 10;
    pub const VT_SUBNAME: flatbuffers::VOffsetT = 12;
    pub const VT_DESC: flatbuffers::VOffsetT = 14;
    pub const VT_TOWERTYPE: flatbuffers::VOffsetT = 16;
    pub const VT_LEVELS: flatbuffers::VOffsetT = 18;
    pub const VT_HARDLEVELS: flatbuffers::VOffsetT = 20;
    pub const VT_TASKINFO: flatbuffers::VOffsetT = 22;
    pub const VT_PRETOWERID: flatbuffers::VOffsetT = 24;
    pub const VT_MEDALID: flatbuffers::VOffsetT = 26;
    pub const VT_HIDDENMEDALID: flatbuffers::VOffsetT = 28;
    pub const VT_HARDMODEMEDALID: flatbuffers::VOffsetT = 30;
    pub const VT_BOSSID: flatbuffers::VOffsetT = 32;
    pub const VT_CARDID: flatbuffers::VOffsetT = 34;
    pub const VT_CURSECARDIDS: flatbuffers::VOffsetT = 36;
    pub const VT_DANGERDESC: flatbuffers::VOffsetT = 38;
    pub const VT_HARDMODEDESC: flatbuffers::VOffsetT = 40;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ClimbTowerSingleTowerData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ClimbTowerSingleTowerDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSingleTowerData<'bldr>> {
        let mut builder = clz_Torappu_ClimbTowerSingleTowerDataBuilder::new(_fbb);
        if let Some(x) = args.hardModeDesc {
            builder.add_hardModeDesc(x);
        }
        if let Some(x) = args.dangerDesc {
            builder.add_dangerDesc(x);
        }
        if let Some(x) = args.curseCardIds {
            builder.add_curseCardIds(x);
        }
        if let Some(x) = args.cardId {
            builder.add_cardId(x);
        }
        if let Some(x) = args.bossId {
            builder.add_bossId(x);
        }
        if let Some(x) = args.hardModeMedalId {
            builder.add_hardModeMedalId(x);
        }
        if let Some(x) = args.hiddenMedalId {
            builder.add_hiddenMedalId(x);
        }
        if let Some(x) = args.medalId {
            builder.add_medalId(x);
        }
        if let Some(x) = args.preTowerId {
            builder.add_preTowerId(x);
        }
        if let Some(x) = args.taskInfo {
            builder.add_taskInfo(x);
        }
        if let Some(x) = args.hardLevels {
            builder.add_hardLevels(x);
        }
        if let Some(x) = args.levels {
            builder.add_levels(x);
        }
        builder.add_towerType(args.towerType);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.subName {
            builder.add_subName(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_stageNum(args.stageNum);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ClimbTowerSingleTowerDataT {
        let id = self.id().map(|x| x.to_string());
        let sortId = self.sortId();
        let stageNum = self.stageNum();
        let name = self.name().map(|x| x.to_string());
        let subName = self.subName().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let towerType = self.towerType();
        let levels = self
            .levels()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let hardLevels = self
            .hardLevels()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let taskInfo = self
            .taskInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let preTowerId = self.preTowerId().map(|x| x.to_string());
        let medalId = self.medalId().map(|x| x.to_string());
        let hiddenMedalId = self.hiddenMedalId().map(|x| x.to_string());
        let hardModeMedalId = self.hardModeMedalId().map(|x| x.to_string());
        let bossId = self.bossId().map(|x| x.to_string());
        let cardId = self.cardId().map(|x| x.to_string());
        let curseCardIds = self
            .curseCardIds()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let dangerDesc = self.dangerDesc().map(|x| x.to_string());
        let hardModeDesc = self.hardModeDesc().map(|x| x.to_string());
        clz_Torappu_ClimbTowerSingleTowerDataT {
            id,
            sortId,
            stageNum,
            name,
            subName,
            desc,
            towerType,
            levels,
            hardLevels,
            taskInfo,
            preTowerId,
            medalId,
            hiddenMedalId,
            hardModeMedalId,
            bossId,
            cardId,
            curseCardIds,
            dangerDesc,
            hardModeDesc,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSingleTowerData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ClimbTowerSingleTowerData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn stageNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ClimbTowerSingleTowerData::VT_STAGENUM, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSingleTowerData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn subName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSingleTowerData::VT_SUBNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSingleTowerData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn towerType(&self) -> enum__Torappu_ClimbTowerTowerType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ClimbTowerTowerType>(
                    clz_Torappu_ClimbTowerSingleTowerData::VT_TOWERTYPE,
                    Some(enum__Torappu_ClimbTowerTowerType::TRAINING),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn levels(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ClimbTowerSingleTowerData::VT_LEVELS, None)
        }
    }
    #[inline]
    pub fn hardLevels(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ClimbTowerSingleTowerData::VT_HARDLEVELS, None)
        }
    }
    #[inline]
    pub fn taskInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData,
                    >,
                >,
            >>(clz_Torappu_ClimbTowerSingleTowerData::VT_TASKINFO, None)
        }
    }
    #[inline]
    pub fn preTowerId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSingleTowerData::VT_PRETOWERID,
                None,
            )
        }
    }
    #[inline]
    pub fn medalId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSingleTowerData::VT_MEDALID,
                None,
            )
        }
    }
    #[inline]
    pub fn hiddenMedalId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSingleTowerData::VT_HIDDENMEDALID,
                None,
            )
        }
    }
    #[inline]
    pub fn hardModeMedalId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSingleTowerData::VT_HARDMODEMEDALID,
                None,
            )
        }
    }
    #[inline]
    pub fn bossId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSingleTowerData::VT_BOSSID,
                None,
            )
        }
    }
    #[inline]
    pub fn cardId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSingleTowerData::VT_CARDID,
                None,
            )
        }
    }
    #[inline]
    pub fn curseCardIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ClimbTowerSingleTowerData::VT_CURSECARDIDS, None)
        }
    }
    #[inline]
    pub fn dangerDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSingleTowerData::VT_DANGERDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn hardModeDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSingleTowerData::VT_HARDMODEDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ClimbTowerSingleTowerData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<i32>("stageNum", Self::VT_STAGENUM, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("subName", Self::VT_SUBNAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<enum__Torappu_ClimbTowerTowerType>(
                "towerType",
                Self::VT_TOWERTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("levels", Self::VT_LEVELS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("hardLevels", Self::VT_HARDLEVELS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData,
                    >,
                >,
            >>("taskInfo", Self::VT_TASKINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "preTowerId",
                Self::VT_PRETOWERID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("medalId", Self::VT_MEDALID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "hiddenMedalId",
                Self::VT_HIDDENMEDALID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "hardModeMedalId",
                Self::VT_HARDMODEMEDALID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bossId", Self::VT_BOSSID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cardId", Self::VT_CARDID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("curseCardIds", Self::VT_CURSECARDIDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dangerDesc",
                Self::VT_DANGERDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "hardModeDesc",
                Self::VT_HARDMODEDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ClimbTowerSingleTowerDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub stageNum: i32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub subName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub towerType: enum__Torappu_ClimbTowerTowerType,
    pub levels: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub hardLevels: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub taskInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData<'a>,
                >,
            >,
        >,
    >,
    pub preTowerId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub medalId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hiddenMedalId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hardModeMedalId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bossId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cardId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub curseCardIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub dangerDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hardModeDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ClimbTowerSingleTowerDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ClimbTowerSingleTowerDataArgs {
            id: None,
            sortId: 0,
            stageNum: 0,
            name: None,
            subName: None,
            desc: None,
            towerType: enum__Torappu_ClimbTowerTowerType::TRAINING,
            levels: None,
            hardLevels: None,
            taskInfo: None,
            preTowerId: None,
            medalId: None,
            hiddenMedalId: None,
            hardModeMedalId: None,
            bossId: None,
            cardId: None,
            curseCardIds: None,
            dangerDesc: None,
            hardModeDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_ClimbTowerSingleTowerData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ClimbTowerSingleTowerData", 19)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.serialize_field("stageNum", &self.stageNum())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.subName() {
            s.serialize_field("subName", &f)?;
        } else {
            s.skip_field("subName")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        s.serialize_field("towerType", &self.towerType())?;
        if let Some(f) = self.levels() {
            s.serialize_field("levels", &f)?;
        } else {
            s.skip_field("levels")?;
        }
        if let Some(f) = self.hardLevels() {
            s.serialize_field("hardLevels", &f)?;
        } else {
            s.skip_field("hardLevels")?;
        }
        if let Some(f) = self.taskInfo() {
            s.serialize_field("taskInfo", &f)?;
        } else {
            s.skip_field("taskInfo")?;
        }
        if let Some(f) = self.preTowerId() {
            s.serialize_field("preTowerId", &f)?;
        } else {
            s.skip_field("preTowerId")?;
        }
        if let Some(f) = self.medalId() {
            s.serialize_field("medalId", &f)?;
        } else {
            s.skip_field("medalId")?;
        }
        if let Some(f) = self.hiddenMedalId() {
            s.serialize_field("hiddenMedalId", &f)?;
        } else {
            s.skip_field("hiddenMedalId")?;
        }
        if let Some(f) = self.hardModeMedalId() {
            s.serialize_field("hardModeMedalId", &f)?;
        } else {
            s.skip_field("hardModeMedalId")?;
        }
        if let Some(f) = self.bossId() {
            s.serialize_field("bossId", &f)?;
        } else {
            s.skip_field("bossId")?;
        }
        if let Some(f) = self.cardId() {
            s.serialize_field("cardId", &f)?;
        } else {
            s.skip_field("cardId")?;
        }
        if let Some(f) = self.curseCardIds() {
            s.serialize_field("curseCardIds", &f)?;
        } else {
            s.skip_field("curseCardIds")?;
        }
        if let Some(f) = self.dangerDesc() {
            s.serialize_field("dangerDesc", &f)?;
        } else {
            s.skip_field("dangerDesc")?;
        }
        if let Some(f) = self.hardModeDesc() {
            s.serialize_field("hardModeDesc", &f)?;
        } else {
            s.skip_field("hardModeDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ClimbTowerSingleTowerDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ClimbTowerSingleTowerDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleTowerData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ClimbTowerSingleTowerData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_stageNum(&mut self, stageNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ClimbTowerSingleTowerData::VT_STAGENUM,
            stageNum,
            0,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleTowerData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_subName(&mut self, subName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleTowerData::VT_SUBNAME,
            subName,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleTowerData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_towerType(&mut self, towerType: enum__Torappu_ClimbTowerTowerType) {
        self.fbb_.push_slot::<enum__Torappu_ClimbTowerTowerType>(
            clz_Torappu_ClimbTowerSingleTowerData::VT_TOWERTYPE,
            towerType,
            enum__Torappu_ClimbTowerTowerType::TRAINING,
        );
    }
    #[inline]
    pub fn add_levels(
        &mut self,
        levels: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleTowerData::VT_LEVELS,
            levels,
        );
    }
    #[inline]
    pub fn add_hardLevels(
        &mut self,
        hardLevels: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleTowerData::VT_HARDLEVELS,
            hardLevels,
        );
    }
    #[inline]
    pub fn add_taskInfo(
        &mut self,
        taskInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleTowerData::VT_TASKINFO,
            taskInfo,
        );
    }
    #[inline]
    pub fn add_preTowerId(&mut self, preTowerId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleTowerData::VT_PRETOWERID,
            preTowerId,
        );
    }
    #[inline]
    pub fn add_medalId(&mut self, medalId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleTowerData::VT_MEDALID,
            medalId,
        );
    }
    #[inline]
    pub fn add_hiddenMedalId(&mut self, hiddenMedalId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleTowerData::VT_HIDDENMEDALID,
            hiddenMedalId,
        );
    }
    #[inline]
    pub fn add_hardModeMedalId(&mut self, hardModeMedalId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleTowerData::VT_HARDMODEMEDALID,
            hardModeMedalId,
        );
    }
    #[inline]
    pub fn add_bossId(&mut self, bossId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleTowerData::VT_BOSSID,
            bossId,
        );
    }
    #[inline]
    pub fn add_cardId(&mut self, cardId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleTowerData::VT_CARDID,
            cardId,
        );
    }
    #[inline]
    pub fn add_curseCardIds(
        &mut self,
        curseCardIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleTowerData::VT_CURSECARDIDS,
            curseCardIds,
        );
    }
    #[inline]
    pub fn add_dangerDesc(&mut self, dangerDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleTowerData::VT_DANGERDESC,
            dangerDesc,
        );
    }
    #[inline]
    pub fn add_hardModeDesc(&mut self, hardModeDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleTowerData::VT_HARDMODEDESC,
            hardModeDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ClimbTowerSingleTowerDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ClimbTowerSingleTowerDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSingleTowerData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ClimbTowerSingleTowerData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ClimbTowerSingleTowerData");
        ds.field("id", &self.id());
        ds.field("sortId", &self.sortId());
        ds.field("stageNum", &self.stageNum());
        ds.field("name", &self.name());
        ds.field("subName", &self.subName());
        ds.field("desc", &self.desc());
        ds.field("towerType", &self.towerType());
        ds.field("levels", &self.levels());
        ds.field("hardLevels", &self.hardLevels());
        ds.field("taskInfo", &self.taskInfo());
        ds.field("preTowerId", &self.preTowerId());
        ds.field("medalId", &self.medalId());
        ds.field("hiddenMedalId", &self.hiddenMedalId());
        ds.field("hardModeMedalId", &self.hardModeMedalId());
        ds.field("bossId", &self.bossId());
        ds.field("cardId", &self.cardId());
        ds.field("curseCardIds", &self.curseCardIds());
        ds.field("dangerDesc", &self.dangerDesc());
        ds.field("hardModeDesc", &self.hardModeDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ClimbTowerSingleTowerDataT {
    pub id: Option<String>,
    pub sortId: i32,
    pub stageNum: i32,
    pub name: Option<String>,
    pub subName: Option<String>,
    pub desc: Option<String>,
    pub towerType: enum__Torappu_ClimbTowerTowerType,
    pub levels: Option<Vec<String>>,
    pub hardLevels: Option<Vec<String>>,
    pub taskInfo: Option<Vec<clz_Torappu_ClimbTowerSingleTowerData_ClimbTowerTaskRewardDataT>>,
    pub preTowerId: Option<String>,
    pub medalId: Option<String>,
    pub hiddenMedalId: Option<String>,
    pub hardModeMedalId: Option<String>,
    pub bossId: Option<String>,
    pub cardId: Option<String>,
    pub curseCardIds: Option<Vec<String>>,
    pub dangerDesc: Option<String>,
    pub hardModeDesc: Option<String>,
}
impl Default for clz_Torappu_ClimbTowerSingleTowerDataT {
    fn default() -> Self {
        Self {
            id: None,
            sortId: 0,
            stageNum: 0,
            name: None,
            subName: None,
            desc: None,
            towerType: enum__Torappu_ClimbTowerTowerType::TRAINING,
            levels: None,
            hardLevels: None,
            taskInfo: None,
            preTowerId: None,
            medalId: None,
            hiddenMedalId: None,
            hardModeMedalId: None,
            bossId: None,
            cardId: None,
            curseCardIds: None,
            dangerDesc: None,
            hardModeDesc: None,
        }
    }
}
impl clz_Torappu_ClimbTowerSingleTowerDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSingleTowerData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let stageNum = self.stageNum;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let subName = self.subName.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let towerType = self.towerType;
        let levels = self.levels.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let hardLevels = self.hardLevels.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let taskInfo = self.taskInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let preTowerId = self.preTowerId.as_ref().map(|x| _fbb.create_string(x));
        let medalId = self.medalId.as_ref().map(|x| _fbb.create_string(x));
        let hiddenMedalId = self.hiddenMedalId.as_ref().map(|x| _fbb.create_string(x));
        let hardModeMedalId = self.hardModeMedalId.as_ref().map(|x| _fbb.create_string(x));
        let bossId = self.bossId.as_ref().map(|x| _fbb.create_string(x));
        let cardId = self.cardId.as_ref().map(|x| _fbb.create_string(x));
        let curseCardIds = self.curseCardIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let dangerDesc = self.dangerDesc.as_ref().map(|x| _fbb.create_string(x));
        let hardModeDesc = self.hardModeDesc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_ClimbTowerSingleTowerData::create(
            _fbb,
            &clz_Torappu_ClimbTowerSingleTowerDataArgs {
                id,
                sortId,
                stageNum,
                name,
                subName,
                desc,
                towerType,
                levels,
                hardLevels,
                taskInfo,
                preTowerId,
                medalId,
                hiddenMedalId,
                hardModeMedalId,
                bossId,
                cardId,
                curseCardIds,
                dangerDesc,
                hardModeDesc,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ClimbTowerSingleTowerDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ClimbTowerSingleTowerData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ClimbTowerSingleTowerData<'a> {
    type Inner = dict__string__clz_Torappu_ClimbTowerSingleTowerData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ClimbTowerSingleTowerData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ClimbTowerSingleTowerData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ClimbTowerSingleTowerDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerSingleTowerData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ClimbTowerSingleTowerDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ClimbTowerSingleTowerDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ClimbTowerSingleTowerDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ClimbTowerSingleTowerData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ClimbTowerSingleTowerData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ClimbTowerSingleTowerData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerSingleTowerData>>(
                    dict__string__clz_Torappu_ClimbTowerSingleTowerData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ClimbTowerSingleTowerData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerSingleTowerData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ClimbTowerSingleTowerDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSingleTowerData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ClimbTowerSingleTowerDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ClimbTowerSingleTowerDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ClimbTowerSingleTowerData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_ClimbTowerSingleTowerData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ClimbTowerSingleTowerDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ClimbTowerSingleTowerDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ClimbTowerSingleTowerData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSingleTowerData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSingleTowerData>>(
                dict__string__clz_Torappu_ClimbTowerSingleTowerData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ClimbTowerSingleTowerDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ClimbTowerSingleTowerDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerSingleTowerData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ClimbTowerSingleTowerData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ClimbTowerSingleTowerData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ClimbTowerSingleTowerData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ClimbTowerSingleTowerDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ClimbTowerSingleTowerDataT>>,
}
impl Default for dict__string__clz_Torappu_ClimbTowerSingleTowerDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ClimbTowerSingleTowerDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerSingleTowerData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ClimbTowerSingleTowerData::create(
            _fbb,
            &dict__string__clz_Torappu_ClimbTowerSingleTowerDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_WeightItemBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_WeightItemBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_WeightItemBundle<'a> {
    type Inner = clz_Torappu_WeightItemBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_WeightItemBundle<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_DROPTYPE: flatbuffers::VOffsetT = 8;
    pub const VT_COUNT: flatbuffers::VOffsetT = 10;
    pub const VT_WEIGHT: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_WeightItemBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_WeightItemBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_WeightItemBundle<'bldr>> {
        let mut builder = clz_Torappu_WeightItemBundleBuilder::new(_fbb);
        builder.add_weight(args.weight);
        builder.add_count(args.count);
        builder.add_dropType(args.dropType);
        builder.add_type_(args.type_);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_WeightItemBundleT {
        let id = self.id().map(|x| x.to_string());
        let type_ = self.type_();
        let dropType = self.dropType();
        let count = self.count();
        let weight = self.weight();
        clz_Torappu_WeightItemBundleT {
            id,
            type_,
            dropType,
            count,
            weight,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_WeightItemBundle::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_WeightItemBundle::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn dropType(&self) -> enum__Torappu_StageDropType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageDropType>(
                    clz_Torappu_WeightItemBundle::VT_DROPTYPE,
                    Some(enum__Torappu_StageDropType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_WeightItemBundle::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn weight(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_WeightItemBundle::VT_WEIGHT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_WeightItemBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<enum__Torappu_StageDropType>("dropType", Self::VT_DROPTYPE, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<i32>("weight", Self::VT_WEIGHT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_WeightItemBundleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_ItemType,
    pub dropType: enum__Torappu_StageDropType,
    pub count: i32,
    pub weight: i32,
}
impl<'a> Default for clz_Torappu_WeightItemBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_WeightItemBundleArgs {
            id: None,
            type_: enum__Torappu_ItemType::NONE,
            dropType: enum__Torappu_StageDropType::NONE,
            count: 0,
            weight: 0,
        }
    }
}

impl Serialize for clz_Torappu_WeightItemBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_WeightItemBundle", 5)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("type_", &self.type_())?;
        s.serialize_field("dropType", &self.dropType())?;
        s.serialize_field("count", &self.count())?;
        s.serialize_field("weight", &self.weight())?;
        s.end()
    }
}

pub struct clz_Torappu_WeightItemBundleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_WeightItemBundleBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_WeightItemBundle::VT_ID, id);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_WeightItemBundle::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn add_dropType(&mut self, dropType: enum__Torappu_StageDropType) {
        self.fbb_.push_slot::<enum__Torappu_StageDropType>(
            clz_Torappu_WeightItemBundle::VT_DROPTYPE,
            dropType,
            enum__Torappu_StageDropType::NONE,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_WeightItemBundle::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_weight(&mut self, weight: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_WeightItemBundle::VT_WEIGHT, weight, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_WeightItemBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_WeightItemBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_WeightItemBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_WeightItemBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_WeightItemBundle");
        ds.field("id", &self.id());
        ds.field("type_", &self.type_());
        ds.field("dropType", &self.dropType());
        ds.field("count", &self.count());
        ds.field("weight", &self.weight());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_WeightItemBundleT {
    pub id: Option<String>,
    pub type_: enum__Torappu_ItemType,
    pub dropType: enum__Torappu_StageDropType,
    pub count: i32,
    pub weight: i32,
}
impl Default for clz_Torappu_WeightItemBundleT {
    fn default() -> Self {
        Self {
            id: None,
            type_: enum__Torappu_ItemType::NONE,
            dropType: enum__Torappu_StageDropType::NONE,
            count: 0,
            weight: 0,
        }
    }
}
impl clz_Torappu_WeightItemBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_WeightItemBundle<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let dropType = self.dropType;
        let count = self.count;
        let weight = self.weight;
        clz_Torappu_WeightItemBundle::create(
            _fbb,
            &clz_Torappu_WeightItemBundleArgs {
                id,
                type_,
                dropType,
                count,
                weight,
            },
        )
    }
}
pub enum list_clz_Torappu_WeightItemBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct list_clz_Torappu_WeightItemBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for list_clz_Torappu_WeightItemBundle<'a> {
    type Inner = list_clz_Torappu_WeightItemBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> list_clz_Torappu_WeightItemBundle<'a> {
    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        list_clz_Torappu_WeightItemBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args list_clz_Torappu_WeightItemBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<list_clz_Torappu_WeightItemBundle<'bldr>> {
        let mut builder = list_clz_Torappu_WeightItemBundleBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> list_clz_Torappu_WeightItemBundleT {
        let values = self
            .values()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        list_clz_Torappu_WeightItemBundleT { values }
    }

    #[inline]
    pub fn values(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_WeightItemBundle<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_WeightItemBundle>>,
            >>(list_clz_Torappu_WeightItemBundle::VT_VALUES, None)
        }
    }
}

impl flatbuffers::Verifiable for list_clz_Torappu_WeightItemBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_WeightItemBundle>>,
            >>("values", Self::VT_VALUES, false)?
            .finish();
        Ok(())
    }
}
pub struct list_clz_Torappu_WeightItemBundleArgs<'a> {
    pub values: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_WeightItemBundle<'a>>>,
        >,
    >,
}
impl<'a> Default for list_clz_Torappu_WeightItemBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        list_clz_Torappu_WeightItemBundleArgs { values: None }
    }
}

impl Serialize for list_clz_Torappu_WeightItemBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("list_clz_Torappu_WeightItemBundle", 1)?;
        if let Some(f) = self.values() {
            s.serialize_field("values", &f)?;
        } else {
            s.skip_field("values")?;
        }
        s.end()
    }
}

pub struct list_clz_Torappu_WeightItemBundleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    list_clz_Torappu_WeightItemBundleBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_values(
        &mut self,
        values: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_WeightItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            list_clz_Torappu_WeightItemBundle::VT_VALUES,
            values,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> list_clz_Torappu_WeightItemBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        list_clz_Torappu_WeightItemBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<list_clz_Torappu_WeightItemBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for list_clz_Torappu_WeightItemBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("list_clz_Torappu_WeightItemBundle");
        ds.field("values", &self.values());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct list_clz_Torappu_WeightItemBundleT {
    pub values: Option<Vec<clz_Torappu_WeightItemBundleT>>,
}
impl Default for list_clz_Torappu_WeightItemBundleT {
    fn default() -> Self {
        Self { values: None }
    }
}
impl list_clz_Torappu_WeightItemBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<list_clz_Torappu_WeightItemBundle<'b>> {
        let values = self.values.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        list_clz_Torappu_WeightItemBundle::create(
            _fbb,
            &list_clz_Torappu_WeightItemBundleArgs { values },
        )
    }
}
pub enum clz_Torappu_StageData_DisplayRewardsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageData_DisplayRewards<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageData_DisplayRewards<'a> {
    type Inner = clz_Torappu_StageData_DisplayRewards<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageData_DisplayRewards<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_ID: flatbuffers::VOffsetT = 6;
    pub const VT_DROPTYPE: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageData_DisplayRewards { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageData_DisplayRewardsArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayRewards<'bldr>> {
        let mut builder = clz_Torappu_StageData_DisplayRewardsBuilder::new(_fbb);
        builder.add_dropType(args.dropType);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageData_DisplayRewardsT {
        let type_ = self.type_();
        let id = self.id().map(|x| x.to_string());
        let dropType = self.dropType();
        clz_Torappu_StageData_DisplayRewardsT {
            type_,
            id,
            dropType,
        }
    }

    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_StageData_DisplayRewards::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData_DisplayRewards::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn dropType(&self) -> enum__Torappu_StageDropType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageDropType>(
                    clz_Torappu_StageData_DisplayRewards::VT_DROPTYPE,
                    Some(enum__Torappu_StageDropType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageData_DisplayRewards<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_StageDropType>("dropType", Self::VT_DROPTYPE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageData_DisplayRewardsArgs<'a> {
    pub type_: enum__Torappu_ItemType,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dropType: enum__Torappu_StageDropType,
}
impl<'a> Default for clz_Torappu_StageData_DisplayRewardsArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageData_DisplayRewardsArgs {
            type_: enum__Torappu_ItemType::NONE,
            id: None,
            dropType: enum__Torappu_StageDropType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_StageData_DisplayRewards<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageData_DisplayRewards", 3)?;
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("dropType", &self.dropType())?;
        s.end()
    }
}

pub struct clz_Torappu_StageData_DisplayRewardsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StageData_DisplayRewardsBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_StageData_DisplayRewards::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_DisplayRewards::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_dropType(&mut self, dropType: enum__Torappu_StageDropType) {
        self.fbb_.push_slot::<enum__Torappu_StageDropType>(
            clz_Torappu_StageData_DisplayRewards::VT_DROPTYPE,
            dropType,
            enum__Torappu_StageDropType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageData_DisplayRewardsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageData_DisplayRewardsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayRewards<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageData_DisplayRewards<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageData_DisplayRewards");
        ds.field("type_", &self.type_());
        ds.field("id", &self.id());
        ds.field("dropType", &self.dropType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageData_DisplayRewardsT {
    pub type_: enum__Torappu_ItemType,
    pub id: Option<String>,
    pub dropType: enum__Torappu_StageDropType,
}
impl Default for clz_Torappu_StageData_DisplayRewardsT {
    fn default() -> Self {
        Self {
            type_: enum__Torappu_ItemType::NONE,
            id: None,
            dropType: enum__Torappu_StageDropType::NONE,
        }
    }
}
impl clz_Torappu_StageData_DisplayRewardsT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayRewards<'b>> {
        let type_ = self.type_;
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let dropType = self.dropType;
        clz_Torappu_StageData_DisplayRewards::create(
            _fbb,
            &clz_Torappu_StageData_DisplayRewardsArgs {
                type_,
                id,
                dropType,
            },
        )
    }
}
pub enum clz_Torappu_StageData_DisplayDetailRewardsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageData_DisplayDetailRewards<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageData_DisplayDetailRewards<'a> {
    type Inner = clz_Torappu_StageData_DisplayDetailRewards<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageData_DisplayDetailRewards<'a> {
    pub const VT_OCCPERCENT: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_ID: flatbuffers::VOffsetT = 8;
    pub const VT_DROPTYPE: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageData_DisplayDetailRewards { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageData_DisplayDetailRewardsArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayDetailRewards<'bldr>> {
        let mut builder = clz_Torappu_StageData_DisplayDetailRewardsBuilder::new(_fbb);
        builder.add_dropType(args.dropType);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_type_(args.type_);
        builder.add_occPercent(args.occPercent);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageData_DisplayDetailRewardsT {
        let occPercent = self.occPercent();
        let type_ = self.type_();
        let id = self.id().map(|x| x.to_string());
        let dropType = self.dropType();
        clz_Torappu_StageData_DisplayDetailRewardsT {
            occPercent,
            type_,
            id,
            dropType,
        }
    }

    #[inline]
    pub fn occPercent(&self) -> enum__Torappu_OccPer {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_OccPer>(
                    clz_Torappu_StageData_DisplayDetailRewards::VT_OCCPERCENT,
                    Some(enum__Torappu_OccPer::ALWAYS),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_StageData_DisplayDetailRewards::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData_DisplayDetailRewards::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn dropType(&self) -> enum__Torappu_StageDropType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageDropType>(
                    clz_Torappu_StageData_DisplayDetailRewards::VT_DROPTYPE,
                    Some(enum__Torappu_StageDropType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageData_DisplayDetailRewards<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_OccPer>("occPercent", Self::VT_OCCPERCENT, false)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_StageDropType>("dropType", Self::VT_DROPTYPE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageData_DisplayDetailRewardsArgs<'a> {
    pub occPercent: enum__Torappu_OccPer,
    pub type_: enum__Torappu_ItemType,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dropType: enum__Torappu_StageDropType,
}
impl<'a> Default for clz_Torappu_StageData_DisplayDetailRewardsArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageData_DisplayDetailRewardsArgs {
            occPercent: enum__Torappu_OccPer::ALWAYS,
            type_: enum__Torappu_ItemType::NONE,
            id: None,
            dropType: enum__Torappu_StageDropType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_StageData_DisplayDetailRewards<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageData_DisplayDetailRewards", 4)?;
        s.serialize_field("occPercent", &self.occPercent())?;
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("dropType", &self.dropType())?;
        s.end()
    }
}

pub struct clz_Torappu_StageData_DisplayDetailRewardsBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StageData_DisplayDetailRewardsBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_occPercent(&mut self, occPercent: enum__Torappu_OccPer) {
        self.fbb_.push_slot::<enum__Torappu_OccPer>(
            clz_Torappu_StageData_DisplayDetailRewards::VT_OCCPERCENT,
            occPercent,
            enum__Torappu_OccPer::ALWAYS,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_StageData_DisplayDetailRewards::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_DisplayDetailRewards::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_dropType(&mut self, dropType: enum__Torappu_StageDropType) {
        self.fbb_.push_slot::<enum__Torappu_StageDropType>(
            clz_Torappu_StageData_DisplayDetailRewards::VT_DROPTYPE,
            dropType,
            enum__Torappu_StageDropType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageData_DisplayDetailRewardsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageData_DisplayDetailRewardsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayDetailRewards<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageData_DisplayDetailRewards<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageData_DisplayDetailRewards");
        ds.field("occPercent", &self.occPercent());
        ds.field("type_", &self.type_());
        ds.field("id", &self.id());
        ds.field("dropType", &self.dropType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageData_DisplayDetailRewardsT {
    pub occPercent: enum__Torappu_OccPer,
    pub type_: enum__Torappu_ItemType,
    pub id: Option<String>,
    pub dropType: enum__Torappu_StageDropType,
}
impl Default for clz_Torappu_StageData_DisplayDetailRewardsT {
    fn default() -> Self {
        Self {
            occPercent: enum__Torappu_OccPer::ALWAYS,
            type_: enum__Torappu_ItemType::NONE,
            id: None,
            dropType: enum__Torappu_StageDropType::NONE,
        }
    }
}
impl clz_Torappu_StageData_DisplayDetailRewardsT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayDetailRewards<'b>> {
        let occPercent = self.occPercent;
        let type_ = self.type_;
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let dropType = self.dropType;
        clz_Torappu_StageData_DisplayDetailRewards::create(
            _fbb,
            &clz_Torappu_StageData_DisplayDetailRewardsArgs {
                occPercent,
                type_,
                id,
                dropType,
            },
        )
    }
}
pub enum clz_Torappu_ClimbTowerDropDisplayInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ClimbTowerDropDisplayInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ClimbTowerDropDisplayInfo<'a> {
    type Inner = clz_Torappu_ClimbTowerDropDisplayInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ClimbTowerDropDisplayInfo<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_MAXCOUNT: flatbuffers::VOffsetT = 8;
    pub const VT_MINCOUNT: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ClimbTowerDropDisplayInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ClimbTowerDropDisplayInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerDropDisplayInfo<'bldr>> {
        let mut builder = clz_Torappu_ClimbTowerDropDisplayInfoBuilder::new(_fbb);
        builder.add_minCount(args.minCount);
        builder.add_maxCount(args.maxCount);
        builder.add_type_(args.type_);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ClimbTowerDropDisplayInfoT {
        let itemId = self.itemId().map(|x| x.to_string());
        let type_ = self.type_();
        let maxCount = self.maxCount();
        let minCount = self.minCount();
        clz_Torappu_ClimbTowerDropDisplayInfoT {
            itemId,
            type_,
            maxCount,
            minCount,
        }
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerDropDisplayInfo::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_ClimbTowerDropDisplayInfo::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ClimbTowerDropDisplayInfo::VT_MAXCOUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn minCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ClimbTowerDropDisplayInfo::VT_MINCOUNT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ClimbTowerDropDisplayInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<i32>("maxCount", Self::VT_MAXCOUNT, false)?
            .visit_field::<i32>("minCount", Self::VT_MINCOUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ClimbTowerDropDisplayInfoArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_ItemType,
    pub maxCount: i32,
    pub minCount: i32,
}
impl<'a> Default for clz_Torappu_ClimbTowerDropDisplayInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ClimbTowerDropDisplayInfoArgs {
            itemId: None,
            type_: enum__Torappu_ItemType::NONE,
            maxCount: 0,
            minCount: 0,
        }
    }
}

impl Serialize for clz_Torappu_ClimbTowerDropDisplayInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ClimbTowerDropDisplayInfo", 4)?;
        if let Some(f) = self.itemId() {
            s.serialize_field("itemId", &f)?;
        } else {
            s.skip_field("itemId")?;
        }
        s.serialize_field("type_", &self.type_())?;
        s.serialize_field("maxCount", &self.maxCount())?;
        s.serialize_field("minCount", &self.minCount())?;
        s.end()
    }
}

pub struct clz_Torappu_ClimbTowerDropDisplayInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ClimbTowerDropDisplayInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerDropDisplayInfo::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_ClimbTowerDropDisplayInfo::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn add_maxCount(&mut self, maxCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ClimbTowerDropDisplayInfo::VT_MAXCOUNT,
            maxCount,
            0,
        );
    }
    #[inline]
    pub fn add_minCount(&mut self, minCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ClimbTowerDropDisplayInfo::VT_MINCOUNT,
            minCount,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ClimbTowerDropDisplayInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ClimbTowerDropDisplayInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerDropDisplayInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ClimbTowerDropDisplayInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ClimbTowerDropDisplayInfo");
        ds.field("itemId", &self.itemId());
        ds.field("type_", &self.type_());
        ds.field("maxCount", &self.maxCount());
        ds.field("minCount", &self.minCount());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ClimbTowerDropDisplayInfoT {
    pub itemId: Option<String>,
    pub type_: enum__Torappu_ItemType,
    pub maxCount: i32,
    pub minCount: i32,
}
impl Default for clz_Torappu_ClimbTowerDropDisplayInfoT {
    fn default() -> Self {
        Self {
            itemId: None,
            type_: enum__Torappu_ItemType::NONE,
            maxCount: 0,
            minCount: 0,
        }
    }
}
impl clz_Torappu_ClimbTowerDropDisplayInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerDropDisplayInfo<'b>> {
        let itemId = self.itemId.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let maxCount = self.maxCount;
        let minCount = self.minCount;
        clz_Torappu_ClimbTowerDropDisplayInfo::create(
            _fbb,
            &clz_Torappu_ClimbTowerDropDisplayInfoArgs {
                itemId,
                type_,
                maxCount,
                minCount,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ClimbTowerDropDisplayInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ClimbTowerDropDisplayInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ClimbTowerDropDisplayInfo<'a> {
    type Inner = dict__string__clz_Torappu_ClimbTowerDropDisplayInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ClimbTowerDropDisplayInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ClimbTowerDropDisplayInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ClimbTowerDropDisplayInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerDropDisplayInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ClimbTowerDropDisplayInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ClimbTowerDropDisplayInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ClimbTowerDropDisplayInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ClimbTowerDropDisplayInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ClimbTowerDropDisplayInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ClimbTowerDropDisplayInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerDropDisplayInfo>>(
                    dict__string__clz_Torappu_ClimbTowerDropDisplayInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ClimbTowerDropDisplayInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerDropDisplayInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ClimbTowerDropDisplayInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ClimbTowerDropDisplayInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ClimbTowerDropDisplayInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ClimbTowerDropDisplayInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ClimbTowerDropDisplayInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_ClimbTowerDropDisplayInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ClimbTowerDropDisplayInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ClimbTowerDropDisplayInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ClimbTowerDropDisplayInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ClimbTowerDropDisplayInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ClimbTowerDropDisplayInfo>>(
                dict__string__clz_Torappu_ClimbTowerDropDisplayInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ClimbTowerDropDisplayInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ClimbTowerDropDisplayInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerDropDisplayInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ClimbTowerDropDisplayInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ClimbTowerDropDisplayInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ClimbTowerDropDisplayInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ClimbTowerDropDisplayInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ClimbTowerDropDisplayInfoT>>,
}
impl Default for dict__string__clz_Torappu_ClimbTowerDropDisplayInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ClimbTowerDropDisplayInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerDropDisplayInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ClimbTowerDropDisplayInfo::create(
            _fbb,
            &dict__string__clz_Torappu_ClimbTowerDropDisplayInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ClimbTowerLevelDropInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ClimbTowerLevelDropInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ClimbTowerLevelDropInfo<'a> {
    type Inner = clz_Torappu_ClimbTowerLevelDropInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ClimbTowerLevelDropInfo<'a> {
    pub const VT_PASSREWARDS: flatbuffers::VOffsetT = 4;
    pub const VT_DISPLAYREWARDS: flatbuffers::VOffsetT = 6;
    pub const VT_DISPLAYDETAILREWARDS: flatbuffers::VOffsetT = 8;
    pub const VT_DISPLAYDROPINFO: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ClimbTowerLevelDropInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ClimbTowerLevelDropInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerLevelDropInfo<'bldr>> {
        let mut builder = clz_Torappu_ClimbTowerLevelDropInfoBuilder::new(_fbb);
        if let Some(x) = args.displayDropInfo {
            builder.add_displayDropInfo(x);
        }
        if let Some(x) = args.displayDetailRewards {
            builder.add_displayDetailRewards(x);
        }
        if let Some(x) = args.displayRewards {
            builder.add_displayRewards(x);
        }
        if let Some(x) = args.passRewards {
            builder.add_passRewards(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ClimbTowerLevelDropInfoT {
        let passRewards = self
            .passRewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let displayRewards = self
            .displayRewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let displayDetailRewards = self
            .displayDetailRewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let displayDropInfo = self
            .displayDropInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ClimbTowerLevelDropInfoT {
            passRewards,
            displayRewards,
            displayDetailRewards,
            displayDropInfo,
        }
    }

    #[inline]
    pub fn passRewards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle>,
                >,
            >>(clz_Torappu_ClimbTowerLevelDropInfo::VT_PASSREWARDS, None)
        }
    }
    #[inline]
    pub fn displayRewards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayRewards<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayRewards>,
                >,
            >>(clz_Torappu_ClimbTowerLevelDropInfo::VT_DISPLAYREWARDS, None)
        }
    }
    #[inline]
    pub fn displayDetailRewards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards>,
                >,
            >>(
                clz_Torappu_ClimbTowerLevelDropInfo::VT_DISPLAYDETAILREWARDS,
                None,
            )
        }
    }
    #[inline]
    pub fn displayDropInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerDropDisplayInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ClimbTowerDropDisplayInfo,
                    >,
                >,
            >>(
                clz_Torappu_ClimbTowerLevelDropInfo::VT_DISPLAYDROPINFO,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ClimbTowerLevelDropInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle>,
                >,
            >>("passRewards", Self::VT_PASSREWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayRewards>,
                >,
            >>("displayRewards", Self::VT_DISPLAYREWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards>,
                >,
            >>("displayDetailRewards", Self::VT_DISPLAYDETAILREWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ClimbTowerDropDisplayInfo,
                    >,
                >,
            >>("displayDropInfo", Self::VT_DISPLAYDROPINFO, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ClimbTowerLevelDropInfoArgs<'a> {
    pub passRewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle<'a>>,
            >,
        >,
    >,
    pub displayRewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayRewards<'a>>,
            >,
        >,
    >,
    pub displayDetailRewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards<'a>>,
            >,
        >,
    >,
    pub displayDropInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ClimbTowerDropDisplayInfo<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ClimbTowerLevelDropInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ClimbTowerLevelDropInfoArgs {
            passRewards: None,
            displayRewards: None,
            displayDetailRewards: None,
            displayDropInfo: None,
        }
    }
}

impl Serialize for clz_Torappu_ClimbTowerLevelDropInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ClimbTowerLevelDropInfo", 4)?;
        if let Some(f) = self.passRewards() {
            s.serialize_field("passRewards", &f)?;
        } else {
            s.skip_field("passRewards")?;
        }
        if let Some(f) = self.displayRewards() {
            s.serialize_field("displayRewards", &f)?;
        } else {
            s.skip_field("displayRewards")?;
        }
        if let Some(f) = self.displayDetailRewards() {
            s.serialize_field("displayDetailRewards", &f)?;
        } else {
            s.skip_field("displayDetailRewards")?;
        }
        if let Some(f) = self.displayDropInfo() {
            s.serialize_field("displayDropInfo", &f)?;
        } else {
            s.skip_field("displayDropInfo")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ClimbTowerLevelDropInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ClimbTowerLevelDropInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_passRewards(
        &mut self,
        passRewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerLevelDropInfo::VT_PASSREWARDS,
            passRewards,
        );
    }
    #[inline]
    pub fn add_displayRewards(
        &mut self,
        displayRewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayRewards<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerLevelDropInfo::VT_DISPLAYREWARDS,
            displayRewards,
        );
    }
    #[inline]
    pub fn add_displayDetailRewards(
        &mut self,
        displayDetailRewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerLevelDropInfo::VT_DISPLAYDETAILREWARDS,
            displayDetailRewards,
        );
    }
    #[inline]
    pub fn add_displayDropInfo(
        &mut self,
        displayDropInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ClimbTowerDropDisplayInfo<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerLevelDropInfo::VT_DISPLAYDROPINFO,
            displayDropInfo,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ClimbTowerLevelDropInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ClimbTowerLevelDropInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerLevelDropInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ClimbTowerLevelDropInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ClimbTowerLevelDropInfo");
        ds.field("passRewards", &self.passRewards());
        ds.field("displayRewards", &self.displayRewards());
        ds.field("displayDetailRewards", &self.displayDetailRewards());
        ds.field("displayDropInfo", &self.displayDropInfo());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ClimbTowerLevelDropInfoT {
    pub passRewards: Option<Vec<list_clz_Torappu_WeightItemBundleT>>,
    pub displayRewards: Option<Vec<clz_Torappu_StageData_DisplayRewardsT>>,
    pub displayDetailRewards: Option<Vec<clz_Torappu_StageData_DisplayDetailRewardsT>>,
    pub displayDropInfo: Option<Vec<dict__string__clz_Torappu_ClimbTowerDropDisplayInfoT>>,
}
impl Default for clz_Torappu_ClimbTowerLevelDropInfoT {
    fn default() -> Self {
        Self {
            passRewards: None,
            displayRewards: None,
            displayDetailRewards: None,
            displayDropInfo: None,
        }
    }
}
impl clz_Torappu_ClimbTowerLevelDropInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerLevelDropInfo<'b>> {
        let passRewards = self.passRewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let displayRewards = self.displayRewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let displayDetailRewards = self.displayDetailRewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let displayDropInfo = self.displayDropInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ClimbTowerLevelDropInfo::create(
            _fbb,
            &clz_Torappu_ClimbTowerLevelDropInfoArgs {
                passRewards,
                displayRewards,
                displayDetailRewards,
                displayDropInfo,
            },
        )
    }
}
pub enum clz_Torappu_ClimbTowerSingleLevelDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ClimbTowerSingleLevelData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ClimbTowerSingleLevelData<'a> {
    type Inner = clz_Torappu_ClimbTowerSingleLevelData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ClimbTowerSingleLevelData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_LEVELID: flatbuffers::VOffsetT = 6;
    pub const VT_TOWERID: flatbuffers::VOffsetT = 8;
    pub const VT_LAYERNUM: flatbuffers::VOffsetT = 10;
    pub const VT_CODE: flatbuffers::VOffsetT = 12;
    pub const VT_NAME: flatbuffers::VOffsetT = 14;
    pub const VT_DESC: flatbuffers::VOffsetT = 16;
    pub const VT_LEVELTYPE: flatbuffers::VOffsetT = 18;
    pub const VT_LOADINGPICID: flatbuffers::VOffsetT = 20;
    pub const VT_DROPINFO: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ClimbTowerSingleLevelData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ClimbTowerSingleLevelDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSingleLevelData<'bldr>> {
        let mut builder = clz_Torappu_ClimbTowerSingleLevelDataBuilder::new(_fbb);
        if let Some(x) = args.dropInfo {
            builder.add_dropInfo(x);
        }
        if let Some(x) = args.loadingPicId {
            builder.add_loadingPicId(x);
        }
        builder.add_levelType(args.levelType);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.code {
            builder.add_code(x);
        }
        builder.add_layerNum(args.layerNum);
        if let Some(x) = args.towerId {
            builder.add_towerId(x);
        }
        if let Some(x) = args.levelId {
            builder.add_levelId(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ClimbTowerSingleLevelDataT {
        let id = self.id().map(|x| x.to_string());
        let levelId = self.levelId().map(|x| x.to_string());
        let towerId = self.towerId().map(|x| x.to_string());
        let layerNum = self.layerNum();
        let code = self.code().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let levelType = self.levelType();
        let loadingPicId = self.loadingPicId().map(|x| x.to_string());
        let dropInfo = self.dropInfo().map(|x| Box::new(x.unpack()));
        clz_Torappu_ClimbTowerSingleLevelDataT {
            id,
            levelId,
            towerId,
            layerNum,
            code,
            name,
            desc,
            levelType,
            loadingPicId,
            dropInfo,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSingleLevelData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn levelId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSingleLevelData::VT_LEVELID,
                None,
            )
        }
    }
    #[inline]
    pub fn towerId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSingleLevelData::VT_TOWERID,
                None,
            )
        }
    }
    #[inline]
    pub fn layerNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ClimbTowerSingleLevelData::VT_LAYERNUM, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn code(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSingleLevelData::VT_CODE,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSingleLevelData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSingleLevelData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn levelType(&self) -> enum__Torappu_ClimbTowerLevelType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ClimbTowerLevelType>(
                    clz_Torappu_ClimbTowerSingleLevelData::VT_LEVELTYPE,
                    Some(enum__Torappu_ClimbTowerLevelType::NORMAL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn loadingPicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSingleLevelData::VT_LOADINGPICID,
                None,
            )
        }
    }
    #[inline]
    pub fn dropInfo(&self) -> Option<clz_Torappu_ClimbTowerLevelDropInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerLevelDropInfo>>(
                    clz_Torappu_ClimbTowerSingleLevelData::VT_DROPINFO,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ClimbTowerSingleLevelData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("levelId", Self::VT_LEVELID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("towerId", Self::VT_TOWERID, false)?
            .visit_field::<i32>("layerNum", Self::VT_LAYERNUM, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("code", Self::VT_CODE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<enum__Torappu_ClimbTowerLevelType>(
                "levelType",
                Self::VT_LEVELTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "loadingPicId",
                Self::VT_LOADINGPICID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerLevelDropInfo>>(
                "dropInfo",
                Self::VT_DROPINFO,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ClimbTowerSingleLevelDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub levelId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub towerId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub layerNum: i32,
    pub code: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub levelType: enum__Torappu_ClimbTowerLevelType,
    pub loadingPicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dropInfo: Option<flatbuffers::WIPOffset<clz_Torappu_ClimbTowerLevelDropInfo<'a>>>,
}
impl<'a> Default for clz_Torappu_ClimbTowerSingleLevelDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ClimbTowerSingleLevelDataArgs {
            id: None,
            levelId: None,
            towerId: None,
            layerNum: 0,
            code: None,
            name: None,
            desc: None,
            levelType: enum__Torappu_ClimbTowerLevelType::NORMAL,
            loadingPicId: None,
            dropInfo: None,
        }
    }
}

impl Serialize for clz_Torappu_ClimbTowerSingleLevelData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ClimbTowerSingleLevelData", 10)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.levelId() {
            s.serialize_field("levelId", &f)?;
        } else {
            s.skip_field("levelId")?;
        }
        if let Some(f) = self.towerId() {
            s.serialize_field("towerId", &f)?;
        } else {
            s.skip_field("towerId")?;
        }
        s.serialize_field("layerNum", &self.layerNum())?;
        if let Some(f) = self.code() {
            s.serialize_field("code", &f)?;
        } else {
            s.skip_field("code")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        s.serialize_field("levelType", &self.levelType())?;
        if let Some(f) = self.loadingPicId() {
            s.serialize_field("loadingPicId", &f)?;
        } else {
            s.skip_field("loadingPicId")?;
        }
        if let Some(f) = self.dropInfo() {
            s.serialize_field("dropInfo", &f)?;
        } else {
            s.skip_field("dropInfo")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ClimbTowerSingleLevelDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ClimbTowerSingleLevelDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleLevelData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_levelId(&mut self, levelId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleLevelData::VT_LEVELID,
            levelId,
        );
    }
    #[inline]
    pub fn add_towerId(&mut self, towerId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleLevelData::VT_TOWERID,
            towerId,
        );
    }
    #[inline]
    pub fn add_layerNum(&mut self, layerNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ClimbTowerSingleLevelData::VT_LAYERNUM,
            layerNum,
            0,
        );
    }
    #[inline]
    pub fn add_code(&mut self, code: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleLevelData::VT_CODE,
            code,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleLevelData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleLevelData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_levelType(&mut self, levelType: enum__Torappu_ClimbTowerLevelType) {
        self.fbb_.push_slot::<enum__Torappu_ClimbTowerLevelType>(
            clz_Torappu_ClimbTowerSingleLevelData::VT_LEVELTYPE,
            levelType,
            enum__Torappu_ClimbTowerLevelType::NORMAL,
        );
    }
    #[inline]
    pub fn add_loadingPicId(&mut self, loadingPicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSingleLevelData::VT_LOADINGPICID,
            loadingPicId,
        );
    }
    #[inline]
    pub fn add_dropInfo(
        &mut self,
        dropInfo: flatbuffers::WIPOffset<clz_Torappu_ClimbTowerLevelDropInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ClimbTowerLevelDropInfo>>(
                clz_Torappu_ClimbTowerSingleLevelData::VT_DROPINFO,
                dropInfo,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ClimbTowerSingleLevelDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ClimbTowerSingleLevelDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSingleLevelData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ClimbTowerSingleLevelData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ClimbTowerSingleLevelData");
        ds.field("id", &self.id());
        ds.field("levelId", &self.levelId());
        ds.field("towerId", &self.towerId());
        ds.field("layerNum", &self.layerNum());
        ds.field("code", &self.code());
        ds.field("name", &self.name());
        ds.field("desc", &self.desc());
        ds.field("levelType", &self.levelType());
        ds.field("loadingPicId", &self.loadingPicId());
        ds.field("dropInfo", &self.dropInfo());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ClimbTowerSingleLevelDataT {
    pub id: Option<String>,
    pub levelId: Option<String>,
    pub towerId: Option<String>,
    pub layerNum: i32,
    pub code: Option<String>,
    pub name: Option<String>,
    pub desc: Option<String>,
    pub levelType: enum__Torappu_ClimbTowerLevelType,
    pub loadingPicId: Option<String>,
    pub dropInfo: Option<Box<clz_Torappu_ClimbTowerLevelDropInfoT>>,
}
impl Default for clz_Torappu_ClimbTowerSingleLevelDataT {
    fn default() -> Self {
        Self {
            id: None,
            levelId: None,
            towerId: None,
            layerNum: 0,
            code: None,
            name: None,
            desc: None,
            levelType: enum__Torappu_ClimbTowerLevelType::NORMAL,
            loadingPicId: None,
            dropInfo: None,
        }
    }
}
impl clz_Torappu_ClimbTowerSingleLevelDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSingleLevelData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let levelId = self.levelId.as_ref().map(|x| _fbb.create_string(x));
        let towerId = self.towerId.as_ref().map(|x| _fbb.create_string(x));
        let layerNum = self.layerNum;
        let code = self.code.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let levelType = self.levelType;
        let loadingPicId = self.loadingPicId.as_ref().map(|x| _fbb.create_string(x));
        let dropInfo = self.dropInfo.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_ClimbTowerSingleLevelData::create(
            _fbb,
            &clz_Torappu_ClimbTowerSingleLevelDataArgs {
                id,
                levelId,
                towerId,
                layerNum,
                code,
                name,
                desc,
                levelType,
                loadingPicId,
                dropInfo,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ClimbTowerSingleLevelDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ClimbTowerSingleLevelData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ClimbTowerSingleLevelData<'a> {
    type Inner = dict__string__clz_Torappu_ClimbTowerSingleLevelData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ClimbTowerSingleLevelData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ClimbTowerSingleLevelData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ClimbTowerSingleLevelDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerSingleLevelData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ClimbTowerSingleLevelDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ClimbTowerSingleLevelDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ClimbTowerSingleLevelDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ClimbTowerSingleLevelData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ClimbTowerSingleLevelData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ClimbTowerSingleLevelData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerSingleLevelData>>(
                    dict__string__clz_Torappu_ClimbTowerSingleLevelData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ClimbTowerSingleLevelData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerSingleLevelData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ClimbTowerSingleLevelDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSingleLevelData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ClimbTowerSingleLevelDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ClimbTowerSingleLevelDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ClimbTowerSingleLevelData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_ClimbTowerSingleLevelData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ClimbTowerSingleLevelDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ClimbTowerSingleLevelDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ClimbTowerSingleLevelData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSingleLevelData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSingleLevelData>>(
                dict__string__clz_Torappu_ClimbTowerSingleLevelData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ClimbTowerSingleLevelDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ClimbTowerSingleLevelDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerSingleLevelData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ClimbTowerSingleLevelData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ClimbTowerSingleLevelData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ClimbTowerSingleLevelData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ClimbTowerSingleLevelDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ClimbTowerSingleLevelDataT>>,
}
impl Default for dict__string__clz_Torappu_ClimbTowerSingleLevelDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ClimbTowerSingleLevelDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerSingleLevelData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ClimbTowerSingleLevelData::create(
            _fbb,
            &dict__string__clz_Torappu_ClimbTowerSingleLevelDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ClimbTowerTacticalBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ClimbTowerTacticalBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ClimbTowerTacticalBuffData<'a> {
    type Inner = clz_Torappu_ClimbTowerTacticalBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ClimbTowerTacticalBuffData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DESC: flatbuffers::VOffsetT = 6;
    pub const VT_PROFESSION: flatbuffers::VOffsetT = 8;
    pub const VT_ISDEFAULTACTIVE: flatbuffers::VOffsetT = 10;
    pub const VT_SORTID: flatbuffers::VOffsetT = 12;
    pub const VT_BUFFTYPE: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ClimbTowerTacticalBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ClimbTowerTacticalBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerTacticalBuffData<'bldr>> {
        let mut builder = clz_Torappu_ClimbTowerTacticalBuffDataBuilder::new(_fbb);
        builder.add_buffType(args.buffType);
        builder.add_sortId(args.sortId);
        builder.add_profession(args.profession);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_isDefaultActive(args.isDefaultActive);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ClimbTowerTacticalBuffDataT {
        let id = self.id().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let profession = self.profession();
        let isDefaultActive = self.isDefaultActive();
        let sortId = self.sortId();
        let buffType = self.buffType();
        clz_Torappu_ClimbTowerTacticalBuffDataT {
            id,
            desc,
            profession,
            isDefaultActive,
            sortId,
            buffType,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerTacticalBuffData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerTacticalBuffData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn profession(&self) -> enum__Torappu_ProfessionCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ProfessionCategory>(
                    clz_Torappu_ClimbTowerTacticalBuffData::VT_PROFESSION,
                    Some(enum__Torappu_ProfessionCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn isDefaultActive(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_ClimbTowerTacticalBuffData::VT_ISDEFAULTACTIVE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ClimbTowerTacticalBuffData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn buffType(&self) -> enum__Torappu_ClimbTowerTaticalBuffType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ClimbTowerTaticalBuffType>(
                    clz_Torappu_ClimbTowerTacticalBuffData::VT_BUFFTYPE,
                    Some(enum__Torappu_ClimbTowerTaticalBuffType::A),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ClimbTowerTacticalBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<enum__Torappu_ProfessionCategory>(
                "profession",
                Self::VT_PROFESSION,
                false,
            )?
            .visit_field::<bool>("isDefaultActive", Self::VT_ISDEFAULTACTIVE, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<enum__Torappu_ClimbTowerTaticalBuffType>(
                "buffType",
                Self::VT_BUFFTYPE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ClimbTowerTacticalBuffDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub profession: enum__Torappu_ProfessionCategory,
    pub isDefaultActive: bool,
    pub sortId: i32,
    pub buffType: enum__Torappu_ClimbTowerTaticalBuffType,
}
impl<'a> Default for clz_Torappu_ClimbTowerTacticalBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ClimbTowerTacticalBuffDataArgs {
            id: None,
            desc: None,
            profession: enum__Torappu_ProfessionCategory::NONE,
            isDefaultActive: false,
            sortId: 0,
            buffType: enum__Torappu_ClimbTowerTaticalBuffType::A,
        }
    }
}

impl Serialize for clz_Torappu_ClimbTowerTacticalBuffData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ClimbTowerTacticalBuffData", 6)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        s.serialize_field("profession", &self.profession())?;
        s.serialize_field("isDefaultActive", &self.isDefaultActive())?;
        s.serialize_field("sortId", &self.sortId())?;
        s.serialize_field("buffType", &self.buffType())?;
        s.end()
    }
}

pub struct clz_Torappu_ClimbTowerTacticalBuffDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ClimbTowerTacticalBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerTacticalBuffData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerTacticalBuffData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_profession(&mut self, profession: enum__Torappu_ProfessionCategory) {
        self.fbb_.push_slot::<enum__Torappu_ProfessionCategory>(
            clz_Torappu_ClimbTowerTacticalBuffData::VT_PROFESSION,
            profession,
            enum__Torappu_ProfessionCategory::NONE,
        );
    }
    #[inline]
    pub fn add_isDefaultActive(&mut self, isDefaultActive: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_ClimbTowerTacticalBuffData::VT_ISDEFAULTACTIVE,
            isDefaultActive,
            false,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ClimbTowerTacticalBuffData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_buffType(&mut self, buffType: enum__Torappu_ClimbTowerTaticalBuffType) {
        self.fbb_
            .push_slot::<enum__Torappu_ClimbTowerTaticalBuffType>(
                clz_Torappu_ClimbTowerTacticalBuffData::VT_BUFFTYPE,
                buffType,
                enum__Torappu_ClimbTowerTaticalBuffType::A,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ClimbTowerTacticalBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ClimbTowerTacticalBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerTacticalBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ClimbTowerTacticalBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ClimbTowerTacticalBuffData");
        ds.field("id", &self.id());
        ds.field("desc", &self.desc());
        ds.field("profession", &self.profession());
        ds.field("isDefaultActive", &self.isDefaultActive());
        ds.field("sortId", &self.sortId());
        ds.field("buffType", &self.buffType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ClimbTowerTacticalBuffDataT {
    pub id: Option<String>,
    pub desc: Option<String>,
    pub profession: enum__Torappu_ProfessionCategory,
    pub isDefaultActive: bool,
    pub sortId: i32,
    pub buffType: enum__Torappu_ClimbTowerTaticalBuffType,
}
impl Default for clz_Torappu_ClimbTowerTacticalBuffDataT {
    fn default() -> Self {
        Self {
            id: None,
            desc: None,
            profession: enum__Torappu_ProfessionCategory::NONE,
            isDefaultActive: false,
            sortId: 0,
            buffType: enum__Torappu_ClimbTowerTaticalBuffType::A,
        }
    }
}
impl clz_Torappu_ClimbTowerTacticalBuffDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerTacticalBuffData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let profession = self.profession;
        let isDefaultActive = self.isDefaultActive;
        let sortId = self.sortId;
        let buffType = self.buffType;
        clz_Torappu_ClimbTowerTacticalBuffData::create(
            _fbb,
            &clz_Torappu_ClimbTowerTacticalBuffDataArgs {
                id,
                desc,
                profession,
                isDefaultActive,
                sortId,
                buffType,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ClimbTowerTacticalBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ClimbTowerTacticalBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ClimbTowerTacticalBuffData<'a> {
    type Inner = dict__string__clz_Torappu_ClimbTowerTacticalBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ClimbTowerTacticalBuffData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ClimbTowerTacticalBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ClimbTowerTacticalBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerTacticalBuffData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ClimbTowerTacticalBuffDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ClimbTowerTacticalBuffDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ClimbTowerTacticalBuffDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ClimbTowerTacticalBuffData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ClimbTowerTacticalBuffData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ClimbTowerTacticalBuffData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerTacticalBuffData>>(
                    dict__string__clz_Torappu_ClimbTowerTacticalBuffData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ClimbTowerTacticalBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerTacticalBuffData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ClimbTowerTacticalBuffDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ClimbTowerTacticalBuffData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ClimbTowerTacticalBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ClimbTowerTacticalBuffDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ClimbTowerTacticalBuffData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_ClimbTowerTacticalBuffData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ClimbTowerTacticalBuffDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ClimbTowerTacticalBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ClimbTowerTacticalBuffData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ClimbTowerTacticalBuffData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ClimbTowerTacticalBuffData>>(
                dict__string__clz_Torappu_ClimbTowerTacticalBuffData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ClimbTowerTacticalBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ClimbTowerTacticalBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerTacticalBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ClimbTowerTacticalBuffData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ClimbTowerTacticalBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ClimbTowerTacticalBuffData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ClimbTowerTacticalBuffDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ClimbTowerTacticalBuffDataT>>,
}
impl Default for dict__string__clz_Torappu_ClimbTowerTacticalBuffDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ClimbTowerTacticalBuffDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerTacticalBuffData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ClimbTowerTacticalBuffData::create(
            _fbb,
            &dict__string__clz_Torappu_ClimbTowerTacticalBuffDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RuneData_SelectorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RuneData_Selector<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RuneData_Selector<'a> {
    type Inner = clz_Torappu_RuneData_Selector<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RuneData_Selector<'a> {
    pub const VT_PROFESSIONMASK: flatbuffers::VOffsetT = 4;
    pub const VT_BUILDABLEMASK: flatbuffers::VOffsetT = 6;
    pub const VT_PLAYERSIDEMASK: flatbuffers::VOffsetT = 8;
    pub const VT_SIDETYPE: flatbuffers::VOffsetT = 10;
    pub const VT_CHARIDFILTER: flatbuffers::VOffsetT = 12;
    pub const VT_ENEMYIDFILTER: flatbuffers::VOffsetT = 14;
    pub const VT_ENEMYIDEXCLUDEFILTER: flatbuffers::VOffsetT = 16;
    pub const VT_ENEMYLEVELTYPEFILTER: flatbuffers::VOffsetT = 18;
    pub const VT_ENEMYACTIONHIDDENGROUPFILTER: flatbuffers::VOffsetT = 20;
    pub const VT_SKILLIDFILTER: flatbuffers::VOffsetT = 22;
    pub const VT_TILEKEYFILTER: flatbuffers::VOffsetT = 24;
    pub const VT_GROUPTAGFILTER: flatbuffers::VOffsetT = 26;
    pub const VT_FILTERTAGFILTER: flatbuffers::VOffsetT = 28;
    pub const VT_FILTERTAGEXCLUDEFILTER: flatbuffers::VOffsetT = 30;
    pub const VT_SUBPROFESSIONEXCLUDEFILTER: flatbuffers::VOffsetT = 32;
    pub const VT_MAPTAGFILTER: flatbuffers::VOffsetT = 34;
    pub const VT_HEIGHTTYPEMASK: flatbuffers::VOffsetT = 36;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RuneData_Selector { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RuneData_SelectorArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'bldr>> {
        let mut builder = clz_Torappu_RuneData_SelectorBuilder::new(_fbb);
        builder.add_heightTypeMask(args.heightTypeMask);
        if let Some(x) = args.mapTagFilter {
            builder.add_mapTagFilter(x);
        }
        if let Some(x) = args.subProfessionExcludeFilter {
            builder.add_subProfessionExcludeFilter(x);
        }
        if let Some(x) = args.filterTagExcludeFilter {
            builder.add_filterTagExcludeFilter(x);
        }
        if let Some(x) = args.filterTagFilter {
            builder.add_filterTagFilter(x);
        }
        if let Some(x) = args.groupTagFilter {
            builder.add_groupTagFilter(x);
        }
        if let Some(x) = args.tileKeyFilter {
            builder.add_tileKeyFilter(x);
        }
        if let Some(x) = args.skillIdFilter {
            builder.add_skillIdFilter(x);
        }
        if let Some(x) = args.enemyActionHiddenGroupFilter {
            builder.add_enemyActionHiddenGroupFilter(x);
        }
        if let Some(x) = args.enemyLevelTypeFilter {
            builder.add_enemyLevelTypeFilter(x);
        }
        if let Some(x) = args.enemyIdExcludeFilter {
            builder.add_enemyIdExcludeFilter(x);
        }
        if let Some(x) = args.enemyIdFilter {
            builder.add_enemyIdFilter(x);
        }
        if let Some(x) = args.charIdFilter {
            builder.add_charIdFilter(x);
        }
        builder.add_sideType(args.sideType);
        builder.add_buildableMask(args.buildableMask);
        builder.add_professionMask(args.professionMask);
        builder.add_playerSideMask(args.playerSideMask);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RuneData_SelectorT {
        let professionMask = self.professionMask();
        let buildableMask = self.buildableMask();
        let playerSideMask = self.playerSideMask();
        let sideType = self.sideType();
        let charIdFilter = self
            .charIdFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let enemyIdFilter = self
            .enemyIdFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let enemyIdExcludeFilter = self
            .enemyIdExcludeFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let enemyLevelTypeFilter = self
            .enemyLevelTypeFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let enemyActionHiddenGroupFilter = self
            .enemyActionHiddenGroupFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let skillIdFilter = self
            .skillIdFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let tileKeyFilter = self
            .tileKeyFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let groupTagFilter = self
            .groupTagFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let filterTagFilter = self
            .filterTagFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let filterTagExcludeFilter = self
            .filterTagExcludeFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let subProfessionExcludeFilter = self
            .subProfessionExcludeFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let mapTagFilter = self
            .mapTagFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let heightTypeMask = self.heightTypeMask();
        clz_Torappu_RuneData_SelectorT {
            professionMask,
            buildableMask,
            playerSideMask,
            sideType,
            charIdFilter,
            enemyIdFilter,
            enemyIdExcludeFilter,
            enemyLevelTypeFilter,
            enemyActionHiddenGroupFilter,
            skillIdFilter,
            tileKeyFilter,
            groupTagFilter,
            filterTagFilter,
            filterTagExcludeFilter,
            subProfessionExcludeFilter,
            mapTagFilter,
            heightTypeMask,
        }
    }

    #[inline]
    pub fn professionMask(&self) -> enum__Torappu_ProfessionCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ProfessionCategory>(
                    clz_Torappu_RuneData_Selector::VT_PROFESSIONMASK,
                    Some(enum__Torappu_ProfessionCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn buildableMask(&self) -> enum__Torappu_BuildableType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildableType>(
                    clz_Torappu_RuneData_Selector::VT_BUILDABLEMASK,
                    Some(enum__Torappu_BuildableType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn playerSideMask(&self) -> enum__Torappu_PlayerSideMask {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_PlayerSideMask>(
                    clz_Torappu_RuneData_Selector::VT_PLAYERSIDEMASK,
                    Some(enum__Torappu_PlayerSideMask::ALL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sideType(&self) -> enum__Torappu_Battle_SideType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_Battle_SideType>(
                    clz_Torappu_RuneData_Selector::VT_SIDETYPE,
                    Some(enum__Torappu_Battle_SideType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn charIdFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_CHARIDFILTER, None)
        }
    }
    #[inline]
    pub fn enemyIdFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_ENEMYIDFILTER, None)
        }
    }
    #[inline]
    pub fn enemyIdExcludeFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_ENEMYIDEXCLUDEFILTER, None)
        }
    }
    #[inline]
    pub fn enemyLevelTypeFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_ENEMYLEVELTYPEFILTER, None)
        }
    }
    #[inline]
    pub fn enemyActionHiddenGroupFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RuneData_Selector::VT_ENEMYACTIONHIDDENGROUPFILTER,
                None,
            )
        }
    }
    #[inline]
    pub fn skillIdFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_SKILLIDFILTER, None)
        }
    }
    #[inline]
    pub fn tileKeyFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_TILEKEYFILTER, None)
        }
    }
    #[inline]
    pub fn groupTagFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_GROUPTAGFILTER, None)
        }
    }
    #[inline]
    pub fn filterTagFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_FILTERTAGFILTER, None)
        }
    }
    #[inline]
    pub fn filterTagExcludeFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RuneData_Selector::VT_FILTERTAGEXCLUDEFILTER,
                None,
            )
        }
    }
    #[inline]
    pub fn subProfessionExcludeFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RuneData_Selector::VT_SUBPROFESSIONEXCLUDEFILTER,
                None,
            )
        }
    }
    #[inline]
    pub fn mapTagFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_MAPTAGFILTER, None)
        }
    }
    #[inline]
    pub fn heightTypeMask(&self) -> enum__Torappu_TileData_HeightTypeMask {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_TileData_HeightTypeMask>(
                    clz_Torappu_RuneData_Selector::VT_HEIGHTTYPEMASK,
                    Some(enum__Torappu_TileData_HeightTypeMask::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RuneData_Selector<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_ProfessionCategory>(
                "professionMask",
                Self::VT_PROFESSIONMASK,
                false,
            )?
            .visit_field::<enum__Torappu_BuildableType>(
                "buildableMask",
                Self::VT_BUILDABLEMASK,
                false,
            )?
            .visit_field::<enum__Torappu_PlayerSideMask>(
                "playerSideMask",
                Self::VT_PLAYERSIDEMASK,
                false,
            )?
            .visit_field::<enum__Torappu_Battle_SideType>("sideType", Self::VT_SIDETYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("charIdFilter", Self::VT_CHARIDFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("enemyIdFilter", Self::VT_ENEMYIDFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("enemyIdExcludeFilter", Self::VT_ENEMYIDEXCLUDEFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("enemyLevelTypeFilter", Self::VT_ENEMYLEVELTYPEFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "enemyActionHiddenGroupFilter",
                Self::VT_ENEMYACTIONHIDDENGROUPFILTER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("skillIdFilter", Self::VT_SKILLIDFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("tileKeyFilter", Self::VT_TILEKEYFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("groupTagFilter", Self::VT_GROUPTAGFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("filterTagFilter", Self::VT_FILTERTAGFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "filterTagExcludeFilter",
                Self::VT_FILTERTAGEXCLUDEFILTER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "subProfessionExcludeFilter",
                Self::VT_SUBPROFESSIONEXCLUDEFILTER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("mapTagFilter", Self::VT_MAPTAGFILTER, false)?
            .visit_field::<enum__Torappu_TileData_HeightTypeMask>(
                "heightTypeMask",
                Self::VT_HEIGHTTYPEMASK,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RuneData_SelectorArgs<'a> {
    pub professionMask: enum__Torappu_ProfessionCategory,
    pub buildableMask: enum__Torappu_BuildableType,
    pub playerSideMask: enum__Torappu_PlayerSideMask,
    pub sideType: enum__Torappu_Battle_SideType,
    pub charIdFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub enemyIdFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub enemyIdExcludeFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub enemyLevelTypeFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub enemyActionHiddenGroupFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub skillIdFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub tileKeyFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub groupTagFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub filterTagFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub filterTagExcludeFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub subProfessionExcludeFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub mapTagFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub heightTypeMask: enum__Torappu_TileData_HeightTypeMask,
}
impl<'a> Default for clz_Torappu_RuneData_SelectorArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RuneData_SelectorArgs {
            professionMask: enum__Torappu_ProfessionCategory::NONE,
            buildableMask: enum__Torappu_BuildableType::NONE,
            playerSideMask: enum__Torappu_PlayerSideMask::ALL,
            sideType: enum__Torappu_Battle_SideType::NONE,
            charIdFilter: None,
            enemyIdFilter: None,
            enemyIdExcludeFilter: None,
            enemyLevelTypeFilter: None,
            enemyActionHiddenGroupFilter: None,
            skillIdFilter: None,
            tileKeyFilter: None,
            groupTagFilter: None,
            filterTagFilter: None,
            filterTagExcludeFilter: None,
            subProfessionExcludeFilter: None,
            mapTagFilter: None,
            heightTypeMask: enum__Torappu_TileData_HeightTypeMask::NONE,
        }
    }
}

impl Serialize for clz_Torappu_RuneData_Selector<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RuneData_Selector", 17)?;
        s.serialize_field("professionMask", &self.professionMask())?;
        s.serialize_field("buildableMask", &self.buildableMask())?;
        s.serialize_field("playerSideMask", &self.playerSideMask())?;
        s.serialize_field("sideType", &self.sideType())?;
        if let Some(f) = self.charIdFilter() {
            s.serialize_field("charIdFilter", &f)?;
        } else {
            s.skip_field("charIdFilter")?;
        }
        if let Some(f) = self.enemyIdFilter() {
            s.serialize_field("enemyIdFilter", &f)?;
        } else {
            s.skip_field("enemyIdFilter")?;
        }
        if let Some(f) = self.enemyIdExcludeFilter() {
            s.serialize_field("enemyIdExcludeFilter", &f)?;
        } else {
            s.skip_field("enemyIdExcludeFilter")?;
        }
        if let Some(f) = self.enemyLevelTypeFilter() {
            s.serialize_field("enemyLevelTypeFilter", &f)?;
        } else {
            s.skip_field("enemyLevelTypeFilter")?;
        }
        if let Some(f) = self.enemyActionHiddenGroupFilter() {
            s.serialize_field("enemyActionHiddenGroupFilter", &f)?;
        } else {
            s.skip_field("enemyActionHiddenGroupFilter")?;
        }
        if let Some(f) = self.skillIdFilter() {
            s.serialize_field("skillIdFilter", &f)?;
        } else {
            s.skip_field("skillIdFilter")?;
        }
        if let Some(f) = self.tileKeyFilter() {
            s.serialize_field("tileKeyFilter", &f)?;
        } else {
            s.skip_field("tileKeyFilter")?;
        }
        if let Some(f) = self.groupTagFilter() {
            s.serialize_field("groupTagFilter", &f)?;
        } else {
            s.skip_field("groupTagFilter")?;
        }
        if let Some(f) = self.filterTagFilter() {
            s.serialize_field("filterTagFilter", &f)?;
        } else {
            s.skip_field("filterTagFilter")?;
        }
        if let Some(f) = self.filterTagExcludeFilter() {
            s.serialize_field("filterTagExcludeFilter", &f)?;
        } else {
            s.skip_field("filterTagExcludeFilter")?;
        }
        if let Some(f) = self.subProfessionExcludeFilter() {
            s.serialize_field("subProfessionExcludeFilter", &f)?;
        } else {
            s.skip_field("subProfessionExcludeFilter")?;
        }
        if let Some(f) = self.mapTagFilter() {
            s.serialize_field("mapTagFilter", &f)?;
        } else {
            s.skip_field("mapTagFilter")?;
        }
        s.serialize_field("heightTypeMask", &self.heightTypeMask())?;
        s.end()
    }
}

pub struct clz_Torappu_RuneData_SelectorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RuneData_SelectorBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_professionMask(&mut self, professionMask: enum__Torappu_ProfessionCategory) {
        self.fbb_.push_slot::<enum__Torappu_ProfessionCategory>(
            clz_Torappu_RuneData_Selector::VT_PROFESSIONMASK,
            professionMask,
            enum__Torappu_ProfessionCategory::NONE,
        );
    }
    #[inline]
    pub fn add_buildableMask(&mut self, buildableMask: enum__Torappu_BuildableType) {
        self.fbb_.push_slot::<enum__Torappu_BuildableType>(
            clz_Torappu_RuneData_Selector::VT_BUILDABLEMASK,
            buildableMask,
            enum__Torappu_BuildableType::NONE,
        );
    }
    #[inline]
    pub fn add_playerSideMask(&mut self, playerSideMask: enum__Torappu_PlayerSideMask) {
        self.fbb_.push_slot::<enum__Torappu_PlayerSideMask>(
            clz_Torappu_RuneData_Selector::VT_PLAYERSIDEMASK,
            playerSideMask,
            enum__Torappu_PlayerSideMask::ALL,
        );
    }
    #[inline]
    pub fn add_sideType(&mut self, sideType: enum__Torappu_Battle_SideType) {
        self.fbb_.push_slot::<enum__Torappu_Battle_SideType>(
            clz_Torappu_RuneData_Selector::VT_SIDETYPE,
            sideType,
            enum__Torappu_Battle_SideType::NONE,
        );
    }
    #[inline]
    pub fn add_charIdFilter(
        &mut self,
        charIdFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_CHARIDFILTER,
            charIdFilter,
        );
    }
    #[inline]
    pub fn add_enemyIdFilter(
        &mut self,
        enemyIdFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_ENEMYIDFILTER,
            enemyIdFilter,
        );
    }
    #[inline]
    pub fn add_enemyIdExcludeFilter(
        &mut self,
        enemyIdExcludeFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_ENEMYIDEXCLUDEFILTER,
            enemyIdExcludeFilter,
        );
    }
    #[inline]
    pub fn add_enemyLevelTypeFilter(
        &mut self,
        enemyLevelTypeFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_ENEMYLEVELTYPEFILTER,
            enemyLevelTypeFilter,
        );
    }
    #[inline]
    pub fn add_enemyActionHiddenGroupFilter(
        &mut self,
        enemyActionHiddenGroupFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_ENEMYACTIONHIDDENGROUPFILTER,
            enemyActionHiddenGroupFilter,
        );
    }
    #[inline]
    pub fn add_skillIdFilter(
        &mut self,
        skillIdFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_SKILLIDFILTER,
            skillIdFilter,
        );
    }
    #[inline]
    pub fn add_tileKeyFilter(
        &mut self,
        tileKeyFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_TILEKEYFILTER,
            tileKeyFilter,
        );
    }
    #[inline]
    pub fn add_groupTagFilter(
        &mut self,
        groupTagFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_GROUPTAGFILTER,
            groupTagFilter,
        );
    }
    #[inline]
    pub fn add_filterTagFilter(
        &mut self,
        filterTagFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_FILTERTAGFILTER,
            filterTagFilter,
        );
    }
    #[inline]
    pub fn add_filterTagExcludeFilter(
        &mut self,
        filterTagExcludeFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_FILTERTAGEXCLUDEFILTER,
            filterTagExcludeFilter,
        );
    }
    #[inline]
    pub fn add_subProfessionExcludeFilter(
        &mut self,
        subProfessionExcludeFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_SUBPROFESSIONEXCLUDEFILTER,
            subProfessionExcludeFilter,
        );
    }
    #[inline]
    pub fn add_mapTagFilter(
        &mut self,
        mapTagFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_MAPTAGFILTER,
            mapTagFilter,
        );
    }
    #[inline]
    pub fn add_heightTypeMask(&mut self, heightTypeMask: enum__Torappu_TileData_HeightTypeMask) {
        self.fbb_
            .push_slot::<enum__Torappu_TileData_HeightTypeMask>(
                clz_Torappu_RuneData_Selector::VT_HEIGHTTYPEMASK,
                heightTypeMask,
                enum__Torappu_TileData_HeightTypeMask::NONE,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RuneData_SelectorBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RuneData_SelectorBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RuneData_Selector<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RuneData_Selector");
        ds.field("professionMask", &self.professionMask());
        ds.field("buildableMask", &self.buildableMask());
        ds.field("playerSideMask", &self.playerSideMask());
        ds.field("sideType", &self.sideType());
        ds.field("charIdFilter", &self.charIdFilter());
        ds.field("enemyIdFilter", &self.enemyIdFilter());
        ds.field("enemyIdExcludeFilter", &self.enemyIdExcludeFilter());
        ds.field("enemyLevelTypeFilter", &self.enemyLevelTypeFilter());
        ds.field(
            "enemyActionHiddenGroupFilter",
            &self.enemyActionHiddenGroupFilter(),
        );
        ds.field("skillIdFilter", &self.skillIdFilter());
        ds.field("tileKeyFilter", &self.tileKeyFilter());
        ds.field("groupTagFilter", &self.groupTagFilter());
        ds.field("filterTagFilter", &self.filterTagFilter());
        ds.field("filterTagExcludeFilter", &self.filterTagExcludeFilter());
        ds.field(
            "subProfessionExcludeFilter",
            &self.subProfessionExcludeFilter(),
        );
        ds.field("mapTagFilter", &self.mapTagFilter());
        ds.field("heightTypeMask", &self.heightTypeMask());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RuneData_SelectorT {
    pub professionMask: enum__Torappu_ProfessionCategory,
    pub buildableMask: enum__Torappu_BuildableType,
    pub playerSideMask: enum__Torappu_PlayerSideMask,
    pub sideType: enum__Torappu_Battle_SideType,
    pub charIdFilter: Option<Vec<String>>,
    pub enemyIdFilter: Option<Vec<String>>,
    pub enemyIdExcludeFilter: Option<Vec<String>>,
    pub enemyLevelTypeFilter: Option<Vec<String>>,
    pub enemyActionHiddenGroupFilter: Option<Vec<String>>,
    pub skillIdFilter: Option<Vec<String>>,
    pub tileKeyFilter: Option<Vec<String>>,
    pub groupTagFilter: Option<Vec<String>>,
    pub filterTagFilter: Option<Vec<String>>,
    pub filterTagExcludeFilter: Option<Vec<String>>,
    pub subProfessionExcludeFilter: Option<Vec<String>>,
    pub mapTagFilter: Option<Vec<String>>,
    pub heightTypeMask: enum__Torappu_TileData_HeightTypeMask,
}
impl Default for clz_Torappu_RuneData_SelectorT {
    fn default() -> Self {
        Self {
            professionMask: enum__Torappu_ProfessionCategory::NONE,
            buildableMask: enum__Torappu_BuildableType::NONE,
            playerSideMask: enum__Torappu_PlayerSideMask::ALL,
            sideType: enum__Torappu_Battle_SideType::NONE,
            charIdFilter: None,
            enemyIdFilter: None,
            enemyIdExcludeFilter: None,
            enemyLevelTypeFilter: None,
            enemyActionHiddenGroupFilter: None,
            skillIdFilter: None,
            tileKeyFilter: None,
            groupTagFilter: None,
            filterTagFilter: None,
            filterTagExcludeFilter: None,
            subProfessionExcludeFilter: None,
            mapTagFilter: None,
            heightTypeMask: enum__Torappu_TileData_HeightTypeMask::NONE,
        }
    }
}
impl clz_Torappu_RuneData_SelectorT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'b>> {
        let professionMask = self.professionMask;
        let buildableMask = self.buildableMask;
        let playerSideMask = self.playerSideMask;
        let sideType = self.sideType;
        let charIdFilter = self.charIdFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let enemyIdFilter = self.enemyIdFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let enemyIdExcludeFilter = self.enemyIdExcludeFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let enemyLevelTypeFilter = self.enemyLevelTypeFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let enemyActionHiddenGroupFilter = self.enemyActionHiddenGroupFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let skillIdFilter = self.skillIdFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let tileKeyFilter = self.tileKeyFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let groupTagFilter = self.groupTagFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let filterTagFilter = self.filterTagFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let filterTagExcludeFilter = self.filterTagExcludeFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let subProfessionExcludeFilter = self.subProfessionExcludeFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let mapTagFilter = self.mapTagFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let heightTypeMask = self.heightTypeMask;
        clz_Torappu_RuneData_Selector::create(
            _fbb,
            &clz_Torappu_RuneData_SelectorArgs {
                professionMask,
                buildableMask,
                playerSideMask,
                sideType,
                charIdFilter,
                enemyIdFilter,
                enemyIdExcludeFilter,
                enemyLevelTypeFilter,
                enemyActionHiddenGroupFilter,
                skillIdFilter,
                tileKeyFilter,
                groupTagFilter,
                filterTagFilter,
                filterTagExcludeFilter,
                subProfessionExcludeFilter,
                mapTagFilter,
                heightTypeMask,
            },
        )
    }
}
pub enum clz_Torappu_Blackboard_DataPairOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Blackboard_DataPair<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Blackboard_DataPair<'a> {
    type Inner = clz_Torappu_Blackboard_DataPair<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Blackboard_DataPair<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;
    pub const VT_VALUESTR: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Blackboard_DataPair { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Blackboard_DataPairArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'bldr>> {
        let mut builder = clz_Torappu_Blackboard_DataPairBuilder::new(_fbb);
        if let Some(x) = args.valueStr {
            builder.add_valueStr(x);
        }
        builder.add_value(args.value);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Blackboard_DataPairT {
        let key = self.key().map(|x| x.to_string());
        let value = self.value();
        let valueStr = self.valueStr().map(|x| x.to_string());
        clz_Torappu_Blackboard_DataPairT {
            key,
            value,
            valueStr,
        }
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_KEY,
                None,
            )
        }
    }
    #[inline]
    pub fn value(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn valueStr(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Blackboard_DataPair<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<f32>("value", Self::VT_VALUE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "valueStr",
                Self::VT_VALUESTR,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Blackboard_DataPairArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: f32,
    pub valueStr: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Blackboard_DataPairArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Blackboard_DataPairArgs {
            key: None,
            value: 0.0,
            valueStr: None,
        }
    }
}

impl Serialize for clz_Torappu_Blackboard_DataPair<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Blackboard_DataPair", 3)?;
        if let Some(f) = self.key() {
            s.serialize_field("key", &f)?;
        } else {
            s.skip_field("key")?;
        }
        s.serialize_field("value", &self.value())?;
        if let Some(f) = self.valueStr() {
            s.serialize_field("valueStr", &f)?;
        } else {
            s.skip_field("valueStr")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Blackboard_DataPairBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, value, 0.0);
    }
    #[inline]
    pub fn add_valueStr(&mut self, valueStr: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
            valueStr,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Blackboard_DataPairBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Blackboard_DataPair<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Blackboard_DataPair");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.field("valueStr", &self.valueStr());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Blackboard_DataPairT {
    pub key: Option<String>,
    pub value: f32,
    pub valueStr: Option<String>,
}
impl Default for clz_Torappu_Blackboard_DataPairT {
    fn default() -> Self {
        Self {
            key: None,
            value: 0.0,
            valueStr: None,
        }
    }
}
impl clz_Torappu_Blackboard_DataPairT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'b>> {
        let key = self.key.as_ref().map(|x| _fbb.create_string(x));
        let value = self.value;
        let valueStr = self.valueStr.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Blackboard_DataPair::create(
            _fbb,
            &clz_Torappu_Blackboard_DataPairArgs {
                key,
                value,
                valueStr,
            },
        )
    }
}
pub enum clz_Torappu_RuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RuneData<'a> {
    type Inner = clz_Torappu_RuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RuneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_SELECTOR: flatbuffers::VOffsetT = 6;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneData<'bldr>> {
        let mut builder = clz_Torappu_RuneDataBuilder::new(_fbb);
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        if let Some(x) = args.selector {
            builder.add_selector(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RuneDataT {
        let key = self.key().map(|x| x.to_string());
        let selector = self.selector().map(|x| Box::new(x.unpack()));
        let blackboard = self
            .blackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RuneDataT {
            key,
            selector,
            blackboard,
        }
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_RuneData::VT_KEY, None)
        }
    }
    #[inline]
    pub fn selector(&self) -> Option<clz_Torappu_RuneData_Selector<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneData_Selector>>(
                    clz_Torappu_RuneData::VT_SELECTOR,
                    None,
                )
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(clz_Torappu_RuneData::VT_BLACKBOARD, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneData_Selector>>(
                "selector",
                Self::VT_SELECTOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RuneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub selector: Option<flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'a>>>,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RuneDataArgs {
            key: None,
            selector: None,
            blackboard: None,
        }
    }
}

impl Serialize for clz_Torappu_RuneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RuneData", 3)?;
        if let Some(f) = self.key() {
            s.serialize_field("key", &f)?;
        } else {
            s.skip_field("key")?;
        }
        if let Some(f) = self.selector() {
            s.serialize_field("selector", &f)?;
        } else {
            s.skip_field("selector")?;
        }
        if let Some(f) = self.blackboard() {
            s.serialize_field("blackboard", &f)?;
        } else {
            s.skip_field("blackboard")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RuneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RuneDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_RuneData::VT_KEY, key);
    }
    #[inline]
    pub fn add_selector(
        &mut self,
        selector: flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector>>(
                clz_Torappu_RuneData::VT_SELECTOR,
                selector,
            );
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RuneData");
        ds.field("key", &self.key());
        ds.field("selector", &self.selector());
        ds.field("blackboard", &self.blackboard());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RuneDataT {
    pub key: Option<String>,
    pub selector: Option<Box<clz_Torappu_RuneData_SelectorT>>,
    pub blackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
}
impl Default for clz_Torappu_RuneDataT {
    fn default() -> Self {
        Self {
            key: None,
            selector: None,
            blackboard: None,
        }
    }
}
impl clz_Torappu_RuneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneData<'b>> {
        let key = self.key.as_ref().map(|x| _fbb.create_string(x));
        let selector = self.selector.as_ref().map(|x| x.pack(_fbb));
        let blackboard = self.blackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RuneData::create(
            _fbb,
            &clz_Torappu_RuneDataArgs {
                key,
                selector,
                blackboard,
            },
        )
    }
}
pub enum clz_Torappu_RuneTable_PackedRuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RuneTable_PackedRuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RuneTable_PackedRuneData<'a> {
    type Inner = clz_Torappu_RuneTable_PackedRuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RuneTable_PackedRuneData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_POINTS: flatbuffers::VOffsetT = 6;
    pub const VT_MUTEXGROUPKEY: flatbuffers::VOffsetT = 8;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
    pub const VT_RUNES: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RuneTable_PackedRuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RuneTable_PackedRuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'bldr>> {
        let mut builder = clz_Torappu_RuneTable_PackedRuneDataBuilder::new(_fbb);
        if let Some(x) = args.runes {
            builder.add_runes(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.mutexGroupKey {
            builder.add_mutexGroupKey(x);
        }
        builder.add_points(args.points);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RuneTable_PackedRuneDataT {
        let id = self.id().map(|x| x.to_string());
        let points = self.points();
        let mutexGroupKey = self.mutexGroupKey().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let runes = self.runes().map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RuneTable_PackedRuneDataT {
            id,
            points,
            mutexGroupKey,
            description,
            runes,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RuneTable_PackedRuneData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn points(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_RuneTable_PackedRuneData::VT_POINTS, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn mutexGroupKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RuneTable_PackedRuneData::VT_MUTEXGROUPKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RuneTable_PackedRuneData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn runes(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData>>,
            >>(clz_Torappu_RuneTable_PackedRuneData::VT_RUNES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RuneTable_PackedRuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<f32>("points", Self::VT_POINTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "mutexGroupKey",
                Self::VT_MUTEXGROUPKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData>>,
            >>("runes", Self::VT_RUNES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RuneTable_PackedRuneDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub points: f32,
    pub mutexGroupKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub runes: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RuneTable_PackedRuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RuneTable_PackedRuneDataArgs {
            id: None,
            points: 0.0,
            mutexGroupKey: None,
            description: None,
            runes: None,
        }
    }
}

impl Serialize for clz_Torappu_RuneTable_PackedRuneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RuneTable_PackedRuneData", 5)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("points", &self.points())?;
        if let Some(f) = self.mutexGroupKey() {
            s.serialize_field("mutexGroupKey", &f)?;
        } else {
            s.skip_field("mutexGroupKey")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        if let Some(f) = self.runes() {
            s.serialize_field("runes", &f)?;
        } else {
            s.skip_field("runes")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RuneTable_PackedRuneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RuneTable_PackedRuneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneTable_PackedRuneData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_points(&mut self, points: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_RuneTable_PackedRuneData::VT_POINTS, points, 0.0);
    }
    #[inline]
    pub fn add_mutexGroupKey(&mut self, mutexGroupKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneTable_PackedRuneData::VT_MUTEXGROUPKEY,
            mutexGroupKey,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneTable_PackedRuneData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_runes(
        &mut self,
        runes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneTable_PackedRuneData::VT_RUNES,
            runes,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RuneTable_PackedRuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RuneTable_PackedRuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RuneTable_PackedRuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RuneTable_PackedRuneData");
        ds.field("id", &self.id());
        ds.field("points", &self.points());
        ds.field("mutexGroupKey", &self.mutexGroupKey());
        ds.field("description", &self.description());
        ds.field("runes", &self.runes());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RuneTable_PackedRuneDataT {
    pub id: Option<String>,
    pub points: f32,
    pub mutexGroupKey: Option<String>,
    pub description: Option<String>,
    pub runes: Option<Vec<clz_Torappu_RuneDataT>>,
}
impl Default for clz_Torappu_RuneTable_PackedRuneDataT {
    fn default() -> Self {
        Self {
            id: None,
            points: 0.0,
            mutexGroupKey: None,
            description: None,
            runes: None,
        }
    }
}
impl clz_Torappu_RuneTable_PackedRuneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let points = self.points;
        let mutexGroupKey = self.mutexGroupKey.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let runes = self.runes.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RuneTable_PackedRuneData::create(
            _fbb,
            &clz_Torappu_RuneTable_PackedRuneDataArgs {
                id,
                points,
                mutexGroupKey,
                description,
                runes,
            },
        )
    }
}
pub enum clz_Torappu_ClimbTowerMainCardDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ClimbTowerMainCardData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ClimbTowerMainCardData<'a> {
    type Inner = clz_Torappu_ClimbTowerMainCardData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ClimbTowerMainCardData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_LINKEDTOWERID: flatbuffers::VOffsetT = 8;
    pub const VT_SORTID: flatbuffers::VOffsetT = 10;
    pub const VT_NAME: flatbuffers::VOffsetT = 12;
    pub const VT_DESC: flatbuffers::VOffsetT = 14;
    pub const VT_SUBCARDIDS: flatbuffers::VOffsetT = 16;
    pub const VT_RUNEDATA: flatbuffers::VOffsetT = 18;
    pub const VT_TRAPIDS: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ClimbTowerMainCardData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ClimbTowerMainCardDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerMainCardData<'bldr>> {
        let mut builder = clz_Torappu_ClimbTowerMainCardDataBuilder::new(_fbb);
        if let Some(x) = args.trapIds {
            builder.add_trapIds(x);
        }
        if let Some(x) = args.runeData {
            builder.add_runeData(x);
        }
        if let Some(x) = args.subCardIds {
            builder.add_subCardIds(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.linkedTowerId {
            builder.add_linkedTowerId(x);
        }
        builder.add_type_(args.type_);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ClimbTowerMainCardDataT {
        let id = self.id().map(|x| x.to_string());
        let type_ = self.type_();
        let linkedTowerId = self.linkedTowerId().map(|x| x.to_string());
        let sortId = self.sortId();
        let name = self.name().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let subCardIds = self
            .subCardIds()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let runeData = self.runeData().map(|x| Box::new(x.unpack()));
        let trapIds = self
            .trapIds()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_ClimbTowerMainCardDataT {
            id,
            type_,
            linkedTowerId,
            sortId,
            name,
            desc,
            subCardIds,
            runeData,
            trapIds,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerMainCardData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ClimbTowerCardType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ClimbTowerCardType>(
                    clz_Torappu_ClimbTowerMainCardData::VT_TYPE_,
                    Some(enum__Torappu_ClimbTowerCardType::SEASON),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn linkedTowerId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerMainCardData::VT_LINKEDTOWERID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ClimbTowerMainCardData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerMainCardData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerMainCardData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn subCardIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ClimbTowerMainCardData::VT_SUBCARDIDS, None)
        }
    }
    #[inline]
    pub fn runeData(&self) -> Option<clz_Torappu_RuneTable_PackedRuneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneTable_PackedRuneData>>(
                    clz_Torappu_ClimbTowerMainCardData::VT_RUNEDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn trapIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ClimbTowerMainCardData::VT_TRAPIDS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ClimbTowerMainCardData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_ClimbTowerCardType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "linkedTowerId",
                Self::VT_LINKEDTOWERID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("subCardIds", Self::VT_SUBCARDIDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneTable_PackedRuneData>>(
                "runeData",
                Self::VT_RUNEDATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("trapIds", Self::VT_TRAPIDS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ClimbTowerMainCardDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_ClimbTowerCardType,
    pub linkedTowerId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub subCardIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub runeData: Option<flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'a>>>,
    pub trapIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_ClimbTowerMainCardDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ClimbTowerMainCardDataArgs {
            id: None,
            type_: enum__Torappu_ClimbTowerCardType::SEASON,
            linkedTowerId: None,
            sortId: 0,
            name: None,
            desc: None,
            subCardIds: None,
            runeData: None,
            trapIds: None,
        }
    }
}

impl Serialize for clz_Torappu_ClimbTowerMainCardData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ClimbTowerMainCardData", 9)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.linkedTowerId() {
            s.serialize_field("linkedTowerId", &f)?;
        } else {
            s.skip_field("linkedTowerId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.subCardIds() {
            s.serialize_field("subCardIds", &f)?;
        } else {
            s.skip_field("subCardIds")?;
        }
        if let Some(f) = self.runeData() {
            s.serialize_field("runeData", &f)?;
        } else {
            s.skip_field("runeData")?;
        }
        if let Some(f) = self.trapIds() {
            s.serialize_field("trapIds", &f)?;
        } else {
            s.skip_field("trapIds")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ClimbTowerMainCardDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ClimbTowerMainCardDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerMainCardData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ClimbTowerCardType) {
        self.fbb_.push_slot::<enum__Torappu_ClimbTowerCardType>(
            clz_Torappu_ClimbTowerMainCardData::VT_TYPE_,
            type_,
            enum__Torappu_ClimbTowerCardType::SEASON,
        );
    }
    #[inline]
    pub fn add_linkedTowerId(&mut self, linkedTowerId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerMainCardData::VT_LINKEDTOWERID,
            linkedTowerId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ClimbTowerMainCardData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerMainCardData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerMainCardData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_subCardIds(
        &mut self,
        subCardIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerMainCardData::VT_SUBCARDIDS,
            subCardIds,
        );
    }
    #[inline]
    pub fn add_runeData(
        &mut self,
        runeData: flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData>>(
                clz_Torappu_ClimbTowerMainCardData::VT_RUNEDATA,
                runeData,
            );
    }
    #[inline]
    pub fn add_trapIds(
        &mut self,
        trapIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerMainCardData::VT_TRAPIDS,
            trapIds,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ClimbTowerMainCardDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ClimbTowerMainCardDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerMainCardData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ClimbTowerMainCardData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ClimbTowerMainCardData");
        ds.field("id", &self.id());
        ds.field("type_", &self.type_());
        ds.field("linkedTowerId", &self.linkedTowerId());
        ds.field("sortId", &self.sortId());
        ds.field("name", &self.name());
        ds.field("desc", &self.desc());
        ds.field("subCardIds", &self.subCardIds());
        ds.field("runeData", &self.runeData());
        ds.field("trapIds", &self.trapIds());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ClimbTowerMainCardDataT {
    pub id: Option<String>,
    pub type_: enum__Torappu_ClimbTowerCardType,
    pub linkedTowerId: Option<String>,
    pub sortId: i32,
    pub name: Option<String>,
    pub desc: Option<String>,
    pub subCardIds: Option<Vec<String>>,
    pub runeData: Option<Box<clz_Torappu_RuneTable_PackedRuneDataT>>,
    pub trapIds: Option<Vec<String>>,
}
impl Default for clz_Torappu_ClimbTowerMainCardDataT {
    fn default() -> Self {
        Self {
            id: None,
            type_: enum__Torappu_ClimbTowerCardType::SEASON,
            linkedTowerId: None,
            sortId: 0,
            name: None,
            desc: None,
            subCardIds: None,
            runeData: None,
            trapIds: None,
        }
    }
}
impl clz_Torappu_ClimbTowerMainCardDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerMainCardData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let linkedTowerId = self.linkedTowerId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let subCardIds = self.subCardIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let runeData = self.runeData.as_ref().map(|x| x.pack(_fbb));
        let trapIds = self.trapIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ClimbTowerMainCardData::create(
            _fbb,
            &clz_Torappu_ClimbTowerMainCardDataArgs {
                id,
                type_,
                linkedTowerId,
                sortId,
                name,
                desc,
                subCardIds,
                runeData,
                trapIds,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ClimbTowerMainCardDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ClimbTowerMainCardData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ClimbTowerMainCardData<'a> {
    type Inner = dict__string__clz_Torappu_ClimbTowerMainCardData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ClimbTowerMainCardData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ClimbTowerMainCardData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ClimbTowerMainCardDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerMainCardData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ClimbTowerMainCardDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ClimbTowerMainCardDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ClimbTowerMainCardDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ClimbTowerMainCardData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ClimbTowerMainCardData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ClimbTowerMainCardData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerMainCardData>>(
                    dict__string__clz_Torappu_ClimbTowerMainCardData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ClimbTowerMainCardData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerMainCardData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ClimbTowerMainCardDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ClimbTowerMainCardData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ClimbTowerMainCardDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ClimbTowerMainCardDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ClimbTowerMainCardData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ClimbTowerMainCardData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ClimbTowerMainCardDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ClimbTowerMainCardDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ClimbTowerMainCardData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ClimbTowerMainCardData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ClimbTowerMainCardData>>(
                dict__string__clz_Torappu_ClimbTowerMainCardData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ClimbTowerMainCardDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ClimbTowerMainCardDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerMainCardData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ClimbTowerMainCardData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ClimbTowerMainCardData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ClimbTowerMainCardData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ClimbTowerMainCardDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ClimbTowerMainCardDataT>>,
}
impl Default for dict__string__clz_Torappu_ClimbTowerMainCardDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ClimbTowerMainCardDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerMainCardData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ClimbTowerMainCardData::create(
            _fbb,
            &dict__string__clz_Torappu_ClimbTowerMainCardDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ClimbTowerSubCardDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ClimbTowerSubCardData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ClimbTowerSubCardData<'a> {
    type Inner = clz_Torappu_ClimbTowerSubCardData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ClimbTowerSubCardData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_MAINCARDID: flatbuffers::VOffsetT = 6;
    pub const VT_SORTID: flatbuffers::VOffsetT = 8;
    pub const VT_NAME: flatbuffers::VOffsetT = 10;
    pub const VT_DESC: flatbuffers::VOffsetT = 12;
    pub const VT_RUNEDATA: flatbuffers::VOffsetT = 14;
    pub const VT_TRAPIDS: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ClimbTowerSubCardData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ClimbTowerSubCardDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSubCardData<'bldr>> {
        let mut builder = clz_Torappu_ClimbTowerSubCardDataBuilder::new(_fbb);
        if let Some(x) = args.trapIds {
            builder.add_trapIds(x);
        }
        if let Some(x) = args.runeData {
            builder.add_runeData(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.mainCardId {
            builder.add_mainCardId(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ClimbTowerSubCardDataT {
        let id = self.id().map(|x| x.to_string());
        let mainCardId = self.mainCardId().map(|x| x.to_string());
        let sortId = self.sortId();
        let name = self.name().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let runeData = self.runeData().map(|x| Box::new(x.unpack()));
        let trapIds = self
            .trapIds()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_ClimbTowerSubCardDataT {
            id,
            mainCardId,
            sortId,
            name,
            desc,
            runeData,
            trapIds,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSubCardData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn mainCardId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSubCardData::VT_MAINCARDID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ClimbTowerSubCardData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSubCardData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSubCardData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn runeData(&self) -> Option<clz_Torappu_RuneTable_PackedRuneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneTable_PackedRuneData>>(
                    clz_Torappu_ClimbTowerSubCardData::VT_RUNEDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn trapIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ClimbTowerSubCardData::VT_TRAPIDS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ClimbTowerSubCardData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "mainCardId",
                Self::VT_MAINCARDID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneTable_PackedRuneData>>(
                "runeData",
                Self::VT_RUNEDATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("trapIds", Self::VT_TRAPIDS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ClimbTowerSubCardDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mainCardId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub runeData: Option<flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'a>>>,
    pub trapIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_ClimbTowerSubCardDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ClimbTowerSubCardDataArgs {
            id: None,
            mainCardId: None,
            sortId: 0,
            name: None,
            desc: None,
            runeData: None,
            trapIds: None,
        }
    }
}

impl Serialize for clz_Torappu_ClimbTowerSubCardData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ClimbTowerSubCardData", 7)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.mainCardId() {
            s.serialize_field("mainCardId", &f)?;
        } else {
            s.skip_field("mainCardId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.runeData() {
            s.serialize_field("runeData", &f)?;
        } else {
            s.skip_field("runeData")?;
        }
        if let Some(f) = self.trapIds() {
            s.serialize_field("trapIds", &f)?;
        } else {
            s.skip_field("trapIds")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ClimbTowerSubCardDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ClimbTowerSubCardDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSubCardData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_mainCardId(&mut self, mainCardId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSubCardData::VT_MAINCARDID,
            mainCardId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ClimbTowerSubCardData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSubCardData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSubCardData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_runeData(
        &mut self,
        runeData: flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData>>(
                clz_Torappu_ClimbTowerSubCardData::VT_RUNEDATA,
                runeData,
            );
    }
    #[inline]
    pub fn add_trapIds(
        &mut self,
        trapIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSubCardData::VT_TRAPIDS,
            trapIds,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ClimbTowerSubCardDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ClimbTowerSubCardDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSubCardData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ClimbTowerSubCardData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ClimbTowerSubCardData");
        ds.field("id", &self.id());
        ds.field("mainCardId", &self.mainCardId());
        ds.field("sortId", &self.sortId());
        ds.field("name", &self.name());
        ds.field("desc", &self.desc());
        ds.field("runeData", &self.runeData());
        ds.field("trapIds", &self.trapIds());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ClimbTowerSubCardDataT {
    pub id: Option<String>,
    pub mainCardId: Option<String>,
    pub sortId: i32,
    pub name: Option<String>,
    pub desc: Option<String>,
    pub runeData: Option<Box<clz_Torappu_RuneTable_PackedRuneDataT>>,
    pub trapIds: Option<Vec<String>>,
}
impl Default for clz_Torappu_ClimbTowerSubCardDataT {
    fn default() -> Self {
        Self {
            id: None,
            mainCardId: None,
            sortId: 0,
            name: None,
            desc: None,
            runeData: None,
            trapIds: None,
        }
    }
}
impl clz_Torappu_ClimbTowerSubCardDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSubCardData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let mainCardId = self.mainCardId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let runeData = self.runeData.as_ref().map(|x| x.pack(_fbb));
        let trapIds = self.trapIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ClimbTowerSubCardData::create(
            _fbb,
            &clz_Torappu_ClimbTowerSubCardDataArgs {
                id,
                mainCardId,
                sortId,
                name,
                desc,
                runeData,
                trapIds,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ClimbTowerSubCardDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ClimbTowerSubCardData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ClimbTowerSubCardData<'a> {
    type Inner = dict__string__clz_Torappu_ClimbTowerSubCardData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ClimbTowerSubCardData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ClimbTowerSubCardData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ClimbTowerSubCardDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerSubCardData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ClimbTowerSubCardDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ClimbTowerSubCardDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ClimbTowerSubCardDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ClimbTowerSubCardData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ClimbTowerSubCardData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ClimbTowerSubCardData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerSubCardData>>(
                    dict__string__clz_Torappu_ClimbTowerSubCardData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ClimbTowerSubCardData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerSubCardData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ClimbTowerSubCardDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSubCardData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ClimbTowerSubCardDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ClimbTowerSubCardDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ClimbTowerSubCardData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ClimbTowerSubCardData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ClimbTowerSubCardDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ClimbTowerSubCardDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ClimbTowerSubCardData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSubCardData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSubCardData>>(
                dict__string__clz_Torappu_ClimbTowerSubCardData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ClimbTowerSubCardDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ClimbTowerSubCardDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerSubCardData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ClimbTowerSubCardData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ClimbTowerSubCardData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ClimbTowerSubCardData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ClimbTowerSubCardDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ClimbTowerSubCardDataT>>,
}
impl Default for dict__string__clz_Torappu_ClimbTowerSubCardDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ClimbTowerSubCardDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerSubCardData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ClimbTowerSubCardData::create(
            _fbb,
            &dict__string__clz_Torappu_ClimbTowerSubCardDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ClimbTowerCurseCardDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ClimbTowerCurseCardData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ClimbTowerCurseCardData<'a> {
    type Inner = clz_Torappu_ClimbTowerCurseCardData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ClimbTowerCurseCardData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TOWERIDLIST: flatbuffers::VOffsetT = 6;
    pub const VT_NAME: flatbuffers::VOffsetT = 8;
    pub const VT_DESC: flatbuffers::VOffsetT = 10;
    pub const VT_TRAPID: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ClimbTowerCurseCardData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ClimbTowerCurseCardDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerCurseCardData<'bldr>> {
        let mut builder = clz_Torappu_ClimbTowerCurseCardDataBuilder::new(_fbb);
        if let Some(x) = args.trapId {
            builder.add_trapId(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.towerIdList {
            builder.add_towerIdList(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ClimbTowerCurseCardDataT {
        let id = self.id().map(|x| x.to_string());
        let towerIdList = self
            .towerIdList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let name = self.name().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let trapId = self.trapId().map(|x| x.to_string());
        clz_Torappu_ClimbTowerCurseCardDataT {
            id,
            towerIdList,
            name,
            desc,
            trapId,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerCurseCardData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn towerIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ClimbTowerCurseCardData::VT_TOWERIDLIST, None)
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerCurseCardData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerCurseCardData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn trapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerCurseCardData::VT_TRAPID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ClimbTowerCurseCardData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("towerIdList", Self::VT_TOWERIDLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("trapId", Self::VT_TRAPID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ClimbTowerCurseCardDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub towerIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trapId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ClimbTowerCurseCardDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ClimbTowerCurseCardDataArgs {
            id: None,
            towerIdList: None,
            name: None,
            desc: None,
            trapId: None,
        }
    }
}

impl Serialize for clz_Torappu_ClimbTowerCurseCardData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ClimbTowerCurseCardData", 5)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.towerIdList() {
            s.serialize_field("towerIdList", &f)?;
        } else {
            s.skip_field("towerIdList")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.trapId() {
            s.serialize_field("trapId", &f)?;
        } else {
            s.skip_field("trapId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ClimbTowerCurseCardDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ClimbTowerCurseCardDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerCurseCardData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_towerIdList(
        &mut self,
        towerIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerCurseCardData::VT_TOWERIDLIST,
            towerIdList,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerCurseCardData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerCurseCardData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_trapId(&mut self, trapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerCurseCardData::VT_TRAPID,
            trapId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ClimbTowerCurseCardDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ClimbTowerCurseCardDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerCurseCardData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ClimbTowerCurseCardData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ClimbTowerCurseCardData");
        ds.field("id", &self.id());
        ds.field("towerIdList", &self.towerIdList());
        ds.field("name", &self.name());
        ds.field("desc", &self.desc());
        ds.field("trapId", &self.trapId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ClimbTowerCurseCardDataT {
    pub id: Option<String>,
    pub towerIdList: Option<Vec<String>>,
    pub name: Option<String>,
    pub desc: Option<String>,
    pub trapId: Option<String>,
}
impl Default for clz_Torappu_ClimbTowerCurseCardDataT {
    fn default() -> Self {
        Self {
            id: None,
            towerIdList: None,
            name: None,
            desc: None,
            trapId: None,
        }
    }
}
impl clz_Torappu_ClimbTowerCurseCardDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerCurseCardData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let towerIdList = self.towerIdList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let trapId = self.trapId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_ClimbTowerCurseCardData::create(
            _fbb,
            &clz_Torappu_ClimbTowerCurseCardDataArgs {
                id,
                towerIdList,
                name,
                desc,
                trapId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ClimbTowerCurseCardDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ClimbTowerCurseCardData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ClimbTowerCurseCardData<'a> {
    type Inner = dict__string__clz_Torappu_ClimbTowerCurseCardData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ClimbTowerCurseCardData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ClimbTowerCurseCardData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ClimbTowerCurseCardDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerCurseCardData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ClimbTowerCurseCardDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ClimbTowerCurseCardDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ClimbTowerCurseCardDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ClimbTowerCurseCardData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ClimbTowerCurseCardData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ClimbTowerCurseCardData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerCurseCardData>>(
                    dict__string__clz_Torappu_ClimbTowerCurseCardData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ClimbTowerCurseCardData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerCurseCardData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ClimbTowerCurseCardDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ClimbTowerCurseCardData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ClimbTowerCurseCardDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ClimbTowerCurseCardDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ClimbTowerCurseCardData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ClimbTowerCurseCardData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ClimbTowerCurseCardDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ClimbTowerCurseCardDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ClimbTowerCurseCardData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ClimbTowerCurseCardData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ClimbTowerCurseCardData>>(
                dict__string__clz_Torappu_ClimbTowerCurseCardData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ClimbTowerCurseCardDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ClimbTowerCurseCardDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerCurseCardData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ClimbTowerCurseCardData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ClimbTowerCurseCardData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ClimbTowerCurseCardData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ClimbTowerCurseCardDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ClimbTowerCurseCardDataT>>,
}
impl Default for dict__string__clz_Torappu_ClimbTowerCurseCardDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ClimbTowerCurseCardDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerCurseCardData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ClimbTowerCurseCardData::create(
            _fbb,
            &dict__string__clz_Torappu_ClimbTowerCurseCardDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ClimbTowerSeasonInfoDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ClimbTowerSeasonInfoData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ClimbTowerSeasonInfoData<'a> {
    type Inner = clz_Torappu_ClimbTowerSeasonInfoData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ClimbTowerSeasonInfoData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_SEASONNUM: flatbuffers::VOffsetT = 8;
    pub const VT_STARTTS: flatbuffers::VOffsetT = 10;
    pub const VT_ENDTS: flatbuffers::VOffsetT = 12;
    pub const VT_TOWERS: flatbuffers::VOffsetT = 14;
    pub const VT_SEASONCARDS: flatbuffers::VOffsetT = 16;
    pub const VT_REPLICATEDTOWERS: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ClimbTowerSeasonInfoData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ClimbTowerSeasonInfoDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSeasonInfoData<'bldr>> {
        let mut builder = clz_Torappu_ClimbTowerSeasonInfoDataBuilder::new(_fbb);
        builder.add_endTs(args.endTs);
        builder.add_startTs(args.startTs);
        if let Some(x) = args.replicatedTowers {
            builder.add_replicatedTowers(x);
        }
        if let Some(x) = args.seasonCards {
            builder.add_seasonCards(x);
        }
        if let Some(x) = args.towers {
            builder.add_towers(x);
        }
        builder.add_seasonNum(args.seasonNum);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ClimbTowerSeasonInfoDataT {
        let id = self.id().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let seasonNum = self.seasonNum();
        let startTs = self.startTs();
        let endTs = self.endTs();
        let towers = self
            .towers()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let seasonCards = self
            .seasonCards()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let replicatedTowers = self
            .replicatedTowers()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_ClimbTowerSeasonInfoDataT {
            id,
            name,
            seasonNum,
            startTs,
            endTs,
            towers,
            seasonCards,
            replicatedTowers,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSeasonInfoData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerSeasonInfoData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn seasonNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ClimbTowerSeasonInfoData::VT_SEASONNUM, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn startTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_ClimbTowerSeasonInfoData::VT_STARTTS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_ClimbTowerSeasonInfoData::VT_ENDTS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn towers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ClimbTowerSeasonInfoData::VT_TOWERS, None)
        }
    }
    #[inline]
    pub fn seasonCards(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ClimbTowerSeasonInfoData::VT_SEASONCARDS, None)
        }
    }
    #[inline]
    pub fn replicatedTowers(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_ClimbTowerSeasonInfoData::VT_REPLICATEDTOWERS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ClimbTowerSeasonInfoData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<i32>("seasonNum", Self::VT_SEASONNUM, false)?
            .visit_field::<i64>("startTs", Self::VT_STARTTS, false)?
            .visit_field::<i64>("endTs", Self::VT_ENDTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("towers", Self::VT_TOWERS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("seasonCards", Self::VT_SEASONCARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("replicatedTowers", Self::VT_REPLICATEDTOWERS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ClimbTowerSeasonInfoDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub seasonNum: i32,
    pub startTs: i64,
    pub endTs: i64,
    pub towers: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub seasonCards: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub replicatedTowers: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_ClimbTowerSeasonInfoDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ClimbTowerSeasonInfoDataArgs {
            id: None,
            name: None,
            seasonNum: 0,
            startTs: 0,
            endTs: 0,
            towers: None,
            seasonCards: None,
            replicatedTowers: None,
        }
    }
}

impl Serialize for clz_Torappu_ClimbTowerSeasonInfoData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ClimbTowerSeasonInfoData", 8)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        s.serialize_field("seasonNum", &self.seasonNum())?;
        s.serialize_field("startTs", &self.startTs())?;
        s.serialize_field("endTs", &self.endTs())?;
        if let Some(f) = self.towers() {
            s.serialize_field("towers", &f)?;
        } else {
            s.skip_field("towers")?;
        }
        if let Some(f) = self.seasonCards() {
            s.serialize_field("seasonCards", &f)?;
        } else {
            s.skip_field("seasonCards")?;
        }
        if let Some(f) = self.replicatedTowers() {
            s.serialize_field("replicatedTowers", &f)?;
        } else {
            s.skip_field("replicatedTowers")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ClimbTowerSeasonInfoDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ClimbTowerSeasonInfoDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSeasonInfoData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSeasonInfoData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_seasonNum(&mut self, seasonNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ClimbTowerSeasonInfoData::VT_SEASONNUM,
            seasonNum,
            0,
        );
    }
    #[inline]
    pub fn add_startTs(&mut self, startTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_ClimbTowerSeasonInfoData::VT_STARTTS, startTs, 0);
    }
    #[inline]
    pub fn add_endTs(&mut self, endTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_ClimbTowerSeasonInfoData::VT_ENDTS, endTs, 0);
    }
    #[inline]
    pub fn add_towers(
        &mut self,
        towers: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSeasonInfoData::VT_TOWERS,
            towers,
        );
    }
    #[inline]
    pub fn add_seasonCards(
        &mut self,
        seasonCards: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSeasonInfoData::VT_SEASONCARDS,
            seasonCards,
        );
    }
    #[inline]
    pub fn add_replicatedTowers(
        &mut self,
        replicatedTowers: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerSeasonInfoData::VT_REPLICATEDTOWERS,
            replicatedTowers,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ClimbTowerSeasonInfoDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ClimbTowerSeasonInfoDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSeasonInfoData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ClimbTowerSeasonInfoData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ClimbTowerSeasonInfoData");
        ds.field("id", &self.id());
        ds.field("name", &self.name());
        ds.field("seasonNum", &self.seasonNum());
        ds.field("startTs", &self.startTs());
        ds.field("endTs", &self.endTs());
        ds.field("towers", &self.towers());
        ds.field("seasonCards", &self.seasonCards());
        ds.field("replicatedTowers", &self.replicatedTowers());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ClimbTowerSeasonInfoDataT {
    pub id: Option<String>,
    pub name: Option<String>,
    pub seasonNum: i32,
    pub startTs: i64,
    pub endTs: i64,
    pub towers: Option<Vec<String>>,
    pub seasonCards: Option<Vec<String>>,
    pub replicatedTowers: Option<Vec<String>>,
}
impl Default for clz_Torappu_ClimbTowerSeasonInfoDataT {
    fn default() -> Self {
        Self {
            id: None,
            name: None,
            seasonNum: 0,
            startTs: 0,
            endTs: 0,
            towers: None,
            seasonCards: None,
            replicatedTowers: None,
        }
    }
}
impl clz_Torappu_ClimbTowerSeasonInfoDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSeasonInfoData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let seasonNum = self.seasonNum;
        let startTs = self.startTs;
        let endTs = self.endTs;
        let towers = self.towers.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let seasonCards = self.seasonCards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let replicatedTowers = self.replicatedTowers.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ClimbTowerSeasonInfoData::create(
            _fbb,
            &clz_Torappu_ClimbTowerSeasonInfoDataArgs {
                id,
                name,
                seasonNum,
                startTs,
                endTs,
                towers,
                seasonCards,
                replicatedTowers,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ClimbTowerSeasonInfoDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ClimbTowerSeasonInfoData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ClimbTowerSeasonInfoData<'a> {
    type Inner = dict__string__clz_Torappu_ClimbTowerSeasonInfoData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ClimbTowerSeasonInfoData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ClimbTowerSeasonInfoData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ClimbTowerSeasonInfoDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerSeasonInfoData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ClimbTowerSeasonInfoDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ClimbTowerSeasonInfoDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ClimbTowerSeasonInfoDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ClimbTowerSeasonInfoData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ClimbTowerSeasonInfoData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ClimbTowerSeasonInfoData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerSeasonInfoData>>(
                    dict__string__clz_Torappu_ClimbTowerSeasonInfoData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ClimbTowerSeasonInfoData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerSeasonInfoData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ClimbTowerSeasonInfoDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSeasonInfoData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ClimbTowerSeasonInfoDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ClimbTowerSeasonInfoDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ClimbTowerSeasonInfoData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ClimbTowerSeasonInfoData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ClimbTowerSeasonInfoDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ClimbTowerSeasonInfoDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ClimbTowerSeasonInfoData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSeasonInfoData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ClimbTowerSeasonInfoData>>(
                dict__string__clz_Torappu_ClimbTowerSeasonInfoData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ClimbTowerSeasonInfoDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ClimbTowerSeasonInfoDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerSeasonInfoData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ClimbTowerSeasonInfoData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ClimbTowerSeasonInfoData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ClimbTowerSeasonInfoData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ClimbTowerSeasonInfoDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ClimbTowerSeasonInfoDataT>>,
}
impl Default for dict__string__clz_Torappu_ClimbTowerSeasonInfoDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ClimbTowerSeasonInfoDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerSeasonInfoData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ClimbTowerSeasonInfoData::create(
            _fbb,
            &dict__string__clz_Torappu_ClimbTowerSeasonInfoDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ClimbTowerDetailConstOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ClimbTowerDetailConst<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ClimbTowerDetailConst<'a> {
    type Inner = clz_Torappu_ClimbTowerDetailConst<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ClimbTowerDetailConst<'a> {
    pub const VT_UNLOCKLEVELID: flatbuffers::VOffsetT = 4;
    pub const VT_UNLOCKMODULENUMREQUIREMENT: flatbuffers::VOffsetT = 6;
    pub const VT_LOWERITEMID: flatbuffers::VOffsetT = 8;
    pub const VT_LOWERITEMLIMIT: flatbuffers::VOffsetT = 10;
    pub const VT_HIGHERITEMID: flatbuffers::VOffsetT = 12;
    pub const VT_HIGHERITEMLIMIT: flatbuffers::VOffsetT = 14;
    pub const VT_INITCHARCOUNT: flatbuffers::VOffsetT = 16;
    pub const VT_CHARRECRUITTIMES: flatbuffers::VOffsetT = 18;
    pub const VT_CHARRECRUITCHOICECOUNT: flatbuffers::VOffsetT = 20;
    pub const VT_SUBCARDSTAGESORT: flatbuffers::VOffsetT = 22;
    pub const VT_ASSISTCHARLIMIT: flatbuffers::VOffsetT = 24;
    pub const VT_FIRSTCLEARTASKDESC: flatbuffers::VOffsetT = 26;
    pub const VT_SUBCARDOBTAINDESC: flatbuffers::VOffsetT = 28;
    pub const VT_SUBGODCARDUNLOCKDESC: flatbuffers::VOffsetT = 30;
    pub const VT_SWEEPSTARTTIME: flatbuffers::VOffsetT = 32;
    pub const VT_SWEEPOPENORDINARYLAYER: flatbuffers::VOffsetT = 34;
    pub const VT_SWEEPOPENDIFFICULTLAYER: flatbuffers::VOffsetT = 36;
    pub const VT_SWEEPCOSTCOUNT: flatbuffers::VOffsetT = 38;
    pub const VT_SQUADMEMSTARTTIME: flatbuffers::VOffsetT = 40;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ClimbTowerDetailConst { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ClimbTowerDetailConstArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerDetailConst<'bldr>> {
        let mut builder = clz_Torappu_ClimbTowerDetailConstBuilder::new(_fbb);
        builder.add_squadMemStartTime(args.squadMemStartTime);
        builder.add_sweepStartTime(args.sweepStartTime);
        builder.add_sweepCostCount(args.sweepCostCount);
        builder.add_sweepOpenDifficultLayer(args.sweepOpenDifficultLayer);
        builder.add_sweepOpenOrdinaryLayer(args.sweepOpenOrdinaryLayer);
        if let Some(x) = args.subGodCardUnlockDesc {
            builder.add_subGodCardUnlockDesc(x);
        }
        if let Some(x) = args.subCardObtainDesc {
            builder.add_subCardObtainDesc(x);
        }
        if let Some(x) = args.firstClearTaskDesc {
            builder.add_firstClearTaskDesc(x);
        }
        builder.add_assistCharLimit(args.assistCharLimit);
        builder.add_subcardStageSort(args.subcardStageSort);
        builder.add_charRecruitChoiceCount(args.charRecruitChoiceCount);
        builder.add_charRecruitTimes(args.charRecruitTimes);
        builder.add_initCharCount(args.initCharCount);
        builder.add_higherItemLimit(args.higherItemLimit);
        if let Some(x) = args.higherItemId {
            builder.add_higherItemId(x);
        }
        builder.add_lowerItemLimit(args.lowerItemLimit);
        if let Some(x) = args.lowerItemId {
            builder.add_lowerItemId(x);
        }
        builder.add_unlockModuleNumRequirement(args.unlockModuleNumRequirement);
        if let Some(x) = args.unlockLevelId {
            builder.add_unlockLevelId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ClimbTowerDetailConstT {
        let unlockLevelId = self.unlockLevelId().map(|x| x.to_string());
        let unlockModuleNumRequirement = self.unlockModuleNumRequirement();
        let lowerItemId = self.lowerItemId().map(|x| x.to_string());
        let lowerItemLimit = self.lowerItemLimit();
        let higherItemId = self.higherItemId().map(|x| x.to_string());
        let higherItemLimit = self.higherItemLimit();
        let initCharCount = self.initCharCount();
        let charRecruitTimes = self.charRecruitTimes();
        let charRecruitChoiceCount = self.charRecruitChoiceCount();
        let subcardStageSort = self.subcardStageSort();
        let assistCharLimit = self.assistCharLimit();
        let firstClearTaskDesc = self.firstClearTaskDesc().map(|x| x.to_string());
        let subCardObtainDesc = self.subCardObtainDesc().map(|x| x.to_string());
        let subGodCardUnlockDesc = self.subGodCardUnlockDesc().map(|x| x.to_string());
        let sweepStartTime = self.sweepStartTime();
        let sweepOpenOrdinaryLayer = self.sweepOpenOrdinaryLayer();
        let sweepOpenDifficultLayer = self.sweepOpenDifficultLayer();
        let sweepCostCount = self.sweepCostCount();
        let squadMemStartTime = self.squadMemStartTime();
        clz_Torappu_ClimbTowerDetailConstT {
            unlockLevelId,
            unlockModuleNumRequirement,
            lowerItemId,
            lowerItemLimit,
            higherItemId,
            higherItemLimit,
            initCharCount,
            charRecruitTimes,
            charRecruitChoiceCount,
            subcardStageSort,
            assistCharLimit,
            firstClearTaskDesc,
            subCardObtainDesc,
            subGodCardUnlockDesc,
            sweepStartTime,
            sweepOpenOrdinaryLayer,
            sweepOpenDifficultLayer,
            sweepCostCount,
            squadMemStartTime,
        }
    }

    #[inline]
    pub fn unlockLevelId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerDetailConst::VT_UNLOCKLEVELID,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockModuleNumRequirement(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ClimbTowerDetailConst::VT_UNLOCKMODULENUMREQUIREMENT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn lowerItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerDetailConst::VT_LOWERITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn lowerItemLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ClimbTowerDetailConst::VT_LOWERITEMLIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn higherItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerDetailConst::VT_HIGHERITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn higherItemLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ClimbTowerDetailConst::VT_HIGHERITEMLIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn initCharCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ClimbTowerDetailConst::VT_INITCHARCOUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn charRecruitTimes(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ClimbTowerDetailConst::VT_CHARRECRUITTIMES,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn charRecruitChoiceCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ClimbTowerDetailConst::VT_CHARRECRUITCHOICECOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn subcardStageSort(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ClimbTowerDetailConst::VT_SUBCARDSTAGESORT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn assistCharLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ClimbTowerDetailConst::VT_ASSISTCHARLIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn firstClearTaskDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerDetailConst::VT_FIRSTCLEARTASKDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn subCardObtainDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerDetailConst::VT_SUBCARDOBTAINDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn subGodCardUnlockDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerDetailConst::VT_SUBGODCARDUNLOCKDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn sweepStartTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_ClimbTowerDetailConst::VT_SWEEPSTARTTIME,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sweepOpenOrdinaryLayer(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ClimbTowerDetailConst::VT_SWEEPOPENORDINARYLAYER,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sweepOpenDifficultLayer(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ClimbTowerDetailConst::VT_SWEEPOPENDIFFICULTLAYER,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sweepCostCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ClimbTowerDetailConst::VT_SWEEPCOSTCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn squadMemStartTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_ClimbTowerDetailConst::VT_SQUADMEMSTARTTIME,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ClimbTowerDetailConst<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockLevelId",
                Self::VT_UNLOCKLEVELID,
                false,
            )?
            .visit_field::<i32>(
                "unlockModuleNumRequirement",
                Self::VT_UNLOCKMODULENUMREQUIREMENT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "lowerItemId",
                Self::VT_LOWERITEMID,
                false,
            )?
            .visit_field::<i32>("lowerItemLimit", Self::VT_LOWERITEMLIMIT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "higherItemId",
                Self::VT_HIGHERITEMID,
                false,
            )?
            .visit_field::<i32>("higherItemLimit", Self::VT_HIGHERITEMLIMIT, false)?
            .visit_field::<i32>("initCharCount", Self::VT_INITCHARCOUNT, false)?
            .visit_field::<i32>("charRecruitTimes", Self::VT_CHARRECRUITTIMES, false)?
            .visit_field::<i32>(
                "charRecruitChoiceCount",
                Self::VT_CHARRECRUITCHOICECOUNT,
                false,
            )?
            .visit_field::<i32>("subcardStageSort", Self::VT_SUBCARDSTAGESORT, false)?
            .visit_field::<i32>("assistCharLimit", Self::VT_ASSISTCHARLIMIT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "firstClearTaskDesc",
                Self::VT_FIRSTCLEARTASKDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "subCardObtainDesc",
                Self::VT_SUBCARDOBTAINDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "subGodCardUnlockDesc",
                Self::VT_SUBGODCARDUNLOCKDESC,
                false,
            )?
            .visit_field::<i64>("sweepStartTime", Self::VT_SWEEPSTARTTIME, false)?
            .visit_field::<i32>(
                "sweepOpenOrdinaryLayer",
                Self::VT_SWEEPOPENORDINARYLAYER,
                false,
            )?
            .visit_field::<i32>(
                "sweepOpenDifficultLayer",
                Self::VT_SWEEPOPENDIFFICULTLAYER,
                false,
            )?
            .visit_field::<i32>("sweepCostCount", Self::VT_SWEEPCOSTCOUNT, false)?
            .visit_field::<i64>("squadMemStartTime", Self::VT_SQUADMEMSTARTTIME, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ClimbTowerDetailConstArgs<'a> {
    pub unlockLevelId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockModuleNumRequirement: i32,
    pub lowerItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lowerItemLimit: i32,
    pub higherItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub higherItemLimit: i32,
    pub initCharCount: i32,
    pub charRecruitTimes: i32,
    pub charRecruitChoiceCount: i32,
    pub subcardStageSort: i32,
    pub assistCharLimit: i32,
    pub firstClearTaskDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub subCardObtainDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub subGodCardUnlockDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sweepStartTime: i64,
    pub sweepOpenOrdinaryLayer: i32,
    pub sweepOpenDifficultLayer: i32,
    pub sweepCostCount: i32,
    pub squadMemStartTime: i64,
}
impl<'a> Default for clz_Torappu_ClimbTowerDetailConstArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ClimbTowerDetailConstArgs {
            unlockLevelId: None,
            unlockModuleNumRequirement: 0,
            lowerItemId: None,
            lowerItemLimit: 0,
            higherItemId: None,
            higherItemLimit: 0,
            initCharCount: 0,
            charRecruitTimes: 0,
            charRecruitChoiceCount: 0,
            subcardStageSort: 0,
            assistCharLimit: 0,
            firstClearTaskDesc: None,
            subCardObtainDesc: None,
            subGodCardUnlockDesc: None,
            sweepStartTime: 0,
            sweepOpenOrdinaryLayer: 0,
            sweepOpenDifficultLayer: 0,
            sweepCostCount: 0,
            squadMemStartTime: 0,
        }
    }
}

impl Serialize for clz_Torappu_ClimbTowerDetailConst<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ClimbTowerDetailConst", 19)?;
        if let Some(f) = self.unlockLevelId() {
            s.serialize_field("unlockLevelId", &f)?;
        } else {
            s.skip_field("unlockLevelId")?;
        }
        s.serialize_field(
            "unlockModuleNumRequirement",
            &self.unlockModuleNumRequirement(),
        )?;
        if let Some(f) = self.lowerItemId() {
            s.serialize_field("lowerItemId", &f)?;
        } else {
            s.skip_field("lowerItemId")?;
        }
        s.serialize_field("lowerItemLimit", &self.lowerItemLimit())?;
        if let Some(f) = self.higherItemId() {
            s.serialize_field("higherItemId", &f)?;
        } else {
            s.skip_field("higherItemId")?;
        }
        s.serialize_field("higherItemLimit", &self.higherItemLimit())?;
        s.serialize_field("initCharCount", &self.initCharCount())?;
        s.serialize_field("charRecruitTimes", &self.charRecruitTimes())?;
        s.serialize_field("charRecruitChoiceCount", &self.charRecruitChoiceCount())?;
        s.serialize_field("subcardStageSort", &self.subcardStageSort())?;
        s.serialize_field("assistCharLimit", &self.assistCharLimit())?;
        if let Some(f) = self.firstClearTaskDesc() {
            s.serialize_field("firstClearTaskDesc", &f)?;
        } else {
            s.skip_field("firstClearTaskDesc")?;
        }
        if let Some(f) = self.subCardObtainDesc() {
            s.serialize_field("subCardObtainDesc", &f)?;
        } else {
            s.skip_field("subCardObtainDesc")?;
        }
        if let Some(f) = self.subGodCardUnlockDesc() {
            s.serialize_field("subGodCardUnlockDesc", &f)?;
        } else {
            s.skip_field("subGodCardUnlockDesc")?;
        }
        s.serialize_field("sweepStartTime", &self.sweepStartTime())?;
        s.serialize_field("sweepOpenOrdinaryLayer", &self.sweepOpenOrdinaryLayer())?;
        s.serialize_field("sweepOpenDifficultLayer", &self.sweepOpenDifficultLayer())?;
        s.serialize_field("sweepCostCount", &self.sweepCostCount())?;
        s.serialize_field("squadMemStartTime", &self.squadMemStartTime())?;
        s.end()
    }
}

pub struct clz_Torappu_ClimbTowerDetailConstBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ClimbTowerDetailConstBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_unlockLevelId(&mut self, unlockLevelId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerDetailConst::VT_UNLOCKLEVELID,
            unlockLevelId,
        );
    }
    #[inline]
    pub fn add_unlockModuleNumRequirement(&mut self, unlockModuleNumRequirement: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ClimbTowerDetailConst::VT_UNLOCKMODULENUMREQUIREMENT,
            unlockModuleNumRequirement,
            0,
        );
    }
    #[inline]
    pub fn add_lowerItemId(&mut self, lowerItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerDetailConst::VT_LOWERITEMID,
            lowerItemId,
        );
    }
    #[inline]
    pub fn add_lowerItemLimit(&mut self, lowerItemLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ClimbTowerDetailConst::VT_LOWERITEMLIMIT,
            lowerItemLimit,
            0,
        );
    }
    #[inline]
    pub fn add_higherItemId(&mut self, higherItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerDetailConst::VT_HIGHERITEMID,
            higherItemId,
        );
    }
    #[inline]
    pub fn add_higherItemLimit(&mut self, higherItemLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ClimbTowerDetailConst::VT_HIGHERITEMLIMIT,
            higherItemLimit,
            0,
        );
    }
    #[inline]
    pub fn add_initCharCount(&mut self, initCharCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ClimbTowerDetailConst::VT_INITCHARCOUNT,
            initCharCount,
            0,
        );
    }
    #[inline]
    pub fn add_charRecruitTimes(&mut self, charRecruitTimes: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ClimbTowerDetailConst::VT_CHARRECRUITTIMES,
            charRecruitTimes,
            0,
        );
    }
    #[inline]
    pub fn add_charRecruitChoiceCount(&mut self, charRecruitChoiceCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ClimbTowerDetailConst::VT_CHARRECRUITCHOICECOUNT,
            charRecruitChoiceCount,
            0,
        );
    }
    #[inline]
    pub fn add_subcardStageSort(&mut self, subcardStageSort: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ClimbTowerDetailConst::VT_SUBCARDSTAGESORT,
            subcardStageSort,
            0,
        );
    }
    #[inline]
    pub fn add_assistCharLimit(&mut self, assistCharLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ClimbTowerDetailConst::VT_ASSISTCHARLIMIT,
            assistCharLimit,
            0,
        );
    }
    #[inline]
    pub fn add_firstClearTaskDesc(&mut self, firstClearTaskDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerDetailConst::VT_FIRSTCLEARTASKDESC,
            firstClearTaskDesc,
        );
    }
    #[inline]
    pub fn add_subCardObtainDesc(&mut self, subCardObtainDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerDetailConst::VT_SUBCARDOBTAINDESC,
            subCardObtainDesc,
        );
    }
    #[inline]
    pub fn add_subGodCardUnlockDesc(
        &mut self,
        subGodCardUnlockDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerDetailConst::VT_SUBGODCARDUNLOCKDESC,
            subGodCardUnlockDesc,
        );
    }
    #[inline]
    pub fn add_sweepStartTime(&mut self, sweepStartTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_ClimbTowerDetailConst::VT_SWEEPSTARTTIME,
            sweepStartTime,
            0,
        );
    }
    #[inline]
    pub fn add_sweepOpenOrdinaryLayer(&mut self, sweepOpenOrdinaryLayer: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ClimbTowerDetailConst::VT_SWEEPOPENORDINARYLAYER,
            sweepOpenOrdinaryLayer,
            0,
        );
    }
    #[inline]
    pub fn add_sweepOpenDifficultLayer(&mut self, sweepOpenDifficultLayer: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ClimbTowerDetailConst::VT_SWEEPOPENDIFFICULTLAYER,
            sweepOpenDifficultLayer,
            0,
        );
    }
    #[inline]
    pub fn add_sweepCostCount(&mut self, sweepCostCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ClimbTowerDetailConst::VT_SWEEPCOSTCOUNT,
            sweepCostCount,
            0,
        );
    }
    #[inline]
    pub fn add_squadMemStartTime(&mut self, squadMemStartTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_ClimbTowerDetailConst::VT_SQUADMEMSTARTTIME,
            squadMemStartTime,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ClimbTowerDetailConstBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ClimbTowerDetailConstBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerDetailConst<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ClimbTowerDetailConst<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ClimbTowerDetailConst");
        ds.field("unlockLevelId", &self.unlockLevelId());
        ds.field(
            "unlockModuleNumRequirement",
            &self.unlockModuleNumRequirement(),
        );
        ds.field("lowerItemId", &self.lowerItemId());
        ds.field("lowerItemLimit", &self.lowerItemLimit());
        ds.field("higherItemId", &self.higherItemId());
        ds.field("higherItemLimit", &self.higherItemLimit());
        ds.field("initCharCount", &self.initCharCount());
        ds.field("charRecruitTimes", &self.charRecruitTimes());
        ds.field("charRecruitChoiceCount", &self.charRecruitChoiceCount());
        ds.field("subcardStageSort", &self.subcardStageSort());
        ds.field("assistCharLimit", &self.assistCharLimit());
        ds.field("firstClearTaskDesc", &self.firstClearTaskDesc());
        ds.field("subCardObtainDesc", &self.subCardObtainDesc());
        ds.field("subGodCardUnlockDesc", &self.subGodCardUnlockDesc());
        ds.field("sweepStartTime", &self.sweepStartTime());
        ds.field("sweepOpenOrdinaryLayer", &self.sweepOpenOrdinaryLayer());
        ds.field("sweepOpenDifficultLayer", &self.sweepOpenDifficultLayer());
        ds.field("sweepCostCount", &self.sweepCostCount());
        ds.field("squadMemStartTime", &self.squadMemStartTime());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ClimbTowerDetailConstT {
    pub unlockLevelId: Option<String>,
    pub unlockModuleNumRequirement: i32,
    pub lowerItemId: Option<String>,
    pub lowerItemLimit: i32,
    pub higherItemId: Option<String>,
    pub higherItemLimit: i32,
    pub initCharCount: i32,
    pub charRecruitTimes: i32,
    pub charRecruitChoiceCount: i32,
    pub subcardStageSort: i32,
    pub assistCharLimit: i32,
    pub firstClearTaskDesc: Option<String>,
    pub subCardObtainDesc: Option<String>,
    pub subGodCardUnlockDesc: Option<String>,
    pub sweepStartTime: i64,
    pub sweepOpenOrdinaryLayer: i32,
    pub sweepOpenDifficultLayer: i32,
    pub sweepCostCount: i32,
    pub squadMemStartTime: i64,
}
impl Default for clz_Torappu_ClimbTowerDetailConstT {
    fn default() -> Self {
        Self {
            unlockLevelId: None,
            unlockModuleNumRequirement: 0,
            lowerItemId: None,
            lowerItemLimit: 0,
            higherItemId: None,
            higherItemLimit: 0,
            initCharCount: 0,
            charRecruitTimes: 0,
            charRecruitChoiceCount: 0,
            subcardStageSort: 0,
            assistCharLimit: 0,
            firstClearTaskDesc: None,
            subCardObtainDesc: None,
            subGodCardUnlockDesc: None,
            sweepStartTime: 0,
            sweepOpenOrdinaryLayer: 0,
            sweepOpenDifficultLayer: 0,
            sweepCostCount: 0,
            squadMemStartTime: 0,
        }
    }
}
impl clz_Torappu_ClimbTowerDetailConstT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerDetailConst<'b>> {
        let unlockLevelId = self.unlockLevelId.as_ref().map(|x| _fbb.create_string(x));
        let unlockModuleNumRequirement = self.unlockModuleNumRequirement;
        let lowerItemId = self.lowerItemId.as_ref().map(|x| _fbb.create_string(x));
        let lowerItemLimit = self.lowerItemLimit;
        let higherItemId = self.higherItemId.as_ref().map(|x| _fbb.create_string(x));
        let higherItemLimit = self.higherItemLimit;
        let initCharCount = self.initCharCount;
        let charRecruitTimes = self.charRecruitTimes;
        let charRecruitChoiceCount = self.charRecruitChoiceCount;
        let subcardStageSort = self.subcardStageSort;
        let assistCharLimit = self.assistCharLimit;
        let firstClearTaskDesc = self
            .firstClearTaskDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let subCardObtainDesc = self
            .subCardObtainDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let subGodCardUnlockDesc = self
            .subGodCardUnlockDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let sweepStartTime = self.sweepStartTime;
        let sweepOpenOrdinaryLayer = self.sweepOpenOrdinaryLayer;
        let sweepOpenDifficultLayer = self.sweepOpenDifficultLayer;
        let sweepCostCount = self.sweepCostCount;
        let squadMemStartTime = self.squadMemStartTime;
        clz_Torappu_ClimbTowerDetailConst::create(
            _fbb,
            &clz_Torappu_ClimbTowerDetailConstArgs {
                unlockLevelId,
                unlockModuleNumRequirement,
                lowerItemId,
                lowerItemLimit,
                higherItemId,
                higherItemLimit,
                initCharCount,
                charRecruitTimes,
                charRecruitChoiceCount,
                subcardStageSort,
                assistCharLimit,
                firstClearTaskDesc,
                subCardObtainDesc,
                subGodCardUnlockDesc,
                sweepStartTime,
                sweepOpenOrdinaryLayer,
                sweepOpenDifficultLayer,
                sweepCostCount,
                squadMemStartTime,
            },
        )
    }
}
pub enum clz_Torappu_ClimbTowerRewardInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ClimbTowerRewardInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ClimbTowerRewardInfo<'a> {
    type Inner = clz_Torappu_ClimbTowerRewardInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ClimbTowerRewardInfo<'a> {
    pub const VT_STAGESORT: flatbuffers::VOffsetT = 4;
    pub const VT_LOWERITEMCOUNT: flatbuffers::VOffsetT = 6;
    pub const VT_HIGHERITEMCOUNT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ClimbTowerRewardInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ClimbTowerRewardInfoArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerRewardInfo<'bldr>> {
        let mut builder = clz_Torappu_ClimbTowerRewardInfoBuilder::new(_fbb);
        builder.add_higherItemCount(args.higherItemCount);
        builder.add_lowerItemCount(args.lowerItemCount);
        builder.add_stageSort(args.stageSort);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ClimbTowerRewardInfoT {
        let stageSort = self.stageSort();
        let lowerItemCount = self.lowerItemCount();
        let higherItemCount = self.higherItemCount();
        clz_Torappu_ClimbTowerRewardInfoT {
            stageSort,
            lowerItemCount,
            higherItemCount,
        }
    }

    #[inline]
    pub fn stageSort(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ClimbTowerRewardInfo::VT_STAGESORT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn lowerItemCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ClimbTowerRewardInfo::VT_LOWERITEMCOUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn higherItemCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ClimbTowerRewardInfo::VT_HIGHERITEMCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ClimbTowerRewardInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("stageSort", Self::VT_STAGESORT, false)?
            .visit_field::<i32>("lowerItemCount", Self::VT_LOWERITEMCOUNT, false)?
            .visit_field::<i32>("higherItemCount", Self::VT_HIGHERITEMCOUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ClimbTowerRewardInfoArgs {
    pub stageSort: i32,
    pub lowerItemCount: i32,
    pub higherItemCount: i32,
}
impl<'a> Default for clz_Torappu_ClimbTowerRewardInfoArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ClimbTowerRewardInfoArgs {
            stageSort: 0,
            lowerItemCount: 0,
            higherItemCount: 0,
        }
    }
}

impl Serialize for clz_Torappu_ClimbTowerRewardInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ClimbTowerRewardInfo", 3)?;
        s.serialize_field("stageSort", &self.stageSort())?;
        s.serialize_field("lowerItemCount", &self.lowerItemCount())?;
        s.serialize_field("higherItemCount", &self.higherItemCount())?;
        s.end()
    }
}

pub struct clz_Torappu_ClimbTowerRewardInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ClimbTowerRewardInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_stageSort(&mut self, stageSort: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ClimbTowerRewardInfo::VT_STAGESORT, stageSort, 0);
    }
    #[inline]
    pub fn add_lowerItemCount(&mut self, lowerItemCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ClimbTowerRewardInfo::VT_LOWERITEMCOUNT,
            lowerItemCount,
            0,
        );
    }
    #[inline]
    pub fn add_higherItemCount(&mut self, higherItemCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ClimbTowerRewardInfo::VT_HIGHERITEMCOUNT,
            higherItemCount,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ClimbTowerRewardInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ClimbTowerRewardInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerRewardInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ClimbTowerRewardInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ClimbTowerRewardInfo");
        ds.field("stageSort", &self.stageSort());
        ds.field("lowerItemCount", &self.lowerItemCount());
        ds.field("higherItemCount", &self.higherItemCount());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ClimbTowerRewardInfoT {
    pub stageSort: i32,
    pub lowerItemCount: i32,
    pub higherItemCount: i32,
}
impl Default for clz_Torappu_ClimbTowerRewardInfoT {
    fn default() -> Self {
        Self {
            stageSort: 0,
            lowerItemCount: 0,
            higherItemCount: 0,
        }
    }
}
impl clz_Torappu_ClimbTowerRewardInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerRewardInfo<'b>> {
        let stageSort = self.stageSort;
        let lowerItemCount = self.lowerItemCount;
        let higherItemCount = self.higherItemCount;
        clz_Torappu_ClimbTowerRewardInfo::create(
            _fbb,
            &clz_Torappu_ClimbTowerRewardInfoArgs {
                stageSort,
                lowerItemCount,
                higherItemCount,
            },
        )
    }
}
pub enum clz_Torappu_MissionDisplayRewardsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_MissionDisplayRewards<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_MissionDisplayRewards<'a> {
    type Inner = clz_Torappu_MissionDisplayRewards<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_MissionDisplayRewards<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_ID: flatbuffers::VOffsetT = 6;
    pub const VT_COUNT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_MissionDisplayRewards { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_MissionDisplayRewardsArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MissionDisplayRewards<'bldr>> {
        let mut builder = clz_Torappu_MissionDisplayRewardsBuilder::new(_fbb);
        builder.add_count(args.count);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_MissionDisplayRewardsT {
        let type_ = self.type_();
        let id = self.id().map(|x| x.to_string());
        let count = self.count();
        clz_Torappu_MissionDisplayRewardsT { type_, id, count }
    }

    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_MissionDisplayRewards::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MissionDisplayRewards::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_MissionDisplayRewards::VT_COUNT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_MissionDisplayRewards<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_MissionDisplayRewardsArgs<'a> {
    pub type_: enum__Torappu_ItemType,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
}
impl<'a> Default for clz_Torappu_MissionDisplayRewardsArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_MissionDisplayRewardsArgs {
            type_: enum__Torappu_ItemType::NONE,
            id: None,
            count: 0,
        }
    }
}

impl Serialize for clz_Torappu_MissionDisplayRewards<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_MissionDisplayRewards", 3)?;
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("count", &self.count())?;
        s.end()
    }
}

pub struct clz_Torappu_MissionDisplayRewardsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_MissionDisplayRewardsBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_MissionDisplayRewards::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionDisplayRewards::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_MissionDisplayRewards::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_MissionDisplayRewardsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_MissionDisplayRewardsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_MissionDisplayRewards<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_MissionDisplayRewards<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_MissionDisplayRewards");
        ds.field("type_", &self.type_());
        ds.field("id", &self.id());
        ds.field("count", &self.count());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_MissionDisplayRewardsT {
    pub type_: enum__Torappu_ItemType,
    pub id: Option<String>,
    pub count: i32,
}
impl Default for clz_Torappu_MissionDisplayRewardsT {
    fn default() -> Self {
        Self {
            type_: enum__Torappu_ItemType::NONE,
            id: None,
            count: 0,
        }
    }
}
impl clz_Torappu_MissionDisplayRewardsT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MissionDisplayRewards<'b>> {
        let type_ = self.type_;
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let count = self.count;
        clz_Torappu_MissionDisplayRewards::create(
            _fbb,
            &clz_Torappu_MissionDisplayRewardsArgs { type_, id, count },
        )
    }
}
pub enum clz_Torappu_ClimbTowerMissionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ClimbTowerMissionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ClimbTowerMissionData<'a> {
    type Inner = clz_Torappu_ClimbTowerMissionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ClimbTowerMissionData<'a> {
    pub const VT_BINDGODCARDID: flatbuffers::VOffsetT = 4;
    pub const VT_BINDTOWERID: flatbuffers::VOffsetT = 6;
    pub const VT_ID: flatbuffers::VOffsetT = 8;
    pub const VT_SORTID: flatbuffers::VOffsetT = 10;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 12;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 14;
    pub const VT_ITEMBGTYPE: flatbuffers::VOffsetT = 16;
    pub const VT_PREMISSIONIDS: flatbuffers::VOffsetT = 18;
    pub const VT_TEMPLATE: flatbuffers::VOffsetT = 20;
    pub const VT_TEMPLATETYPE: flatbuffers::VOffsetT = 22;
    pub const VT_PARAM: flatbuffers::VOffsetT = 24;
    pub const VT_UNLOCKCONDITION: flatbuffers::VOffsetT = 26;
    pub const VT_UNLOCKPARAM: flatbuffers::VOffsetT = 28;
    pub const VT_MISSIONGROUP: flatbuffers::VOffsetT = 30;
    pub const VT_TOPAGE: flatbuffers::VOffsetT = 32;
    pub const VT_PERIODICALPOINT: flatbuffers::VOffsetT = 34;
    pub const VT_REWARDS: flatbuffers::VOffsetT = 36;
    pub const VT_BACKIMAGEPATH: flatbuffers::VOffsetT = 38;
    pub const VT_FOLDID: flatbuffers::VOffsetT = 40;
    pub const VT_HAVESUBMISSIONTOUNLOCK: flatbuffers::VOffsetT = 42;
    pub const VT_COUNTENDTS: flatbuffers::VOffsetT = 44;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ClimbTowerMissionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ClimbTowerMissionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerMissionData<'bldr>> {
        let mut builder = clz_Torappu_ClimbTowerMissionDataBuilder::new(_fbb);
        builder.add_countEndTs(args.countEndTs);
        if let Some(x) = args.foldId {
            builder.add_foldId(x);
        }
        if let Some(x) = args.backImagePath {
            builder.add_backImagePath(x);
        }
        if let Some(x) = args.rewards {
            builder.add_rewards(x);
        }
        builder.add_periodicalPoint(args.periodicalPoint);
        if let Some(x) = args.toPage {
            builder.add_toPage(x);
        }
        if let Some(x) = args.missionGroup {
            builder.add_missionGroup(x);
        }
        if let Some(x) = args.unlockParam {
            builder.add_unlockParam(x);
        }
        if let Some(x) = args.unlockCondition {
            builder.add_unlockCondition(x);
        }
        if let Some(x) = args.param {
            builder.add_param(x);
        }
        if let Some(x) = args.templateType {
            builder.add_templateType(x);
        }
        if let Some(x) = args.template {
            builder.add_template(x);
        }
        if let Some(x) = args.preMissionIds {
            builder.add_preMissionIds(x);
        }
        builder.add_itemBgType(args.itemBgType);
        builder.add_type_(args.type_);
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        if let Some(x) = args.bindTowerId {
            builder.add_bindTowerId(x);
        }
        if let Some(x) = args.bindGodCardId {
            builder.add_bindGodCardId(x);
        }
        builder.add_haveSubMissionToUnlock(args.haveSubMissionToUnlock);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ClimbTowerMissionDataT {
        let bindGodCardId = self.bindGodCardId().map(|x| x.to_string());
        let bindTowerId = self.bindTowerId().map(|x| x.to_string());
        let id = self.id().map(|x| x.to_string());
        let sortId = self.sortId();
        let description = self.description().map(|x| x.to_string());
        let type_ = self.type_();
        let itemBgType = self.itemBgType();
        let preMissionIds = self
            .preMissionIds()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let template = self.template().map(|x| x.to_string());
        let templateType = self.templateType().map(|x| x.to_string());
        let param = self
            .param()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let unlockCondition = self.unlockCondition().map(|x| x.to_string());
        let unlockParam = self
            .unlockParam()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let missionGroup = self.missionGroup().map(|x| x.to_string());
        let toPage = self.toPage().map(|x| x.to_string());
        let periodicalPoint = self.periodicalPoint();
        let rewards = self
            .rewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let backImagePath = self.backImagePath().map(|x| x.to_string());
        let foldId = self.foldId().map(|x| x.to_string());
        let haveSubMissionToUnlock = self.haveSubMissionToUnlock();
        let countEndTs = self.countEndTs();
        clz_Torappu_ClimbTowerMissionDataT {
            bindGodCardId,
            bindTowerId,
            id,
            sortId,
            description,
            type_,
            itemBgType,
            preMissionIds,
            template,
            templateType,
            param,
            unlockCondition,
            unlockParam,
            missionGroup,
            toPage,
            periodicalPoint,
            rewards,
            backImagePath,
            foldId,
            haveSubMissionToUnlock,
            countEndTs,
        }
    }

    #[inline]
    pub fn bindGodCardId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerMissionData::VT_BINDGODCARDID,
                None,
            )
        }
    }
    #[inline]
    pub fn bindTowerId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerMissionData::VT_BINDTOWERID,
                None,
            )
        }
    }
    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerMissionData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ClimbTowerMissionData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerMissionData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_MissionType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_MissionType>(
                    clz_Torappu_ClimbTowerMissionData::VT_TYPE_,
                    Some(enum__Torappu_MissionType::UNKNOWN),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn itemBgType(&self) -> enum__Torappu_MissionItemBgType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_MissionItemBgType>(
                    clz_Torappu_ClimbTowerMissionData::VT_ITEMBGTYPE,
                    Some(enum__Torappu_MissionItemBgType::COMMON),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn preMissionIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ClimbTowerMissionData::VT_PREMISSIONIDS, None)
        }
    }
    #[inline]
    pub fn template(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerMissionData::VT_TEMPLATE,
                None,
            )
        }
    }
    #[inline]
    pub fn templateType(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerMissionData::VT_TEMPLATETYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn param(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ClimbTowerMissionData::VT_PARAM, None)
        }
    }
    #[inline]
    pub fn unlockCondition(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerMissionData::VT_UNLOCKCONDITION,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockParam(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ClimbTowerMissionData::VT_UNLOCKPARAM, None)
        }
    }
    #[inline]
    pub fn missionGroup(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerMissionData::VT_MISSIONGROUP,
                None,
            )
        }
    }
    #[inline]
    pub fn toPage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerMissionData::VT_TOPAGE,
                None,
            )
        }
    }
    #[inline]
    pub fn periodicalPoint(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ClimbTowerMissionData::VT_PERIODICALPOINT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rewards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_MissionDisplayRewards<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_MissionDisplayRewards>,
                >,
            >>(clz_Torappu_ClimbTowerMissionData::VT_REWARDS, None)
        }
    }
    #[inline]
    pub fn backImagePath(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerMissionData::VT_BACKIMAGEPATH,
                None,
            )
        }
    }
    #[inline]
    pub fn foldId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ClimbTowerMissionData::VT_FOLDID,
                None,
            )
        }
    }
    #[inline]
    pub fn haveSubMissionToUnlock(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_ClimbTowerMissionData::VT_HAVESUBMISSIONTOUNLOCK,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn countEndTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_ClimbTowerMissionData::VT_COUNTENDTS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ClimbTowerMissionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bindGodCardId",
                Self::VT_BINDGODCARDID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bindTowerId",
                Self::VT_BINDTOWERID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<enum__Torappu_MissionType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<enum__Torappu_MissionItemBgType>(
                "itemBgType",
                Self::VT_ITEMBGTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("preMissionIds", Self::VT_PREMISSIONIDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "template",
                Self::VT_TEMPLATE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "templateType",
                Self::VT_TEMPLATETYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("param", Self::VT_PARAM, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockCondition",
                Self::VT_UNLOCKCONDITION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("unlockParam", Self::VT_UNLOCKPARAM, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "missionGroup",
                Self::VT_MISSIONGROUP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("toPage", Self::VT_TOPAGE, false)?
            .visit_field::<i32>("periodicalPoint", Self::VT_PERIODICALPOINT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_MissionDisplayRewards>,
                >,
            >>("rewards", Self::VT_REWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "backImagePath",
                Self::VT_BACKIMAGEPATH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("foldId", Self::VT_FOLDID, false)?
            .visit_field::<bool>(
                "haveSubMissionToUnlock",
                Self::VT_HAVESUBMISSIONTOUNLOCK,
                false,
            )?
            .visit_field::<i64>("countEndTs", Self::VT_COUNTENDTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ClimbTowerMissionDataArgs<'a> {
    pub bindGodCardId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bindTowerId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_MissionType,
    pub itemBgType: enum__Torappu_MissionItemBgType,
    pub preMissionIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub template: Option<flatbuffers::WIPOffset<&'a str>>,
    pub templateType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub param: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub unlockCondition: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockParam: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub missionGroup: Option<flatbuffers::WIPOffset<&'a str>>,
    pub toPage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub periodicalPoint: i32,
    pub rewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_MissionDisplayRewards<'a>>,
            >,
        >,
    >,
    pub backImagePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub foldId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub haveSubMissionToUnlock: bool,
    pub countEndTs: i64,
}
impl<'a> Default for clz_Torappu_ClimbTowerMissionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ClimbTowerMissionDataArgs {
            bindGodCardId: None,
            bindTowerId: None,
            id: None,
            sortId: 0,
            description: None,
            type_: enum__Torappu_MissionType::UNKNOWN,
            itemBgType: enum__Torappu_MissionItemBgType::COMMON,
            preMissionIds: None,
            template: None,
            templateType: None,
            param: None,
            unlockCondition: None,
            unlockParam: None,
            missionGroup: None,
            toPage: None,
            periodicalPoint: 0,
            rewards: None,
            backImagePath: None,
            foldId: None,
            haveSubMissionToUnlock: false,
            countEndTs: 0,
        }
    }
}

impl Serialize for clz_Torappu_ClimbTowerMissionData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ClimbTowerMissionData", 21)?;
        if let Some(f) = self.bindGodCardId() {
            s.serialize_field("bindGodCardId", &f)?;
        } else {
            s.skip_field("bindGodCardId")?;
        }
        if let Some(f) = self.bindTowerId() {
            s.serialize_field("bindTowerId", &f)?;
        } else {
            s.skip_field("bindTowerId")?;
        }
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        s.serialize_field("type_", &self.type_())?;
        s.serialize_field("itemBgType", &self.itemBgType())?;
        if let Some(f) = self.preMissionIds() {
            s.serialize_field("preMissionIds", &f)?;
        } else {
            s.skip_field("preMissionIds")?;
        }
        if let Some(f) = self.template() {
            s.serialize_field("template", &f)?;
        } else {
            s.skip_field("template")?;
        }
        if let Some(f) = self.templateType() {
            s.serialize_field("templateType", &f)?;
        } else {
            s.skip_field("templateType")?;
        }
        if let Some(f) = self.param() {
            s.serialize_field("param", &f)?;
        } else {
            s.skip_field("param")?;
        }
        if let Some(f) = self.unlockCondition() {
            s.serialize_field("unlockCondition", &f)?;
        } else {
            s.skip_field("unlockCondition")?;
        }
        if let Some(f) = self.unlockParam() {
            s.serialize_field("unlockParam", &f)?;
        } else {
            s.skip_field("unlockParam")?;
        }
        if let Some(f) = self.missionGroup() {
            s.serialize_field("missionGroup", &f)?;
        } else {
            s.skip_field("missionGroup")?;
        }
        if let Some(f) = self.toPage() {
            s.serialize_field("toPage", &f)?;
        } else {
            s.skip_field("toPage")?;
        }
        s.serialize_field("periodicalPoint", &self.periodicalPoint())?;
        if let Some(f) = self.rewards() {
            s.serialize_field("rewards", &f)?;
        } else {
            s.skip_field("rewards")?;
        }
        if let Some(f) = self.backImagePath() {
            s.serialize_field("backImagePath", &f)?;
        } else {
            s.skip_field("backImagePath")?;
        }
        if let Some(f) = self.foldId() {
            s.serialize_field("foldId", &f)?;
        } else {
            s.skip_field("foldId")?;
        }
        s.serialize_field("haveSubMissionToUnlock", &self.haveSubMissionToUnlock())?;
        s.serialize_field("countEndTs", &self.countEndTs())?;
        s.end()
    }
}

pub struct clz_Torappu_ClimbTowerMissionDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ClimbTowerMissionDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_bindGodCardId(&mut self, bindGodCardId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerMissionData::VT_BINDGODCARDID,
            bindGodCardId,
        );
    }
    #[inline]
    pub fn add_bindTowerId(&mut self, bindTowerId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerMissionData::VT_BINDTOWERID,
            bindTowerId,
        );
    }
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerMissionData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ClimbTowerMissionData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerMissionData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_MissionType) {
        self.fbb_.push_slot::<enum__Torappu_MissionType>(
            clz_Torappu_ClimbTowerMissionData::VT_TYPE_,
            type_,
            enum__Torappu_MissionType::UNKNOWN,
        );
    }
    #[inline]
    pub fn add_itemBgType(&mut self, itemBgType: enum__Torappu_MissionItemBgType) {
        self.fbb_.push_slot::<enum__Torappu_MissionItemBgType>(
            clz_Torappu_ClimbTowerMissionData::VT_ITEMBGTYPE,
            itemBgType,
            enum__Torappu_MissionItemBgType::COMMON,
        );
    }
    #[inline]
    pub fn add_preMissionIds(
        &mut self,
        preMissionIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerMissionData::VT_PREMISSIONIDS,
            preMissionIds,
        );
    }
    #[inline]
    pub fn add_template(&mut self, template: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerMissionData::VT_TEMPLATE,
            template,
        );
    }
    #[inline]
    pub fn add_templateType(&mut self, templateType: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerMissionData::VT_TEMPLATETYPE,
            templateType,
        );
    }
    #[inline]
    pub fn add_param(
        &mut self,
        param: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerMissionData::VT_PARAM,
            param,
        );
    }
    #[inline]
    pub fn add_unlockCondition(&mut self, unlockCondition: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerMissionData::VT_UNLOCKCONDITION,
            unlockCondition,
        );
    }
    #[inline]
    pub fn add_unlockParam(
        &mut self,
        unlockParam: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerMissionData::VT_UNLOCKPARAM,
            unlockParam,
        );
    }
    #[inline]
    pub fn add_missionGroup(&mut self, missionGroup: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerMissionData::VT_MISSIONGROUP,
            missionGroup,
        );
    }
    #[inline]
    pub fn add_toPage(&mut self, toPage: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerMissionData::VT_TOPAGE,
            toPage,
        );
    }
    #[inline]
    pub fn add_periodicalPoint(&mut self, periodicalPoint: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ClimbTowerMissionData::VT_PERIODICALPOINT,
            periodicalPoint,
            0,
        );
    }
    #[inline]
    pub fn add_rewards(
        &mut self,
        rewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_MissionDisplayRewards<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerMissionData::VT_REWARDS,
            rewards,
        );
    }
    #[inline]
    pub fn add_backImagePath(&mut self, backImagePath: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerMissionData::VT_BACKIMAGEPATH,
            backImagePath,
        );
    }
    #[inline]
    pub fn add_foldId(&mut self, foldId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerMissionData::VT_FOLDID,
            foldId,
        );
    }
    #[inline]
    pub fn add_haveSubMissionToUnlock(&mut self, haveSubMissionToUnlock: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_ClimbTowerMissionData::VT_HAVESUBMISSIONTOUNLOCK,
            haveSubMissionToUnlock,
            false,
        );
    }
    #[inline]
    pub fn add_countEndTs(&mut self, countEndTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_ClimbTowerMissionData::VT_COUNTENDTS,
            countEndTs,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ClimbTowerMissionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ClimbTowerMissionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerMissionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ClimbTowerMissionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ClimbTowerMissionData");
        ds.field("bindGodCardId", &self.bindGodCardId());
        ds.field("bindTowerId", &self.bindTowerId());
        ds.field("id", &self.id());
        ds.field("sortId", &self.sortId());
        ds.field("description", &self.description());
        ds.field("type_", &self.type_());
        ds.field("itemBgType", &self.itemBgType());
        ds.field("preMissionIds", &self.preMissionIds());
        ds.field("template", &self.template());
        ds.field("templateType", &self.templateType());
        ds.field("param", &self.param());
        ds.field("unlockCondition", &self.unlockCondition());
        ds.field("unlockParam", &self.unlockParam());
        ds.field("missionGroup", &self.missionGroup());
        ds.field("toPage", &self.toPage());
        ds.field("periodicalPoint", &self.periodicalPoint());
        ds.field("rewards", &self.rewards());
        ds.field("backImagePath", &self.backImagePath());
        ds.field("foldId", &self.foldId());
        ds.field("haveSubMissionToUnlock", &self.haveSubMissionToUnlock());
        ds.field("countEndTs", &self.countEndTs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ClimbTowerMissionDataT {
    pub bindGodCardId: Option<String>,
    pub bindTowerId: Option<String>,
    pub id: Option<String>,
    pub sortId: i32,
    pub description: Option<String>,
    pub type_: enum__Torappu_MissionType,
    pub itemBgType: enum__Torappu_MissionItemBgType,
    pub preMissionIds: Option<Vec<String>>,
    pub template: Option<String>,
    pub templateType: Option<String>,
    pub param: Option<Vec<String>>,
    pub unlockCondition: Option<String>,
    pub unlockParam: Option<Vec<String>>,
    pub missionGroup: Option<String>,
    pub toPage: Option<String>,
    pub periodicalPoint: i32,
    pub rewards: Option<Vec<clz_Torappu_MissionDisplayRewardsT>>,
    pub backImagePath: Option<String>,
    pub foldId: Option<String>,
    pub haveSubMissionToUnlock: bool,
    pub countEndTs: i64,
}
impl Default for clz_Torappu_ClimbTowerMissionDataT {
    fn default() -> Self {
        Self {
            bindGodCardId: None,
            bindTowerId: None,
            id: None,
            sortId: 0,
            description: None,
            type_: enum__Torappu_MissionType::UNKNOWN,
            itemBgType: enum__Torappu_MissionItemBgType::COMMON,
            preMissionIds: None,
            template: None,
            templateType: None,
            param: None,
            unlockCondition: None,
            unlockParam: None,
            missionGroup: None,
            toPage: None,
            periodicalPoint: 0,
            rewards: None,
            backImagePath: None,
            foldId: None,
            haveSubMissionToUnlock: false,
            countEndTs: 0,
        }
    }
}
impl clz_Torappu_ClimbTowerMissionDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerMissionData<'b>> {
        let bindGodCardId = self.bindGodCardId.as_ref().map(|x| _fbb.create_string(x));
        let bindTowerId = self.bindTowerId.as_ref().map(|x| _fbb.create_string(x));
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let itemBgType = self.itemBgType;
        let preMissionIds = self.preMissionIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let template = self.template.as_ref().map(|x| _fbb.create_string(x));
        let templateType = self.templateType.as_ref().map(|x| _fbb.create_string(x));
        let param = self.param.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let unlockCondition = self.unlockCondition.as_ref().map(|x| _fbb.create_string(x));
        let unlockParam = self.unlockParam.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let missionGroup = self.missionGroup.as_ref().map(|x| _fbb.create_string(x));
        let toPage = self.toPage.as_ref().map(|x| _fbb.create_string(x));
        let periodicalPoint = self.periodicalPoint;
        let rewards = self.rewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let backImagePath = self.backImagePath.as_ref().map(|x| _fbb.create_string(x));
        let foldId = self.foldId.as_ref().map(|x| _fbb.create_string(x));
        let haveSubMissionToUnlock = self.haveSubMissionToUnlock;
        let countEndTs = self.countEndTs;
        clz_Torappu_ClimbTowerMissionData::create(
            _fbb,
            &clz_Torappu_ClimbTowerMissionDataArgs {
                bindGodCardId,
                bindTowerId,
                id,
                sortId,
                description,
                type_,
                itemBgType,
                preMissionIds,
                template,
                templateType,
                param,
                unlockCondition,
                unlockParam,
                missionGroup,
                toPage,
                periodicalPoint,
                rewards,
                backImagePath,
                foldId,
                haveSubMissionToUnlock,
                countEndTs,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ClimbTowerMissionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ClimbTowerMissionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ClimbTowerMissionData<'a> {
    type Inner = dict__string__clz_Torappu_ClimbTowerMissionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ClimbTowerMissionData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ClimbTowerMissionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ClimbTowerMissionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerMissionData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ClimbTowerMissionDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ClimbTowerMissionDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ClimbTowerMissionDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ClimbTowerMissionData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ClimbTowerMissionData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ClimbTowerMissionData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerMissionData>>(
                    dict__string__clz_Torappu_ClimbTowerMissionData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ClimbTowerMissionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerMissionData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ClimbTowerMissionDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ClimbTowerMissionData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ClimbTowerMissionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ClimbTowerMissionDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ClimbTowerMissionData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ClimbTowerMissionData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ClimbTowerMissionDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ClimbTowerMissionDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ClimbTowerMissionData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ClimbTowerMissionData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ClimbTowerMissionData>>(
                dict__string__clz_Torappu_ClimbTowerMissionData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ClimbTowerMissionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ClimbTowerMissionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerMissionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ClimbTowerMissionData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ClimbTowerMissionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ClimbTowerMissionData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ClimbTowerMissionDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ClimbTowerMissionDataT>>,
}
impl Default for dict__string__clz_Torappu_ClimbTowerMissionDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ClimbTowerMissionDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ClimbTowerMissionData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ClimbTowerMissionData::create(
            _fbb,
            &dict__string__clz_Torappu_ClimbTowerMissionDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_MissionGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_MissionGroup<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_MissionGroup<'a> {
    type Inner = clz_Torappu_MissionGroup<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_MissionGroup<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TITLE: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;
    pub const VT_PREMISSIONGROUP: flatbuffers::VOffsetT = 10;
    pub const VT_PERIOD: flatbuffers::VOffsetT = 12;
    pub const VT_REWARDS: flatbuffers::VOffsetT = 14;
    pub const VT_MISSIONIDS: flatbuffers::VOffsetT = 16;
    pub const VT_STARTTS: flatbuffers::VOffsetT = 18;
    pub const VT_ENDTS: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_MissionGroup { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_MissionGroupArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MissionGroup<'bldr>> {
        let mut builder = clz_Torappu_MissionGroupBuilder::new(_fbb);
        builder.add_endTs(args.endTs);
        builder.add_startTs(args.startTs);
        if let Some(x) = args.missionIds {
            builder.add_missionIds(x);
        }
        if let Some(x) = args.rewards {
            builder.add_rewards(x);
        }
        if let Some(x) = args.period {
            builder.add_period(x);
        }
        if let Some(x) = args.preMissionGroup {
            builder.add_preMissionGroup(x);
        }
        builder.add_type_(args.type_);
        if let Some(x) = args.title {
            builder.add_title(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_MissionGroupT {
        let id = self.id().map(|x| x.to_string());
        let title = self.title().map(|x| x.to_string());
        let type_ = self.type_();
        let preMissionGroup = self.preMissionGroup().map(|x| x.to_string());
        let period = self.period().map(|x| x.into_iter().collect());
        let rewards = self
            .rewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let missionIds = self
            .missionIds()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let startTs = self.startTs();
        let endTs = self.endTs();
        clz_Torappu_MissionGroupT {
            id,
            title,
            type_,
            preMissionGroup,
            period,
            rewards,
            missionIds,
            startTs,
            endTs,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_MissionGroup::VT_ID, None)
        }
    }
    #[inline]
    pub fn title(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_MissionGroup::VT_TITLE, None)
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_MissionType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_MissionType>(
                    clz_Torappu_MissionGroup::VT_TYPE_,
                    Some(enum__Torappu_MissionType::UNKNOWN),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn preMissionGroup(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MissionGroup::VT_PREMISSIONGROUP,
                None,
            )
        }
    }
    #[inline]
    pub fn period(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    clz_Torappu_MissionGroup::VT_PERIOD,
                    None,
                )
        }
    }
    #[inline]
    pub fn rewards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_MissionDisplayRewards<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_MissionDisplayRewards>,
                >,
            >>(clz_Torappu_MissionGroup::VT_REWARDS, None)
        }
    }
    #[inline]
    pub fn missionIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_MissionGroup::VT_MISSIONIDS, None)
        }
    }
    #[inline]
    pub fn startTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_MissionGroup::VT_STARTTS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_MissionGroup::VT_ENDTS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_MissionGroup<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
            .visit_field::<enum__Torappu_MissionType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "preMissionGroup",
                Self::VT_PREMISSIONGROUP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "period",
                Self::VT_PERIOD,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_MissionDisplayRewards>,
                >,
            >>("rewards", Self::VT_REWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("missionIds", Self::VT_MISSIONIDS, false)?
            .visit_field::<i64>("startTs", Self::VT_STARTTS, false)?
            .visit_field::<i64>("endTs", Self::VT_ENDTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_MissionGroupArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_MissionType,
    pub preMissionGroup: Option<flatbuffers::WIPOffset<&'a str>>,
    pub period: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub rewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_MissionDisplayRewards<'a>>,
            >,
        >,
    >,
    pub missionIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub startTs: i64,
    pub endTs: i64,
}
impl<'a> Default for clz_Torappu_MissionGroupArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_MissionGroupArgs {
            id: None,
            title: None,
            type_: enum__Torappu_MissionType::UNKNOWN,
            preMissionGroup: None,
            period: None,
            rewards: None,
            missionIds: None,
            startTs: 0,
            endTs: 0,
        }
    }
}

impl Serialize for clz_Torappu_MissionGroup<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_MissionGroup", 9)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.title() {
            s.serialize_field("title", &f)?;
        } else {
            s.skip_field("title")?;
        }
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.preMissionGroup() {
            s.serialize_field("preMissionGroup", &f)?;
        } else {
            s.skip_field("preMissionGroup")?;
        }
        if let Some(f) = self.period() {
            s.serialize_field("period", &f)?;
        } else {
            s.skip_field("period")?;
        }
        if let Some(f) = self.rewards() {
            s.serialize_field("rewards", &f)?;
        } else {
            s.skip_field("rewards")?;
        }
        if let Some(f) = self.missionIds() {
            s.serialize_field("missionIds", &f)?;
        } else {
            s.skip_field("missionIds")?;
        }
        s.serialize_field("startTs", &self.startTs())?;
        s.serialize_field("endTs", &self.endTs())?;
        s.end()
    }
}

pub struct clz_Torappu_MissionGroupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_MissionGroupBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_MissionGroup::VT_ID, id);
    }
    #[inline]
    pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionGroup::VT_TITLE,
            title,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_MissionType) {
        self.fbb_.push_slot::<enum__Torappu_MissionType>(
            clz_Torappu_MissionGroup::VT_TYPE_,
            type_,
            enum__Torappu_MissionType::UNKNOWN,
        );
    }
    #[inline]
    pub fn add_preMissionGroup(&mut self, preMissionGroup: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionGroup::VT_PREMISSIONGROUP,
            preMissionGroup,
        );
    }
    #[inline]
    pub fn add_period(&mut self, period: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionGroup::VT_PERIOD,
            period,
        );
    }
    #[inline]
    pub fn add_rewards(
        &mut self,
        rewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_MissionDisplayRewards<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionGroup::VT_REWARDS,
            rewards,
        );
    }
    #[inline]
    pub fn add_missionIds(
        &mut self,
        missionIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionGroup::VT_MISSIONIDS,
            missionIds,
        );
    }
    #[inline]
    pub fn add_startTs(&mut self, startTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_MissionGroup::VT_STARTTS, startTs, 0);
    }
    #[inline]
    pub fn add_endTs(&mut self, endTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_MissionGroup::VT_ENDTS, endTs, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_MissionGroupBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_MissionGroupBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_MissionGroup<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_MissionGroup<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_MissionGroup");
        ds.field("id", &self.id());
        ds.field("title", &self.title());
        ds.field("type_", &self.type_());
        ds.field("preMissionGroup", &self.preMissionGroup());
        ds.field("period", &self.period());
        ds.field("rewards", &self.rewards());
        ds.field("missionIds", &self.missionIds());
        ds.field("startTs", &self.startTs());
        ds.field("endTs", &self.endTs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_MissionGroupT {
    pub id: Option<String>,
    pub title: Option<String>,
    pub type_: enum__Torappu_MissionType,
    pub preMissionGroup: Option<String>,
    pub period: Option<Vec<i32>>,
    pub rewards: Option<Vec<clz_Torappu_MissionDisplayRewardsT>>,
    pub missionIds: Option<Vec<String>>,
    pub startTs: i64,
    pub endTs: i64,
}
impl Default for clz_Torappu_MissionGroupT {
    fn default() -> Self {
        Self {
            id: None,
            title: None,
            type_: enum__Torappu_MissionType::UNKNOWN,
            preMissionGroup: None,
            period: None,
            rewards: None,
            missionIds: None,
            startTs: 0,
            endTs: 0,
        }
    }
}
impl clz_Torappu_MissionGroupT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MissionGroup<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let title = self.title.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let preMissionGroup = self.preMissionGroup.as_ref().map(|x| _fbb.create_string(x));
        let period = self.period.as_ref().map(|x| _fbb.create_vector(x));
        let rewards = self.rewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let missionIds = self.missionIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let startTs = self.startTs;
        let endTs = self.endTs;
        clz_Torappu_MissionGroup::create(
            _fbb,
            &clz_Torappu_MissionGroupArgs {
                id,
                title,
                type_,
                preMissionGroup,
                period,
                rewards,
                missionIds,
                startTs,
                endTs,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_MissionGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_MissionGroup<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_MissionGroup<'a> {
    type Inner = dict__string__clz_Torappu_MissionGroup<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_MissionGroup<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_MissionGroup { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_MissionGroupArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_MissionGroup<'bldr>> {
        let mut builder = dict__string__clz_Torappu_MissionGroupBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_MissionGroupT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_MissionGroupT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_MissionGroup::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_MissionGroup) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_MissionGroup<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_MissionGroup>>(
                    dict__string__clz_Torappu_MissionGroup::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_MissionGroup<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_MissionGroup>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_MissionGroupArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_MissionGroup<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_MissionGroupArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_MissionGroupArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_MissionGroup<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_MissionGroup", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_MissionGroupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_MissionGroupBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_MissionGroup::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_MissionGroup<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_MissionGroup>>(
                dict__string__clz_Torappu_MissionGroup::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_MissionGroupBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_MissionGroupBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_MissionGroup<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_MissionGroup::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_MissionGroup<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_MissionGroup");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_MissionGroupT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_MissionGroupT>>,
}
impl Default for dict__string__clz_Torappu_MissionGroupT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_MissionGroupT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_MissionGroup<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_MissionGroup::create(
            _fbb,
            &dict__string__clz_Torappu_MissionGroupArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ClimbTowerTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ClimbTowerTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ClimbTowerTable<'a> {
    type Inner = clz_Torappu_ClimbTowerTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ClimbTowerTable<'a> {
    pub const VT_TOWERS: flatbuffers::VOffsetT = 4;
    pub const VT_LEVELS: flatbuffers::VOffsetT = 6;
    pub const VT_TACTICALBUFFS: flatbuffers::VOffsetT = 8;
    pub const VT_MAINCARDS: flatbuffers::VOffsetT = 10;
    pub const VT_SUBCARDS: flatbuffers::VOffsetT = 12;
    pub const VT_CURSECARDS: flatbuffers::VOffsetT = 14;
    pub const VT_SEASONINFOS: flatbuffers::VOffsetT = 16;
    pub const VT_DETAILCONST: flatbuffers::VOffsetT = 18;
    pub const VT_REWARDINFOLIST: flatbuffers::VOffsetT = 20;
    pub const VT_REWARDINFOLISTHARDMODE: flatbuffers::VOffsetT = 22;
    pub const VT_MISSIONDATA: flatbuffers::VOffsetT = 24;
    pub const VT_MISSIONGROUP: flatbuffers::VOffsetT = 26;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ClimbTowerTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ClimbTowerTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerTable<'bldr>> {
        let mut builder = clz_Torappu_ClimbTowerTableBuilder::new(_fbb);
        if let Some(x) = args.missionGroup {
            builder.add_missionGroup(x);
        }
        if let Some(x) = args.missionData {
            builder.add_missionData(x);
        }
        if let Some(x) = args.rewardInfoListHardMode {
            builder.add_rewardInfoListHardMode(x);
        }
        if let Some(x) = args.rewardInfoList {
            builder.add_rewardInfoList(x);
        }
        if let Some(x) = args.detailConst {
            builder.add_detailConst(x);
        }
        if let Some(x) = args.seasonInfos {
            builder.add_seasonInfos(x);
        }
        if let Some(x) = args.curseCards {
            builder.add_curseCards(x);
        }
        if let Some(x) = args.subCards {
            builder.add_subCards(x);
        }
        if let Some(x) = args.mainCards {
            builder.add_mainCards(x);
        }
        if let Some(x) = args.tacticalBuffs {
            builder.add_tacticalBuffs(x);
        }
        if let Some(x) = args.levels {
            builder.add_levels(x);
        }
        if let Some(x) = args.towers {
            builder.add_towers(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ClimbTowerTableT {
        let towers = self
            .towers()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let levels = self
            .levels()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let tacticalBuffs = self
            .tacticalBuffs()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let mainCards = self
            .mainCards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let subCards = self
            .subCards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let curseCards = self
            .curseCards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let seasonInfos = self
            .seasonInfos()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let detailConst = self.detailConst().map(|x| Box::new(x.unpack()));
        let rewardInfoList = self
            .rewardInfoList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let rewardInfoListHardMode = self
            .rewardInfoListHardMode()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let missionData = self
            .missionData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let missionGroup = self
            .missionGroup()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ClimbTowerTableT {
            towers,
            levels,
            tacticalBuffs,
            mainCards,
            subCards,
            curseCards,
            seasonInfos,
            detailConst,
            rewardInfoList,
            rewardInfoListHardMode,
            missionData,
            missionGroup,
        }
    }

    #[inline]
    pub fn towers(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerSingleTowerData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ClimbTowerSingleTowerData,
                    >,
                >,
            >>(clz_Torappu_ClimbTowerTable::VT_TOWERS, None)
        }
    }
    #[inline]
    pub fn levels(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerSingleLevelData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ClimbTowerSingleLevelData,
                    >,
                >,
            >>(clz_Torappu_ClimbTowerTable::VT_LEVELS, None)
        }
    }
    #[inline]
    pub fn tacticalBuffs(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerTacticalBuffData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ClimbTowerTacticalBuffData,
                    >,
                >,
            >>(clz_Torappu_ClimbTowerTable::VT_TACTICALBUFFS, None)
        }
    }
    #[inline]
    pub fn mainCards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerMainCardData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerMainCardData>,
                >,
            >>(clz_Torappu_ClimbTowerTable::VT_MAINCARDS, None)
        }
    }
    #[inline]
    pub fn subCards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerSubCardData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerSubCardData>,
                >,
            >>(clz_Torappu_ClimbTowerTable::VT_SUBCARDS, None)
        }
    }
    #[inline]
    pub fn curseCards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerCurseCardData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerCurseCardData>,
                >,
            >>(clz_Torappu_ClimbTowerTable::VT_CURSECARDS, None)
        }
    }
    #[inline]
    pub fn seasonInfos(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerSeasonInfoData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ClimbTowerSeasonInfoData,
                    >,
                >,
            >>(clz_Torappu_ClimbTowerTable::VT_SEASONINFOS, None)
        }
    }
    #[inline]
    pub fn detailConst(&self) -> Option<clz_Torappu_ClimbTowerDetailConst<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerDetailConst>>(
                    clz_Torappu_ClimbTowerTable::VT_DETAILCONST,
                    None,
                )
        }
    }
    #[inline]
    pub fn rewardInfoList(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerRewardInfo<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerRewardInfo>,
                >,
            >>(clz_Torappu_ClimbTowerTable::VT_REWARDINFOLIST, None)
        }
    }
    #[inline]
    pub fn rewardInfoListHardMode(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerRewardInfo<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerRewardInfo>,
                >,
            >>(clz_Torappu_ClimbTowerTable::VT_REWARDINFOLISTHARDMODE, None)
        }
    }
    #[inline]
    pub fn missionData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerMissionData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerMissionData>,
                >,
            >>(clz_Torappu_ClimbTowerTable::VT_MISSIONDATA, None)
        }
    }
    #[inline]
    pub fn missionGroup(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MissionGroup<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MissionGroup>,
                >,
            >>(clz_Torappu_ClimbTowerTable::VT_MISSIONGROUP, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ClimbTowerTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ClimbTowerSingleTowerData,
                    >,
                >,
            >>("towers", Self::VT_TOWERS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ClimbTowerSingleLevelData,
                    >,
                >,
            >>("levels", Self::VT_LEVELS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ClimbTowerTacticalBuffData,
                    >,
                >,
            >>("tacticalBuffs", Self::VT_TACTICALBUFFS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerMainCardData>,
                >,
            >>("mainCards", Self::VT_MAINCARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerSubCardData>,
                >,
            >>("subCards", Self::VT_SUBCARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerCurseCardData>,
                >,
            >>("curseCards", Self::VT_CURSECARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ClimbTowerSeasonInfoData,
                    >,
                >,
            >>("seasonInfos", Self::VT_SEASONINFOS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerDetailConst>>(
                "detailConst",
                Self::VT_DETAILCONST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerRewardInfo>,
                >,
            >>("rewardInfoList", Self::VT_REWARDINFOLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerRewardInfo>,
                >,
            >>(
                "rewardInfoListHardMode",
                Self::VT_REWARDINFOLISTHARDMODE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerMissionData>,
                >,
            >>("missionData", Self::VT_MISSIONDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MissionGroup>,
                >,
            >>("missionGroup", Self::VT_MISSIONGROUP, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ClimbTowerTableArgs<'a> {
    pub towers: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ClimbTowerSingleTowerData<'a>,
                >,
            >,
        >,
    >,
    pub levels: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ClimbTowerSingleLevelData<'a>,
                >,
            >,
        >,
    >,
    pub tacticalBuffs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ClimbTowerTacticalBuffData<'a>,
                >,
            >,
        >,
    >,
    pub mainCards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerMainCardData<'a>>,
            >,
        >,
    >,
    pub subCards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerSubCardData<'a>>,
            >,
        >,
    >,
    pub curseCards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerCurseCardData<'a>>,
            >,
        >,
    >,
    pub seasonInfos: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ClimbTowerSeasonInfoData<'a>,
                >,
            >,
        >,
    >,
    pub detailConst: Option<flatbuffers::WIPOffset<clz_Torappu_ClimbTowerDetailConst<'a>>>,
    pub rewardInfoList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerRewardInfo<'a>>,
            >,
        >,
    >,
    pub rewardInfoListHardMode: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerRewardInfo<'a>>,
            >,
        >,
    >,
    pub missionData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerMissionData<'a>>,
            >,
        >,
    >,
    pub missionGroup: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MissionGroup<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ClimbTowerTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ClimbTowerTableArgs {
            towers: None,
            levels: None,
            tacticalBuffs: None,
            mainCards: None,
            subCards: None,
            curseCards: None,
            seasonInfos: None,
            detailConst: None,
            rewardInfoList: None,
            rewardInfoListHardMode: None,
            missionData: None,
            missionGroup: None,
        }
    }
}

impl Serialize for clz_Torappu_ClimbTowerTable<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ClimbTowerTable", 12)?;
        if let Some(f) = self.towers() {
            s.serialize_field("towers", &f)?;
        } else {
            s.skip_field("towers")?;
        }
        if let Some(f) = self.levels() {
            s.serialize_field("levels", &f)?;
        } else {
            s.skip_field("levels")?;
        }
        if let Some(f) = self.tacticalBuffs() {
            s.serialize_field("tacticalBuffs", &f)?;
        } else {
            s.skip_field("tacticalBuffs")?;
        }
        if let Some(f) = self.mainCards() {
            s.serialize_field("mainCards", &f)?;
        } else {
            s.skip_field("mainCards")?;
        }
        if let Some(f) = self.subCards() {
            s.serialize_field("subCards", &f)?;
        } else {
            s.skip_field("subCards")?;
        }
        if let Some(f) = self.curseCards() {
            s.serialize_field("curseCards", &f)?;
        } else {
            s.skip_field("curseCards")?;
        }
        if let Some(f) = self.seasonInfos() {
            s.serialize_field("seasonInfos", &f)?;
        } else {
            s.skip_field("seasonInfos")?;
        }
        if let Some(f) = self.detailConst() {
            s.serialize_field("detailConst", &f)?;
        } else {
            s.skip_field("detailConst")?;
        }
        if let Some(f) = self.rewardInfoList() {
            s.serialize_field("rewardInfoList", &f)?;
        } else {
            s.skip_field("rewardInfoList")?;
        }
        if let Some(f) = self.rewardInfoListHardMode() {
            s.serialize_field("rewardInfoListHardMode", &f)?;
        } else {
            s.skip_field("rewardInfoListHardMode")?;
        }
        if let Some(f) = self.missionData() {
            s.serialize_field("missionData", &f)?;
        } else {
            s.skip_field("missionData")?;
        }
        if let Some(f) = self.missionGroup() {
            s.serialize_field("missionGroup", &f)?;
        } else {
            s.skip_field("missionGroup")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ClimbTowerTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ClimbTowerTableBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_towers(
        &mut self,
        towers: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ClimbTowerSingleTowerData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerTable::VT_TOWERS,
            towers,
        );
    }
    #[inline]
    pub fn add_levels(
        &mut self,
        levels: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ClimbTowerSingleLevelData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerTable::VT_LEVELS,
            levels,
        );
    }
    #[inline]
    pub fn add_tacticalBuffs(
        &mut self,
        tacticalBuffs: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ClimbTowerTacticalBuffData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerTable::VT_TACTICALBUFFS,
            tacticalBuffs,
        );
    }
    #[inline]
    pub fn add_mainCards(
        &mut self,
        mainCards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerMainCardData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerTable::VT_MAINCARDS,
            mainCards,
        );
    }
    #[inline]
    pub fn add_subCards(
        &mut self,
        subCards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerSubCardData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerTable::VT_SUBCARDS,
            subCards,
        );
    }
    #[inline]
    pub fn add_curseCards(
        &mut self,
        curseCards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerCurseCardData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerTable::VT_CURSECARDS,
            curseCards,
        );
    }
    #[inline]
    pub fn add_seasonInfos(
        &mut self,
        seasonInfos: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ClimbTowerSeasonInfoData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerTable::VT_SEASONINFOS,
            seasonInfos,
        );
    }
    #[inline]
    pub fn add_detailConst(
        &mut self,
        detailConst: flatbuffers::WIPOffset<clz_Torappu_ClimbTowerDetailConst<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ClimbTowerDetailConst>>(
                clz_Torappu_ClimbTowerTable::VT_DETAILCONST,
                detailConst,
            );
    }
    #[inline]
    pub fn add_rewardInfoList(
        &mut self,
        rewardInfoList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerRewardInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerTable::VT_REWARDINFOLIST,
            rewardInfoList,
        );
    }
    #[inline]
    pub fn add_rewardInfoListHardMode(
        &mut self,
        rewardInfoListHardMode: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_ClimbTowerRewardInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerTable::VT_REWARDINFOLISTHARDMODE,
            rewardInfoListHardMode,
        );
    }
    #[inline]
    pub fn add_missionData(
        &mut self,
        missionData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ClimbTowerMissionData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerTable::VT_MISSIONDATA,
            missionData,
        );
    }
    #[inline]
    pub fn add_missionGroup(
        &mut self,
        missionGroup: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MissionGroup<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ClimbTowerTable::VT_MISSIONGROUP,
            missionGroup,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ClimbTowerTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ClimbTowerTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ClimbTowerTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ClimbTowerTable");
        ds.field("towers", &self.towers());
        ds.field("levels", &self.levels());
        ds.field("tacticalBuffs", &self.tacticalBuffs());
        ds.field("mainCards", &self.mainCards());
        ds.field("subCards", &self.subCards());
        ds.field("curseCards", &self.curseCards());
        ds.field("seasonInfos", &self.seasonInfos());
        ds.field("detailConst", &self.detailConst());
        ds.field("rewardInfoList", &self.rewardInfoList());
        ds.field("rewardInfoListHardMode", &self.rewardInfoListHardMode());
        ds.field("missionData", &self.missionData());
        ds.field("missionGroup", &self.missionGroup());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ClimbTowerTableT {
    pub towers: Option<Vec<dict__string__clz_Torappu_ClimbTowerSingleTowerDataT>>,
    pub levels: Option<Vec<dict__string__clz_Torappu_ClimbTowerSingleLevelDataT>>,
    pub tacticalBuffs: Option<Vec<dict__string__clz_Torappu_ClimbTowerTacticalBuffDataT>>,
    pub mainCards: Option<Vec<dict__string__clz_Torappu_ClimbTowerMainCardDataT>>,
    pub subCards: Option<Vec<dict__string__clz_Torappu_ClimbTowerSubCardDataT>>,
    pub curseCards: Option<Vec<dict__string__clz_Torappu_ClimbTowerCurseCardDataT>>,
    pub seasonInfos: Option<Vec<dict__string__clz_Torappu_ClimbTowerSeasonInfoDataT>>,
    pub detailConst: Option<Box<clz_Torappu_ClimbTowerDetailConstT>>,
    pub rewardInfoList: Option<Vec<clz_Torappu_ClimbTowerRewardInfoT>>,
    pub rewardInfoListHardMode: Option<Vec<clz_Torappu_ClimbTowerRewardInfoT>>,
    pub missionData: Option<Vec<dict__string__clz_Torappu_ClimbTowerMissionDataT>>,
    pub missionGroup: Option<Vec<dict__string__clz_Torappu_MissionGroupT>>,
}
impl Default for clz_Torappu_ClimbTowerTableT {
    fn default() -> Self {
        Self {
            towers: None,
            levels: None,
            tacticalBuffs: None,
            mainCards: None,
            subCards: None,
            curseCards: None,
            seasonInfos: None,
            detailConst: None,
            rewardInfoList: None,
            rewardInfoListHardMode: None,
            missionData: None,
            missionGroup: None,
        }
    }
}
impl clz_Torappu_ClimbTowerTableT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ClimbTowerTable<'b>> {
        let towers = self.towers.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let levels = self.levels.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let tacticalBuffs = self.tacticalBuffs.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let mainCards = self.mainCards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let subCards = self.subCards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let curseCards = self.curseCards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let seasonInfos = self.seasonInfos.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let detailConst = self.detailConst.as_ref().map(|x| x.pack(_fbb));
        let rewardInfoList = self.rewardInfoList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let rewardInfoListHardMode = self.rewardInfoListHardMode.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let missionData = self.missionData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let missionGroup = self.missionGroup.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ClimbTowerTable::create(
            _fbb,
            &clz_Torappu_ClimbTowerTableArgs {
                towers,
                levels,
                tacticalBuffs,
                mainCards,
                subCards,
                curseCards,
                seasonInfos,
                detailConst,
                rewardInfoList,
                rewardInfoListHardMode,
                missionData,
                missionGroup,
            },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_ClimbTowerTable`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_climb_tower_table_unchecked`.
pub fn root_as_clz_torappu_climb_tower_table(
    buf: &[u8],
) -> Result<clz_Torappu_ClimbTowerTable<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_ClimbTowerTable>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_ClimbTowerTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_climb_tower_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_climb_tower_table(
    buf: &[u8],
) -> Result<clz_Torappu_ClimbTowerTable<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_ClimbTowerTable>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_ClimbTowerTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_climb_tower_table_unchecked`.
pub fn root_as_clz_torappu_climb_tower_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_ClimbTowerTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_ClimbTowerTable<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_ClimbTowerTable` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_climb_tower_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_climb_tower_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_ClimbTowerTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_ClimbTowerTable<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_ClimbTowerTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_ClimbTowerTable`.
pub unsafe fn root_as_clz_torappu_climb_tower_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_ClimbTowerTable<'_> {
    unsafe { flatbuffers::root_unchecked::<clz_Torappu_ClimbTowerTable>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_ClimbTowerTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_ClimbTowerTable`.
pub unsafe fn size_prefixed_root_as_clz_torappu_climb_tower_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_ClimbTowerTable<'_> {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_ClimbTowerTable>(buf) }
}
#[inline]
pub fn finish_clz_torappu_climb_tower_table_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_ClimbTowerTable<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_climb_tower_table_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_ClimbTowerTable<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
