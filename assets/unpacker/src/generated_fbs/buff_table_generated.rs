// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ABNORMAL_FLAG: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ABNORMAL_FLAG: i32 = 42;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ABNORMAL_FLAG: [enum__Torappu_AbnormalFlag; 43] = [
    enum__Torappu_AbnormalFlag::STUNNED,
    enum__Torappu_AbnormalFlag::SP_RECOVER_STOPPED,
    enum__Torappu_AbnormalFlag::TARGET_FREE,
    enum__Torappu_AbnormalFlag::BLOCK_FREE,
    enum__Torappu_AbnormalFlag::HIDDEN,
    enum__Torappu_AbnormalFlag::INVINCIBLE,
    enum__Torappu_AbnormalFlag::UNDEADABLE,
    enum__Torappu_AbnormalFlag::HEAL_FREE,
    enum__Torappu_AbnormalFlag::UNBALANCE_IMMUNE,
    enum__Torappu_AbnormalFlag::INVISIBLE,
    enum__Torappu_AbnormalFlag::UNUSED_PLACEHOLDER_1,
    enum__Torappu_AbnormalFlag::DISARMED,
    enum__Torappu_AbnormalFlag::SILENCED,
    enum__Torappu_AbnormalFlag::UNMOVABLE,
    enum__Torappu_AbnormalFlag::UNUSED_PLACEHOLDER_2,
    enum__Torappu_AbnormalFlag::ALLY_TARGET_FREE,
    enum__Torappu_AbnormalFlag::FROZEN,
    enum__Torappu_AbnormalFlag::CAMOUFLAGE,
    enum__Torappu_AbnormalFlag::FORCE_DISARMED,
    enum__Torappu_AbnormalFlag::STUNNED_NO_AMPLIFY_DAMAGE,
    enum__Torappu_AbnormalFlag::DISABLE_COMBAT,
    enum__Torappu_AbnormalFlag::ELEMENT_FREE_ALL,
    enum__Torappu_AbnormalFlag::UNMOVABLE_PRIVATE,
    enum__Torappu_AbnormalFlag::COLD,
    enum__Torappu_AbnormalFlag::SKILL_NOT_ACTIVATABLE,
    enum__Torappu_AbnormalFlag::LEVITATE,
    enum__Torappu_AbnormalFlag::DURANCE,
    enum__Torappu_AbnormalFlag::NOT_WITHDRAWABLE,
    enum__Torappu_AbnormalFlag::OUT_OF_GROUND,
    enum__Torappu_AbnormalFlag::SP_MODIFY_STOPPED,
    enum__Torappu_AbnormalFlag::ANTI_STATUS_RESISTABLE,
    enum__Torappu_AbnormalFlag::DISARMED_COMBAT,
    enum__Torappu_AbnormalFlag::TOWER_TARGET_FREE,
    enum__Torappu_AbnormalFlag::FEARED,
    enum__Torappu_AbnormalFlag::SKILL_ACTIVABLE_IN_ABNORMAL,
    enum__Torappu_AbnormalFlag::MOTION_TARGET_FREE,
    enum__Torappu_AbnormalFlag::FORCE_LEVITATE,
    enum__Torappu_AbnormalFlag::BUFF_ADD_CAN_BE_CANCELED_IF_DEFENSE,
    enum__Torappu_AbnormalFlag::DEFENSE_BUFF_ADD_IF_CANCELABLE_BUFF,
    enum__Torappu_AbnormalFlag::PALSY,
    enum__Torappu_AbnormalFlag::PALSYING,
    enum__Torappu_AbnormalFlag::ATTRACTED,
    enum__Torappu_AbnormalFlag::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_AbnormalFlag(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_AbnormalFlag {
    pub const STUNNED: Self = Self(0);
    pub const SP_RECOVER_STOPPED: Self = Self(1);
    pub const TARGET_FREE: Self = Self(2);
    pub const BLOCK_FREE: Self = Self(3);
    pub const HIDDEN: Self = Self(4);
    pub const INVINCIBLE: Self = Self(5);
    pub const UNDEADABLE: Self = Self(6);
    pub const HEAL_FREE: Self = Self(7);
    pub const UNBALANCE_IMMUNE: Self = Self(8);
    pub const INVISIBLE: Self = Self(9);
    pub const UNUSED_PLACEHOLDER_1: Self = Self(10);
    pub const DISARMED: Self = Self(11);
    pub const SILENCED: Self = Self(12);
    pub const UNMOVABLE: Self = Self(13);
    pub const UNUSED_PLACEHOLDER_2: Self = Self(14);
    pub const ALLY_TARGET_FREE: Self = Self(15);
    pub const FROZEN: Self = Self(16);
    pub const CAMOUFLAGE: Self = Self(17);
    pub const FORCE_DISARMED: Self = Self(18);
    pub const STUNNED_NO_AMPLIFY_DAMAGE: Self = Self(19);
    pub const DISABLE_COMBAT: Self = Self(20);
    pub const ELEMENT_FREE_ALL: Self = Self(21);
    pub const UNMOVABLE_PRIVATE: Self = Self(22);
    pub const COLD: Self = Self(23);
    pub const SKILL_NOT_ACTIVATABLE: Self = Self(24);
    pub const LEVITATE: Self = Self(25);
    pub const DURANCE: Self = Self(26);
    pub const NOT_WITHDRAWABLE: Self = Self(27);
    pub const OUT_OF_GROUND: Self = Self(28);
    pub const SP_MODIFY_STOPPED: Self = Self(29);
    pub const ANTI_STATUS_RESISTABLE: Self = Self(30);
    pub const DISARMED_COMBAT: Self = Self(31);
    pub const TOWER_TARGET_FREE: Self = Self(32);
    pub const FEARED: Self = Self(33);
    pub const SKILL_ACTIVABLE_IN_ABNORMAL: Self = Self(34);
    pub const MOTION_TARGET_FREE: Self = Self(35);
    pub const FORCE_LEVITATE: Self = Self(36);
    pub const BUFF_ADD_CAN_BE_CANCELED_IF_DEFENSE: Self = Self(37);
    pub const DEFENSE_BUFF_ADD_IF_CANCELABLE_BUFF: Self = Self(38);
    pub const PALSY: Self = Self(39);
    pub const PALSYING: Self = Self(40);
    pub const ATTRACTED: Self = Self(41);
    pub const E_NUM: Self = Self(42);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 42;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::STUNNED,
        Self::SP_RECOVER_STOPPED,
        Self::TARGET_FREE,
        Self::BLOCK_FREE,
        Self::HIDDEN,
        Self::INVINCIBLE,
        Self::UNDEADABLE,
        Self::HEAL_FREE,
        Self::UNBALANCE_IMMUNE,
        Self::INVISIBLE,
        Self::UNUSED_PLACEHOLDER_1,
        Self::DISARMED,
        Self::SILENCED,
        Self::UNMOVABLE,
        Self::UNUSED_PLACEHOLDER_2,
        Self::ALLY_TARGET_FREE,
        Self::FROZEN,
        Self::CAMOUFLAGE,
        Self::FORCE_DISARMED,
        Self::STUNNED_NO_AMPLIFY_DAMAGE,
        Self::DISABLE_COMBAT,
        Self::ELEMENT_FREE_ALL,
        Self::UNMOVABLE_PRIVATE,
        Self::COLD,
        Self::SKILL_NOT_ACTIVATABLE,
        Self::LEVITATE,
        Self::DURANCE,
        Self::NOT_WITHDRAWABLE,
        Self::OUT_OF_GROUND,
        Self::SP_MODIFY_STOPPED,
        Self::ANTI_STATUS_RESISTABLE,
        Self::DISARMED_COMBAT,
        Self::TOWER_TARGET_FREE,
        Self::FEARED,
        Self::SKILL_ACTIVABLE_IN_ABNORMAL,
        Self::MOTION_TARGET_FREE,
        Self::FORCE_LEVITATE,
        Self::BUFF_ADD_CAN_BE_CANCELED_IF_DEFENSE,
        Self::DEFENSE_BUFF_ADD_IF_CANCELABLE_BUFF,
        Self::PALSY,
        Self::PALSYING,
        Self::ATTRACTED,
        Self::E_NUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::STUNNED => Some("STUNNED"),
            Self::SP_RECOVER_STOPPED => Some("SP_RECOVER_STOPPED"),
            Self::TARGET_FREE => Some("TARGET_FREE"),
            Self::BLOCK_FREE => Some("BLOCK_FREE"),
            Self::HIDDEN => Some("HIDDEN"),
            Self::INVINCIBLE => Some("INVINCIBLE"),
            Self::UNDEADABLE => Some("UNDEADABLE"),
            Self::HEAL_FREE => Some("HEAL_FREE"),
            Self::UNBALANCE_IMMUNE => Some("UNBALANCE_IMMUNE"),
            Self::INVISIBLE => Some("INVISIBLE"),
            Self::UNUSED_PLACEHOLDER_1 => Some("UNUSED_PLACEHOLDER_1"),
            Self::DISARMED => Some("DISARMED"),
            Self::SILENCED => Some("SILENCED"),
            Self::UNMOVABLE => Some("UNMOVABLE"),
            Self::UNUSED_PLACEHOLDER_2 => Some("UNUSED_PLACEHOLDER_2"),
            Self::ALLY_TARGET_FREE => Some("ALLY_TARGET_FREE"),
            Self::FROZEN => Some("FROZEN"),
            Self::CAMOUFLAGE => Some("CAMOUFLAGE"),
            Self::FORCE_DISARMED => Some("FORCE_DISARMED"),
            Self::STUNNED_NO_AMPLIFY_DAMAGE => Some("STUNNED_NO_AMPLIFY_DAMAGE"),
            Self::DISABLE_COMBAT => Some("DISABLE_COMBAT"),
            Self::ELEMENT_FREE_ALL => Some("ELEMENT_FREE_ALL"),
            Self::UNMOVABLE_PRIVATE => Some("UNMOVABLE_PRIVATE"),
            Self::COLD => Some("COLD"),
            Self::SKILL_NOT_ACTIVATABLE => Some("SKILL_NOT_ACTIVATABLE"),
            Self::LEVITATE => Some("LEVITATE"),
            Self::DURANCE => Some("DURANCE"),
            Self::NOT_WITHDRAWABLE => Some("NOT_WITHDRAWABLE"),
            Self::OUT_OF_GROUND => Some("OUT_OF_GROUND"),
            Self::SP_MODIFY_STOPPED => Some("SP_MODIFY_STOPPED"),
            Self::ANTI_STATUS_RESISTABLE => Some("ANTI_STATUS_RESISTABLE"),
            Self::DISARMED_COMBAT => Some("DISARMED_COMBAT"),
            Self::TOWER_TARGET_FREE => Some("TOWER_TARGET_FREE"),
            Self::FEARED => Some("FEARED"),
            Self::SKILL_ACTIVABLE_IN_ABNORMAL => Some("SKILL_ACTIVABLE_IN_ABNORMAL"),
            Self::MOTION_TARGET_FREE => Some("MOTION_TARGET_FREE"),
            Self::FORCE_LEVITATE => Some("FORCE_LEVITATE"),
            Self::BUFF_ADD_CAN_BE_CANCELED_IF_DEFENSE => {
                Some("BUFF_ADD_CAN_BE_CANCELED_IF_DEFENSE")
            }
            Self::DEFENSE_BUFF_ADD_IF_CANCELABLE_BUFF => {
                Some("DEFENSE_BUFF_ADD_IF_CANCELABLE_BUFF")
            }
            Self::PALSY => Some("PALSY"),
            Self::PALSYING => Some("PALSYING"),
            Self::ATTRACTED => Some("ATTRACTED"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_AbnormalFlag {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_AbnormalFlag {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_AbnormalFlag",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_AbnormalFlag {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_AbnormalFlag {
    type Output = enum__Torappu_AbnormalFlag;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_AbnormalFlag {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_AbnormalFlag {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_AbnormalFlag {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ABNORMAL_COMBO: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ABNORMAL_COMBO: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ABNORMAL_COMBO: [enum__Torappu_AbnormalCombo; 3] = [
    enum__Torappu_AbnormalCombo::SLEEPING,
    enum__Torappu_AbnormalCombo::SHELTERING,
    enum__Torappu_AbnormalCombo::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_AbnormalCombo(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_AbnormalCombo {
    pub const SLEEPING: Self = Self(0);
    pub const SHELTERING: Self = Self(1);
    pub const E_NUM: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::SLEEPING, Self::SHELTERING, Self::E_NUM];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::SLEEPING => Some("SLEEPING"),
            Self::SHELTERING => Some("SHELTERING"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_AbnormalCombo {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_AbnormalCombo {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_AbnormalCombo",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_AbnormalCombo {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_AbnormalCombo {
    type Output = enum__Torappu_AbnormalCombo;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_AbnormalCombo {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_AbnormalCombo {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_AbnormalCombo {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ATTRIBUTE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ATTRIBUTE_TYPE: i32 = 36;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ATTRIBUTE_TYPE: [enum__Torappu_AttributeType; 37] = [
    enum__Torappu_AttributeType::MAX_HP,
    enum__Torappu_AttributeType::ATK,
    enum__Torappu_AttributeType::DEF,
    enum__Torappu_AttributeType::MAGIC_RESISTANCE,
    enum__Torappu_AttributeType::COST,
    enum__Torappu_AttributeType::BLOCK_CNT,
    enum__Torappu_AttributeType::MOVE_SPEED,
    enum__Torappu_AttributeType::ATTACK_SPEED,
    enum__Torappu_AttributeType::BASE_ATTACK_TIME,
    enum__Torappu_AttributeType::RESERVED_0,
    enum__Torappu_AttributeType::RESERVED_1,
    enum__Torappu_AttributeType::RESERVED_2,
    enum__Torappu_AttributeType::RESERVED_3,
    enum__Torappu_AttributeType::HP_RECOVERY_PER_SEC,
    enum__Torappu_AttributeType::SP_RECOVERY_PER_SEC,
    enum__Torappu_AttributeType::ABILITY_RANGE_FORWARD_EXTEND,
    enum__Torappu_AttributeType::MAX_DEPLOY_COUNT,
    enum__Torappu_AttributeType::DEF_PENETRATE,
    enum__Torappu_AttributeType::MAGIC_RESIST_PENETRATE,
    enum__Torappu_AttributeType::HP_RECOVERY_PER_SEC_BY_MAX_HP_RATIO,
    enum__Torappu_AttributeType::TAUNT_LEVEL,
    enum__Torappu_AttributeType::RESPAWN_TIME,
    enum__Torappu_AttributeType::MAX_DECK_STACK_CNT,
    enum__Torappu_AttributeType::MASS_LEVEL,
    enum__Torappu_AttributeType::BASE_FORCE_LEVEL,
    enum__Torappu_AttributeType::DEF_PENETRATE_FIXED,
    enum__Torappu_AttributeType::ONE_MINUS_STATUS_RESISTANCE,
    enum__Torappu_AttributeType::MAGIC_RESIST_PENETRATE_FIXED,
    enum__Torappu_AttributeType::MAX_EP,
    enum__Torappu_AttributeType::EP_RECOVERY_PER_SEC,
    enum__Torappu_AttributeType::SP_RECOVER_RATIO,
    enum__Torappu_AttributeType::EP_DAMAGE_RESISTANCE,
    enum__Torappu_AttributeType::EP_RESISTANCE,
    enum__Torappu_AttributeType::DAMAGE_HITRATE_PHYSICAL,
    enum__Torappu_AttributeType::DAMAGE_HITRATE_MAGICAL,
    enum__Torappu_AttributeType::EP_BREAK_RECOVER_SPEED,
    enum__Torappu_AttributeType::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_AttributeType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_AttributeType {
    pub const MAX_HP: Self = Self(0);
    pub const ATK: Self = Self(1);
    pub const DEF: Self = Self(2);
    pub const MAGIC_RESISTANCE: Self = Self(3);
    pub const COST: Self = Self(4);
    pub const BLOCK_CNT: Self = Self(5);
    pub const MOVE_SPEED: Self = Self(6);
    pub const ATTACK_SPEED: Self = Self(7);
    pub const BASE_ATTACK_TIME: Self = Self(8);
    pub const RESERVED_0: Self = Self(9);
    pub const RESERVED_1: Self = Self(10);
    pub const RESERVED_2: Self = Self(11);
    pub const RESERVED_3: Self = Self(12);
    pub const HP_RECOVERY_PER_SEC: Self = Self(13);
    pub const SP_RECOVERY_PER_SEC: Self = Self(14);
    pub const ABILITY_RANGE_FORWARD_EXTEND: Self = Self(15);
    pub const MAX_DEPLOY_COUNT: Self = Self(16);
    pub const DEF_PENETRATE: Self = Self(17);
    pub const MAGIC_RESIST_PENETRATE: Self = Self(18);
    pub const HP_RECOVERY_PER_SEC_BY_MAX_HP_RATIO: Self = Self(19);
    pub const TAUNT_LEVEL: Self = Self(20);
    pub const RESPAWN_TIME: Self = Self(21);
    pub const MAX_DECK_STACK_CNT: Self = Self(22);
    pub const MASS_LEVEL: Self = Self(23);
    pub const BASE_FORCE_LEVEL: Self = Self(24);
    pub const DEF_PENETRATE_FIXED: Self = Self(25);
    pub const ONE_MINUS_STATUS_RESISTANCE: Self = Self(26);
    pub const MAGIC_RESIST_PENETRATE_FIXED: Self = Self(27);
    pub const MAX_EP: Self = Self(28);
    pub const EP_RECOVERY_PER_SEC: Self = Self(29);
    pub const SP_RECOVER_RATIO: Self = Self(30);
    pub const EP_DAMAGE_RESISTANCE: Self = Self(31);
    pub const EP_RESISTANCE: Self = Self(32);
    pub const DAMAGE_HITRATE_PHYSICAL: Self = Self(33);
    pub const DAMAGE_HITRATE_MAGICAL: Self = Self(34);
    pub const EP_BREAK_RECOVER_SPEED: Self = Self(35);
    pub const E_NUM: Self = Self(36);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 36;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::MAX_HP,
        Self::ATK,
        Self::DEF,
        Self::MAGIC_RESISTANCE,
        Self::COST,
        Self::BLOCK_CNT,
        Self::MOVE_SPEED,
        Self::ATTACK_SPEED,
        Self::BASE_ATTACK_TIME,
        Self::RESERVED_0,
        Self::RESERVED_1,
        Self::RESERVED_2,
        Self::RESERVED_3,
        Self::HP_RECOVERY_PER_SEC,
        Self::SP_RECOVERY_PER_SEC,
        Self::ABILITY_RANGE_FORWARD_EXTEND,
        Self::MAX_DEPLOY_COUNT,
        Self::DEF_PENETRATE,
        Self::MAGIC_RESIST_PENETRATE,
        Self::HP_RECOVERY_PER_SEC_BY_MAX_HP_RATIO,
        Self::TAUNT_LEVEL,
        Self::RESPAWN_TIME,
        Self::MAX_DECK_STACK_CNT,
        Self::MASS_LEVEL,
        Self::BASE_FORCE_LEVEL,
        Self::DEF_PENETRATE_FIXED,
        Self::ONE_MINUS_STATUS_RESISTANCE,
        Self::MAGIC_RESIST_PENETRATE_FIXED,
        Self::MAX_EP,
        Self::EP_RECOVERY_PER_SEC,
        Self::SP_RECOVER_RATIO,
        Self::EP_DAMAGE_RESISTANCE,
        Self::EP_RESISTANCE,
        Self::DAMAGE_HITRATE_PHYSICAL,
        Self::DAMAGE_HITRATE_MAGICAL,
        Self::EP_BREAK_RECOVER_SPEED,
        Self::E_NUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::MAX_HP => Some("MAX_HP"),
            Self::ATK => Some("ATK"),
            Self::DEF => Some("DEF"),
            Self::MAGIC_RESISTANCE => Some("MAGIC_RESISTANCE"),
            Self::COST => Some("COST"),
            Self::BLOCK_CNT => Some("BLOCK_CNT"),
            Self::MOVE_SPEED => Some("MOVE_SPEED"),
            Self::ATTACK_SPEED => Some("ATTACK_SPEED"),
            Self::BASE_ATTACK_TIME => Some("BASE_ATTACK_TIME"),
            Self::RESERVED_0 => Some("RESERVED_0"),
            Self::RESERVED_1 => Some("RESERVED_1"),
            Self::RESERVED_2 => Some("RESERVED_2"),
            Self::RESERVED_3 => Some("RESERVED_3"),
            Self::HP_RECOVERY_PER_SEC => Some("HP_RECOVERY_PER_SEC"),
            Self::SP_RECOVERY_PER_SEC => Some("SP_RECOVERY_PER_SEC"),
            Self::ABILITY_RANGE_FORWARD_EXTEND => Some("ABILITY_RANGE_FORWARD_EXTEND"),
            Self::MAX_DEPLOY_COUNT => Some("MAX_DEPLOY_COUNT"),
            Self::DEF_PENETRATE => Some("DEF_PENETRATE"),
            Self::MAGIC_RESIST_PENETRATE => Some("MAGIC_RESIST_PENETRATE"),
            Self::HP_RECOVERY_PER_SEC_BY_MAX_HP_RATIO => {
                Some("HP_RECOVERY_PER_SEC_BY_MAX_HP_RATIO")
            }
            Self::TAUNT_LEVEL => Some("TAUNT_LEVEL"),
            Self::RESPAWN_TIME => Some("RESPAWN_TIME"),
            Self::MAX_DECK_STACK_CNT => Some("MAX_DECK_STACK_CNT"),
            Self::MASS_LEVEL => Some("MASS_LEVEL"),
            Self::BASE_FORCE_LEVEL => Some("BASE_FORCE_LEVEL"),
            Self::DEF_PENETRATE_FIXED => Some("DEF_PENETRATE_FIXED"),
            Self::ONE_MINUS_STATUS_RESISTANCE => Some("ONE_MINUS_STATUS_RESISTANCE"),
            Self::MAGIC_RESIST_PENETRATE_FIXED => Some("MAGIC_RESIST_PENETRATE_FIXED"),
            Self::MAX_EP => Some("MAX_EP"),
            Self::EP_RECOVERY_PER_SEC => Some("EP_RECOVERY_PER_SEC"),
            Self::SP_RECOVER_RATIO => Some("SP_RECOVER_RATIO"),
            Self::EP_DAMAGE_RESISTANCE => Some("EP_DAMAGE_RESISTANCE"),
            Self::EP_RESISTANCE => Some("EP_RESISTANCE"),
            Self::DAMAGE_HITRATE_PHYSICAL => Some("DAMAGE_HITRATE_PHYSICAL"),
            Self::DAMAGE_HITRATE_MAGICAL => Some("DAMAGE_HITRATE_MAGICAL"),
            Self::EP_BREAK_RECOVER_SPEED => Some("EP_BREAK_RECOVER_SPEED"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_AttributeType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_AttributeType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_AttributeType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_AttributeType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_AttributeType {
    type Output = enum__Torappu_AttributeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_AttributeType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_AttributeType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_AttributeType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ATTRIBUTE_MODIFIER_DATA_ATTRIBUTE_MODIFIER_FORMULA_ITEM_TYPE: i32 =
    0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ATTRIBUTE_MODIFIER_DATA_ATTRIBUTE_MODIFIER_FORMULA_ITEM_TYPE: i32 =
    3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ATTRIBUTE_MODIFIER_DATA_ATTRIBUTE_MODIFIER_FORMULA_ITEM_TYPE:
    [enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType; 4] = [
    enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType::ADDITION,
    enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType::MULTIPLIER,
    enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType::FINAL_ADDITION,
    enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType::FINAL_SCALER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType {
    pub const ADDITION: Self = Self(0);
    pub const MULTIPLIER: Self = Self(1);
    pub const FINAL_ADDITION: Self = Self(2);
    pub const FINAL_SCALER: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::ADDITION,
        Self::MULTIPLIER,
        Self::FINAL_ADDITION,
        Self::FINAL_SCALER,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ADDITION => Some("ADDITION"),
            Self::MULTIPLIER => Some("MULTIPLIER"),
            Self::FINAL_ADDITION => Some("FINAL_ADDITION"),
            Self::FINAL_SCALER => Some("FINAL_SCALER"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a>
    for enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType
{
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType {
    type Output = enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar
    for enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType
{
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable
    for enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice
    for enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType
{
}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUFF_DATA_STATUS_RESISTABLE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUFF_DATA_STATUS_RESISTABLE: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUFF_DATA_STATUS_RESISTABLE:
    [enum__Torappu_BuffData_StatusResistable; 3] = [
    enum__Torappu_BuffData_StatusResistable::NO,
    enum__Torappu_BuffData_StatusResistable::YES,
    enum__Torappu_BuffData_StatusResistable::AUTOMATIC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuffData_StatusResistable(pub u8);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuffData_StatusResistable {
    pub const NO: Self = Self(0);
    pub const YES: Self = Self(1);
    pub const AUTOMATIC: Self = Self(2);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NO, Self::YES, Self::AUTOMATIC];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NO => Some("NO"),
            Self::YES => Some("YES"),
            Self::AUTOMATIC => Some("AUTOMATIC"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuffData_StatusResistable {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_BuffData_StatusResistable {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_BuffData_StatusResistable",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuffData_StatusResistable {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuffData_StatusResistable {
    type Output = enum__Torappu_BuffData_StatusResistable;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuffData_StatusResistable {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuffData_StatusResistable {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuffData_StatusResistable {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUFF_DATA_OVERRIDE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUFF_DATA_OVERRIDE_TYPE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUFF_DATA_OVERRIDE_TYPE: [enum__Torappu_BuffData_OverrideType;
    5] = [
    enum__Torappu_BuffData_OverrideType::DEFAULT,
    enum__Torappu_BuffData_OverrideType::STACK,
    enum__Torappu_BuffData_OverrideType::UNIQUE,
    enum__Torappu_BuffData_OverrideType::EXTEND,
    enum__Torappu_BuffData_OverrideType::EXTEND_TIME,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuffData_OverrideType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuffData_OverrideType {
    pub const DEFAULT: Self = Self(0);
    pub const STACK: Self = Self(1);
    pub const UNIQUE: Self = Self(2);
    pub const EXTEND: Self = Self(3);
    pub const EXTEND_TIME: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::DEFAULT,
        Self::STACK,
        Self::UNIQUE,
        Self::EXTEND,
        Self::EXTEND_TIME,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::DEFAULT => Some("DEFAULT"),
            Self::STACK => Some("STACK"),
            Self::UNIQUE => Some("UNIQUE"),
            Self::EXTEND => Some("EXTEND"),
            Self::EXTEND_TIME => Some("EXTEND_TIME"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuffData_OverrideType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_BuffData_OverrideType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_BuffData_OverrideType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuffData_OverrideType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuffData_OverrideType {
    type Output = enum__Torappu_BuffData_OverrideType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuffData_OverrideType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuffData_OverrideType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuffData_OverrideType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUFF_DATA_ON_EVENT_PRIORITY: i32 = -3000;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUFF_DATA_ON_EVENT_PRIORITY: i32 = 2000;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUFF_DATA_ON_EVENT_PRIORITY:
    [enum__Torappu_BuffData_OnEventPriority; 6] = [
    enum__Torappu_BuffData_OnEventPriority::LOWEST_PRIORITY,
    enum__Torappu_BuffData_OnEventPriority::LOWER_PRIORITY,
    enum__Torappu_BuffData_OnEventPriority::LOW_PRIORITY,
    enum__Torappu_BuffData_OnEventPriority::DEFAULT,
    enum__Torappu_BuffData_OnEventPriority::HIGH_PRIORITY,
    enum__Torappu_BuffData_OnEventPriority::HIGHER_PRIORITY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuffData_OnEventPriority(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuffData_OnEventPriority {
    pub const LOWEST_PRIORITY: Self = Self(-3000);
    pub const LOWER_PRIORITY: Self = Self(-2000);
    pub const LOW_PRIORITY: Self = Self(-1000);
    pub const DEFAULT: Self = Self(0);
    pub const HIGH_PRIORITY: Self = Self(1000);
    pub const HIGHER_PRIORITY: Self = Self(2000);

    pub const ENUM_MIN: i32 = -3000;
    pub const ENUM_MAX: i32 = 2000;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::LOWEST_PRIORITY,
        Self::LOWER_PRIORITY,
        Self::LOW_PRIORITY,
        Self::DEFAULT,
        Self::HIGH_PRIORITY,
        Self::HIGHER_PRIORITY,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::LOWEST_PRIORITY => Some("LOWEST_PRIORITY"),
            Self::LOWER_PRIORITY => Some("LOWER_PRIORITY"),
            Self::LOW_PRIORITY => Some("LOW_PRIORITY"),
            Self::DEFAULT => Some("DEFAULT"),
            Self::HIGH_PRIORITY => Some("HIGH_PRIORITY"),
            Self::HIGHER_PRIORITY => Some("HIGHER_PRIORITY"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuffData_OnEventPriority {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_BuffData_OnEventPriority {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_BuffData_OnEventPriority",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuffData_OnEventPriority {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuffData_OnEventPriority {
    type Output = enum__Torappu_BuffData_OnEventPriority;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuffData_OnEventPriority {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuffData_OnEventPriority {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuffData_OnEventPriority {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_LIFE_TYPE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_LIFE_TYPE: u8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_LIFE_TYPE: [enum__Torappu_LifeType; 4] = [
    enum__Torappu_LifeType::IMMEDIATELY,
    enum__Torappu_LifeType::LIMITED,
    enum__Torappu_LifeType::INFINITY,
    enum__Torappu_LifeType::CUSTOM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_LifeType(pub u8);
#[allow(non_upper_case_globals)]
impl enum__Torappu_LifeType {
    pub const IMMEDIATELY: Self = Self(0);
    pub const LIMITED: Self = Self(1);
    pub const INFINITY: Self = Self(2);
    pub const CUSTOM: Self = Self(3);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::IMMEDIATELY,
        Self::LIMITED,
        Self::INFINITY,
        Self::CUSTOM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::IMMEDIATELY => Some("IMMEDIATELY"),
            Self::LIMITED => Some("LIMITED"),
            Self::INFINITY => Some("INFINITY"),
            Self::CUSTOM => Some("CUSTOM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_LifeType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_LifeType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_LifeType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_LifeType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_LifeType {
    type Output = enum__Torappu_LifeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_LifeType {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_LifeType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_LifeType {}
pub enum clz_Torappu_AttributeModifierData_AttributeModifierOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_AttributeModifierData_AttributeModifier<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_AttributeModifierData_AttributeModifier<'a> {
    type Inner = clz_Torappu_AttributeModifierData_AttributeModifier<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_AttributeModifierData_AttributeModifier<'a> {
    pub const VT_ATTRIBUTETYPE: flatbuffers::VOffsetT = 4;
    pub const VT_FORMULAITEM: flatbuffers::VOffsetT = 6;
    pub const VT_VALUE: flatbuffers::VOffsetT = 8;
    pub const VT_LOADFROMBLACKBOARD: flatbuffers::VOffsetT = 10;
    pub const VT_FETCHBASEVALUEFROMSOURCEENTITY: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_AttributeModifierData_AttributeModifier { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_AttributeModifierData_AttributeModifierArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_AttributeModifierData_AttributeModifier<'bldr>> {
        let mut builder = clz_Torappu_AttributeModifierData_AttributeModifierBuilder::new(_fbb);
        builder.add_value(args.value);
        builder.add_formulaItem(args.formulaItem);
        builder.add_attributeType(args.attributeType);
        builder.add_fetchBaseValueFromSourceEntity(args.fetchBaseValueFromSourceEntity);
        builder.add_loadFromBlackboard(args.loadFromBlackboard);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_AttributeModifierData_AttributeModifierT {
        let attributeType = self.attributeType();
        let formulaItem = self.formulaItem();
        let value = self.value();
        let loadFromBlackboard = self.loadFromBlackboard();
        let fetchBaseValueFromSourceEntity = self.fetchBaseValueFromSourceEntity();
        clz_Torappu_AttributeModifierData_AttributeModifierT {
            attributeType,
            formulaItem,
            value,
            loadFromBlackboard,
            fetchBaseValueFromSourceEntity,
        }
    }

    #[inline]
    pub fn attributeType(&self) -> enum__Torappu_AttributeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_AttributeType>(
                    clz_Torappu_AttributeModifierData_AttributeModifier::VT_ATTRIBUTETYPE,
                    Some(enum__Torappu_AttributeType::MAX_HP),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn formulaItem(
        &self,
    ) -> enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType>(clz_Torappu_AttributeModifierData_AttributeModifier::VT_FORMULAITEM, Some(enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType::ADDITION)).unwrap()
        }
    }
    #[inline]
    pub fn value(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_AttributeModifierData_AttributeModifier::VT_VALUE,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn loadFromBlackboard(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_AttributeModifierData_AttributeModifier::VT_LOADFROMBLACKBOARD,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn fetchBaseValueFromSourceEntity(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<bool>(clz_Torappu_AttributeModifierData_AttributeModifier::VT_FETCHBASEVALUEFROMSOURCEENTITY, Some(false)).unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_AttributeModifierData_AttributeModifier<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_AttributeType>(
                "attributeType",
                Self::VT_ATTRIBUTETYPE,
                false,
            )?
            .visit_field::<enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType>(
                "formulaItem",
                Self::VT_FORMULAITEM,
                false,
            )?
            .visit_field::<f32>("value", Self::VT_VALUE, false)?
            .visit_field::<bool>("loadFromBlackboard", Self::VT_LOADFROMBLACKBOARD, false)?
            .visit_field::<bool>(
                "fetchBaseValueFromSourceEntity",
                Self::VT_FETCHBASEVALUEFROMSOURCEENTITY,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_AttributeModifierData_AttributeModifierArgs {
    pub attributeType: enum__Torappu_AttributeType,
    pub formulaItem: enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType,
    pub value: f32,
    pub loadFromBlackboard: bool,
    pub fetchBaseValueFromSourceEntity: bool,
}
impl<'a> Default for clz_Torappu_AttributeModifierData_AttributeModifierArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_AttributeModifierData_AttributeModifierArgs {
            attributeType: enum__Torappu_AttributeType::MAX_HP,
            formulaItem:
                enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType::ADDITION,
            value: 0.0,
            loadFromBlackboard: false,
            fetchBaseValueFromSourceEntity: false,
        }
    }
}

impl Serialize for clz_Torappu_AttributeModifierData_AttributeModifier<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("clz_Torappu_AttributeModifierData_AttributeModifier", 5)?;
        s.serialize_field("attributeType", &self.attributeType())?;
        s.serialize_field("formulaItem", &self.formulaItem())?;
        s.serialize_field("value", &self.value())?;
        s.serialize_field("loadFromBlackboard", &self.loadFromBlackboard())?;
        s.serialize_field(
            "fetchBaseValueFromSourceEntity",
            &self.fetchBaseValueFromSourceEntity(),
        )?;
        s.end()
    }
}

pub struct clz_Torappu_AttributeModifierData_AttributeModifierBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_AttributeModifierData_AttributeModifierBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_attributeType(&mut self, attributeType: enum__Torappu_AttributeType) {
        self.fbb_.push_slot::<enum__Torappu_AttributeType>(
            clz_Torappu_AttributeModifierData_AttributeModifier::VT_ATTRIBUTETYPE,
            attributeType,
            enum__Torappu_AttributeType::MAX_HP,
        );
    }
    #[inline]
    pub fn add_formulaItem(
        &mut self,
        formulaItem: enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType>(
                clz_Torappu_AttributeModifierData_AttributeModifier::VT_FORMULAITEM,
                formulaItem,
                enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType::ADDITION,
            );
    }
    #[inline]
    pub fn add_value(&mut self, value: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_AttributeModifierData_AttributeModifier::VT_VALUE,
            value,
            0.0,
        );
    }
    #[inline]
    pub fn add_loadFromBlackboard(&mut self, loadFromBlackboard: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributeModifierData_AttributeModifier::VT_LOADFROMBLACKBOARD,
            loadFromBlackboard,
            false,
        );
    }
    #[inline]
    pub fn add_fetchBaseValueFromSourceEntity(&mut self, fetchBaseValueFromSourceEntity: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributeModifierData_AttributeModifier::VT_FETCHBASEVALUEFROMSOURCEENTITY,
            fetchBaseValueFromSourceEntity,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_AttributeModifierData_AttributeModifierBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_AttributeModifierData_AttributeModifierBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_AttributeModifierData_AttributeModifier<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_AttributeModifierData_AttributeModifier<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_AttributeModifierData_AttributeModifier");
        ds.field("attributeType", &self.attributeType());
        ds.field("formulaItem", &self.formulaItem());
        ds.field("value", &self.value());
        ds.field("loadFromBlackboard", &self.loadFromBlackboard());
        ds.field(
            "fetchBaseValueFromSourceEntity",
            &self.fetchBaseValueFromSourceEntity(),
        );
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_AttributeModifierData_AttributeModifierT {
    pub attributeType: enum__Torappu_AttributeType,
    pub formulaItem: enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType,
    pub value: f32,
    pub loadFromBlackboard: bool,
    pub fetchBaseValueFromSourceEntity: bool,
}
impl Default for clz_Torappu_AttributeModifierData_AttributeModifierT {
    fn default() -> Self {
        Self {
            attributeType: enum__Torappu_AttributeType::MAX_HP,
            formulaItem:
                enum__Torappu_AttributeModifierData_AttributeModifier_FormulaItemType::ADDITION,
            value: 0.0,
            loadFromBlackboard: false,
            fetchBaseValueFromSourceEntity: false,
        }
    }
}
impl clz_Torappu_AttributeModifierData_AttributeModifierT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_AttributeModifierData_AttributeModifier<'b>> {
        let attributeType = self.attributeType;
        let formulaItem = self.formulaItem;
        let value = self.value;
        let loadFromBlackboard = self.loadFromBlackboard;
        let fetchBaseValueFromSourceEntity = self.fetchBaseValueFromSourceEntity;
        clz_Torappu_AttributeModifierData_AttributeModifier::create(
            _fbb,
            &clz_Torappu_AttributeModifierData_AttributeModifierArgs {
                attributeType,
                formulaItem,
                value,
                loadFromBlackboard,
                fetchBaseValueFromSourceEntity,
            },
        )
    }
}
pub enum clz_Torappu_AttributeModifierDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_AttributeModifierData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_AttributeModifierData<'a> {
    type Inner = clz_Torappu_AttributeModifierData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_AttributeModifierData<'a> {
    pub const VT_ABNORMALFLAGS: flatbuffers::VOffsetT = 4;
    pub const VT_ABNORMALIMMUNES: flatbuffers::VOffsetT = 6;
    pub const VT_ABNORMALANTIS: flatbuffers::VOffsetT = 8;
    pub const VT_ABNORMALCOMBOS: flatbuffers::VOffsetT = 10;
    pub const VT_ABNORMALCOMBOIMMUNES: flatbuffers::VOffsetT = 12;
    pub const VT_ATTRIBUTEMODIFIERS: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_AttributeModifierData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_AttributeModifierDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_AttributeModifierData<'bldr>> {
        let mut builder = clz_Torappu_AttributeModifierDataBuilder::new(_fbb);
        if let Some(x) = args.attributeModifiers {
            builder.add_attributeModifiers(x);
        }
        if let Some(x) = args.abnormalComboImmunes {
            builder.add_abnormalComboImmunes(x);
        }
        if let Some(x) = args.abnormalCombos {
            builder.add_abnormalCombos(x);
        }
        if let Some(x) = args.abnormalAntis {
            builder.add_abnormalAntis(x);
        }
        if let Some(x) = args.abnormalImmunes {
            builder.add_abnormalImmunes(x);
        }
        if let Some(x) = args.abnormalFlags {
            builder.add_abnormalFlags(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_AttributeModifierDataT {
        let abnormalFlags = self.abnormalFlags().map(|x| x.into_iter().collect());
        let abnormalImmunes = self.abnormalImmunes().map(|x| x.into_iter().collect());
        let abnormalAntis = self.abnormalAntis().map(|x| x.into_iter().collect());
        let abnormalCombos = self.abnormalCombos().map(|x| x.into_iter().collect());
        let abnormalComboImmunes = self.abnormalComboImmunes().map(|x| x.into_iter().collect());
        let attributeModifiers = self
            .attributeModifiers()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_AttributeModifierDataT {
            abnormalFlags,
            abnormalImmunes,
            abnormalAntis,
            abnormalCombos,
            abnormalComboImmunes,
            attributeModifiers,
        }
    }

    #[inline]
    pub fn abnormalFlags(&self) -> Option<flatbuffers::Vector<'a, enum__Torappu_AbnormalFlag>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_AbnormalFlag>,
            >>(clz_Torappu_AttributeModifierData::VT_ABNORMALFLAGS, None)
        }
    }
    #[inline]
    pub fn abnormalImmunes(&self) -> Option<flatbuffers::Vector<'a, enum__Torappu_AbnormalFlag>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_AbnormalFlag>,
            >>(clz_Torappu_AttributeModifierData::VT_ABNORMALIMMUNES, None)
        }
    }
    #[inline]
    pub fn abnormalAntis(&self) -> Option<flatbuffers::Vector<'a, enum__Torappu_AbnormalFlag>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_AbnormalFlag>,
            >>(clz_Torappu_AttributeModifierData::VT_ABNORMALANTIS, None)
        }
    }
    #[inline]
    pub fn abnormalCombos(&self) -> Option<flatbuffers::Vector<'a, enum__Torappu_AbnormalCombo>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_AbnormalCombo>,
            >>(clz_Torappu_AttributeModifierData::VT_ABNORMALCOMBOS, None)
        }
    }
    #[inline]
    pub fn abnormalComboImmunes(
        &self,
    ) -> Option<flatbuffers::Vector<'a, enum__Torappu_AbnormalCombo>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_AbnormalCombo>,
            >>(
                clz_Torappu_AttributeModifierData::VT_ABNORMALCOMBOIMMUNES,
                None,
            )
        }
    }
    #[inline]
    pub fn attributeModifiers(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_AttributeModifierData_AttributeModifier<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_AttributeModifierData_AttributeModifier,
                    >,
                >,
            >>(
                clz_Torappu_AttributeModifierData::VT_ATTRIBUTEMODIFIERS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_AttributeModifierData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_AbnormalFlag>>>("abnormalFlags", Self::VT_ABNORMALFLAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_AbnormalFlag>>>("abnormalImmunes", Self::VT_ABNORMALIMMUNES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_AbnormalFlag>>>("abnormalAntis", Self::VT_ABNORMALANTIS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_AbnormalCombo>>>("abnormalCombos", Self::VT_ABNORMALCOMBOS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_AbnormalCombo>>>("abnormalComboImmunes", Self::VT_ABNORMALCOMBOIMMUNES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_AttributeModifierData_AttributeModifier>>>>("attributeModifiers", Self::VT_ATTRIBUTEMODIFIERS, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_AttributeModifierDataArgs<'a> {
    pub abnormalFlags:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_AbnormalFlag>>>,
    pub abnormalImmunes:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_AbnormalFlag>>>,
    pub abnormalAntis:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_AbnormalFlag>>>,
    pub abnormalCombos:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_AbnormalCombo>>>,
    pub abnormalComboImmunes:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_AbnormalCombo>>>,
    pub attributeModifiers: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_AttributeModifierData_AttributeModifier<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_AttributeModifierDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_AttributeModifierDataArgs {
            abnormalFlags: None,
            abnormalImmunes: None,
            abnormalAntis: None,
            abnormalCombos: None,
            abnormalComboImmunes: None,
            attributeModifiers: None,
        }
    }
}

impl Serialize for clz_Torappu_AttributeModifierData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_AttributeModifierData", 6)?;
        if let Some(f) = self.abnormalFlags() {
            s.serialize_field("abnormalFlags", &f)?;
        } else {
            s.skip_field("abnormalFlags")?;
        }
        if let Some(f) = self.abnormalImmunes() {
            s.serialize_field("abnormalImmunes", &f)?;
        } else {
            s.skip_field("abnormalImmunes")?;
        }
        if let Some(f) = self.abnormalAntis() {
            s.serialize_field("abnormalAntis", &f)?;
        } else {
            s.skip_field("abnormalAntis")?;
        }
        if let Some(f) = self.abnormalCombos() {
            s.serialize_field("abnormalCombos", &f)?;
        } else {
            s.skip_field("abnormalCombos")?;
        }
        if let Some(f) = self.abnormalComboImmunes() {
            s.serialize_field("abnormalComboImmunes", &f)?;
        } else {
            s.skip_field("abnormalComboImmunes")?;
        }
        if let Some(f) = self.attributeModifiers() {
            s.serialize_field("attributeModifiers", &f)?;
        } else {
            s.skip_field("attributeModifiers")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_AttributeModifierDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_AttributeModifierDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_abnormalFlags(
        &mut self,
        abnormalFlags: flatbuffers::WIPOffset<flatbuffers::Vector<'b, enum__Torappu_AbnormalFlag>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_AttributeModifierData::VT_ABNORMALFLAGS,
            abnormalFlags,
        );
    }
    #[inline]
    pub fn add_abnormalImmunes(
        &mut self,
        abnormalImmunes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, enum__Torappu_AbnormalFlag>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_AttributeModifierData::VT_ABNORMALIMMUNES,
            abnormalImmunes,
        );
    }
    #[inline]
    pub fn add_abnormalAntis(
        &mut self,
        abnormalAntis: flatbuffers::WIPOffset<flatbuffers::Vector<'b, enum__Torappu_AbnormalFlag>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_AttributeModifierData::VT_ABNORMALANTIS,
            abnormalAntis,
        );
    }
    #[inline]
    pub fn add_abnormalCombos(
        &mut self,
        abnormalCombos: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, enum__Torappu_AbnormalCombo>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_AttributeModifierData::VT_ABNORMALCOMBOS,
            abnormalCombos,
        );
    }
    #[inline]
    pub fn add_abnormalComboImmunes(
        &mut self,
        abnormalComboImmunes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, enum__Torappu_AbnormalCombo>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_AttributeModifierData::VT_ABNORMALCOMBOIMMUNES,
            abnormalComboImmunes,
        );
    }
    #[inline]
    pub fn add_attributeModifiers(
        &mut self,
        attributeModifiers: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_AttributeModifierData_AttributeModifier<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_AttributeModifierData::VT_ATTRIBUTEMODIFIERS,
            attributeModifiers,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_AttributeModifierDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_AttributeModifierDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_AttributeModifierData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_AttributeModifierData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_AttributeModifierData");
        ds.field("abnormalFlags", &self.abnormalFlags());
        ds.field("abnormalImmunes", &self.abnormalImmunes());
        ds.field("abnormalAntis", &self.abnormalAntis());
        ds.field("abnormalCombos", &self.abnormalCombos());
        ds.field("abnormalComboImmunes", &self.abnormalComboImmunes());
        ds.field("attributeModifiers", &self.attributeModifiers());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_AttributeModifierDataT {
    pub abnormalFlags: Option<Vec<enum__Torappu_AbnormalFlag>>,
    pub abnormalImmunes: Option<Vec<enum__Torappu_AbnormalFlag>>,
    pub abnormalAntis: Option<Vec<enum__Torappu_AbnormalFlag>>,
    pub abnormalCombos: Option<Vec<enum__Torappu_AbnormalCombo>>,
    pub abnormalComboImmunes: Option<Vec<enum__Torappu_AbnormalCombo>>,
    pub attributeModifiers: Option<Vec<clz_Torappu_AttributeModifierData_AttributeModifierT>>,
}
impl Default for clz_Torappu_AttributeModifierDataT {
    fn default() -> Self {
        Self {
            abnormalFlags: None,
            abnormalImmunes: None,
            abnormalAntis: None,
            abnormalCombos: None,
            abnormalComboImmunes: None,
            attributeModifiers: None,
        }
    }
}
impl clz_Torappu_AttributeModifierDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_AttributeModifierData<'b>> {
        let abnormalFlags = self.abnormalFlags.as_ref().map(|x| _fbb.create_vector(x));
        let abnormalImmunes = self.abnormalImmunes.as_ref().map(|x| _fbb.create_vector(x));
        let abnormalAntis = self.abnormalAntis.as_ref().map(|x| _fbb.create_vector(x));
        let abnormalCombos = self.abnormalCombos.as_ref().map(|x| _fbb.create_vector(x));
        let abnormalComboImmunes = self
            .abnormalComboImmunes
            .as_ref()
            .map(|x| _fbb.create_vector(x));
        let attributeModifiers = self.attributeModifiers.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_AttributeModifierData::create(
            _fbb,
            &clz_Torappu_AttributeModifierDataArgs {
                abnormalFlags,
                abnormalImmunes,
                abnormalAntis,
                abnormalCombos,
                abnormalComboImmunes,
                attributeModifiers,
            },
        )
    }
}
pub enum clz_Torappu_Blackboard_DataPairOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Blackboard_DataPair<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Blackboard_DataPair<'a> {
    type Inner = clz_Torappu_Blackboard_DataPair<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Blackboard_DataPair<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;
    pub const VT_VALUESTR: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Blackboard_DataPair { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Blackboard_DataPairArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'bldr>> {
        let mut builder = clz_Torappu_Blackboard_DataPairBuilder::new(_fbb);
        if let Some(x) = args.valueStr {
            builder.add_valueStr(x);
        }
        builder.add_value(args.value);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Blackboard_DataPairT {
        let key = self.key().map(|x| x.to_string());
        let value = self.value();
        let valueStr = self.valueStr().map(|x| x.to_string());
        clz_Torappu_Blackboard_DataPairT {
            key,
            value,
            valueStr,
        }
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_KEY,
                None,
            )
        }
    }
    #[inline]
    pub fn value(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn valueStr(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Blackboard_DataPair<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<f32>("value", Self::VT_VALUE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "valueStr",
                Self::VT_VALUESTR,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Blackboard_DataPairArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: f32,
    pub valueStr: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Blackboard_DataPairArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Blackboard_DataPairArgs {
            key: None,
            value: 0.0,
            valueStr: None,
        }
    }
}

impl Serialize for clz_Torappu_Blackboard_DataPair<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Blackboard_DataPair", 3)?;
        if let Some(f) = self.key() {
            s.serialize_field("key", &f)?;
        } else {
            s.skip_field("key")?;
        }
        s.serialize_field("value", &self.value())?;
        if let Some(f) = self.valueStr() {
            s.serialize_field("valueStr", &f)?;
        } else {
            s.skip_field("valueStr")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Blackboard_DataPairBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, value, 0.0);
    }
    #[inline]
    pub fn add_valueStr(&mut self, valueStr: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
            valueStr,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Blackboard_DataPairBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Blackboard_DataPair<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Blackboard_DataPair");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.field("valueStr", &self.valueStr());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Blackboard_DataPairT {
    pub key: Option<String>,
    pub value: f32,
    pub valueStr: Option<String>,
}
impl Default for clz_Torappu_Blackboard_DataPairT {
    fn default() -> Self {
        Self {
            key: None,
            value: 0.0,
            valueStr: None,
        }
    }
}
impl clz_Torappu_Blackboard_DataPairT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'b>> {
        let key = self.key.as_ref().map(|x| _fbb.create_string(x));
        let value = self.value;
        let valueStr = self.valueStr.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Blackboard_DataPair::create(
            _fbb,
            &clz_Torappu_Blackboard_DataPairArgs {
                key,
                value,
                valueStr,
            },
        )
    }
}
pub enum clz_Torappu_BuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuffData<'a> {
    type Inner = clz_Torappu_BuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_BuffData<'a> {
    pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 4;
    pub const VT_BUFFKEY: flatbuffers::VOffsetT = 6;
    pub const VT_LOADFROMDB: flatbuffers::VOffsetT = 8;
    pub const VT_ISDURABLEBUFF: flatbuffers::VOffsetT = 10;
    pub const VT_ISDAMAGEMISSABLE: flatbuffers::VOffsetT = 12;
    pub const VT_ISSILENCEABLE: flatbuffers::VOffsetT = 14;
    pub const VT_ISSTUNNABLE: flatbuffers::VOffsetT = 16;
    pub const VT_ISFREEZABLE: flatbuffers::VOffsetT = 18;
    pub const VT_ISLEVITATABLE: flatbuffers::VOffsetT = 20;
    pub const VT_STATUSRESISTABLE: flatbuffers::VOffsetT = 22;
    pub const VT_TEMPLATEKEY: flatbuffers::VOffsetT = 24;
    pub const VT_DISABLEOVERRIDE: flatbuffers::VOffsetT = 26;
    pub const VT_OVERRIDEKEY: flatbuffers::VOffsetT = 28;
    pub const VT_OVERRIDETYPE: flatbuffers::VOffsetT = 30;
    pub const VT_MAXSTACKCNT: flatbuffers::VOffsetT = 32;
    pub const VT_REFRESHREMAININGTIMEWHENSTACKMAX: flatbuffers::VOffsetT = 34;
    pub const VT_CLEARALLSTACKCNTWHENTIMEUP: flatbuffers::VOffsetT = 36;
    pub const VT_MAXVALIDSTACKCNT: flatbuffers::VOffsetT = 38;
    pub const VT_INDEPENDENTCHARACTERSOURCE: flatbuffers::VOffsetT = 40;
    pub const VT_OVERRIDEEFFECTKEY: flatbuffers::VOffsetT = 42;
    pub const VT_OVERRIDEONEVENTPRIORITY: flatbuffers::VOffsetT = 44;
    pub const VT_ONEVENTPRIORITY: flatbuffers::VOffsetT = 46;
    pub const VT_AUDIOSIGNAL: flatbuffers::VOffsetT = 48;
    pub const VT_LIFETIMETYPE: flatbuffers::VOffsetT = 50;
    pub const VT_TAKESNAPSHOTWHENEXTEND: flatbuffers::VOffsetT = 52;
    pub const VT_DURATIONKEY: flatbuffers::VOffsetT = 54;
    pub const VT_LIFETIME: flatbuffers::VOffsetT = 56;
    pub const VT_TRIGGERLIFETYPE: flatbuffers::VOffsetT = 58;
    pub const VT_TRIGGERCNT: flatbuffers::VOffsetT = 60;
    pub const VT_TRIGGERINTERVAL: flatbuffers::VOffsetT = 62;
    pub const VT_WAITFIRSTTRIGGERINTERVAL: flatbuffers::VOffsetT = 64;
    pub const VT_FIRSTTRIGGERINTERVAL: flatbuffers::VOffsetT = 66;
    pub const VT_PRIORITY: flatbuffers::VOffsetT = 68;
    pub const VT_PRIORITYBBKEYS: flatbuffers::VOffsetT = 70;
    pub const VT_STRIPBLACKBOARDPARAMSWITHBUFFKEY: flatbuffers::VOffsetT = 72;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 74;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuffData<'bldr>> {
        let mut builder = clz_Torappu_BuffDataBuilder::new(_fbb);
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        if let Some(x) = args.priorityBBKeys {
            builder.add_priorityBBKeys(x);
        }
        builder.add_priority(args.priority);
        builder.add_firstTriggerInterval(args.firstTriggerInterval);
        builder.add_triggerInterval(args.triggerInterval);
        builder.add_triggerCnt(args.triggerCnt);
        builder.add_lifeTime(args.lifeTime);
        if let Some(x) = args.durationKey {
            builder.add_durationKey(x);
        }
        if let Some(x) = args.audioSignal {
            builder.add_audioSignal(x);
        }
        builder.add_onEventPriority(args.onEventPriority);
        if let Some(x) = args.overrideEffectKey {
            builder.add_overrideEffectKey(x);
        }
        builder.add_maxValidStackCnt(args.maxValidStackCnt);
        builder.add_maxStackCnt(args.maxStackCnt);
        builder.add_overrideType(args.overrideType);
        if let Some(x) = args.overrideKey {
            builder.add_overrideKey(x);
        }
        if let Some(x) = args.templateKey {
            builder.add_templateKey(x);
        }
        if let Some(x) = args.buffKey {
            builder.add_buffKey(x);
        }
        if let Some(x) = args.attributes {
            builder.add_attributes(x);
        }
        builder.add_stripBlackboardParamsWithBuffKey(args.stripBlackboardParamsWithBuffKey);
        builder.add_waitFirstTriggerInterval(args.waitFirstTriggerInterval);
        builder.add_triggerLifeType(args.triggerLifeType);
        builder.add_takeSnapshotWhenExtend(args.takeSnapshotWhenExtend);
        builder.add_lifeTimeType(args.lifeTimeType);
        builder.add_overrideOnEventPriority(args.overrideOnEventPriority);
        builder.add_independentCharacterSource(args.independentCharacterSource);
        builder.add_clearAllStackCntWhenTimeUp(args.clearAllStackCntWhenTimeUp);
        builder.add_refreshRemainingTimeWhenStackMax(args.refreshRemainingTimeWhenStackMax);
        builder.add_disableOverride(args.disableOverride);
        builder.add_statusResistable(args.statusResistable);
        builder.add_isLevitatable(args.isLevitatable);
        builder.add_isFreezable(args.isFreezable);
        builder.add_isStunnable(args.isStunnable);
        builder.add_isSilenceable(args.isSilenceable);
        builder.add_isDamageMissable(args.isDamageMissable);
        builder.add_isDurableBuff(args.isDurableBuff);
        builder.add_loadFromDB(args.loadFromDB);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_BuffDataT {
        let attributes = self.attributes().map(|x| Box::new(x.unpack()));
        let buffKey = self.buffKey().map(|x| x.to_string());
        let loadFromDB = self.loadFromDB();
        let isDurableBuff = self.isDurableBuff();
        let isDamageMissable = self.isDamageMissable();
        let isSilenceable = self.isSilenceable();
        let isStunnable = self.isStunnable();
        let isFreezable = self.isFreezable();
        let isLevitatable = self.isLevitatable();
        let statusResistable = self.statusResistable();
        let templateKey = self.templateKey().map(|x| x.to_string());
        let disableOverride = self.disableOverride();
        let overrideKey = self.overrideKey().map(|x| x.to_string());
        let overrideType = self.overrideType();
        let maxStackCnt = self.maxStackCnt();
        let refreshRemainingTimeWhenStackMax = self.refreshRemainingTimeWhenStackMax();
        let clearAllStackCntWhenTimeUp = self.clearAllStackCntWhenTimeUp();
        let maxValidStackCnt = self.maxValidStackCnt();
        let independentCharacterSource = self.independentCharacterSource();
        let overrideEffectKey = self.overrideEffectKey().map(|x| x.to_string());
        let overrideOnEventPriority = self.overrideOnEventPriority();
        let onEventPriority = self.onEventPriority();
        let audioSignal = self.audioSignal().map(|x| x.to_string());
        let lifeTimeType = self.lifeTimeType();
        let takeSnapshotWhenExtend = self.takeSnapshotWhenExtend();
        let durationKey = self.durationKey().map(|x| x.to_string());
        let lifeTime = self.lifeTime();
        let triggerLifeType = self.triggerLifeType();
        let triggerCnt = self.triggerCnt();
        let triggerInterval = self.triggerInterval();
        let waitFirstTriggerInterval = self.waitFirstTriggerInterval();
        let firstTriggerInterval = self.firstTriggerInterval();
        let priority = self.priority();
        let priorityBBKeys = self
            .priorityBBKeys()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let stripBlackboardParamsWithBuffKey = self.stripBlackboardParamsWithBuffKey();
        let blackboard = self
            .blackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_BuffDataT {
            attributes,
            buffKey,
            loadFromDB,
            isDurableBuff,
            isDamageMissable,
            isSilenceable,
            isStunnable,
            isFreezable,
            isLevitatable,
            statusResistable,
            templateKey,
            disableOverride,
            overrideKey,
            overrideType,
            maxStackCnt,
            refreshRemainingTimeWhenStackMax,
            clearAllStackCntWhenTimeUp,
            maxValidStackCnt,
            independentCharacterSource,
            overrideEffectKey,
            overrideOnEventPriority,
            onEventPriority,
            audioSignal,
            lifeTimeType,
            takeSnapshotWhenExtend,
            durationKey,
            lifeTime,
            triggerLifeType,
            triggerCnt,
            triggerInterval,
            waitFirstTriggerInterval,
            firstTriggerInterval,
            priority,
            priorityBBKeys,
            stripBlackboardParamsWithBuffKey,
            blackboard,
        }
    }

    #[inline]
    pub fn attributes(&self) -> Option<clz_Torappu_AttributeModifierData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_AttributeModifierData>>(
                    clz_Torappu_BuffData::VT_ATTRIBUTES,
                    None,
                )
        }
    }
    #[inline]
    pub fn buffKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_BuffData::VT_BUFFKEY, None)
        }
    }
    #[inline]
    pub fn loadFromDB(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_BuffData::VT_LOADFROMDB, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn isDurableBuff(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_BuffData::VT_ISDURABLEBUFF, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn isDamageMissable(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_BuffData::VT_ISDAMAGEMISSABLE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn isSilenceable(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_BuffData::VT_ISSILENCEABLE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn isStunnable(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_BuffData::VT_ISSTUNNABLE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn isFreezable(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_BuffData::VT_ISFREEZABLE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn isLevitatable(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_BuffData::VT_ISLEVITATABLE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn statusResistable(&self) -> enum__Torappu_BuffData_StatusResistable {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuffData_StatusResistable>(
                    clz_Torappu_BuffData::VT_STATUSRESISTABLE,
                    Some(enum__Torappu_BuffData_StatusResistable::NO),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn templateKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuffData::VT_TEMPLATEKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn disableOverride(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_BuffData::VT_DISABLEOVERRIDE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn overrideKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuffData::VT_OVERRIDEKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn overrideType(&self) -> enum__Torappu_BuffData_OverrideType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuffData_OverrideType>(
                    clz_Torappu_BuffData::VT_OVERRIDETYPE,
                    Some(enum__Torappu_BuffData_OverrideType::DEFAULT),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxStackCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuffData::VT_MAXSTACKCNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn refreshRemainingTimeWhenStackMax(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_BuffData::VT_REFRESHREMAININGTIMEWHENSTACKMAX,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn clearAllStackCntWhenTimeUp(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_BuffData::VT_CLEARALLSTACKCNTWHENTIMEUP,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxValidStackCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuffData::VT_MAXVALIDSTACKCNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn independentCharacterSource(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_BuffData::VT_INDEPENDENTCHARACTERSOURCE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn overrideEffectKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuffData::VT_OVERRIDEEFFECTKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn overrideOnEventPriority(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_BuffData::VT_OVERRIDEONEVENTPRIORITY,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn onEventPriority(&self) -> enum__Torappu_BuffData_OnEventPriority {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuffData_OnEventPriority>(
                    clz_Torappu_BuffData::VT_ONEVENTPRIORITY,
                    Some(enum__Torappu_BuffData_OnEventPriority::DEFAULT),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn audioSignal(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuffData::VT_AUDIOSIGNAL,
                None,
            )
        }
    }
    #[inline]
    pub fn lifeTimeType(&self) -> enum__Torappu_LifeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_LifeType>(
                    clz_Torappu_BuffData::VT_LIFETIMETYPE,
                    Some(enum__Torappu_LifeType::IMMEDIATELY),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn takeSnapshotWhenExtend(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_BuffData::VT_TAKESNAPSHOTWHENEXTEND, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn durationKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuffData::VT_DURATIONKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn lifeTime(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_BuffData::VT_LIFETIME, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn triggerLifeType(&self) -> enum__Torappu_LifeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_LifeType>(
                    clz_Torappu_BuffData::VT_TRIGGERLIFETYPE,
                    Some(enum__Torappu_LifeType::IMMEDIATELY),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn triggerCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuffData::VT_TRIGGERCNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn triggerInterval(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_BuffData::VT_TRIGGERINTERVAL, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn waitFirstTriggerInterval(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_BuffData::VT_WAITFIRSTTRIGGERINTERVAL,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn firstTriggerInterval(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_BuffData::VT_FIRSTTRIGGERINTERVAL, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn priority(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuffData::VT_PRIORITY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn priorityBBKeys(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_BuffData::VT_PRIORITYBBKEYS, None)
        }
    }
    #[inline]
    pub fn stripBlackboardParamsWithBuffKey(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_BuffData::VT_STRIPBLACKBOARDPARAMSWITHBUFFKEY,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(clz_Torappu_BuffData::VT_BLACKBOARD, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_AttributeModifierData>>(
                "attributes",
                Self::VT_ATTRIBUTES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buffKey", Self::VT_BUFFKEY, false)?
            .visit_field::<bool>("loadFromDB", Self::VT_LOADFROMDB, false)?
            .visit_field::<bool>("isDurableBuff", Self::VT_ISDURABLEBUFF, false)?
            .visit_field::<bool>("isDamageMissable", Self::VT_ISDAMAGEMISSABLE, false)?
            .visit_field::<bool>("isSilenceable", Self::VT_ISSILENCEABLE, false)?
            .visit_field::<bool>("isStunnable", Self::VT_ISSTUNNABLE, false)?
            .visit_field::<bool>("isFreezable", Self::VT_ISFREEZABLE, false)?
            .visit_field::<bool>("isLevitatable", Self::VT_ISLEVITATABLE, false)?
            .visit_field::<enum__Torappu_BuffData_StatusResistable>(
                "statusResistable",
                Self::VT_STATUSRESISTABLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "templateKey",
                Self::VT_TEMPLATEKEY,
                false,
            )?
            .visit_field::<bool>("disableOverride", Self::VT_DISABLEOVERRIDE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "overrideKey",
                Self::VT_OVERRIDEKEY,
                false,
            )?
            .visit_field::<enum__Torappu_BuffData_OverrideType>(
                "overrideType",
                Self::VT_OVERRIDETYPE,
                false,
            )?
            .visit_field::<i32>("maxStackCnt", Self::VT_MAXSTACKCNT, false)?
            .visit_field::<bool>(
                "refreshRemainingTimeWhenStackMax",
                Self::VT_REFRESHREMAININGTIMEWHENSTACKMAX,
                false,
            )?
            .visit_field::<bool>(
                "clearAllStackCntWhenTimeUp",
                Self::VT_CLEARALLSTACKCNTWHENTIMEUP,
                false,
            )?
            .visit_field::<i32>("maxValidStackCnt", Self::VT_MAXVALIDSTACKCNT, false)?
            .visit_field::<bool>(
                "independentCharacterSource",
                Self::VT_INDEPENDENTCHARACTERSOURCE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "overrideEffectKey",
                Self::VT_OVERRIDEEFFECTKEY,
                false,
            )?
            .visit_field::<bool>(
                "overrideOnEventPriority",
                Self::VT_OVERRIDEONEVENTPRIORITY,
                false,
            )?
            .visit_field::<enum__Torappu_BuffData_OnEventPriority>(
                "onEventPriority",
                Self::VT_ONEVENTPRIORITY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "audioSignal",
                Self::VT_AUDIOSIGNAL,
                false,
            )?
            .visit_field::<enum__Torappu_LifeType>("lifeTimeType", Self::VT_LIFETIMETYPE, false)?
            .visit_field::<bool>(
                "takeSnapshotWhenExtend",
                Self::VT_TAKESNAPSHOTWHENEXTEND,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "durationKey",
                Self::VT_DURATIONKEY,
                false,
            )?
            .visit_field::<f32>("lifeTime", Self::VT_LIFETIME, false)?
            .visit_field::<enum__Torappu_LifeType>(
                "triggerLifeType",
                Self::VT_TRIGGERLIFETYPE,
                false,
            )?
            .visit_field::<i32>("triggerCnt", Self::VT_TRIGGERCNT, false)?
            .visit_field::<f32>("triggerInterval", Self::VT_TRIGGERINTERVAL, false)?
            .visit_field::<bool>(
                "waitFirstTriggerInterval",
                Self::VT_WAITFIRSTTRIGGERINTERVAL,
                false,
            )?
            .visit_field::<f32>("firstTriggerInterval", Self::VT_FIRSTTRIGGERINTERVAL, false)?
            .visit_field::<i32>("priority", Self::VT_PRIORITY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("priorityBBKeys", Self::VT_PRIORITYBBKEYS, false)?
            .visit_field::<bool>(
                "stripBlackboardParamsWithBuffKey",
                Self::VT_STRIPBLACKBOARDPARAMSWITHBUFFKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuffDataArgs<'a> {
    pub attributes: Option<flatbuffers::WIPOffset<clz_Torappu_AttributeModifierData<'a>>>,
    pub buffKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub loadFromDB: bool,
    pub isDurableBuff: bool,
    pub isDamageMissable: bool,
    pub isSilenceable: bool,
    pub isStunnable: bool,
    pub isFreezable: bool,
    pub isLevitatable: bool,
    pub statusResistable: enum__Torappu_BuffData_StatusResistable,
    pub templateKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub disableOverride: bool,
    pub overrideKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub overrideType: enum__Torappu_BuffData_OverrideType,
    pub maxStackCnt: i32,
    pub refreshRemainingTimeWhenStackMax: bool,
    pub clearAllStackCntWhenTimeUp: bool,
    pub maxValidStackCnt: i32,
    pub independentCharacterSource: bool,
    pub overrideEffectKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub overrideOnEventPriority: bool,
    pub onEventPriority: enum__Torappu_BuffData_OnEventPriority,
    pub audioSignal: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lifeTimeType: enum__Torappu_LifeType,
    pub takeSnapshotWhenExtend: bool,
    pub durationKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lifeTime: f32,
    pub triggerLifeType: enum__Torappu_LifeType,
    pub triggerCnt: i32,
    pub triggerInterval: f32,
    pub waitFirstTriggerInterval: bool,
    pub firstTriggerInterval: f32,
    pub priority: i32,
    pub priorityBBKeys: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub stripBlackboardParamsWithBuffKey: bool,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuffDataArgs {
            attributes: None,
            buffKey: None,
            loadFromDB: false,
            isDurableBuff: false,
            isDamageMissable: false,
            isSilenceable: false,
            isStunnable: false,
            isFreezable: false,
            isLevitatable: false,
            statusResistable: enum__Torappu_BuffData_StatusResistable::NO,
            templateKey: None,
            disableOverride: false,
            overrideKey: None,
            overrideType: enum__Torappu_BuffData_OverrideType::DEFAULT,
            maxStackCnt: 0,
            refreshRemainingTimeWhenStackMax: false,
            clearAllStackCntWhenTimeUp: false,
            maxValidStackCnt: 0,
            independentCharacterSource: false,
            overrideEffectKey: None,
            overrideOnEventPriority: false,
            onEventPriority: enum__Torappu_BuffData_OnEventPriority::DEFAULT,
            audioSignal: None,
            lifeTimeType: enum__Torappu_LifeType::IMMEDIATELY,
            takeSnapshotWhenExtend: false,
            durationKey: None,
            lifeTime: 0.0,
            triggerLifeType: enum__Torappu_LifeType::IMMEDIATELY,
            triggerCnt: 0,
            triggerInterval: 0.0,
            waitFirstTriggerInterval: false,
            firstTriggerInterval: 0.0,
            priority: 0,
            priorityBBKeys: None,
            stripBlackboardParamsWithBuffKey: false,
            blackboard: None,
        }
    }
}

impl Serialize for clz_Torappu_BuffData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_BuffData", 36)?;
        if let Some(f) = self.attributes() {
            s.serialize_field("attributes", &f)?;
        } else {
            s.skip_field("attributes")?;
        }
        if let Some(f) = self.buffKey() {
            s.serialize_field("buffKey", &f)?;
        } else {
            s.skip_field("buffKey")?;
        }
        s.serialize_field("loadFromDB", &self.loadFromDB())?;
        s.serialize_field("isDurableBuff", &self.isDurableBuff())?;
        s.serialize_field("isDamageMissable", &self.isDamageMissable())?;
        s.serialize_field("isSilenceable", &self.isSilenceable())?;
        s.serialize_field("isStunnable", &self.isStunnable())?;
        s.serialize_field("isFreezable", &self.isFreezable())?;
        s.serialize_field("isLevitatable", &self.isLevitatable())?;
        s.serialize_field("statusResistable", &self.statusResistable())?;
        if let Some(f) = self.templateKey() {
            s.serialize_field("templateKey", &f)?;
        } else {
            s.skip_field("templateKey")?;
        }
        s.serialize_field("disableOverride", &self.disableOverride())?;
        if let Some(f) = self.overrideKey() {
            s.serialize_field("overrideKey", &f)?;
        } else {
            s.skip_field("overrideKey")?;
        }
        s.serialize_field("overrideType", &self.overrideType())?;
        s.serialize_field("maxStackCnt", &self.maxStackCnt())?;
        s.serialize_field(
            "refreshRemainingTimeWhenStackMax",
            &self.refreshRemainingTimeWhenStackMax(),
        )?;
        s.serialize_field(
            "clearAllStackCntWhenTimeUp",
            &self.clearAllStackCntWhenTimeUp(),
        )?;
        s.serialize_field("maxValidStackCnt", &self.maxValidStackCnt())?;
        s.serialize_field(
            "independentCharacterSource",
            &self.independentCharacterSource(),
        )?;
        if let Some(f) = self.overrideEffectKey() {
            s.serialize_field("overrideEffectKey", &f)?;
        } else {
            s.skip_field("overrideEffectKey")?;
        }
        s.serialize_field("overrideOnEventPriority", &self.overrideOnEventPriority())?;
        s.serialize_field("onEventPriority", &self.onEventPriority())?;
        if let Some(f) = self.audioSignal() {
            s.serialize_field("audioSignal", &f)?;
        } else {
            s.skip_field("audioSignal")?;
        }
        s.serialize_field("lifeTimeType", &self.lifeTimeType())?;
        s.serialize_field("takeSnapshotWhenExtend", &self.takeSnapshotWhenExtend())?;
        if let Some(f) = self.durationKey() {
            s.serialize_field("durationKey", &f)?;
        } else {
            s.skip_field("durationKey")?;
        }
        s.serialize_field("lifeTime", &self.lifeTime())?;
        s.serialize_field("triggerLifeType", &self.triggerLifeType())?;
        s.serialize_field("triggerCnt", &self.triggerCnt())?;
        s.serialize_field("triggerInterval", &self.triggerInterval())?;
        s.serialize_field("waitFirstTriggerInterval", &self.waitFirstTriggerInterval())?;
        s.serialize_field("firstTriggerInterval", &self.firstTriggerInterval())?;
        s.serialize_field("priority", &self.priority())?;
        if let Some(f) = self.priorityBBKeys() {
            s.serialize_field("priorityBBKeys", &f)?;
        } else {
            s.skip_field("priorityBBKeys")?;
        }
        s.serialize_field(
            "stripBlackboardParamsWithBuffKey",
            &self.stripBlackboardParamsWithBuffKey(),
        )?;
        if let Some(f) = self.blackboard() {
            s.serialize_field("blackboard", &f)?;
        } else {
            s.skip_field("blackboard")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_BuffDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_BuffDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_attributes(
        &mut self,
        attributes: flatbuffers::WIPOffset<clz_Torappu_AttributeModifierData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_AttributeModifierData>>(
                clz_Torappu_BuffData::VT_ATTRIBUTES,
                attributes,
            );
    }
    #[inline]
    pub fn add_buffKey(&mut self, buffKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuffData::VT_BUFFKEY,
            buffKey,
        );
    }
    #[inline]
    pub fn add_loadFromDB(&mut self, loadFromDB: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_BuffData::VT_LOADFROMDB, loadFromDB, false);
    }
    #[inline]
    pub fn add_isDurableBuff(&mut self, isDurableBuff: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_BuffData::VT_ISDURABLEBUFF, isDurableBuff, false);
    }
    #[inline]
    pub fn add_isDamageMissable(&mut self, isDamageMissable: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_BuffData::VT_ISDAMAGEMISSABLE,
            isDamageMissable,
            false,
        );
    }
    #[inline]
    pub fn add_isSilenceable(&mut self, isSilenceable: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_BuffData::VT_ISSILENCEABLE, isSilenceable, false);
    }
    #[inline]
    pub fn add_isStunnable(&mut self, isStunnable: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_BuffData::VT_ISSTUNNABLE, isStunnable, false);
    }
    #[inline]
    pub fn add_isFreezable(&mut self, isFreezable: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_BuffData::VT_ISFREEZABLE, isFreezable, false);
    }
    #[inline]
    pub fn add_isLevitatable(&mut self, isLevitatable: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_BuffData::VT_ISLEVITATABLE, isLevitatable, false);
    }
    #[inline]
    pub fn add_statusResistable(
        &mut self,
        statusResistable: enum__Torappu_BuffData_StatusResistable,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_BuffData_StatusResistable>(
                clz_Torappu_BuffData::VT_STATUSRESISTABLE,
                statusResistable,
                enum__Torappu_BuffData_StatusResistable::NO,
            );
    }
    #[inline]
    pub fn add_templateKey(&mut self, templateKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuffData::VT_TEMPLATEKEY,
            templateKey,
        );
    }
    #[inline]
    pub fn add_disableOverride(&mut self, disableOverride: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_BuffData::VT_DISABLEOVERRIDE,
            disableOverride,
            false,
        );
    }
    #[inline]
    pub fn add_overrideKey(&mut self, overrideKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuffData::VT_OVERRIDEKEY,
            overrideKey,
        );
    }
    #[inline]
    pub fn add_overrideType(&mut self, overrideType: enum__Torappu_BuffData_OverrideType) {
        self.fbb_.push_slot::<enum__Torappu_BuffData_OverrideType>(
            clz_Torappu_BuffData::VT_OVERRIDETYPE,
            overrideType,
            enum__Torappu_BuffData_OverrideType::DEFAULT,
        );
    }
    #[inline]
    pub fn add_maxStackCnt(&mut self, maxStackCnt: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_BuffData::VT_MAXSTACKCNT, maxStackCnt, 0);
    }
    #[inline]
    pub fn add_refreshRemainingTimeWhenStackMax(&mut self, refreshRemainingTimeWhenStackMax: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_BuffData::VT_REFRESHREMAININGTIMEWHENSTACKMAX,
            refreshRemainingTimeWhenStackMax,
            false,
        );
    }
    #[inline]
    pub fn add_clearAllStackCntWhenTimeUp(&mut self, clearAllStackCntWhenTimeUp: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_BuffData::VT_CLEARALLSTACKCNTWHENTIMEUP,
            clearAllStackCntWhenTimeUp,
            false,
        );
    }
    #[inline]
    pub fn add_maxValidStackCnt(&mut self, maxValidStackCnt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuffData::VT_MAXVALIDSTACKCNT,
            maxValidStackCnt,
            0,
        );
    }
    #[inline]
    pub fn add_independentCharacterSource(&mut self, independentCharacterSource: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_BuffData::VT_INDEPENDENTCHARACTERSOURCE,
            independentCharacterSource,
            false,
        );
    }
    #[inline]
    pub fn add_overrideEffectKey(&mut self, overrideEffectKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuffData::VT_OVERRIDEEFFECTKEY,
            overrideEffectKey,
        );
    }
    #[inline]
    pub fn add_overrideOnEventPriority(&mut self, overrideOnEventPriority: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_BuffData::VT_OVERRIDEONEVENTPRIORITY,
            overrideOnEventPriority,
            false,
        );
    }
    #[inline]
    pub fn add_onEventPriority(&mut self, onEventPriority: enum__Torappu_BuffData_OnEventPriority) {
        self.fbb_
            .push_slot::<enum__Torappu_BuffData_OnEventPriority>(
                clz_Torappu_BuffData::VT_ONEVENTPRIORITY,
                onEventPriority,
                enum__Torappu_BuffData_OnEventPriority::DEFAULT,
            );
    }
    #[inline]
    pub fn add_audioSignal(&mut self, audioSignal: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuffData::VT_AUDIOSIGNAL,
            audioSignal,
        );
    }
    #[inline]
    pub fn add_lifeTimeType(&mut self, lifeTimeType: enum__Torappu_LifeType) {
        self.fbb_.push_slot::<enum__Torappu_LifeType>(
            clz_Torappu_BuffData::VT_LIFETIMETYPE,
            lifeTimeType,
            enum__Torappu_LifeType::IMMEDIATELY,
        );
    }
    #[inline]
    pub fn add_takeSnapshotWhenExtend(&mut self, takeSnapshotWhenExtend: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_BuffData::VT_TAKESNAPSHOTWHENEXTEND,
            takeSnapshotWhenExtend,
            false,
        );
    }
    #[inline]
    pub fn add_durationKey(&mut self, durationKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuffData::VT_DURATIONKEY,
            durationKey,
        );
    }
    #[inline]
    pub fn add_lifeTime(&mut self, lifeTime: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_BuffData::VT_LIFETIME, lifeTime, 0.0);
    }
    #[inline]
    pub fn add_triggerLifeType(&mut self, triggerLifeType: enum__Torappu_LifeType) {
        self.fbb_.push_slot::<enum__Torappu_LifeType>(
            clz_Torappu_BuffData::VT_TRIGGERLIFETYPE,
            triggerLifeType,
            enum__Torappu_LifeType::IMMEDIATELY,
        );
    }
    #[inline]
    pub fn add_triggerCnt(&mut self, triggerCnt: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_BuffData::VT_TRIGGERCNT, triggerCnt, 0);
    }
    #[inline]
    pub fn add_triggerInterval(&mut self, triggerInterval: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_BuffData::VT_TRIGGERINTERVAL,
            triggerInterval,
            0.0,
        );
    }
    #[inline]
    pub fn add_waitFirstTriggerInterval(&mut self, waitFirstTriggerInterval: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_BuffData::VT_WAITFIRSTTRIGGERINTERVAL,
            waitFirstTriggerInterval,
            false,
        );
    }
    #[inline]
    pub fn add_firstTriggerInterval(&mut self, firstTriggerInterval: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_BuffData::VT_FIRSTTRIGGERINTERVAL,
            firstTriggerInterval,
            0.0,
        );
    }
    #[inline]
    pub fn add_priority(&mut self, priority: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_BuffData::VT_PRIORITY, priority, 0);
    }
    #[inline]
    pub fn add_priorityBBKeys(
        &mut self,
        priorityBBKeys: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuffData::VT_PRIORITYBBKEYS,
            priorityBBKeys,
        );
    }
    #[inline]
    pub fn add_stripBlackboardParamsWithBuffKey(&mut self, stripBlackboardParamsWithBuffKey: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_BuffData::VT_STRIPBLACKBOARDPARAMSWITHBUFFKEY,
            stripBlackboardParamsWithBuffKey,
            false,
        );
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuffData::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuffData");
        ds.field("attributes", &self.attributes());
        ds.field("buffKey", &self.buffKey());
        ds.field("loadFromDB", &self.loadFromDB());
        ds.field("isDurableBuff", &self.isDurableBuff());
        ds.field("isDamageMissable", &self.isDamageMissable());
        ds.field("isSilenceable", &self.isSilenceable());
        ds.field("isStunnable", &self.isStunnable());
        ds.field("isFreezable", &self.isFreezable());
        ds.field("isLevitatable", &self.isLevitatable());
        ds.field("statusResistable", &self.statusResistable());
        ds.field("templateKey", &self.templateKey());
        ds.field("disableOverride", &self.disableOverride());
        ds.field("overrideKey", &self.overrideKey());
        ds.field("overrideType", &self.overrideType());
        ds.field("maxStackCnt", &self.maxStackCnt());
        ds.field(
            "refreshRemainingTimeWhenStackMax",
            &self.refreshRemainingTimeWhenStackMax(),
        );
        ds.field(
            "clearAllStackCntWhenTimeUp",
            &self.clearAllStackCntWhenTimeUp(),
        );
        ds.field("maxValidStackCnt", &self.maxValidStackCnt());
        ds.field(
            "independentCharacterSource",
            &self.independentCharacterSource(),
        );
        ds.field("overrideEffectKey", &self.overrideEffectKey());
        ds.field("overrideOnEventPriority", &self.overrideOnEventPriority());
        ds.field("onEventPriority", &self.onEventPriority());
        ds.field("audioSignal", &self.audioSignal());
        ds.field("lifeTimeType", &self.lifeTimeType());
        ds.field("takeSnapshotWhenExtend", &self.takeSnapshotWhenExtend());
        ds.field("durationKey", &self.durationKey());
        ds.field("lifeTime", &self.lifeTime());
        ds.field("triggerLifeType", &self.triggerLifeType());
        ds.field("triggerCnt", &self.triggerCnt());
        ds.field("triggerInterval", &self.triggerInterval());
        ds.field("waitFirstTriggerInterval", &self.waitFirstTriggerInterval());
        ds.field("firstTriggerInterval", &self.firstTriggerInterval());
        ds.field("priority", &self.priority());
        ds.field("priorityBBKeys", &self.priorityBBKeys());
        ds.field(
            "stripBlackboardParamsWithBuffKey",
            &self.stripBlackboardParamsWithBuffKey(),
        );
        ds.field("blackboard", &self.blackboard());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_BuffDataT {
    pub attributes: Option<Box<clz_Torappu_AttributeModifierDataT>>,
    pub buffKey: Option<String>,
    pub loadFromDB: bool,
    pub isDurableBuff: bool,
    pub isDamageMissable: bool,
    pub isSilenceable: bool,
    pub isStunnable: bool,
    pub isFreezable: bool,
    pub isLevitatable: bool,
    pub statusResistable: enum__Torappu_BuffData_StatusResistable,
    pub templateKey: Option<String>,
    pub disableOverride: bool,
    pub overrideKey: Option<String>,
    pub overrideType: enum__Torappu_BuffData_OverrideType,
    pub maxStackCnt: i32,
    pub refreshRemainingTimeWhenStackMax: bool,
    pub clearAllStackCntWhenTimeUp: bool,
    pub maxValidStackCnt: i32,
    pub independentCharacterSource: bool,
    pub overrideEffectKey: Option<String>,
    pub overrideOnEventPriority: bool,
    pub onEventPriority: enum__Torappu_BuffData_OnEventPriority,
    pub audioSignal: Option<String>,
    pub lifeTimeType: enum__Torappu_LifeType,
    pub takeSnapshotWhenExtend: bool,
    pub durationKey: Option<String>,
    pub lifeTime: f32,
    pub triggerLifeType: enum__Torappu_LifeType,
    pub triggerCnt: i32,
    pub triggerInterval: f32,
    pub waitFirstTriggerInterval: bool,
    pub firstTriggerInterval: f32,
    pub priority: i32,
    pub priorityBBKeys: Option<Vec<String>>,
    pub stripBlackboardParamsWithBuffKey: bool,
    pub blackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
}
impl Default for clz_Torappu_BuffDataT {
    fn default() -> Self {
        Self {
            attributes: None,
            buffKey: None,
            loadFromDB: false,
            isDurableBuff: false,
            isDamageMissable: false,
            isSilenceable: false,
            isStunnable: false,
            isFreezable: false,
            isLevitatable: false,
            statusResistable: enum__Torappu_BuffData_StatusResistable::NO,
            templateKey: None,
            disableOverride: false,
            overrideKey: None,
            overrideType: enum__Torappu_BuffData_OverrideType::DEFAULT,
            maxStackCnt: 0,
            refreshRemainingTimeWhenStackMax: false,
            clearAllStackCntWhenTimeUp: false,
            maxValidStackCnt: 0,
            independentCharacterSource: false,
            overrideEffectKey: None,
            overrideOnEventPriority: false,
            onEventPriority: enum__Torappu_BuffData_OnEventPriority::DEFAULT,
            audioSignal: None,
            lifeTimeType: enum__Torappu_LifeType::IMMEDIATELY,
            takeSnapshotWhenExtend: false,
            durationKey: None,
            lifeTime: 0.0,
            triggerLifeType: enum__Torappu_LifeType::IMMEDIATELY,
            triggerCnt: 0,
            triggerInterval: 0.0,
            waitFirstTriggerInterval: false,
            firstTriggerInterval: 0.0,
            priority: 0,
            priorityBBKeys: None,
            stripBlackboardParamsWithBuffKey: false,
            blackboard: None,
        }
    }
}
impl clz_Torappu_BuffDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuffData<'b>> {
        let attributes = self.attributes.as_ref().map(|x| x.pack(_fbb));
        let buffKey = self.buffKey.as_ref().map(|x| _fbb.create_string(x));
        let loadFromDB = self.loadFromDB;
        let isDurableBuff = self.isDurableBuff;
        let isDamageMissable = self.isDamageMissable;
        let isSilenceable = self.isSilenceable;
        let isStunnable = self.isStunnable;
        let isFreezable = self.isFreezable;
        let isLevitatable = self.isLevitatable;
        let statusResistable = self.statusResistable;
        let templateKey = self.templateKey.as_ref().map(|x| _fbb.create_string(x));
        let disableOverride = self.disableOverride;
        let overrideKey = self.overrideKey.as_ref().map(|x| _fbb.create_string(x));
        let overrideType = self.overrideType;
        let maxStackCnt = self.maxStackCnt;
        let refreshRemainingTimeWhenStackMax = self.refreshRemainingTimeWhenStackMax;
        let clearAllStackCntWhenTimeUp = self.clearAllStackCntWhenTimeUp;
        let maxValidStackCnt = self.maxValidStackCnt;
        let independentCharacterSource = self.independentCharacterSource;
        let overrideEffectKey = self
            .overrideEffectKey
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let overrideOnEventPriority = self.overrideOnEventPriority;
        let onEventPriority = self.onEventPriority;
        let audioSignal = self.audioSignal.as_ref().map(|x| _fbb.create_string(x));
        let lifeTimeType = self.lifeTimeType;
        let takeSnapshotWhenExtend = self.takeSnapshotWhenExtend;
        let durationKey = self.durationKey.as_ref().map(|x| _fbb.create_string(x));
        let lifeTime = self.lifeTime;
        let triggerLifeType = self.triggerLifeType;
        let triggerCnt = self.triggerCnt;
        let triggerInterval = self.triggerInterval;
        let waitFirstTriggerInterval = self.waitFirstTriggerInterval;
        let firstTriggerInterval = self.firstTriggerInterval;
        let priority = self.priority;
        let priorityBBKeys = self.priorityBBKeys.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let stripBlackboardParamsWithBuffKey = self.stripBlackboardParamsWithBuffKey;
        let blackboard = self.blackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_BuffData::create(
            _fbb,
            &clz_Torappu_BuffDataArgs {
                attributes,
                buffKey,
                loadFromDB,
                isDurableBuff,
                isDamageMissable,
                isSilenceable,
                isStunnable,
                isFreezable,
                isLevitatable,
                statusResistable,
                templateKey,
                disableOverride,
                overrideKey,
                overrideType,
                maxStackCnt,
                refreshRemainingTimeWhenStackMax,
                clearAllStackCntWhenTimeUp,
                maxValidStackCnt,
                independentCharacterSource,
                overrideEffectKey,
                overrideOnEventPriority,
                onEventPriority,
                audioSignal,
                lifeTimeType,
                takeSnapshotWhenExtend,
                durationKey,
                lifeTime,
                triggerLifeType,
                triggerCnt,
                triggerInterval,
                waitFirstTriggerInterval,
                firstTriggerInterval,
                priority,
                priorityBBKeys,
                stripBlackboardParamsWithBuffKey,
                blackboard,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_BuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_BuffData<'a> {
    type Inner = dict__string__clz_Torappu_BuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuffData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuffData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_BuffDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_BuffDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_BuffDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BuffData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_BuffData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuffData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuffData>>(
                    dict__string__clz_Torappu_BuffData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_BuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuffData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuffDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_BuffData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuffDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_BuffData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_BuffData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_BuffDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuffData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_BuffData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuffData>>(
                dict__string__clz_Torappu_BuffData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_BuffData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_BuffData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_BuffDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_BuffDataT>>,
}
impl Default for dict__string__clz_Torappu_BuffDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_BuffDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuffData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_BuffData::create(
            _fbb,
            &dict__string__clz_Torappu_BuffDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SimpleKVTable_clz_Torappu_BuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SimpleKVTable_clz_Torappu_BuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SimpleKVTable_clz_Torappu_BuffData<'a> {
    type Inner = clz_Torappu_SimpleKVTable_clz_Torappu_BuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SimpleKVTable_clz_Torappu_BuffData<'a> {
    pub const VT_BUFFS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SimpleKVTable_clz_Torappu_BuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SimpleKVTable_clz_Torappu_BuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SimpleKVTable_clz_Torappu_BuffData<'bldr>> {
        let mut builder = clz_Torappu_SimpleKVTable_clz_Torappu_BuffDataBuilder::new(_fbb);
        if let Some(x) = args.buffs {
            builder.add_buffs(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SimpleKVTable_clz_Torappu_BuffDataT {
        let buffs = self.buffs().map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_SimpleKVTable_clz_Torappu_BuffDataT { buffs }
    }

    #[inline]
    pub fn buffs(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuffData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuffData>,
                >,
            >>(
                clz_Torappu_SimpleKVTable_clz_Torappu_BuffData::VT_BUFFS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SimpleKVTable_clz_Torappu_BuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuffData>,
                >,
            >>("buffs", Self::VT_BUFFS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SimpleKVTable_clz_Torappu_BuffDataArgs<'a> {
    pub buffs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuffData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SimpleKVTable_clz_Torappu_BuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SimpleKVTable_clz_Torappu_BuffDataArgs { buffs: None }
    }
}

impl Serialize for clz_Torappu_SimpleKVTable_clz_Torappu_BuffData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_SimpleKVTable_clz_Torappu_BuffData", 1)?;
        if let Some(f) = self.buffs() {
            s.serialize_field("buffs", &f)?;
        } else {
            s.skip_field("buffs")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SimpleKVTable_clz_Torappu_BuffDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SimpleKVTable_clz_Torappu_BuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_buffs(
        &mut self,
        buffs: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuffData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SimpleKVTable_clz_Torappu_BuffData::VT_BUFFS,
            buffs,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SimpleKVTable_clz_Torappu_BuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SimpleKVTable_clz_Torappu_BuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SimpleKVTable_clz_Torappu_BuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SimpleKVTable_clz_Torappu_BuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SimpleKVTable_clz_Torappu_BuffData");
        ds.field("buffs", &self.buffs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SimpleKVTable_clz_Torappu_BuffDataT {
    pub buffs: Option<Vec<dict__string__clz_Torappu_BuffDataT>>,
}
impl Default for clz_Torappu_SimpleKVTable_clz_Torappu_BuffDataT {
    fn default() -> Self {
        Self { buffs: None }
    }
}
impl clz_Torappu_SimpleKVTable_clz_Torappu_BuffDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SimpleKVTable_clz_Torappu_BuffData<'b>> {
        let buffs = self.buffs.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SimpleKVTable_clz_Torappu_BuffData::create(
            _fbb,
            &clz_Torappu_SimpleKVTable_clz_Torappu_BuffDataArgs { buffs },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_SimpleKVTable_clz_Torappu_BuffData`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_simple_kvtable_clz_torappu_buff_data_unchecked`.
pub fn root_as_clz_torappu_simple_kvtable_clz_torappu_buff_data(
    buf: &[u8],
) -> Result<clz_Torappu_SimpleKVTable_clz_Torappu_BuffData, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_SimpleKVTable_clz_Torappu_BuffData>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_SimpleKVTable_clz_Torappu_BuffData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_simple_kvtable_clz_torappu_buff_data_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_simple_kvtable_clz_torappu_buff_data(
    buf: &[u8],
) -> Result<clz_Torappu_SimpleKVTable_clz_Torappu_BuffData, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_SimpleKVTable_clz_Torappu_BuffData>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_SimpleKVTable_clz_Torappu_BuffData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_simple_kvtable_clz_torappu_buff_data_unchecked`.
pub fn root_as_clz_torappu_simple_kvtable_clz_torappu_buff_data_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_SimpleKVTable_clz_Torappu_BuffData<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_SimpleKVTable_clz_Torappu_BuffData<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_SimpleKVTable_clz_Torappu_BuffData` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_simple_kvtable_clz_torappu_buff_data_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_simple_kvtable_clz_torappu_buff_data_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_SimpleKVTable_clz_Torappu_BuffData<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_SimpleKVTable_clz_Torappu_BuffData<'b>>(
        opts, buf,
    )
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_SimpleKVTable_clz_Torappu_BuffData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_SimpleKVTable_clz_Torappu_BuffData`.
pub unsafe fn root_as_clz_torappu_simple_kvtable_clz_torappu_buff_data_unchecked(
    buf: &[u8],
) -> clz_Torappu_SimpleKVTable_clz_Torappu_BuffData {
    unsafe { flatbuffers::root_unchecked::<clz_Torappu_SimpleKVTable_clz_Torappu_BuffData>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_SimpleKVTable_clz_Torappu_BuffData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_SimpleKVTable_clz_Torappu_BuffData`.
pub unsafe fn size_prefixed_root_as_clz_torappu_simple_kvtable_clz_torappu_buff_data_unchecked(
    buf: &[u8],
) -> clz_Torappu_SimpleKVTable_clz_Torappu_BuffData {
    unsafe {
        flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_SimpleKVTable_clz_Torappu_BuffData>(
            buf,
        )
    }
}
#[inline]
pub fn finish_clz_torappu_simple_kvtable_clz_torappu_buff_data_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_SimpleKVTable_clz_Torappu_BuffData<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_simple_kvtable_clz_torappu_buff_data_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_SimpleKVTable_clz_Torappu_BuffData<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
