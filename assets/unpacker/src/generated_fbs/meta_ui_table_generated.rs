// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_COMMON_UNLOCK_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_COMMON_UNLOCK_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_COMMON_UNLOCK_TYPE: [enum__Torappu_CommonUnlockType; 3] = [
    enum__Torappu_CommonUnlockType::STAGECLEAR,
    enum__Torappu_CommonUnlockType::HASCHAR,
    enum__Torappu_CommonUnlockType::NONE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_CommonUnlockType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_CommonUnlockType {
    pub const STAGECLEAR: Self = Self(0);
    pub const HASCHAR: Self = Self(1);
    pub const NONE: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::STAGECLEAR, Self::HASCHAR, Self::NONE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::STAGECLEAR => Some("STAGECLEAR"),
            Self::HASCHAR => Some("HASCHAR"),
            Self::NONE => Some("NONE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_CommonUnlockType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_CommonUnlockType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_CommonUnlockType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_CommonUnlockType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_CommonUnlockType {
    type Output = enum__Torappu_CommonUnlockType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_CommonUnlockType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_CommonUnlockType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_CommonUnlockType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_TIP_DATA_CATEGORY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_TIP_DATA_CATEGORY: i32 = 31;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_TIP_DATA_CATEGORY: [enum__Torappu_TipData_Category; 7] = [
    enum__Torappu_TipData_Category::NONE,
    enum__Torappu_TipData_Category::BATTLE,
    enum__Torappu_TipData_Category::UI,
    enum__Torappu_TipData_Category::BUILDING,
    enum__Torappu_TipData_Category::GACHA,
    enum__Torappu_TipData_Category::MISC,
    enum__Torappu_TipData_Category::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_TipData_Category(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_TipData_Category {
    pub const NONE: Self = Self(0);
    pub const BATTLE: Self = Self(1);
    pub const UI: Self = Self(2);
    pub const BUILDING: Self = Self(4);
    pub const GACHA: Self = Self(8);
    pub const MISC: Self = Self(16);
    pub const ALL: Self = Self(31);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 31;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::BATTLE,
        Self::UI,
        Self::BUILDING,
        Self::GACHA,
        Self::MISC,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::BATTLE => Some("BATTLE"),
            Self::UI => Some("UI"),
            Self::BUILDING => Some("BUILDING"),
            Self::GACHA => Some("GACHA"),
            Self::MISC => Some("MISC"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_TipData_Category {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_TipData_Category {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_TipData_Category",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_TipData_Category {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_TipData_Category {
    type Output = enum__Torappu_TipData_Category;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_TipData_Category {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_TipData_Category {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_TipData_Category {}
pub enum clz_Torappu_StageUnlockParamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageUnlockParam<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageUnlockParam<'a> {
    type Inner = clz_Torappu_StageUnlockParam<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageUnlockParam<'a> {
    pub const VT_STAGEID: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageUnlockParam { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageUnlockParamArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageUnlockParam<'bldr>> {
        let mut builder = clz_Torappu_StageUnlockParamBuilder::new(_fbb);
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageUnlockParamT {
        let stageId = self.stageId().map(|x| x.to_string());
        clz_Torappu_StageUnlockParamT { stageId }
    }

    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageUnlockParam::VT_STAGEID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageUnlockParam<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageUnlockParamArgs<'a> {
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_StageUnlockParamArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageUnlockParamArgs { stageId: None }
    }
}

impl Serialize for clz_Torappu_StageUnlockParam<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageUnlockParam", 1)?;
        if let Some(f) = self.stageId() {
            s.serialize_field("stageId", &f)?;
        } else {
            s.skip_field("stageId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_StageUnlockParamBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_StageUnlockParamBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageUnlockParam::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageUnlockParamBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageUnlockParamBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageUnlockParam<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageUnlockParam<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageUnlockParam");
        ds.field("stageId", &self.stageId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageUnlockParamT {
    pub stageId: Option<String>,
}
impl Default for clz_Torappu_StageUnlockParamT {
    fn default() -> Self {
        Self { stageId: None }
    }
}
impl clz_Torappu_StageUnlockParamT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageUnlockParam<'b>> {
        let stageId = self.stageId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_StageUnlockParam::create(_fbb, &clz_Torappu_StageUnlockParamArgs { stageId })
    }
}
pub enum clz_Torappu_CharUnlockParamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharUnlockParam<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharUnlockParam<'a> {
    type Inner = clz_Torappu_CharUnlockParam<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharUnlockParam<'a> {
    pub const VT_CHARID: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharUnlockParam { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharUnlockParamArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharUnlockParam<'bldr>> {
        let mut builder = clz_Torappu_CharUnlockParamBuilder::new(_fbb);
        if let Some(x) = args.charId {
            builder.add_charId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharUnlockParamT {
        let charId = self.charId().map(|x| x.to_string());
        clz_Torappu_CharUnlockParamT { charId }
    }

    #[inline]
    pub fn charId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharUnlockParam::VT_CHARID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharUnlockParam<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("charId", Self::VT_CHARID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharUnlockParamArgs<'a> {
    pub charId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_CharUnlockParamArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharUnlockParamArgs { charId: None }
    }
}

impl Serialize for clz_Torappu_CharUnlockParam<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharUnlockParam", 1)?;
        if let Some(f) = self.charId() {
            s.serialize_field("charId", &f)?;
        } else {
            s.skip_field("charId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CharUnlockParamBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_CharUnlockParamBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_charId(&mut self, charId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharUnlockParam::VT_CHARID,
            charId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharUnlockParamBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharUnlockParamBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharUnlockParam<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharUnlockParam<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharUnlockParam");
        ds.field("charId", &self.charId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharUnlockParamT {
    pub charId: Option<String>,
}
impl Default for clz_Torappu_CharUnlockParamT {
    fn default() -> Self {
        Self { charId: None }
    }
}
impl clz_Torappu_CharUnlockParamT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharUnlockParam<'b>> {
        let charId = self.charId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_CharUnlockParam::create(_fbb, &clz_Torappu_CharUnlockParamArgs { charId })
    }
}
pub enum clz_Torappu_CommonAvailCheckOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CommonAvailCheck<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CommonAvailCheck<'a> {
    type Inner = clz_Torappu_CommonAvailCheck<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CommonAvailCheck<'a> {
    pub const VT_STARTTS: flatbuffers::VOffsetT = 4;
    pub const VT_ENDTS: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;
    pub const VT_RATE: flatbuffers::VOffsetT = 10;
    pub const VT_STAGEUNLOCKPARAM: flatbuffers::VOffsetT = 12;
    pub const VT_CHARUNLOCKPARAM: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CommonAvailCheck { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CommonAvailCheckArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CommonAvailCheck<'bldr>> {
        let mut builder = clz_Torappu_CommonAvailCheckBuilder::new(_fbb);
        builder.add_endTs(args.endTs);
        builder.add_startTs(args.startTs);
        if let Some(x) = args.charUnlockParam {
            builder.add_charUnlockParam(x);
        }
        if let Some(x) = args.stageUnlockParam {
            builder.add_stageUnlockParam(x);
        }
        builder.add_rate(args.rate);
        builder.add_type_(args.type_);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CommonAvailCheckT {
        let startTs = self.startTs();
        let endTs = self.endTs();
        let type_ = self.type_();
        let rate = self.rate();
        let stageUnlockParam = self.stageUnlockParam().map(|x| Box::new(x.unpack()));
        let charUnlockParam = self.charUnlockParam().map(|x| Box::new(x.unpack()));
        clz_Torappu_CommonAvailCheckT {
            startTs,
            endTs,
            type_,
            rate,
            stageUnlockParam,
            charUnlockParam,
        }
    }

    #[inline]
    pub fn startTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_CommonAvailCheck::VT_STARTTS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_CommonAvailCheck::VT_ENDTS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_CommonUnlockType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_CommonUnlockType>(
                    clz_Torappu_CommonAvailCheck::VT_TYPE_,
                    Some(enum__Torappu_CommonUnlockType::STAGECLEAR),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rate(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_CommonAvailCheck::VT_RATE, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn stageUnlockParam(&self) -> Option<clz_Torappu_StageUnlockParam<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StageUnlockParam>>(
                    clz_Torappu_CommonAvailCheck::VT_STAGEUNLOCKPARAM,
                    None,
                )
        }
    }
    #[inline]
    pub fn charUnlockParam(&self) -> Option<clz_Torappu_CharUnlockParam<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharUnlockParam>>(
                    clz_Torappu_CommonAvailCheck::VT_CHARUNLOCKPARAM,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CommonAvailCheck<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("startTs", Self::VT_STARTTS, false)?
            .visit_field::<i64>("endTs", Self::VT_ENDTS, false)?
            .visit_field::<enum__Torappu_CommonUnlockType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<f32>("rate", Self::VT_RATE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StageUnlockParam>>(
                "stageUnlockParam",
                Self::VT_STAGEUNLOCKPARAM,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharUnlockParam>>(
                "charUnlockParam",
                Self::VT_CHARUNLOCKPARAM,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CommonAvailCheckArgs<'a> {
    pub startTs: i64,
    pub endTs: i64,
    pub type_: enum__Torappu_CommonUnlockType,
    pub rate: f32,
    pub stageUnlockParam: Option<flatbuffers::WIPOffset<clz_Torappu_StageUnlockParam<'a>>>,
    pub charUnlockParam: Option<flatbuffers::WIPOffset<clz_Torappu_CharUnlockParam<'a>>>,
}
impl<'a> Default for clz_Torappu_CommonAvailCheckArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CommonAvailCheckArgs {
            startTs: 0,
            endTs: 0,
            type_: enum__Torappu_CommonUnlockType::STAGECLEAR,
            rate: 0.0,
            stageUnlockParam: None,
            charUnlockParam: None,
        }
    }
}

impl Serialize for clz_Torappu_CommonAvailCheck<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CommonAvailCheck", 6)?;
        s.serialize_field("startTs", &self.startTs())?;
        s.serialize_field("endTs", &self.endTs())?;
        s.serialize_field("type_", &self.type_())?;
        s.serialize_field("rate", &self.rate())?;
        if let Some(f) = self.stageUnlockParam() {
            s.serialize_field("stageUnlockParam", &f)?;
        } else {
            s.skip_field("stageUnlockParam")?;
        }
        if let Some(f) = self.charUnlockParam() {
            s.serialize_field("charUnlockParam", &f)?;
        } else {
            s.skip_field("charUnlockParam")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_CommonAvailCheckBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_CommonAvailCheckBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_startTs(&mut self, startTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_CommonAvailCheck::VT_STARTTS, startTs, 0);
    }
    #[inline]
    pub fn add_endTs(&mut self, endTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_CommonAvailCheck::VT_ENDTS, endTs, 0);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_CommonUnlockType) {
        self.fbb_.push_slot::<enum__Torappu_CommonUnlockType>(
            clz_Torappu_CommonAvailCheck::VT_TYPE_,
            type_,
            enum__Torappu_CommonUnlockType::STAGECLEAR,
        );
    }
    #[inline]
    pub fn add_rate(&mut self, rate: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_CommonAvailCheck::VT_RATE, rate, 0.0);
    }
    #[inline]
    pub fn add_stageUnlockParam(
        &mut self,
        stageUnlockParam: flatbuffers::WIPOffset<clz_Torappu_StageUnlockParam<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StageUnlockParam>>(
                clz_Torappu_CommonAvailCheck::VT_STAGEUNLOCKPARAM,
                stageUnlockParam,
            );
    }
    #[inline]
    pub fn add_charUnlockParam(
        &mut self,
        charUnlockParam: flatbuffers::WIPOffset<clz_Torappu_CharUnlockParam<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharUnlockParam>>(
                clz_Torappu_CommonAvailCheck::VT_CHARUNLOCKPARAM,
                charUnlockParam,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CommonAvailCheckBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CommonAvailCheckBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CommonAvailCheck<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CommonAvailCheck<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CommonAvailCheck");
        ds.field("startTs", &self.startTs());
        ds.field("endTs", &self.endTs());
        ds.field("type_", &self.type_());
        ds.field("rate", &self.rate());
        ds.field("stageUnlockParam", &self.stageUnlockParam());
        ds.field("charUnlockParam", &self.charUnlockParam());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CommonAvailCheckT {
    pub startTs: i64,
    pub endTs: i64,
    pub type_: enum__Torappu_CommonUnlockType,
    pub rate: f32,
    pub stageUnlockParam: Option<Box<clz_Torappu_StageUnlockParamT>>,
    pub charUnlockParam: Option<Box<clz_Torappu_CharUnlockParamT>>,
}
impl Default for clz_Torappu_CommonAvailCheckT {
    fn default() -> Self {
        Self {
            startTs: 0,
            endTs: 0,
            type_: enum__Torappu_CommonUnlockType::STAGECLEAR,
            rate: 0.0,
            stageUnlockParam: None,
            charUnlockParam: None,
        }
    }
}
impl clz_Torappu_CommonAvailCheckT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CommonAvailCheck<'b>> {
        let startTs = self.startTs;
        let endTs = self.endTs;
        let type_ = self.type_;
        let rate = self.rate;
        let stageUnlockParam = self.stageUnlockParam.as_ref().map(|x| x.pack(_fbb));
        let charUnlockParam = self.charUnlockParam.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_CommonAvailCheck::create(
            _fbb,
            &clz_Torappu_CommonAvailCheckArgs {
                startTs,
                endTs,
                type_,
                rate,
                stageUnlockParam,
                charUnlockParam,
            },
        )
    }
}
pub enum clz_Torappu_TipDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_TipData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_TipData<'a> {
    type Inner = clz_Torappu_TipData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_TipData<'a> {
    pub const VT_TIP: flatbuffers::VOffsetT = 4;
    pub const VT_WEIGHT: flatbuffers::VOffsetT = 6;
    pub const VT_CATEGORY: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_TipData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_TipDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TipData<'bldr>> {
        let mut builder = clz_Torappu_TipDataBuilder::new(_fbb);
        builder.add_category(args.category);
        builder.add_weight(args.weight);
        if let Some(x) = args.tip {
            builder.add_tip(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_TipDataT {
        let tip = self.tip().map(|x| x.to_string());
        let weight = self.weight();
        let category = self.category();
        clz_Torappu_TipDataT {
            tip,
            weight,
            category,
        }
    }

    #[inline]
    pub fn tip(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_TipData::VT_TIP, None)
        }
    }
    #[inline]
    pub fn weight(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_TipData::VT_WEIGHT, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn category(&self) -> enum__Torappu_TipData_Category {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_TipData_Category>(
                    clz_Torappu_TipData::VT_CATEGORY,
                    Some(enum__Torappu_TipData_Category::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_TipData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tip", Self::VT_TIP, false)?
            .visit_field::<f32>("weight", Self::VT_WEIGHT, false)?
            .visit_field::<enum__Torappu_TipData_Category>("category", Self::VT_CATEGORY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_TipDataArgs<'a> {
    pub tip: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weight: f32,
    pub category: enum__Torappu_TipData_Category,
}
impl<'a> Default for clz_Torappu_TipDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_TipDataArgs {
            tip: None,
            weight: 0.0,
            category: enum__Torappu_TipData_Category::NONE,
        }
    }
}

impl Serialize for clz_Torappu_TipData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_TipData", 3)?;
        if let Some(f) = self.tip() {
            s.serialize_field("tip", &f)?;
        } else {
            s.skip_field("tip")?;
        }
        s.serialize_field("weight", &self.weight())?;
        s.serialize_field("category", &self.category())?;
        s.end()
    }
}

pub struct clz_Torappu_TipDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_TipDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_tip(&mut self, tip: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_TipData::VT_TIP, tip);
    }
    #[inline]
    pub fn add_weight(&mut self, weight: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_TipData::VT_WEIGHT, weight, 0.0);
    }
    #[inline]
    pub fn add_category(&mut self, category: enum__Torappu_TipData_Category) {
        self.fbb_.push_slot::<enum__Torappu_TipData_Category>(
            clz_Torappu_TipData::VT_CATEGORY,
            category,
            enum__Torappu_TipData_Category::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_TipDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_TipDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_TipData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_TipData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_TipData");
        ds.field("tip", &self.tip());
        ds.field("weight", &self.weight());
        ds.field("category", &self.category());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_TipDataT {
    pub tip: Option<String>,
    pub weight: f32,
    pub category: enum__Torappu_TipData_Category,
}
impl Default for clz_Torappu_TipDataT {
    fn default() -> Self {
        Self {
            tip: None,
            weight: 0.0,
            category: enum__Torappu_TipData_Category::NONE,
        }
    }
}
impl clz_Torappu_TipDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TipData<'b>> {
        let tip = self.tip.as_ref().map(|x| _fbb.create_string(x));
        let weight = self.weight;
        let category = self.category;
        clz_Torappu_TipData::create(
            _fbb,
            &clz_Torappu_TipDataArgs {
                tip,
                weight,
                category,
            },
        )
    }
}
pub enum clz_Torappu_TipsMetaDisplayItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_TipsMetaDisplayItem<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_TipsMetaDisplayItem<'a> {
    type Inner = clz_Torappu_TipsMetaDisplayItem<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_TipsMetaDisplayItem<'a> {
    pub const VT_TIPSID: flatbuffers::VOffsetT = 4;
    pub const VT_LOADINGPIC: flatbuffers::VOffsetT = 6;
    pub const VT_AVAILCHECK: flatbuffers::VOffsetT = 8;
    pub const VT_RELATEACTID: flatbuffers::VOffsetT = 10;
    pub const VT_ISALLSTAGEACTIVE: flatbuffers::VOffsetT = 12;
    pub const VT_STAGEIDLIST: flatbuffers::VOffsetT = 14;
    pub const VT_ZONEIDLIST: flatbuffers::VOffsetT = 16;
    pub const VT_TIPS: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_TipsMetaDisplayItem { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_TipsMetaDisplayItemArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TipsMetaDisplayItem<'bldr>> {
        let mut builder = clz_Torappu_TipsMetaDisplayItemBuilder::new(_fbb);
        if let Some(x) = args.tips {
            builder.add_tips(x);
        }
        if let Some(x) = args.zoneIdList {
            builder.add_zoneIdList(x);
        }
        if let Some(x) = args.stageIdList {
            builder.add_stageIdList(x);
        }
        if let Some(x) = args.relateActId {
            builder.add_relateActId(x);
        }
        if let Some(x) = args.availCheck {
            builder.add_availCheck(x);
        }
        if let Some(x) = args.loadingPic {
            builder.add_loadingPic(x);
        }
        if let Some(x) = args.tipsId {
            builder.add_tipsId(x);
        }
        builder.add_isAllStageActive(args.isAllStageActive);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_TipsMetaDisplayItemT {
        let tipsId = self.tipsId().map(|x| x.to_string());
        let loadingPic = self.loadingPic().map(|x| x.to_string());
        let availCheck = self.availCheck().map(|x| Box::new(x.unpack()));
        let relateActId = self.relateActId().map(|x| x.to_string());
        let isAllStageActive = self.isAllStageActive();
        let stageIdList = self
            .stageIdList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let zoneIdList = self
            .zoneIdList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let tips = self.tips().map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_TipsMetaDisplayItemT {
            tipsId,
            loadingPic,
            availCheck,
            relateActId,
            isAllStageActive,
            stageIdList,
            zoneIdList,
            tips,
        }
    }

    #[inline]
    pub fn tipsId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TipsMetaDisplayItem::VT_TIPSID,
                None,
            )
        }
    }
    #[inline]
    pub fn loadingPic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TipsMetaDisplayItem::VT_LOADINGPIC,
                None,
            )
        }
    }
    #[inline]
    pub fn availCheck(&self) -> Option<clz_Torappu_CommonAvailCheck<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CommonAvailCheck>>(
                    clz_Torappu_TipsMetaDisplayItem::VT_AVAILCHECK,
                    None,
                )
        }
    }
    #[inline]
    pub fn relateActId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TipsMetaDisplayItem::VT_RELATEACTID,
                None,
            )
        }
    }
    #[inline]
    pub fn isAllStageActive(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_TipsMetaDisplayItem::VT_ISALLSTAGEACTIVE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn stageIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_TipsMetaDisplayItem::VT_STAGEIDLIST, None)
        }
    }
    #[inline]
    pub fn zoneIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_TipsMetaDisplayItem::VT_ZONEIDLIST, None)
        }
    }
    #[inline]
    pub fn tips(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TipData<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TipData>>,
            >>(clz_Torappu_TipsMetaDisplayItem::VT_TIPS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_TipsMetaDisplayItem<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tipsId", Self::VT_TIPSID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "loadingPic",
                Self::VT_LOADINGPIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CommonAvailCheck>>(
                "availCheck",
                Self::VT_AVAILCHECK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "relateActId",
                Self::VT_RELATEACTID,
                false,
            )?
            .visit_field::<bool>("isAllStageActive", Self::VT_ISALLSTAGEACTIVE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("stageIdList", Self::VT_STAGEIDLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("zoneIdList", Self::VT_ZONEIDLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_TipData>>,
            >>("tips", Self::VT_TIPS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_TipsMetaDisplayItemArgs<'a> {
    pub tipsId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub loadingPic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub availCheck: Option<flatbuffers::WIPOffset<clz_Torappu_CommonAvailCheck<'a>>>,
    pub relateActId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isAllStageActive: bool,
    pub stageIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub zoneIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub tips: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TipData<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_TipsMetaDisplayItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_TipsMetaDisplayItemArgs {
            tipsId: None,
            loadingPic: None,
            availCheck: None,
            relateActId: None,
            isAllStageActive: false,
            stageIdList: None,
            zoneIdList: None,
            tips: None,
        }
    }
}

impl Serialize for clz_Torappu_TipsMetaDisplayItem<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_TipsMetaDisplayItem", 8)?;
        if let Some(f) = self.tipsId() {
            s.serialize_field("tipsId", &f)?;
        } else {
            s.skip_field("tipsId")?;
        }
        if let Some(f) = self.loadingPic() {
            s.serialize_field("loadingPic", &f)?;
        } else {
            s.skip_field("loadingPic")?;
        }
        if let Some(f) = self.availCheck() {
            s.serialize_field("availCheck", &f)?;
        } else {
            s.skip_field("availCheck")?;
        }
        if let Some(f) = self.relateActId() {
            s.serialize_field("relateActId", &f)?;
        } else {
            s.skip_field("relateActId")?;
        }
        s.serialize_field("isAllStageActive", &self.isAllStageActive())?;
        if let Some(f) = self.stageIdList() {
            s.serialize_field("stageIdList", &f)?;
        } else {
            s.skip_field("stageIdList")?;
        }
        if let Some(f) = self.zoneIdList() {
            s.serialize_field("zoneIdList", &f)?;
        } else {
            s.skip_field("zoneIdList")?;
        }
        if let Some(f) = self.tips() {
            s.serialize_field("tips", &f)?;
        } else {
            s.skip_field("tips")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_TipsMetaDisplayItemBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_TipsMetaDisplayItemBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_tipsId(&mut self, tipsId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TipsMetaDisplayItem::VT_TIPSID,
            tipsId,
        );
    }
    #[inline]
    pub fn add_loadingPic(&mut self, loadingPic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TipsMetaDisplayItem::VT_LOADINGPIC,
            loadingPic,
        );
    }
    #[inline]
    pub fn add_availCheck(
        &mut self,
        availCheck: flatbuffers::WIPOffset<clz_Torappu_CommonAvailCheck<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CommonAvailCheck>>(
                clz_Torappu_TipsMetaDisplayItem::VT_AVAILCHECK,
                availCheck,
            );
    }
    #[inline]
    pub fn add_relateActId(&mut self, relateActId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TipsMetaDisplayItem::VT_RELATEACTID,
            relateActId,
        );
    }
    #[inline]
    pub fn add_isAllStageActive(&mut self, isAllStageActive: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_TipsMetaDisplayItem::VT_ISALLSTAGEACTIVE,
            isAllStageActive,
            false,
        );
    }
    #[inline]
    pub fn add_stageIdList(
        &mut self,
        stageIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TipsMetaDisplayItem::VT_STAGEIDLIST,
            stageIdList,
        );
    }
    #[inline]
    pub fn add_zoneIdList(
        &mut self,
        zoneIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TipsMetaDisplayItem::VT_ZONEIDLIST,
            zoneIdList,
        );
    }
    #[inline]
    pub fn add_tips(
        &mut self,
        tips: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_TipData<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TipsMetaDisplayItem::VT_TIPS,
            tips,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_TipsMetaDisplayItemBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_TipsMetaDisplayItemBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_TipsMetaDisplayItem<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_TipsMetaDisplayItem<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_TipsMetaDisplayItem");
        ds.field("tipsId", &self.tipsId());
        ds.field("loadingPic", &self.loadingPic());
        ds.field("availCheck", &self.availCheck());
        ds.field("relateActId", &self.relateActId());
        ds.field("isAllStageActive", &self.isAllStageActive());
        ds.field("stageIdList", &self.stageIdList());
        ds.field("zoneIdList", &self.zoneIdList());
        ds.field("tips", &self.tips());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_TipsMetaDisplayItemT {
    pub tipsId: Option<String>,
    pub loadingPic: Option<String>,
    pub availCheck: Option<Box<clz_Torappu_CommonAvailCheckT>>,
    pub relateActId: Option<String>,
    pub isAllStageActive: bool,
    pub stageIdList: Option<Vec<String>>,
    pub zoneIdList: Option<Vec<String>>,
    pub tips: Option<Vec<clz_Torappu_TipDataT>>,
}
impl Default for clz_Torappu_TipsMetaDisplayItemT {
    fn default() -> Self {
        Self {
            tipsId: None,
            loadingPic: None,
            availCheck: None,
            relateActId: None,
            isAllStageActive: false,
            stageIdList: None,
            zoneIdList: None,
            tips: None,
        }
    }
}
impl clz_Torappu_TipsMetaDisplayItemT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TipsMetaDisplayItem<'b>> {
        let tipsId = self.tipsId.as_ref().map(|x| _fbb.create_string(x));
        let loadingPic = self.loadingPic.as_ref().map(|x| _fbb.create_string(x));
        let availCheck = self.availCheck.as_ref().map(|x| x.pack(_fbb));
        let relateActId = self.relateActId.as_ref().map(|x| _fbb.create_string(x));
        let isAllStageActive = self.isAllStageActive;
        let stageIdList = self.stageIdList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let zoneIdList = self.zoneIdList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let tips = self.tips.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_TipsMetaDisplayItem::create(
            _fbb,
            &clz_Torappu_TipsMetaDisplayItemArgs {
                tipsId,
                loadingPic,
                availCheck,
                relateActId,
                isAllStageActive,
                stageIdList,
                zoneIdList,
                tips,
            },
        )
    }
}
pub enum clz_Torappu_FlashAlertAfterStageDisplayMetaItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_FlashAlertAfterStageDisplayMetaItem<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_FlashAlertAfterStageDisplayMetaItem<'a> {
    type Inner = clz_Torappu_FlashAlertAfterStageDisplayMetaItem<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_FlashAlertAfterStageDisplayMetaItem<'a> {
    pub const VT_FLASHALERTID: flatbuffers::VOffsetT = 4;
    pub const VT_AVAILCHECK: flatbuffers::VOffsetT = 6;
    pub const VT_ISALLSTAGEACTIVE: flatbuffers::VOffsetT = 8;
    pub const VT_STAGEIDLIST: flatbuffers::VOffsetT = 10;
    pub const VT_RELATEACTID: flatbuffers::VOffsetT = 12;
    pub const VT_DETAILTEXT: flatbuffers::VOffsetT = 14;
    pub const VT_ISBASICINFO: flatbuffers::VOffsetT = 16;
    pub const VT_TIMES: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_FlashAlertAfterStageDisplayMetaItem { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_FlashAlertAfterStageDisplayMetaItemArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_FlashAlertAfterStageDisplayMetaItem<'bldr>> {
        let mut builder = clz_Torappu_FlashAlertAfterStageDisplayMetaItemBuilder::new(_fbb);
        builder.add_times(args.times);
        if let Some(x) = args.detailText {
            builder.add_detailText(x);
        }
        if let Some(x) = args.relateActId {
            builder.add_relateActId(x);
        }
        if let Some(x) = args.stageIdList {
            builder.add_stageIdList(x);
        }
        if let Some(x) = args.availCheck {
            builder.add_availCheck(x);
        }
        if let Some(x) = args.flashAlertId {
            builder.add_flashAlertId(x);
        }
        builder.add_isBasicInfo(args.isBasicInfo);
        builder.add_isAllStageActive(args.isAllStageActive);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_FlashAlertAfterStageDisplayMetaItemT {
        let flashAlertId = self.flashAlertId().map(|x| x.to_string());
        let availCheck = self.availCheck().map(|x| Box::new(x.unpack()));
        let isAllStageActive = self.isAllStageActive();
        let stageIdList = self
            .stageIdList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let relateActId = self.relateActId().map(|x| x.to_string());
        let detailText = self.detailText().map(|x| x.to_string());
        let isBasicInfo = self.isBasicInfo();
        let times = self.times();
        clz_Torappu_FlashAlertAfterStageDisplayMetaItemT {
            flashAlertId,
            availCheck,
            isAllStageActive,
            stageIdList,
            relateActId,
            detailText,
            isBasicInfo,
            times,
        }
    }

    #[inline]
    pub fn flashAlertId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_FlashAlertAfterStageDisplayMetaItem::VT_FLASHALERTID,
                None,
            )
        }
    }
    #[inline]
    pub fn availCheck(&self) -> Option<clz_Torappu_CommonAvailCheck<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CommonAvailCheck>>(
                    clz_Torappu_FlashAlertAfterStageDisplayMetaItem::VT_AVAILCHECK,
                    None,
                )
        }
    }
    #[inline]
    pub fn isAllStageActive(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_FlashAlertAfterStageDisplayMetaItem::VT_ISALLSTAGEACTIVE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn stageIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_FlashAlertAfterStageDisplayMetaItem::VT_STAGEIDLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn relateActId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_FlashAlertAfterStageDisplayMetaItem::VT_RELATEACTID,
                None,
            )
        }
    }
    #[inline]
    pub fn detailText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_FlashAlertAfterStageDisplayMetaItem::VT_DETAILTEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn isBasicInfo(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_FlashAlertAfterStageDisplayMetaItem::VT_ISBASICINFO,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn times(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_FlashAlertAfterStageDisplayMetaItem::VT_TIMES,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_FlashAlertAfterStageDisplayMetaItem<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "flashAlertId",
                Self::VT_FLASHALERTID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CommonAvailCheck>>(
                "availCheck",
                Self::VT_AVAILCHECK,
                false,
            )?
            .visit_field::<bool>("isAllStageActive", Self::VT_ISALLSTAGEACTIVE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("stageIdList", Self::VT_STAGEIDLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "relateActId",
                Self::VT_RELATEACTID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "detailText",
                Self::VT_DETAILTEXT,
                false,
            )?
            .visit_field::<bool>("isBasicInfo", Self::VT_ISBASICINFO, false)?
            .visit_field::<i32>("times", Self::VT_TIMES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_FlashAlertAfterStageDisplayMetaItemArgs<'a> {
    pub flashAlertId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub availCheck: Option<flatbuffers::WIPOffset<clz_Torappu_CommonAvailCheck<'a>>>,
    pub isAllStageActive: bool,
    pub stageIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub relateActId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub detailText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isBasicInfo: bool,
    pub times: i32,
}
impl<'a> Default for clz_Torappu_FlashAlertAfterStageDisplayMetaItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_FlashAlertAfterStageDisplayMetaItemArgs {
            flashAlertId: None,
            availCheck: None,
            isAllStageActive: false,
            stageIdList: None,
            relateActId: None,
            detailText: None,
            isBasicInfo: false,
            times: 0,
        }
    }
}

impl Serialize for clz_Torappu_FlashAlertAfterStageDisplayMetaItem<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_FlashAlertAfterStageDisplayMetaItem", 8)?;
        if let Some(f) = self.flashAlertId() {
            s.serialize_field("flashAlertId", &f)?;
        } else {
            s.skip_field("flashAlertId")?;
        }
        if let Some(f) = self.availCheck() {
            s.serialize_field("availCheck", &f)?;
        } else {
            s.skip_field("availCheck")?;
        }
        s.serialize_field("isAllStageActive", &self.isAllStageActive())?;
        if let Some(f) = self.stageIdList() {
            s.serialize_field("stageIdList", &f)?;
        } else {
            s.skip_field("stageIdList")?;
        }
        if let Some(f) = self.relateActId() {
            s.serialize_field("relateActId", &f)?;
        } else {
            s.skip_field("relateActId")?;
        }
        if let Some(f) = self.detailText() {
            s.serialize_field("detailText", &f)?;
        } else {
            s.skip_field("detailText")?;
        }
        s.serialize_field("isBasicInfo", &self.isBasicInfo())?;
        s.serialize_field("times", &self.times())?;
        s.end()
    }
}

pub struct clz_Torappu_FlashAlertAfterStageDisplayMetaItemBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_FlashAlertAfterStageDisplayMetaItemBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_flashAlertId(&mut self, flashAlertId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_FlashAlertAfterStageDisplayMetaItem::VT_FLASHALERTID,
            flashAlertId,
        );
    }
    #[inline]
    pub fn add_availCheck(
        &mut self,
        availCheck: flatbuffers::WIPOffset<clz_Torappu_CommonAvailCheck<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CommonAvailCheck>>(
                clz_Torappu_FlashAlertAfterStageDisplayMetaItem::VT_AVAILCHECK,
                availCheck,
            );
    }
    #[inline]
    pub fn add_isAllStageActive(&mut self, isAllStageActive: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_FlashAlertAfterStageDisplayMetaItem::VT_ISALLSTAGEACTIVE,
            isAllStageActive,
            false,
        );
    }
    #[inline]
    pub fn add_stageIdList(
        &mut self,
        stageIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_FlashAlertAfterStageDisplayMetaItem::VT_STAGEIDLIST,
            stageIdList,
        );
    }
    #[inline]
    pub fn add_relateActId(&mut self, relateActId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_FlashAlertAfterStageDisplayMetaItem::VT_RELATEACTID,
            relateActId,
        );
    }
    #[inline]
    pub fn add_detailText(&mut self, detailText: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_FlashAlertAfterStageDisplayMetaItem::VT_DETAILTEXT,
            detailText,
        );
    }
    #[inline]
    pub fn add_isBasicInfo(&mut self, isBasicInfo: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_FlashAlertAfterStageDisplayMetaItem::VT_ISBASICINFO,
            isBasicInfo,
            false,
        );
    }
    #[inline]
    pub fn add_times(&mut self, times: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_FlashAlertAfterStageDisplayMetaItem::VT_TIMES,
            times,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_FlashAlertAfterStageDisplayMetaItemBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_FlashAlertAfterStageDisplayMetaItemBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_FlashAlertAfterStageDisplayMetaItem<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_FlashAlertAfterStageDisplayMetaItem<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_FlashAlertAfterStageDisplayMetaItem");
        ds.field("flashAlertId", &self.flashAlertId());
        ds.field("availCheck", &self.availCheck());
        ds.field("isAllStageActive", &self.isAllStageActive());
        ds.field("stageIdList", &self.stageIdList());
        ds.field("relateActId", &self.relateActId());
        ds.field("detailText", &self.detailText());
        ds.field("isBasicInfo", &self.isBasicInfo());
        ds.field("times", &self.times());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_FlashAlertAfterStageDisplayMetaItemT {
    pub flashAlertId: Option<String>,
    pub availCheck: Option<Box<clz_Torappu_CommonAvailCheckT>>,
    pub isAllStageActive: bool,
    pub stageIdList: Option<Vec<String>>,
    pub relateActId: Option<String>,
    pub detailText: Option<String>,
    pub isBasicInfo: bool,
    pub times: i32,
}
impl Default for clz_Torappu_FlashAlertAfterStageDisplayMetaItemT {
    fn default() -> Self {
        Self {
            flashAlertId: None,
            availCheck: None,
            isAllStageActive: false,
            stageIdList: None,
            relateActId: None,
            detailText: None,
            isBasicInfo: false,
            times: 0,
        }
    }
}
impl clz_Torappu_FlashAlertAfterStageDisplayMetaItemT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_FlashAlertAfterStageDisplayMetaItem<'b>> {
        let flashAlertId = self.flashAlertId.as_ref().map(|x| _fbb.create_string(x));
        let availCheck = self.availCheck.as_ref().map(|x| x.pack(_fbb));
        let isAllStageActive = self.isAllStageActive;
        let stageIdList = self.stageIdList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let relateActId = self.relateActId.as_ref().map(|x| _fbb.create_string(x));
        let detailText = self.detailText.as_ref().map(|x| _fbb.create_string(x));
        let isBasicInfo = self.isBasicInfo;
        let times = self.times;
        clz_Torappu_FlashAlertAfterStageDisplayMetaItem::create(
            _fbb,
            &clz_Torappu_FlashAlertAfterStageDisplayMetaItemArgs {
                flashAlertId,
                availCheck,
                isAllStageActive,
                stageIdList,
                relateActId,
                detailText,
                isBasicInfo,
                times,
            },
        )
    }
}
pub enum clz_Torappu_MapPreviewDisplayMetaItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_MapPreviewDisplayMetaItem<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_MapPreviewDisplayMetaItem<'a> {
    type Inner = clz_Torappu_MapPreviewDisplayMetaItem<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_MapPreviewDisplayMetaItem<'a> {
    pub const VT_MAPPREVIEWPICID: flatbuffers::VOffsetT = 4;
    pub const VT_AVAILCHECK: flatbuffers::VOffsetT = 6;
    pub const VT_RELATEACTID: flatbuffers::VOffsetT = 8;
    pub const VT_ISALLSTAGEACTIVE: flatbuffers::VOffsetT = 10;
    pub const VT_STAGEIDLIST: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_MapPreviewDisplayMetaItem { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_MapPreviewDisplayMetaItemArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MapPreviewDisplayMetaItem<'bldr>> {
        let mut builder = clz_Torappu_MapPreviewDisplayMetaItemBuilder::new(_fbb);
        if let Some(x) = args.stageIdList {
            builder.add_stageIdList(x);
        }
        if let Some(x) = args.relateActId {
            builder.add_relateActId(x);
        }
        if let Some(x) = args.availCheck {
            builder.add_availCheck(x);
        }
        if let Some(x) = args.mapPreviewPicId {
            builder.add_mapPreviewPicId(x);
        }
        builder.add_isAllStageActive(args.isAllStageActive);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_MapPreviewDisplayMetaItemT {
        let mapPreviewPicId = self.mapPreviewPicId().map(|x| x.to_string());
        let availCheck = self.availCheck().map(|x| Box::new(x.unpack()));
        let relateActId = self.relateActId().map(|x| x.to_string());
        let isAllStageActive = self.isAllStageActive();
        let stageIdList = self
            .stageIdList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_MapPreviewDisplayMetaItemT {
            mapPreviewPicId,
            availCheck,
            relateActId,
            isAllStageActive,
            stageIdList,
        }
    }

    #[inline]
    pub fn mapPreviewPicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MapPreviewDisplayMetaItem::VT_MAPPREVIEWPICID,
                None,
            )
        }
    }
    #[inline]
    pub fn availCheck(&self) -> Option<clz_Torappu_CommonAvailCheck<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CommonAvailCheck>>(
                    clz_Torappu_MapPreviewDisplayMetaItem::VT_AVAILCHECK,
                    None,
                )
        }
    }
    #[inline]
    pub fn relateActId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MapPreviewDisplayMetaItem::VT_RELATEACTID,
                None,
            )
        }
    }
    #[inline]
    pub fn isAllStageActive(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_MapPreviewDisplayMetaItem::VT_ISALLSTAGEACTIVE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn stageIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_MapPreviewDisplayMetaItem::VT_STAGEIDLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_MapPreviewDisplayMetaItem<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "mapPreviewPicId",
                Self::VT_MAPPREVIEWPICID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CommonAvailCheck>>(
                "availCheck",
                Self::VT_AVAILCHECK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "relateActId",
                Self::VT_RELATEACTID,
                false,
            )?
            .visit_field::<bool>("isAllStageActive", Self::VT_ISALLSTAGEACTIVE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("stageIdList", Self::VT_STAGEIDLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_MapPreviewDisplayMetaItemArgs<'a> {
    pub mapPreviewPicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub availCheck: Option<flatbuffers::WIPOffset<clz_Torappu_CommonAvailCheck<'a>>>,
    pub relateActId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isAllStageActive: bool,
    pub stageIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_MapPreviewDisplayMetaItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_MapPreviewDisplayMetaItemArgs {
            mapPreviewPicId: None,
            availCheck: None,
            relateActId: None,
            isAllStageActive: false,
            stageIdList: None,
        }
    }
}

impl Serialize for clz_Torappu_MapPreviewDisplayMetaItem<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_MapPreviewDisplayMetaItem", 5)?;
        if let Some(f) = self.mapPreviewPicId() {
            s.serialize_field("mapPreviewPicId", &f)?;
        } else {
            s.skip_field("mapPreviewPicId")?;
        }
        if let Some(f) = self.availCheck() {
            s.serialize_field("availCheck", &f)?;
        } else {
            s.skip_field("availCheck")?;
        }
        if let Some(f) = self.relateActId() {
            s.serialize_field("relateActId", &f)?;
        } else {
            s.skip_field("relateActId")?;
        }
        s.serialize_field("isAllStageActive", &self.isAllStageActive())?;
        if let Some(f) = self.stageIdList() {
            s.serialize_field("stageIdList", &f)?;
        } else {
            s.skip_field("stageIdList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_MapPreviewDisplayMetaItemBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_MapPreviewDisplayMetaItemBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_mapPreviewPicId(&mut self, mapPreviewPicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MapPreviewDisplayMetaItem::VT_MAPPREVIEWPICID,
            mapPreviewPicId,
        );
    }
    #[inline]
    pub fn add_availCheck(
        &mut self,
        availCheck: flatbuffers::WIPOffset<clz_Torappu_CommonAvailCheck<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CommonAvailCheck>>(
                clz_Torappu_MapPreviewDisplayMetaItem::VT_AVAILCHECK,
                availCheck,
            );
    }
    #[inline]
    pub fn add_relateActId(&mut self, relateActId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MapPreviewDisplayMetaItem::VT_RELATEACTID,
            relateActId,
        );
    }
    #[inline]
    pub fn add_isAllStageActive(&mut self, isAllStageActive: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_MapPreviewDisplayMetaItem::VT_ISALLSTAGEACTIVE,
            isAllStageActive,
            false,
        );
    }
    #[inline]
    pub fn add_stageIdList(
        &mut self,
        stageIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MapPreviewDisplayMetaItem::VT_STAGEIDLIST,
            stageIdList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_MapPreviewDisplayMetaItemBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_MapPreviewDisplayMetaItemBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_MapPreviewDisplayMetaItem<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_MapPreviewDisplayMetaItem<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_MapPreviewDisplayMetaItem");
        ds.field("mapPreviewPicId", &self.mapPreviewPicId());
        ds.field("availCheck", &self.availCheck());
        ds.field("relateActId", &self.relateActId());
        ds.field("isAllStageActive", &self.isAllStageActive());
        ds.field("stageIdList", &self.stageIdList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_MapPreviewDisplayMetaItemT {
    pub mapPreviewPicId: Option<String>,
    pub availCheck: Option<Box<clz_Torappu_CommonAvailCheckT>>,
    pub relateActId: Option<String>,
    pub isAllStageActive: bool,
    pub stageIdList: Option<Vec<String>>,
}
impl Default for clz_Torappu_MapPreviewDisplayMetaItemT {
    fn default() -> Self {
        Self {
            mapPreviewPicId: None,
            availCheck: None,
            relateActId: None,
            isAllStageActive: false,
            stageIdList: None,
        }
    }
}
impl clz_Torappu_MapPreviewDisplayMetaItemT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MapPreviewDisplayMetaItem<'b>> {
        let mapPreviewPicId = self.mapPreviewPicId.as_ref().map(|x| _fbb.create_string(x));
        let availCheck = self.availCheck.as_ref().map(|x| x.pack(_fbb));
        let relateActId = self.relateActId.as_ref().map(|x| _fbb.create_string(x));
        let isAllStageActive = self.isAllStageActive;
        let stageIdList = self.stageIdList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_MapPreviewDisplayMetaItem::create(
            _fbb,
            &clz_Torappu_MapPreviewDisplayMetaItemArgs {
                mapPreviewPicId,
                availCheck,
                relateActId,
                isAllStageActive,
                stageIdList,
            },
        )
    }
}
pub enum clz_Torappu_BattleFinishDisplayMetaItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BattleFinishDisplayMetaItem<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BattleFinishDisplayMetaItem<'a> {
    type Inner = clz_Torappu_BattleFinishDisplayMetaItem<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_BattleFinishDisplayMetaItem<'a> {
    pub const VT_BATTLEFINISHDISPLAYKEY: flatbuffers::VOffsetT = 4;
    pub const VT_ISALLSTAGEACTIVE: flatbuffers::VOffsetT = 6;
    pub const VT_STAGEIDLIST: flatbuffers::VOffsetT = 8;
    pub const VT_AVAILCHECK: flatbuffers::VOffsetT = 10;
    pub const VT_RELATEACTID: flatbuffers::VOffsetT = 12;
    pub const VT_OVERRIDESTAGENAME: flatbuffers::VOffsetT = 14;
    pub const VT_SIGNAL: flatbuffers::VOffsetT = 16;
    pub const VT_OVERRIDECHARWORD: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BattleFinishDisplayMetaItem { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BattleFinishDisplayMetaItemArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BattleFinishDisplayMetaItem<'bldr>> {
        let mut builder = clz_Torappu_BattleFinishDisplayMetaItemBuilder::new(_fbb);
        if let Some(x) = args.overrideCharWord {
            builder.add_overrideCharWord(x);
        }
        if let Some(x) = args.signal {
            builder.add_signal(x);
        }
        if let Some(x) = args.overrideStageName {
            builder.add_overrideStageName(x);
        }
        if let Some(x) = args.relateActId {
            builder.add_relateActId(x);
        }
        if let Some(x) = args.availCheck {
            builder.add_availCheck(x);
        }
        if let Some(x) = args.stageIdList {
            builder.add_stageIdList(x);
        }
        if let Some(x) = args.battleFinishDisplayKey {
            builder.add_battleFinishDisplayKey(x);
        }
        builder.add_isAllStageActive(args.isAllStageActive);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_BattleFinishDisplayMetaItemT {
        let battleFinishDisplayKey = self.battleFinishDisplayKey().map(|x| x.to_string());
        let isAllStageActive = self.isAllStageActive();
        let stageIdList = self
            .stageIdList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let availCheck = self.availCheck().map(|x| Box::new(x.unpack()));
        let relateActId = self.relateActId().map(|x| x.to_string());
        let overrideStageName = self.overrideStageName().map(|x| x.to_string());
        let signal = self.signal().map(|x| x.to_string());
        let overrideCharWord = self.overrideCharWord().map(|x| x.to_string());
        clz_Torappu_BattleFinishDisplayMetaItemT {
            battleFinishDisplayKey,
            isAllStageActive,
            stageIdList,
            availCheck,
            relateActId,
            overrideStageName,
            signal,
            overrideCharWord,
        }
    }

    #[inline]
    pub fn battleFinishDisplayKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BattleFinishDisplayMetaItem::VT_BATTLEFINISHDISPLAYKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn isAllStageActive(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_BattleFinishDisplayMetaItem::VT_ISALLSTAGEACTIVE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn stageIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_BattleFinishDisplayMetaItem::VT_STAGEIDLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn availCheck(&self) -> Option<clz_Torappu_CommonAvailCheck<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CommonAvailCheck>>(
                    clz_Torappu_BattleFinishDisplayMetaItem::VT_AVAILCHECK,
                    None,
                )
        }
    }
    #[inline]
    pub fn relateActId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BattleFinishDisplayMetaItem::VT_RELATEACTID,
                None,
            )
        }
    }
    #[inline]
    pub fn overrideStageName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BattleFinishDisplayMetaItem::VT_OVERRIDESTAGENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn signal(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BattleFinishDisplayMetaItem::VT_SIGNAL,
                None,
            )
        }
    }
    #[inline]
    pub fn overrideCharWord(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BattleFinishDisplayMetaItem::VT_OVERRIDECHARWORD,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BattleFinishDisplayMetaItem<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "battleFinishDisplayKey",
                Self::VT_BATTLEFINISHDISPLAYKEY,
                false,
            )?
            .visit_field::<bool>("isAllStageActive", Self::VT_ISALLSTAGEACTIVE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("stageIdList", Self::VT_STAGEIDLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CommonAvailCheck>>(
                "availCheck",
                Self::VT_AVAILCHECK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "relateActId",
                Self::VT_RELATEACTID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "overrideStageName",
                Self::VT_OVERRIDESTAGENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("signal", Self::VT_SIGNAL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "overrideCharWord",
                Self::VT_OVERRIDECHARWORD,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BattleFinishDisplayMetaItemArgs<'a> {
    pub battleFinishDisplayKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isAllStageActive: bool,
    pub stageIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub availCheck: Option<flatbuffers::WIPOffset<clz_Torappu_CommonAvailCheck<'a>>>,
    pub relateActId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub overrideStageName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub signal: Option<flatbuffers::WIPOffset<&'a str>>,
    pub overrideCharWord: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_BattleFinishDisplayMetaItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BattleFinishDisplayMetaItemArgs {
            battleFinishDisplayKey: None,
            isAllStageActive: false,
            stageIdList: None,
            availCheck: None,
            relateActId: None,
            overrideStageName: None,
            signal: None,
            overrideCharWord: None,
        }
    }
}

impl Serialize for clz_Torappu_BattleFinishDisplayMetaItem<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_BattleFinishDisplayMetaItem", 8)?;
        if let Some(f) = self.battleFinishDisplayKey() {
            s.serialize_field("battleFinishDisplayKey", &f)?;
        } else {
            s.skip_field("battleFinishDisplayKey")?;
        }
        s.serialize_field("isAllStageActive", &self.isAllStageActive())?;
        if let Some(f) = self.stageIdList() {
            s.serialize_field("stageIdList", &f)?;
        } else {
            s.skip_field("stageIdList")?;
        }
        if let Some(f) = self.availCheck() {
            s.serialize_field("availCheck", &f)?;
        } else {
            s.skip_field("availCheck")?;
        }
        if let Some(f) = self.relateActId() {
            s.serialize_field("relateActId", &f)?;
        } else {
            s.skip_field("relateActId")?;
        }
        if let Some(f) = self.overrideStageName() {
            s.serialize_field("overrideStageName", &f)?;
        } else {
            s.skip_field("overrideStageName")?;
        }
        if let Some(f) = self.signal() {
            s.serialize_field("signal", &f)?;
        } else {
            s.skip_field("signal")?;
        }
        if let Some(f) = self.overrideCharWord() {
            s.serialize_field("overrideCharWord", &f)?;
        } else {
            s.skip_field("overrideCharWord")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_BattleFinishDisplayMetaItemBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BattleFinishDisplayMetaItemBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_battleFinishDisplayKey(
        &mut self,
        battleFinishDisplayKey: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BattleFinishDisplayMetaItem::VT_BATTLEFINISHDISPLAYKEY,
            battleFinishDisplayKey,
        );
    }
    #[inline]
    pub fn add_isAllStageActive(&mut self, isAllStageActive: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_BattleFinishDisplayMetaItem::VT_ISALLSTAGEACTIVE,
            isAllStageActive,
            false,
        );
    }
    #[inline]
    pub fn add_stageIdList(
        &mut self,
        stageIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BattleFinishDisplayMetaItem::VT_STAGEIDLIST,
            stageIdList,
        );
    }
    #[inline]
    pub fn add_availCheck(
        &mut self,
        availCheck: flatbuffers::WIPOffset<clz_Torappu_CommonAvailCheck<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CommonAvailCheck>>(
                clz_Torappu_BattleFinishDisplayMetaItem::VT_AVAILCHECK,
                availCheck,
            );
    }
    #[inline]
    pub fn add_relateActId(&mut self, relateActId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BattleFinishDisplayMetaItem::VT_RELATEACTID,
            relateActId,
        );
    }
    #[inline]
    pub fn add_overrideStageName(&mut self, overrideStageName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BattleFinishDisplayMetaItem::VT_OVERRIDESTAGENAME,
            overrideStageName,
        );
    }
    #[inline]
    pub fn add_signal(&mut self, signal: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BattleFinishDisplayMetaItem::VT_SIGNAL,
            signal,
        );
    }
    #[inline]
    pub fn add_overrideCharWord(&mut self, overrideCharWord: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BattleFinishDisplayMetaItem::VT_OVERRIDECHARWORD,
            overrideCharWord,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BattleFinishDisplayMetaItemBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BattleFinishDisplayMetaItemBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BattleFinishDisplayMetaItem<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BattleFinishDisplayMetaItem<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BattleFinishDisplayMetaItem");
        ds.field("battleFinishDisplayKey", &self.battleFinishDisplayKey());
        ds.field("isAllStageActive", &self.isAllStageActive());
        ds.field("stageIdList", &self.stageIdList());
        ds.field("availCheck", &self.availCheck());
        ds.field("relateActId", &self.relateActId());
        ds.field("overrideStageName", &self.overrideStageName());
        ds.field("signal", &self.signal());
        ds.field("overrideCharWord", &self.overrideCharWord());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_BattleFinishDisplayMetaItemT {
    pub battleFinishDisplayKey: Option<String>,
    pub isAllStageActive: bool,
    pub stageIdList: Option<Vec<String>>,
    pub availCheck: Option<Box<clz_Torappu_CommonAvailCheckT>>,
    pub relateActId: Option<String>,
    pub overrideStageName: Option<String>,
    pub signal: Option<String>,
    pub overrideCharWord: Option<String>,
}
impl Default for clz_Torappu_BattleFinishDisplayMetaItemT {
    fn default() -> Self {
        Self {
            battleFinishDisplayKey: None,
            isAllStageActive: false,
            stageIdList: None,
            availCheck: None,
            relateActId: None,
            overrideStageName: None,
            signal: None,
            overrideCharWord: None,
        }
    }
}
impl clz_Torappu_BattleFinishDisplayMetaItemT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BattleFinishDisplayMetaItem<'b>> {
        let battleFinishDisplayKey = self
            .battleFinishDisplayKey
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let isAllStageActive = self.isAllStageActive;
        let stageIdList = self.stageIdList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let availCheck = self.availCheck.as_ref().map(|x| x.pack(_fbb));
        let relateActId = self.relateActId.as_ref().map(|x| _fbb.create_string(x));
        let overrideStageName = self
            .overrideStageName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let signal = self.signal.as_ref().map(|x| _fbb.create_string(x));
        let overrideCharWord = self
            .overrideCharWord
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_BattleFinishDisplayMetaItem::create(
            _fbb,
            &clz_Torappu_BattleFinishDisplayMetaItemArgs {
                battleFinishDisplayKey,
                isAllStageActive,
                stageIdList,
                availCheck,
                relateActId,
                overrideStageName,
                signal,
                overrideCharWord,
            },
        )
    }
}
pub enum clz_Torappu_BattleLoadingDisplayMetaItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BattleLoadingDisplayMetaItem<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BattleLoadingDisplayMetaItem<'a> {
    type Inner = clz_Torappu_BattleLoadingDisplayMetaItem<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_BattleLoadingDisplayMetaItem<'a> {
    pub const VT_ISALLSTAGEACTIVE: flatbuffers::VOffsetT = 4;
    pub const VT_STAGEIDLIST: flatbuffers::VOffsetT = 6;
    pub const VT_BATTLELOADINGPICID: flatbuffers::VOffsetT = 8;
    pub const VT_RELATEACTID: flatbuffers::VOffsetT = 10;
    pub const VT_AVAILCHECK: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BattleLoadingDisplayMetaItem { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BattleLoadingDisplayMetaItemArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BattleLoadingDisplayMetaItem<'bldr>> {
        let mut builder = clz_Torappu_BattleLoadingDisplayMetaItemBuilder::new(_fbb);
        if let Some(x) = args.availCheck {
            builder.add_availCheck(x);
        }
        if let Some(x) = args.relateActId {
            builder.add_relateActId(x);
        }
        if let Some(x) = args.battleLoadingPicId {
            builder.add_battleLoadingPicId(x);
        }
        if let Some(x) = args.stageIdList {
            builder.add_stageIdList(x);
        }
        builder.add_isAllStageActive(args.isAllStageActive);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_BattleLoadingDisplayMetaItemT {
        let isAllStageActive = self.isAllStageActive();
        let stageIdList = self
            .stageIdList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let battleLoadingPicId = self.battleLoadingPicId().map(|x| x.to_string());
        let relateActId = self.relateActId().map(|x| x.to_string());
        let availCheck = self.availCheck().map(|x| Box::new(x.unpack()));
        clz_Torappu_BattleLoadingDisplayMetaItemT {
            isAllStageActive,
            stageIdList,
            battleLoadingPicId,
            relateActId,
            availCheck,
        }
    }

    #[inline]
    pub fn isAllStageActive(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_BattleLoadingDisplayMetaItem::VT_ISALLSTAGEACTIVE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn stageIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_BattleLoadingDisplayMetaItem::VT_STAGEIDLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn battleLoadingPicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BattleLoadingDisplayMetaItem::VT_BATTLELOADINGPICID,
                None,
            )
        }
    }
    #[inline]
    pub fn relateActId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BattleLoadingDisplayMetaItem::VT_RELATEACTID,
                None,
            )
        }
    }
    #[inline]
    pub fn availCheck(&self) -> Option<clz_Torappu_CommonAvailCheck<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CommonAvailCheck>>(
                    clz_Torappu_BattleLoadingDisplayMetaItem::VT_AVAILCHECK,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BattleLoadingDisplayMetaItem<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("isAllStageActive", Self::VT_ISALLSTAGEACTIVE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("stageIdList", Self::VT_STAGEIDLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "battleLoadingPicId",
                Self::VT_BATTLELOADINGPICID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "relateActId",
                Self::VT_RELATEACTID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CommonAvailCheck>>(
                "availCheck",
                Self::VT_AVAILCHECK,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BattleLoadingDisplayMetaItemArgs<'a> {
    pub isAllStageActive: bool,
    pub stageIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub battleLoadingPicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relateActId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub availCheck: Option<flatbuffers::WIPOffset<clz_Torappu_CommonAvailCheck<'a>>>,
}
impl<'a> Default for clz_Torappu_BattleLoadingDisplayMetaItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BattleLoadingDisplayMetaItemArgs {
            isAllStageActive: false,
            stageIdList: None,
            battleLoadingPicId: None,
            relateActId: None,
            availCheck: None,
        }
    }
}

impl Serialize for clz_Torappu_BattleLoadingDisplayMetaItem<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_BattleLoadingDisplayMetaItem", 5)?;
        s.serialize_field("isAllStageActive", &self.isAllStageActive())?;
        if let Some(f) = self.stageIdList() {
            s.serialize_field("stageIdList", &f)?;
        } else {
            s.skip_field("stageIdList")?;
        }
        if let Some(f) = self.battleLoadingPicId() {
            s.serialize_field("battleLoadingPicId", &f)?;
        } else {
            s.skip_field("battleLoadingPicId")?;
        }
        if let Some(f) = self.relateActId() {
            s.serialize_field("relateActId", &f)?;
        } else {
            s.skip_field("relateActId")?;
        }
        if let Some(f) = self.availCheck() {
            s.serialize_field("availCheck", &f)?;
        } else {
            s.skip_field("availCheck")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_BattleLoadingDisplayMetaItemBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BattleLoadingDisplayMetaItemBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_isAllStageActive(&mut self, isAllStageActive: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_BattleLoadingDisplayMetaItem::VT_ISALLSTAGEACTIVE,
            isAllStageActive,
            false,
        );
    }
    #[inline]
    pub fn add_stageIdList(
        &mut self,
        stageIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BattleLoadingDisplayMetaItem::VT_STAGEIDLIST,
            stageIdList,
        );
    }
    #[inline]
    pub fn add_battleLoadingPicId(&mut self, battleLoadingPicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BattleLoadingDisplayMetaItem::VT_BATTLELOADINGPICID,
            battleLoadingPicId,
        );
    }
    #[inline]
    pub fn add_relateActId(&mut self, relateActId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BattleLoadingDisplayMetaItem::VT_RELATEACTID,
            relateActId,
        );
    }
    #[inline]
    pub fn add_availCheck(
        &mut self,
        availCheck: flatbuffers::WIPOffset<clz_Torappu_CommonAvailCheck<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CommonAvailCheck>>(
                clz_Torappu_BattleLoadingDisplayMetaItem::VT_AVAILCHECK,
                availCheck,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BattleLoadingDisplayMetaItemBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BattleLoadingDisplayMetaItemBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BattleLoadingDisplayMetaItem<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BattleLoadingDisplayMetaItem<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BattleLoadingDisplayMetaItem");
        ds.field("isAllStageActive", &self.isAllStageActive());
        ds.field("stageIdList", &self.stageIdList());
        ds.field("battleLoadingPicId", &self.battleLoadingPicId());
        ds.field("relateActId", &self.relateActId());
        ds.field("availCheck", &self.availCheck());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_BattleLoadingDisplayMetaItemT {
    pub isAllStageActive: bool,
    pub stageIdList: Option<Vec<String>>,
    pub battleLoadingPicId: Option<String>,
    pub relateActId: Option<String>,
    pub availCheck: Option<Box<clz_Torappu_CommonAvailCheckT>>,
}
impl Default for clz_Torappu_BattleLoadingDisplayMetaItemT {
    fn default() -> Self {
        Self {
            isAllStageActive: false,
            stageIdList: None,
            battleLoadingPicId: None,
            relateActId: None,
            availCheck: None,
        }
    }
}
impl clz_Torappu_BattleLoadingDisplayMetaItemT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BattleLoadingDisplayMetaItem<'b>> {
        let isAllStageActive = self.isAllStageActive;
        let stageIdList = self.stageIdList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let battleLoadingPicId = self
            .battleLoadingPicId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let relateActId = self.relateActId.as_ref().map(|x| _fbb.create_string(x));
        let availCheck = self.availCheck.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_BattleLoadingDisplayMetaItem::create(
            _fbb,
            &clz_Torappu_BattleLoadingDisplayMetaItemArgs {
                isAllStageActive,
                stageIdList,
                battleLoadingPicId,
                relateActId,
                availCheck,
            },
        )
    }
}
pub enum clz_Torappu_BattleAutoBattleMetaItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BattleAutoBattleMetaItem<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BattleAutoBattleMetaItem<'a> {
    type Inner = clz_Torappu_BattleAutoBattleMetaItem<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_BattleAutoBattleMetaItem<'a> {
    pub const VT_BATTLEAUTOBATTLEDISPLAYKEY: flatbuffers::VOffsetT = 4;
    pub const VT_ISALLSTAGEACTIVE: flatbuffers::VOffsetT = 6;
    pub const VT_RELATEACTID: flatbuffers::VOffsetT = 8;
    pub const VT_STAGEIDLIST: flatbuffers::VOffsetT = 10;
    pub const VT_AVAILCHECK: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BattleAutoBattleMetaItem { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BattleAutoBattleMetaItemArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BattleAutoBattleMetaItem<'bldr>> {
        let mut builder = clz_Torappu_BattleAutoBattleMetaItemBuilder::new(_fbb);
        if let Some(x) = args.availCheck {
            builder.add_availCheck(x);
        }
        if let Some(x) = args.stageIdList {
            builder.add_stageIdList(x);
        }
        if let Some(x) = args.relateActId {
            builder.add_relateActId(x);
        }
        if let Some(x) = args.battleAutoBattleDisplayKey {
            builder.add_battleAutoBattleDisplayKey(x);
        }
        builder.add_isAllStageActive(args.isAllStageActive);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_BattleAutoBattleMetaItemT {
        let battleAutoBattleDisplayKey = self.battleAutoBattleDisplayKey().map(|x| x.to_string());
        let isAllStageActive = self.isAllStageActive();
        let relateActId = self.relateActId().map(|x| x.to_string());
        let stageIdList = self
            .stageIdList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let availCheck = self.availCheck().map(|x| Box::new(x.unpack()));
        clz_Torappu_BattleAutoBattleMetaItemT {
            battleAutoBattleDisplayKey,
            isAllStageActive,
            relateActId,
            stageIdList,
            availCheck,
        }
    }

    #[inline]
    pub fn battleAutoBattleDisplayKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BattleAutoBattleMetaItem::VT_BATTLEAUTOBATTLEDISPLAYKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn isAllStageActive(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_BattleAutoBattleMetaItem::VT_ISALLSTAGEACTIVE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn relateActId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BattleAutoBattleMetaItem::VT_RELATEACTID,
                None,
            )
        }
    }
    #[inline]
    pub fn stageIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_BattleAutoBattleMetaItem::VT_STAGEIDLIST, None)
        }
    }
    #[inline]
    pub fn availCheck(&self) -> Option<clz_Torappu_CommonAvailCheck<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CommonAvailCheck>>(
                    clz_Torappu_BattleAutoBattleMetaItem::VT_AVAILCHECK,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BattleAutoBattleMetaItem<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "battleAutoBattleDisplayKey",
                Self::VT_BATTLEAUTOBATTLEDISPLAYKEY,
                false,
            )?
            .visit_field::<bool>("isAllStageActive", Self::VT_ISALLSTAGEACTIVE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "relateActId",
                Self::VT_RELATEACTID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("stageIdList", Self::VT_STAGEIDLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CommonAvailCheck>>(
                "availCheck",
                Self::VT_AVAILCHECK,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BattleAutoBattleMetaItemArgs<'a> {
    pub battleAutoBattleDisplayKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isAllStageActive: bool,
    pub relateActId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stageIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub availCheck: Option<flatbuffers::WIPOffset<clz_Torappu_CommonAvailCheck<'a>>>,
}
impl<'a> Default for clz_Torappu_BattleAutoBattleMetaItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BattleAutoBattleMetaItemArgs {
            battleAutoBattleDisplayKey: None,
            isAllStageActive: false,
            relateActId: None,
            stageIdList: None,
            availCheck: None,
        }
    }
}

impl Serialize for clz_Torappu_BattleAutoBattleMetaItem<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_BattleAutoBattleMetaItem", 5)?;
        if let Some(f) = self.battleAutoBattleDisplayKey() {
            s.serialize_field("battleAutoBattleDisplayKey", &f)?;
        } else {
            s.skip_field("battleAutoBattleDisplayKey")?;
        }
        s.serialize_field("isAllStageActive", &self.isAllStageActive())?;
        if let Some(f) = self.relateActId() {
            s.serialize_field("relateActId", &f)?;
        } else {
            s.skip_field("relateActId")?;
        }
        if let Some(f) = self.stageIdList() {
            s.serialize_field("stageIdList", &f)?;
        } else {
            s.skip_field("stageIdList")?;
        }
        if let Some(f) = self.availCheck() {
            s.serialize_field("availCheck", &f)?;
        } else {
            s.skip_field("availCheck")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_BattleAutoBattleMetaItemBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BattleAutoBattleMetaItemBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_battleAutoBattleDisplayKey(
        &mut self,
        battleAutoBattleDisplayKey: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BattleAutoBattleMetaItem::VT_BATTLEAUTOBATTLEDISPLAYKEY,
            battleAutoBattleDisplayKey,
        );
    }
    #[inline]
    pub fn add_isAllStageActive(&mut self, isAllStageActive: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_BattleAutoBattleMetaItem::VT_ISALLSTAGEACTIVE,
            isAllStageActive,
            false,
        );
    }
    #[inline]
    pub fn add_relateActId(&mut self, relateActId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BattleAutoBattleMetaItem::VT_RELATEACTID,
            relateActId,
        );
    }
    #[inline]
    pub fn add_stageIdList(
        &mut self,
        stageIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BattleAutoBattleMetaItem::VT_STAGEIDLIST,
            stageIdList,
        );
    }
    #[inline]
    pub fn add_availCheck(
        &mut self,
        availCheck: flatbuffers::WIPOffset<clz_Torappu_CommonAvailCheck<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CommonAvailCheck>>(
                clz_Torappu_BattleAutoBattleMetaItem::VT_AVAILCHECK,
                availCheck,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BattleAutoBattleMetaItemBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BattleAutoBattleMetaItemBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BattleAutoBattleMetaItem<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BattleAutoBattleMetaItem<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BattleAutoBattleMetaItem");
        ds.field(
            "battleAutoBattleDisplayKey",
            &self.battleAutoBattleDisplayKey(),
        );
        ds.field("isAllStageActive", &self.isAllStageActive());
        ds.field("relateActId", &self.relateActId());
        ds.field("stageIdList", &self.stageIdList());
        ds.field("availCheck", &self.availCheck());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_BattleAutoBattleMetaItemT {
    pub battleAutoBattleDisplayKey: Option<String>,
    pub isAllStageActive: bool,
    pub relateActId: Option<String>,
    pub stageIdList: Option<Vec<String>>,
    pub availCheck: Option<Box<clz_Torappu_CommonAvailCheckT>>,
}
impl Default for clz_Torappu_BattleAutoBattleMetaItemT {
    fn default() -> Self {
        Self {
            battleAutoBattleDisplayKey: None,
            isAllStageActive: false,
            relateActId: None,
            stageIdList: None,
            availCheck: None,
        }
    }
}
impl clz_Torappu_BattleAutoBattleMetaItemT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BattleAutoBattleMetaItem<'b>> {
        let battleAutoBattleDisplayKey = self
            .battleAutoBattleDisplayKey
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let isAllStageActive = self.isAllStageActive;
        let relateActId = self.relateActId.as_ref().map(|x| _fbb.create_string(x));
        let stageIdList = self.stageIdList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let availCheck = self.availCheck.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_BattleAutoBattleMetaItem::create(
            _fbb,
            &clz_Torappu_BattleAutoBattleMetaItemArgs {
                battleAutoBattleDisplayKey,
                isAllStageActive,
                relateActId,
                stageIdList,
                availCheck,
            },
        )
    }
}
pub enum clz_Torappu_MetaUIDisplayTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_MetaUIDisplayTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_MetaUIDisplayTable<'a> {
    type Inner = clz_Torappu_MetaUIDisplayTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_MetaUIDisplayTable<'a> {
    pub const VT_TIPSMETALIST: flatbuffers::VOffsetT = 4;
    pub const VT_FLASHALERTAFTERSTAGEITEMLIST: flatbuffers::VOffsetT = 6;
    pub const VT_MAPPREVIEWDISPLAYMETAITEMLIST: flatbuffers::VOffsetT = 8;
    pub const VT_BATTLEFINISHDISPLAYMETAITEMLIST: flatbuffers::VOffsetT = 10;
    pub const VT_BATTLELOADINGDISPLAYMETAITEMLIST: flatbuffers::VOffsetT = 12;
    pub const VT_BATTLEAUTOBATTLEMETAITEMLIST: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_MetaUIDisplayTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_MetaUIDisplayTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MetaUIDisplayTable<'bldr>> {
        let mut builder = clz_Torappu_MetaUIDisplayTableBuilder::new(_fbb);
        if let Some(x) = args.battleAutoBattleMetaItemList {
            builder.add_battleAutoBattleMetaItemList(x);
        }
        if let Some(x) = args.battleLoadingDisplayMetaItemList {
            builder.add_battleLoadingDisplayMetaItemList(x);
        }
        if let Some(x) = args.battleFinishDisplayMetaItemList {
            builder.add_battleFinishDisplayMetaItemList(x);
        }
        if let Some(x) = args.mapPreviewDisplayMetaItemList {
            builder.add_mapPreviewDisplayMetaItemList(x);
        }
        if let Some(x) = args.flashAlertAfterStageItemList {
            builder.add_flashAlertAfterStageItemList(x);
        }
        if let Some(x) = args.tipsMetaList {
            builder.add_tipsMetaList(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_MetaUIDisplayTableT {
        let tipsMetaList = self
            .tipsMetaList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let flashAlertAfterStageItemList = self
            .flashAlertAfterStageItemList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let mapPreviewDisplayMetaItemList = self
            .mapPreviewDisplayMetaItemList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let battleFinishDisplayMetaItemList = self
            .battleFinishDisplayMetaItemList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let battleLoadingDisplayMetaItemList = self
            .battleLoadingDisplayMetaItemList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let battleAutoBattleMetaItemList = self
            .battleAutoBattleMetaItemList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_MetaUIDisplayTableT {
            tipsMetaList,
            flashAlertAfterStageItemList,
            mapPreviewDisplayMetaItemList,
            battleFinishDisplayMetaItemList,
            battleLoadingDisplayMetaItemList,
            battleAutoBattleMetaItemList,
        }
    }

    #[inline]
    pub fn tipsMetaList(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TipsMetaDisplayItem<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_TipsMetaDisplayItem>,
                >,
            >>(clz_Torappu_MetaUIDisplayTable::VT_TIPSMETALIST, None)
        }
    }
    #[inline]
    pub fn flashAlertAfterStageItemList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_FlashAlertAfterStageDisplayMetaItem<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_FlashAlertAfterStageDisplayMetaItem>,
                >,
            >>(
                clz_Torappu_MetaUIDisplayTable::VT_FLASHALERTAFTERSTAGEITEMLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn mapPreviewDisplayMetaItemList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_MapPreviewDisplayMetaItem<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_MapPreviewDisplayMetaItem>,
                >,
            >>(
                clz_Torappu_MetaUIDisplayTable::VT_MAPPREVIEWDISPLAYMETAITEMLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn battleFinishDisplayMetaItemList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BattleFinishDisplayMetaItem<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BattleFinishDisplayMetaItem>,
                >,
            >>(
                clz_Torappu_MetaUIDisplayTable::VT_BATTLEFINISHDISPLAYMETAITEMLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn battleLoadingDisplayMetaItemList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BattleLoadingDisplayMetaItem<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BattleLoadingDisplayMetaItem>,
                >,
            >>(
                clz_Torappu_MetaUIDisplayTable::VT_BATTLELOADINGDISPLAYMETAITEMLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn battleAutoBattleMetaItemList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BattleAutoBattleMetaItem<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BattleAutoBattleMetaItem>,
                >,
            >>(
                clz_Torappu_MetaUIDisplayTable::VT_BATTLEAUTOBATTLEMETAITEMLIST,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_MetaUIDisplayTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_TipsMetaDisplayItem>,
                >,
            >>("tipsMetaList", Self::VT_TIPSMETALIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_FlashAlertAfterStageDisplayMetaItem>,
                >,
            >>(
                "flashAlertAfterStageItemList",
                Self::VT_FLASHALERTAFTERSTAGEITEMLIST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_MapPreviewDisplayMetaItem>,
                >,
            >>(
                "mapPreviewDisplayMetaItemList",
                Self::VT_MAPPREVIEWDISPLAYMETAITEMLIST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BattleFinishDisplayMetaItem>,
                >,
            >>(
                "battleFinishDisplayMetaItemList",
                Self::VT_BATTLEFINISHDISPLAYMETAITEMLIST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BattleLoadingDisplayMetaItem>,
                >,
            >>(
                "battleLoadingDisplayMetaItemList",
                Self::VT_BATTLELOADINGDISPLAYMETAITEMLIST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BattleAutoBattleMetaItem>,
                >,
            >>(
                "battleAutoBattleMetaItemList",
                Self::VT_BATTLEAUTOBATTLEMETAITEMLIST,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_MetaUIDisplayTableArgs<'a> {
    pub tipsMetaList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_TipsMetaDisplayItem<'a>>,
            >,
        >,
    >,
    pub flashAlertAfterStageItemList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_FlashAlertAfterStageDisplayMetaItem<'a>>,
            >,
        >,
    >,
    pub mapPreviewDisplayMetaItemList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_MapPreviewDisplayMetaItem<'a>>,
            >,
        >,
    >,
    pub battleFinishDisplayMetaItemList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BattleFinishDisplayMetaItem<'a>>,
            >,
        >,
    >,
    pub battleLoadingDisplayMetaItemList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BattleLoadingDisplayMetaItem<'a>>,
            >,
        >,
    >,
    pub battleAutoBattleMetaItemList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BattleAutoBattleMetaItem<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_MetaUIDisplayTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_MetaUIDisplayTableArgs {
            tipsMetaList: None,
            flashAlertAfterStageItemList: None,
            mapPreviewDisplayMetaItemList: None,
            battleFinishDisplayMetaItemList: None,
            battleLoadingDisplayMetaItemList: None,
            battleAutoBattleMetaItemList: None,
        }
    }
}

impl Serialize for clz_Torappu_MetaUIDisplayTable<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_MetaUIDisplayTable", 6)?;
        if let Some(f) = self.tipsMetaList() {
            s.serialize_field("tipsMetaList", &f)?;
        } else {
            s.skip_field("tipsMetaList")?;
        }
        if let Some(f) = self.flashAlertAfterStageItemList() {
            s.serialize_field("flashAlertAfterStageItemList", &f)?;
        } else {
            s.skip_field("flashAlertAfterStageItemList")?;
        }
        if let Some(f) = self.mapPreviewDisplayMetaItemList() {
            s.serialize_field("mapPreviewDisplayMetaItemList", &f)?;
        } else {
            s.skip_field("mapPreviewDisplayMetaItemList")?;
        }
        if let Some(f) = self.battleFinishDisplayMetaItemList() {
            s.serialize_field("battleFinishDisplayMetaItemList", &f)?;
        } else {
            s.skip_field("battleFinishDisplayMetaItemList")?;
        }
        if let Some(f) = self.battleLoadingDisplayMetaItemList() {
            s.serialize_field("battleLoadingDisplayMetaItemList", &f)?;
        } else {
            s.skip_field("battleLoadingDisplayMetaItemList")?;
        }
        if let Some(f) = self.battleAutoBattleMetaItemList() {
            s.serialize_field("battleAutoBattleMetaItemList", &f)?;
        } else {
            s.skip_field("battleAutoBattleMetaItemList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_MetaUIDisplayTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_MetaUIDisplayTableBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_tipsMetaList(
        &mut self,
        tipsMetaList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_TipsMetaDisplayItem<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MetaUIDisplayTable::VT_TIPSMETALIST,
            tipsMetaList,
        );
    }
    #[inline]
    pub fn add_flashAlertAfterStageItemList(
        &mut self,
        flashAlertAfterStageItemList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_FlashAlertAfterStageDisplayMetaItem<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MetaUIDisplayTable::VT_FLASHALERTAFTERSTAGEITEMLIST,
            flashAlertAfterStageItemList,
        );
    }
    #[inline]
    pub fn add_mapPreviewDisplayMetaItemList(
        &mut self,
        mapPreviewDisplayMetaItemList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_MapPreviewDisplayMetaItem<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MetaUIDisplayTable::VT_MAPPREVIEWDISPLAYMETAITEMLIST,
            mapPreviewDisplayMetaItemList,
        );
    }
    #[inline]
    pub fn add_battleFinishDisplayMetaItemList(
        &mut self,
        battleFinishDisplayMetaItemList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BattleFinishDisplayMetaItem<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MetaUIDisplayTable::VT_BATTLEFINISHDISPLAYMETAITEMLIST,
            battleFinishDisplayMetaItemList,
        );
    }
    #[inline]
    pub fn add_battleLoadingDisplayMetaItemList(
        &mut self,
        battleLoadingDisplayMetaItemList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BattleLoadingDisplayMetaItem<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MetaUIDisplayTable::VT_BATTLELOADINGDISPLAYMETAITEMLIST,
            battleLoadingDisplayMetaItemList,
        );
    }
    #[inline]
    pub fn add_battleAutoBattleMetaItemList(
        &mut self,
        battleAutoBattleMetaItemList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BattleAutoBattleMetaItem<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MetaUIDisplayTable::VT_BATTLEAUTOBATTLEMETAITEMLIST,
            battleAutoBattleMetaItemList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_MetaUIDisplayTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_MetaUIDisplayTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_MetaUIDisplayTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_MetaUIDisplayTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_MetaUIDisplayTable");
        ds.field("tipsMetaList", &self.tipsMetaList());
        ds.field(
            "flashAlertAfterStageItemList",
            &self.flashAlertAfterStageItemList(),
        );
        ds.field(
            "mapPreviewDisplayMetaItemList",
            &self.mapPreviewDisplayMetaItemList(),
        );
        ds.field(
            "battleFinishDisplayMetaItemList",
            &self.battleFinishDisplayMetaItemList(),
        );
        ds.field(
            "battleLoadingDisplayMetaItemList",
            &self.battleLoadingDisplayMetaItemList(),
        );
        ds.field(
            "battleAutoBattleMetaItemList",
            &self.battleAutoBattleMetaItemList(),
        );
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_MetaUIDisplayTableT {
    pub tipsMetaList: Option<Vec<clz_Torappu_TipsMetaDisplayItemT>>,
    pub flashAlertAfterStageItemList: Option<Vec<clz_Torappu_FlashAlertAfterStageDisplayMetaItemT>>,
    pub mapPreviewDisplayMetaItemList: Option<Vec<clz_Torappu_MapPreviewDisplayMetaItemT>>,
    pub battleFinishDisplayMetaItemList: Option<Vec<clz_Torappu_BattleFinishDisplayMetaItemT>>,
    pub battleLoadingDisplayMetaItemList: Option<Vec<clz_Torappu_BattleLoadingDisplayMetaItemT>>,
    pub battleAutoBattleMetaItemList: Option<Vec<clz_Torappu_BattleAutoBattleMetaItemT>>,
}
impl Default for clz_Torappu_MetaUIDisplayTableT {
    fn default() -> Self {
        Self {
            tipsMetaList: None,
            flashAlertAfterStageItemList: None,
            mapPreviewDisplayMetaItemList: None,
            battleFinishDisplayMetaItemList: None,
            battleLoadingDisplayMetaItemList: None,
            battleAutoBattleMetaItemList: None,
        }
    }
}
impl clz_Torappu_MetaUIDisplayTableT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MetaUIDisplayTable<'b>> {
        let tipsMetaList = self.tipsMetaList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let flashAlertAfterStageItemList = self.flashAlertAfterStageItemList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let mapPreviewDisplayMetaItemList = self.mapPreviewDisplayMetaItemList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let battleFinishDisplayMetaItemList =
            self.battleFinishDisplayMetaItemList.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
        let battleLoadingDisplayMetaItemList =
            self.battleLoadingDisplayMetaItemList.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
        let battleAutoBattleMetaItemList = self.battleAutoBattleMetaItemList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_MetaUIDisplayTable::create(
            _fbb,
            &clz_Torappu_MetaUIDisplayTableArgs {
                tipsMetaList,
                flashAlertAfterStageItemList,
                mapPreviewDisplayMetaItemList,
                battleFinishDisplayMetaItemList,
                battleLoadingDisplayMetaItemList,
                battleAutoBattleMetaItemList,
            },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_MetaUIDisplayTable`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_meta_uidisplay_table_unchecked`.
pub fn root_as_clz_torappu_meta_uidisplay_table(
    buf: &[u8],
) -> Result<clz_Torappu_MetaUIDisplayTable<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_MetaUIDisplayTable>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_MetaUIDisplayTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_meta_uidisplay_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_meta_uidisplay_table(
    buf: &[u8],
) -> Result<clz_Torappu_MetaUIDisplayTable<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_MetaUIDisplayTable>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_MetaUIDisplayTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_meta_uidisplay_table_unchecked`.
pub fn root_as_clz_torappu_meta_uidisplay_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_MetaUIDisplayTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_MetaUIDisplayTable<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_MetaUIDisplayTable` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_meta_uidisplay_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_meta_uidisplay_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_MetaUIDisplayTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_MetaUIDisplayTable<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_MetaUIDisplayTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_MetaUIDisplayTable`.
pub unsafe fn root_as_clz_torappu_meta_uidisplay_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_MetaUIDisplayTable<'_> {
    unsafe { flatbuffers::root_unchecked::<clz_Torappu_MetaUIDisplayTable>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_MetaUIDisplayTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_MetaUIDisplayTable`.
pub unsafe fn size_prefixed_root_as_clz_torappu_meta_uidisplay_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_MetaUIDisplayTable<'_> {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_MetaUIDisplayTable>(buf) }
}
#[inline]
pub fn finish_clz_torappu_meta_uidisplay_table_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_MetaUIDisplayTable<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_meta_uidisplay_table_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_MetaUIDisplayTable<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
